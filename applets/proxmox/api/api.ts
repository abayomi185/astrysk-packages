/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * ProxMox VE API
 * ProxMox VE API
 * OpenAPI spec version: 2.0
 */
import { useQuery, useMutation } from "@tanstack/react-query";
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from "@tanstack/react-query";
import type {
  GetClusterResponseResponse,
  GetClusterReplicationResponseResponse,
  CreateClusterReplicationResponseResponse,
  CreateClusterReplicationRequest,
  DeleteClusterReplicationSingleResponseResponse,
  GetClusterReplicationSingleResponseResponse,
  UpdateClusterReplicationSingleResponseResponse,
  UpdateClusterReplicationSingleRequest,
  GetClusterMetricsResponseResponse,
  GetClusterMetricsServerResponseResponse,
  DeleteClusterMetricsServerSingleResponseResponse,
  GetClusterMetricsServerSingleResponseResponse,
  CreateClusterMetricsServerSingleResponseResponse,
  CreateClusterMetricsServerSingleRequest,
  UpdateClusterMetricsServerSingleResponseResponse,
  UpdateClusterMetricsServerSingleRequest,
  GetClusterConfigResponseResponse,
  CreateClusterConfigResponseResponse,
  CreateClusterConfigRequest,
  GetClusterConfigApiversionResponseResponse,
  GetClusterConfigNodesResponseResponse,
  DeleteClusterConfigNodesSingleResponseResponse,
  CreateClusterConfigNodesSingleResponseResponse,
  CreateClusterConfigNodesSingleRequest,
  GetClusterConfigJoinResponseResponse,
  CreateClusterConfigJoinResponseResponse,
  CreateClusterConfigJoinRequest,
  GetClusterConfigTotemResponseResponse,
  GetClusterConfigQdeviceResponseResponse,
  GetClusterFirewallResponseResponse,
  GetClusterFirewallGroupsResponseResponse,
  CreateClusterFirewallGroupResponseResponse,
  CreateClusterFirewallGroupRequest,
  DeleteClusterFirewallGroupResponseResponse,
  GetClusterFirewallGroupRulesResponseResponse,
  AddClusterFirewallGroupRuleResponseResponse,
  AddClusterFirewallGroupRuleRequest,
  RemoveClusterFirewallGroupRuleResponseResponse,
  GetClusterFirewallGroupRuleResponseResponse,
  UpdateClusterFirewallGroupRuleResponseResponse,
  UpdateClusterFirewallGroupRuleRequest,
  GetClusterFirewallRulesResponseResponse,
  AddClusterFirewallRuleResponseResponse,
  AddClusterFirewallRuleRequest,
  RemoveClusterFirewallRuleResponseResponse,
  GetClusterFirewallRuleResponseResponse,
  UpdateClusterFirewallRuleResponseResponse,
  UpdateClusterFirewallRuleRequest,
  GetClusterFirewallIPSetsResponseResponse,
  CreateClusterFirewallIPSetResponseResponse,
  CreateClusterFirewallIPSetRequest,
  DeleteClusterFirewallIPSetResponseResponse,
  GetClusterFirewallIPSetResponseResponse,
  AddClusterFirewallIPSetIPResponseResponse,
  AddClusterFirewallIPSetIPRequest,
  RemoveClusterFirewallIPSetIPResponseResponse,
  GetClusterFirewallIPSetIPResponseResponse,
  UpdateClusterFirewallIPSetIPResponseResponse,
  UpdateClusterFirewallIPSetIPRequest,
  GetClusterFirewallAliasesResponseResponse,
  CreateClusterFirewallAliasesResponseResponse,
  CreateClusterFirewallAliasesRequest,
  DeleteClusterFirewallAliasesSingleResponseResponse,
  GetClusterFirewallAliasesSingleResponseResponse,
  UpdateClusterFirewallAliasesSingleResponseResponse,
  UpdateClusterFirewallAliasesSingleRequest,
  GetClusterFirewallOptionsResponseResponse,
  UpdateClusterFirewallOptionsResponseResponse,
  UpdateClusterFirewallOptionsRequest,
  GetClusterFirewallMacrosResponseResponse,
  GetClusterFirewallRefsResponseResponse,
  GetClusterBackupResponseResponse,
  CreateClusterBackupResponseResponse,
  CreateClusterBackupRequest,
  DeleteClusterBackupSingleResponseResponse,
  GetClusterBackupSingleResponseResponse,
  UpdateClusterBackupSingleResponseResponse,
  UpdateClusterBackupSingleRequest,
  GetClusterBackupSingleIncludedvolumesResponseResponse,
  GetClusterBackupinfoResponseResponse,
  GetClusterBackupinfoNotbackedupResponseResponse,
  GetClusterHaResponseResponse,
  GetClusterHaResourcesResponseResponse,
  CreateClusterHaResourcesResponseResponse,
  CreateClusterHaResourcesRequest,
  DeleteClusterHaResourcesSingleResponseResponse,
  GetClusterHaResourcesSingleResponseResponse,
  UpdateClusterHaResourcesSingleResponseResponse,
  UpdateClusterHaResourcesSingleRequest,
  CreateClusterHaResourcesSingleMigrateResponseResponse,
  CreateClusterHaResourcesSingleMigrateRequest,
  CreateClusterHaResourcesSingleRelocateResponseResponse,
  CreateClusterHaResourcesSingleRelocateRequest,
  GetClusterHaGroupsResponseResponse,
  CreateClusterHaGroupsResponseResponse,
  CreateClusterHaGroupsRequest,
  DeleteClusterHaGroupsSingleResponseResponse,
  GetClusterHaGroupsSingleResponseResponse,
  UpdateClusterHaGroupsSingleResponseResponse,
  UpdateClusterHaGroupsSingleRequest,
  GetClusterHaStatusResponseResponse,
  GetClusterHaStatusCurrentResponseResponse,
  GetClusterHaStatusManagerstatusResponseResponse,
  GetClusterAcmeResponseResponse,
  GetClusterAcmePluginsResponseResponse,
  CreateClusterAcmePluginsResponseResponse,
  CreateClusterAcmePluginsRequest,
  DeleteClusterAcmePluginsSingleResponseResponse,
  GetClusterAcmePluginsSingleResponseResponse,
  UpdateClusterAcmePluginsSingleResponseResponse,
  UpdateClusterAcmePluginsSingleRequest,
  GetClusterAcmeAccountResponseResponse,
  CreateClusterAcmeAccountResponseResponse,
  CreateClusterAcmeAccountRequest,
  DeleteClusterAcmeAccountSingleResponseResponse,
  GetClusterAcmeAccountSingleResponseResponse,
  UpdateClusterAcmeAccountSingleResponseResponse,
  UpdateClusterAcmeAccountSingleRequest,
  GetClusterAcmeTosResponseResponse,
  GetClusterAcmeDirectoriesResponseResponse,
  GetClusterAcmeChallengeschemaResponseResponse,
  GetClusterCephResponseResponse,
  GetClusterCephMetadataResponseResponse,
  GetClusterCephStatusResponseResponse,
  GetClusterCephFlagsResponseResponse,
  UpdateClusterCephFlagsResponseResponse,
  UpdateClusterCephFlagsRequest,
  GetClusterCephFlagsSingleResponseResponse,
  UpdateClusterCephFlagsSingleResponseResponse,
  UpdateClusterCephFlagsSingleRequest,
  GetClusterSDNResponseResponse,
  UpdateClusterSDNResponseResponse,
  UpdateClusterSDNRequest,
  GetClusterSDNVnetsResponseResponse,
  CreateClusterSDNVnetResponseResponse,
  CreateClusterSDNVnetRequest,
  DeleteClusterSDNVnetResponseResponse,
  GetClusterSDNVnetResponseResponse,
  UpdateClusterSDNVnetResponseResponse,
  UpdateClusterSDNVnetRequest,
  GetClusterSDNZonesResponseResponse,
  CreateClusterSDNZoneResponseResponse,
  CreateClusterSDNZoneRequest,
  DeleteClusterSDNZoneResponseResponse,
  GetClusterSDNZoneResponseResponse,
  UpdateClusterSDNZoneResponseResponse,
  UpdateClusterSDNZoneRequest,
  GetClusterSDNControllersResponseResponse,
  CreateClusterSDNControllerResponseResponse,
  CreateClusterSDNControllerRequest,
  DeleteClusterSDNControllerResponseResponse,
  GetClusterSDNControllerResponseResponse,
  UpdateClusterSDNControllerResponseResponse,
  UpdateClusterSDNControllerRequest,
  GetClusterLogResponseResponse,
  GetClusterResourcesResponseResponse,
  GetClusterTasksResponseResponse,
  GetClusterOptionsResponseResponse,
  UpdateClusterOptionsResponseResponse,
  UpdateClusterOptionsRequest,
  GetClusterStatusResponseResponse,
  GetClusterNextidResponseResponse,
  GetNodesResponseResponse,
  GetNodeResponseResponse,
  GetVMsResponseResponse,
  CreateVMResponseResponse,
  CreateVMRequest,
  DeleteVMResponseResponse,
  GetVMResponseResponse,
  GetVMFirewallResponseResponse,
  GetVMFirewallRulesResponseResponse,
  CreateVMFirewallRuleResponseResponse,
  CreateVMFirewallRuleRequest,
  DeleteVMFirewallRuleResponseResponse,
  GetVMFirewallRuleResponseResponse,
  UpdateVMFirewallRuleResponseResponse,
  UpdateVMFirewallRuleRequest,
  GetNodesSingleQemuSingleFirewallAliasesResponseResponse,
  CreateNodesSingleQemuSingleFirewallAliasesResponseResponse,
  CreateNodesSingleQemuSingleFirewallAliasesRequest,
  DeleteNodesSingleQemuSingleFirewallAliasesSingleResponseResponse,
  GetNodesSingleQemuSingleFirewallAliasesSingleResponseResponse,
  UpdateNodesSingleQemuSingleFirewallAliasesSingleResponseResponse,
  UpdateNodesSingleQemuSingleFirewallAliasesSingleRequest,
  GetVMFirewallIPSetsResponseResponse,
  CreateVMFirewallIPSetResponseResponse,
  CreateVMFirewallIPSetRequest,
  DeleteVMFirewallIPSetResponseResponse,
  GetVMFirewallIPSetResponseResponse,
  AddVMFirewallIPSetIPResponseResponse,
  AddVMFirewallIPSetIPRequest,
  RemoveVMFirewallIPSetIPResponseResponse,
  GetVMFirewallIPSetIPResponseResponse,
  UpdateVMFirewallIPSetIPResponseResponse,
  UpdateVMFirewallIPSetIPRequest,
  GetVMFirewallOptionsResponseResponse,
  UpdateVMFirewallOptionsResponseResponse,
  UpdateVMFirewallOptionsRequest,
  GetNodesSingleQemuSingleFirewallLogResponseResponse,
  GetNodesSingleQemuSingleFirewallRefsResponseResponse,
  GetNodesSingleQemuSingleAgentResponseResponse,
  CreateNodesSingleQemuSingleAgentResponseResponse,
  CreateNodesSingleQemuSingleAgentRequest,
  CreateNodesSingleQemuSingleAgentFsfreezefreezeResponseResponse,
  CreateNodesSingleQemuSingleAgentFsfreezefreezeRequest,
  CreateNodesSingleQemuSingleAgentFsfreezestatusResponseResponse,
  CreateNodesSingleQemuSingleAgentFsfreezestatusRequest,
  CreateNodesSingleQemuSingleAgentFsfreezethawResponseResponse,
  CreateNodesSingleQemuSingleAgentFsfreezethawRequest,
  CreateNodesSingleQemuSingleAgentFstrimResponseResponse,
  CreateNodesSingleQemuSingleAgentFstrimRequest,
  GetNodesSingleQemuSingleAgentGetfsinfoResponseResponse,
  GetNodesSingleQemuSingleAgentGethostnameResponseResponse,
  GetNodesSingleQemuSingleAgentGetmemoryblockinfoResponseResponse,
  GetNodesSingleQemuSingleAgentGetmemoryblocksResponseResponse,
  GetNodesSingleQemuSingleAgentGetosinfoResponseResponse,
  GetNodesSingleQemuSingleAgentGettimeResponseResponse,
  GetNodesSingleQemuSingleAgentGettimezoneResponseResponse,
  GetNodesSingleQemuSingleAgentGetusersResponseResponse,
  GetNodesSingleQemuSingleAgentGetvcpusResponseResponse,
  GetNodesSingleQemuSingleAgentInfoResponseResponse,
  GetNodesSingleQemuSingleAgentNetworkgetinterfacesResponseResponse,
  CreateNodesSingleQemuSingleAgentPingResponseResponse,
  CreateNodesSingleQemuSingleAgentPingRequest,
  CreateNodesSingleQemuSingleAgentShutdownResponseResponse,
  CreateNodesSingleQemuSingleAgentShutdownRequest,
  CreateNodesSingleQemuSingleAgentSuspenddiskResponseResponse,
  CreateNodesSingleQemuSingleAgentSuspenddiskRequest,
  CreateNodesSingleQemuSingleAgentSuspendhybridResponseResponse,
  CreateNodesSingleQemuSingleAgentSuspendhybridRequest,
  CreateNodesSingleQemuSingleAgentSuspendramResponseResponse,
  CreateNodesSingleQemuSingleAgentSuspendramRequest,
  CreateNodesSingleQemuSingleAgentSetuserpasswordResponseResponse,
  CreateNodesSingleQemuSingleAgentSetuserpasswordRequest,
  CreateNodesSingleQemuSingleAgentExecResponseResponse,
  CreateNodesSingleQemuSingleAgentExecRequest,
  GetNodesSingleQemuSingleAgentExecstatusResponseResponse,
  GetNodesSingleQemuSingleAgentFilereadResponseResponse,
  CreateNodesSingleQemuSingleAgentFilewriteResponseResponse,
  CreateNodesSingleQemuSingleAgentFilewriteRequest,
  GetVMRRDResponseResponse,
  GetVMRRDDataResponseResponse,
  GetVMConfigResponseResponse,
  UpdateVMConfigResponseResponse,
  UpdateVMConfigRequest,
  UpdateVMConfigSyncResponseResponse,
  UpdateVMConfigSyncRequest,
  GetVMConfigPendingResponseResponse,
  UnlinkVMDiskImagesResponseResponse,
  UnlinkVMDiskImagesRequest,
  CreateNodesSingleQemuSingleVncproxyResponseResponse,
  CreateNodesSingleQemuSingleVncproxyRequest,
  CreateNodesSingleQemuSingleTermproxyResponseResponse,
  CreateNodesSingleQemuSingleTermproxyRequest,
  GetNodesSingleQemuSingleVncwebsocketResponseResponse,
  CreateNodesSingleQemuSingleSpiceproxyResponseResponse,
  CreateNodesSingleQemuSingleSpiceproxyRequest,
  GetVMStatusResponseResponse,
  GetCurrentVMStatusResponseResponse,
  StartVMResponseResponse,
  StartVMRequest,
  StopVMResponseResponse,
  StopVMRequest,
  ResetVMResponseResponse,
  ResetVMRequest,
  ShutdownVMResponseResponse,
  ShutdownVMRequest,
  RebootVMResponseResponse,
  RebootVMRequest,
  SuspendVMResponseResponse,
  SuspendVMRequest,
  ResumeVMResponseResponse,
  ResumeVMRequest,
  UpdateNodesSingleQemuSingleSendkeyResponseResponse,
  UpdateNodesSingleQemuSingleSendkeyRequest,
  GetNodesSingleQemuSingleFeatureResponseResponse,
  CloneVMResponseResponse,
  CloneVMRequest,
  CreateNodesSingleQemuSingleMovediskResponseResponse,
  CreateNodesSingleQemuSingleMovediskRequest,
  MigrateVMResponseResponse,
  CreateNodesSingleQemuSingleMigrateResponseResponse,
  CreateNodesSingleQemuSingleMigrateRequest,
  CreateNodesSingleQemuSingleMonitorResponseResponse,
  CreateNodesSingleQemuSingleMonitorRequest,
  ResizeVMDiskResponseResponse,
  ResizeVMDiskRequest,
  GetVMSnapshotsResponseResponse,
  CreateVMSnapshotResponseResponse,
  CreateVMSnapshotRequest,
  DeleteVMSnapshotResponseResponse,
  GetVMSnapshotResponseResponse,
  GetVMSnapshotConfigResponseResponse,
  UpdateVMSnapshotConfigResponseResponse,
  UpdateVMSnapshotConfigRequest,
  RollbackVMSnapshotResponseResponse,
  RollbackVMSnapshotRequest,
  CreateNodesSingleQemuSingleTemplateResponseResponse,
  CreateNodesSingleQemuSingleTemplateRequest,
  GetNodesSingleQemuSingleCloudinitDumpResponseResponse,
  GetNodesSingleCpuResponseResponse,
  GetNodesSingleLxcResponseResponse,
  CreateNodesSingleLxcResponseResponse,
  CreateNodesSingleLxcRequest,
  DeleteNodesSingleLxcSingleResponseResponse,
  GetNodesSingleLxcSingleResponseResponse,
  GetNodesSingleLxcSingleConfigResponseResponse,
  UpdateNodesSingleLxcSingleConfigResponseResponse,
  UpdateNodesSingleLxcSingleConfigRequest,
  GetNodesSingleLxcSingleStatusResponseResponse,
  GetNodesSingleLxcSingleStatusCurrentResponseResponse,
  CreateNodesSingleLxcSingleStatusStartResponseResponse,
  CreateNodesSingleLxcSingleStatusStartRequest,
  CreateNodesSingleLxcSingleStatusStopResponseResponse,
  CreateNodesSingleLxcSingleStatusStopRequest,
  CreateNodesSingleLxcSingleStatusShutdownResponseResponse,
  CreateNodesSingleLxcSingleStatusShutdownRequest,
  CreateNodesSingleLxcSingleStatusSuspendResponseResponse,
  CreateNodesSingleLxcSingleStatusSuspendRequest,
  CreateNodesSingleLxcSingleStatusResumeResponseResponse,
  CreateNodesSingleLxcSingleStatusResumeRequest,
  CreateNodesSingleLxcSingleStatusRebootResponseResponse,
  CreateNodesSingleLxcSingleStatusRebootRequest,
  GetNodesSingleLxcSingleSnapshotResponseResponse,
  CreateNodesSingleLxcSingleSnapshotResponseResponse,
  CreateNodesSingleLxcSingleSnapshotRequest,
  DeleteNodesSingleLxcSingleSnapshotSingleResponseResponse,
  GetNodesSingleLxcSingleSnapshotSingleResponseResponse,
  CreateNodesSingleLxcSingleSnapshotSingleRollbackResponseResponse,
  CreateNodesSingleLxcSingleSnapshotSingleRollbackRequest,
  GetNodesSingleLxcSingleSnapshotSingleConfigResponseResponse,
  UpdateNodesSingleLxcSingleSnapshotSingleConfigResponseResponse,
  UpdateNodesSingleLxcSingleSnapshotSingleConfigRequest,
  GetNodesSingleLxcSingleFirewallResponseResponse,
  GetNodesSingleLxcSingleFirewallRulesResponseResponse,
  CreateNodesSingleLxcSingleFirewallRulesResponseResponse,
  CreateNodesSingleLxcSingleFirewallRulesRequest,
  DeleteNodesSingleLxcSingleFirewallRulesSingleResponseResponse,
  GetNodesSingleLxcSingleFirewallRulesSingleResponseResponse,
  UpdateNodesSingleLxcSingleFirewallRulesSingleResponseResponse,
  UpdateNodesSingleLxcSingleFirewallRulesSingleRequest,
  GetNodesSingleLxcSingleFirewallAliasesResponseResponse,
  CreateNodesSingleLxcSingleFirewallAliasesResponseResponse,
  CreateNodesSingleLxcSingleFirewallAliasesRequest,
  DeleteNodesSingleLxcSingleFirewallAliasesSingleResponseResponse,
  GetNodesSingleLxcSingleFirewallAliasesSingleResponseResponse,
  UpdateNodesSingleLxcSingleFirewallAliasesSingleResponseResponse,
  UpdateNodesSingleLxcSingleFirewallAliasesSingleRequest,
  GetNodesSingleLxcSingleFirewallIpsetResponseResponse,
  CreateNodesSingleLxcSingleFirewallIpsetResponseResponse,
  CreateNodesSingleLxcSingleFirewallIpsetRequest,
  DeleteNodesSingleLxcSingleFirewallIpsetSingleResponseResponse,
  GetNodesSingleLxcSingleFirewallIpsetSingleResponseResponse,
  CreateNodesSingleLxcSingleFirewallIpsetSingleResponseResponse,
  CreateNodesSingleLxcSingleFirewallIpsetSingleRequest,
  DeleteNodesSingleLxcSingleFirewallIpsetSingleSingleResponseResponse,
  GetNodesSingleLxcSingleFirewallIpsetSingleSingleResponseResponse,
  UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleResponseResponse,
  UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleRequest,
  GetNodesSingleLxcSingleFirewallOptionsResponseResponse,
  UpdateNodesSingleLxcSingleFirewallOptionsResponseResponse,
  UpdateNodesSingleLxcSingleFirewallOptionsRequest,
  GetNodesSingleLxcSingleFirewallLogResponseResponse,
  GetNodesSingleLxcSingleFirewallRefsResponseResponse,
  GetNodesSingleLxcSingleRrdResponseResponse,
  GetNodesSingleLxcSingleRrddataResponseResponse,
  CreateNodesSingleLxcSingleVncproxyResponseResponse,
  CreateNodesSingleLxcSingleVncproxyRequest,
  CreateNodesSingleLxcSingleTermproxyResponseResponse,
  CreateNodesSingleLxcSingleTermproxyRequest,
  GetNodesSingleLxcSingleVncwebsocketResponseResponse,
  CreateNodesSingleLxcSingleSpiceproxyResponseResponse,
  CreateNodesSingleLxcSingleSpiceproxyRequest,
  CreateNodesSingleLxcSingleMigrateResponseResponse,
  CreateNodesSingleLxcSingleMigrateRequest,
  GetNodesSingleLxcSingleFeatureResponseResponse,
  CreateNodesSingleLxcSingleTemplateResponseResponse,
  CreateNodesSingleLxcSingleTemplateRequest,
  CreateNodesSingleLxcSingleCloneResponseResponse,
  CreateNodesSingleLxcSingleCloneRequest,
  UpdateNodesSingleLxcSingleResizeResponseResponse,
  UpdateNodesSingleLxcSingleResizeRequest,
  CreateNodesSingleLxcSingleMovevolumeResponseResponse,
  CreateNodesSingleLxcSingleMovevolumeRequest,
  GetNodesSingleLxcSinglePendingResponseResponse,
  GetNodesSingleCephResponseResponse,
  GetNodesSingleCephOsdResponseResponse,
  CreateNodesSingleCephOsdResponseResponse,
  CreateNodesSingleCephOsdRequest,
  DeleteNodesSingleCephOsdSingleResponseResponse,
  CreateNodesSingleCephOsdSingleInResponseResponse,
  CreateNodesSingleCephOsdSingleInRequest,
  CreateNodesSingleCephOsdSingleOutResponseResponse,
  CreateNodesSingleCephOsdSingleOutRequest,
  CreateNodesSingleCephOsdSingleScrubResponseResponse,
  CreateNodesSingleCephOsdSingleScrubRequest,
  GetNodesSingleCephMdsResponseResponse,
  DeleteNodesSingleCephMdsSingleResponseResponse,
  CreateNodesSingleCephMdsSingleResponseResponse,
  CreateNodesSingleCephMdsSingleRequest,
  GetNodesSingleCephMgrResponseResponse,
  DeleteNodesSingleCephMgrSingleResponseResponse,
  CreateNodesSingleCephMgrSingleResponseResponse,
  CreateNodesSingleCephMgrSingleRequest,
  GetNodesSingleCephMonResponseResponse,
  DeleteNodesSingleCephMonSingleResponseResponse,
  CreateNodesSingleCephMonSingleResponseResponse,
  CreateNodesSingleCephMonSingleRequest,
  GetNodesSingleCephFsResponseResponse,
  CreateNodesSingleCephFsSingleResponseResponse,
  CreateNodesSingleCephFsSingleRequest,
  GetNodesSingleCephDisksResponseResponse,
  GetNodesSingleCephConfigResponseResponse,
  GetNodesSingleCephConfigdbResponseResponse,
  CreateNodesSingleCephInitResponseResponse,
  CreateNodesSingleCephInitRequest,
  CreateNodesSingleCephStopResponseResponse,
  CreateNodesSingleCephStopRequest,
  CreateNodesSingleCephStartResponseResponse,
  CreateNodesSingleCephStartRequest,
  CreateNodesSingleCephRestartResponseResponse,
  CreateNodesSingleCephRestartRequest,
  GetNodesSingleCephStatusResponseResponse,
  GetNodesSingleCephPoolsResponseResponse,
  CreateNodesSingleCephPoolsResponseResponse,
  CreateNodesSingleCephPoolsRequest,
  DeleteNodesSingleCephPoolsSingleResponseResponse,
  UpdateNodesSingleCephPoolsSingleResponseResponse,
  UpdateNodesSingleCephPoolsSingleRequest,
  GetNodesSingleCephFlagsResponseResponse,
  DeleteNodesSingleCephFlagsSingleResponseResponse,
  CreateNodesSingleCephFlagsSingleResponseResponse,
  CreateNodesSingleCephFlagsSingleRequest,
  GetNodesSingleCephCrushResponseResponse,
  GetNodesSingleCephLogResponseResponse,
  GetNodesSingleCephRulesResponseResponse,
  CreateNodesSingleVzdumpResponseResponse,
  CreateNodesSingleVzdumpRequest,
  GetNodesSingleVzdumpExtractconfigResponseResponse,
  GetNodesSingleServicesResponseResponse,
  GetNodesSingleServicesSingleResponseResponse,
  GetNodesSingleServicesSingleStateResponseResponse,
  CreateNodesSingleServicesSingleStartResponseResponse,
  CreateNodesSingleServicesSingleStartRequest,
  CreateNodesSingleServicesSingleStopResponseResponse,
  CreateNodesSingleServicesSingleStopRequest,
  CreateNodesSingleServicesSingleRestartResponseResponse,
  CreateNodesSingleServicesSingleRestartRequest,
  CreateNodesSingleServicesSingleReloadResponseResponse,
  CreateNodesSingleServicesSingleReloadRequest,
  DeleteNodesSingleSubscriptionResponseResponse,
  GetNodesSingleSubscriptionResponseResponse,
  CreateNodesSingleSubscriptionResponseResponse,
  CreateNodesSingleSubscriptionRequest,
  UpdateNodesSingleSubscriptionResponseResponse,
  UpdateNodesSingleSubscriptionRequest,
  DeleteNodesSingleNetworkResponseResponse,
  GetNodesSingleNetworkResponseResponse,
  CreateNodesSingleNetworkResponseResponse,
  CreateNodesSingleNetworkRequest,
  UpdateNodesSingleNetworkResponseResponse,
  UpdateNodesSingleNetworkRequest,
  DeleteNodesSingleNetworkSingleResponseResponse,
  GetNodesSingleNetworkSingleResponseResponse,
  UpdateNodesSingleNetworkSingleResponseResponse,
  UpdateNodesSingleNetworkSingleRequest,
  GetNodeTasksResponseResponse,
  StopNodeTaskResponseResponse,
  GetNodeTaskResponseResponse,
  GetNodeTaskLogResponseResponse,
  GetNodeTaskStatusResponseResponse,
  GetNodesSingleScanResponseResponse,
  GetNodesSingleScanZfsResponseResponse,
  GetNodesSingleScanNfsResponseResponse,
  GetNodesSingleScanCifsResponseResponse,
  GetNodesSingleScanGlusterfsResponseResponse,
  GetNodesSingleScanIscsiResponseResponse,
  GetNodesSingleScanLvmResponseResponse,
  GetNodesSingleScanLvmthinResponseResponse,
  GetNodesSingleScanUsbResponseResponse,
  GetNodesSingleHardwareResponseResponse,
  GetNodesSingleHardwarePciResponseResponse,
  GetNodesSingleHardwarePciSingleResponseResponse,
  GetNodesSingleHardwarePciSingleMdevResponseResponse,
  GetNodesSingleStorageResponseResponse,
  GetNodesSingleStorageSingleResponseResponse,
  DeleteNodesSingleStorageSinglePrunebackupsResponseResponse,
  GetNodesSingleStorageSinglePrunebackupsResponseResponse,
  GetNodesSingleStorageSingleContentResponseResponse,
  CreateNodesSingleStorageSingleContentResponseResponse,
  CreateNodesSingleStorageSingleContentRequest,
  DeleteNodesSingleStorageSingleContentSingleResponseResponse,
  GetNodesSingleStorageSingleContentSingleResponseResponse,
  CreateNodesSingleStorageSingleContentSingleResponseResponse,
  CreateNodesSingleStorageSingleContentSingleRequest,
  UpdateNodesSingleStorageSingleContentSingleResponseResponse,
  UpdateNodesSingleStorageSingleContentSingleRequest,
  GetNodesSingleStorageSingleStatusResponseResponse,
  GetNodesSingleStorageSingleRrdResponseResponse,
  GetNodesSingleStorageSingleRrddataResponseResponse,
  CreateNodesSingleStorageSingleUploadResponseResponse,
  CreateNodesSingleStorageSingleUploadRequest,
  GetNodesSingleDisksResponseResponse,
  GetNodesSingleDisksLvmResponseResponse,
  CreateNodesSingleDisksLvmResponseResponse,
  CreateNodesSingleDisksLvmRequest,
  GetNodesSingleDisksLvmthinResponseResponse,
  CreateNodesSingleDisksLvmthinResponseResponse,
  CreateNodesSingleDisksLvmthinRequest,
  GetNodesSingleDisksDirectoryResponseResponse,
  CreateNodesSingleDisksDirectoryResponseResponse,
  CreateNodesSingleDisksDirectoryRequest,
  GetNodesSingleDisksZfsResponseResponse,
  CreateNodesSingleDisksZfsResponseResponse,
  CreateNodesSingleDisksZfsRequest,
  GetNodesSingleDisksZfsSingleResponseResponse,
  GetNodesSingleDisksListResponseResponse,
  GetNodesSingleDisksSmartResponseResponse,
  CreateNodesSingleDisksInitgptResponseResponse,
  CreateNodesSingleDisksInitgptRequest,
  GetNodesSingleAptResponseResponse,
  GetNodesSingleAptUpdateResponseResponse,
  CreateNodesSingleAptUpdateResponseResponse,
  CreateNodesSingleAptUpdateRequest,
  GetNodesSingleAptChangelogResponseResponse,
  GetNodesSingleAptVersionsResponseResponse,
  GetNodeFirewallResponseResponse,
  GetNodeFirewallRulesResponseResponse,
  CreateNodeFirewallRuleResponseResponse,
  CreateNodeFirewallRuleRequest,
  DeleteNodeFirewallRuleResponseResponse,
  GetNodeFirewallRuleResponseResponse,
  UpdateNodeFirewallRuleResponseResponse,
  UpdateNodeFirewallRuleRequest,
  GetNodeFirewallOptionsResponseResponse,
  UpdateNodeFirewallOptionsResponseResponse,
  UpdateNodeFirewallOptionsRequest,
  GetNodesSingleFirewallLogResponseResponse,
  GetNodesSingleReplicationResponseResponse,
  GetNodesSingleReplicationSingleResponseResponse,
  GetNodesSingleReplicationSingleStatusResponseResponse,
  GetNodesSingleReplicationSingleLogResponseResponse,
  CreateNodesSingleReplicationSingleSchedulenowResponseResponse,
  CreateNodesSingleReplicationSingleSchedulenowRequest,
  GetNodesSingleCertificatesResponseResponse,
  GetNodesSingleCertificatesAcmeResponseResponse,
  DeleteNodesSingleCertificatesAcmeCertificateResponseResponse,
  CreateNodesSingleCertificatesAcmeCertificateResponseResponse,
  CreateNodesSingleCertificatesAcmeCertificateRequest,
  UpdateNodesSingleCertificatesAcmeCertificateResponseResponse,
  UpdateNodesSingleCertificatesAcmeCertificateRequest,
  GetNodesSingleCertificatesInfoResponseResponse,
  DeleteNodesSingleCertificatesCustomResponseResponse,
  CreateNodesSingleCertificatesCustomResponseResponse,
  CreateNodesSingleCertificatesCustomRequest,
  GetNodesSingleConfigResponseResponse,
  UpdateNodesSingleConfigResponseResponse,
  UpdateNodesSingleConfigRequest,
  GetNodeSDNResponseResponse,
  GetNodeSDNZonesResponseResponse,
  GetNodeSDNZoneResponseResponse,
  GetNodeSDNZoneContentResponseResponse,
  GetNodesSingleVersionResponseResponse,
  GetNodesSingleStatusResponseResponse,
  CreateNodesSingleStatusResponseResponse,
  CreateNodesSingleStatusRequest,
  GetNodesSingleNetstatResponseResponse,
  CreateNodesSingleExecuteResponseResponse,
  CreateNodesSingleExecuteRequest,
  CreateNodesSingleWakeonlanResponseResponse,
  CreateNodesSingleWakeonlanRequest,
  GetNodeRRDResponseResponse,
  GetNodeRRDDataResponseResponse,
  GetNodesSingleSyslogResponseResponse,
  GetNodesSingleJournalResponseResponse,
  CreateNodesSingleVncshellResponseResponse,
  CreateNodesSingleVncshellRequest,
  CreateNodesSingleTermproxyResponseResponse,
  CreateNodesSingleTermproxyRequest,
  GetNodesSingleVncwebsocketResponseResponse,
  CreateNodesSingleSpiceshellResponseResponse,
  CreateNodesSingleSpiceshellRequest,
  GetNodesSingleDnsResponseResponse,
  UpdateNodesSingleDnsResponseResponse,
  UpdateNodesSingleDnsRequest,
  GetNodesSingleTimeResponseResponse,
  UpdateNodesSingleTimeResponseResponse,
  UpdateNodesSingleTimeRequest,
  GetNodesSingleAplinfoResponseResponse,
  CreateNodesSingleAplinfoResponseResponse,
  CreateNodesSingleAplinfoRequest,
  GetNodesSingleReportResponseResponse,
  CreateNodesSingleStartallResponseResponse,
  CreateNodesSingleStartallRequest,
  CreateNodesSingleStopallResponseResponse,
  CreateNodesSingleStopallRequest,
  CreateNodesSingleMigrateallResponseResponse,
  CreateNodesSingleMigrateallRequest,
  GetNodesSingleHostsResponseResponse,
  CreateNodesSingleHostsResponseResponse,
  CreateNodesSingleHostsRequest,
  GetStorageResponseResponse,
  CreateStorageResponseResponse,
  CreateStorageRequest,
  DeleteStorageSingleResponseResponse,
  GetStorageSingleResponseResponse,
  UpdateStorageSingleResponseResponse,
  UpdateStorageSingleRequest,
  GetAccessResponseResponse,
  GetAccessUsersResponseResponse,
  CreateAccessUsersResponseResponse,
  CreateAccessUsersRequest,
  DeleteAccessUsersSingleResponseResponse,
  GetAccessUsersSingleResponseResponse,
  UpdateAccessUsersSingleResponseResponse,
  UpdateAccessUsersSingleRequest,
  GetAccessUsersSingleTfaResponseResponse,
  GetAccessUsersSingleTokenResponseResponse,
  DeleteAccessUsersSingleTokenSingleResponseResponse,
  GetAccessUsersSingleTokenSingleResponseResponse,
  CreateAccessUsersSingleTokenSingleResponseResponse,
  CreateAccessUsersSingleTokenSingleRequest,
  UpdateAccessUsersSingleTokenSingleResponseResponse,
  UpdateAccessUsersSingleTokenSingleRequest,
  GetAccessGroupsResponseResponse,
  CreateAccessGroupsResponseResponse,
  CreateAccessGroupsRequest,
  DeleteAccessGroupsSingleResponseResponse,
  GetAccessGroupsSingleResponseResponse,
  UpdateAccessGroupsSingleResponseResponse,
  UpdateAccessGroupsSingleRequest,
  GetAccessRolesResponseResponse,
  CreateAccessRolesResponseResponse,
  CreateAccessRolesRequest,
  DeleteAccessRolesSingleResponseResponse,
  GetAccessRolesSingleResponseResponse,
  UpdateAccessRolesSingleResponseResponse,
  UpdateAccessRolesSingleRequest,
  GetAccessAclResponseResponse,
  UpdateAccessAclResponseResponse,
  UpdateAccessAclRequest,
  GetAccessDomainsResponseResponse,
  CreateAccessDomainsResponseResponse,
  CreateAccessDomainsRequest,
  DeleteAccessDomainsSingleResponseResponse,
  GetAccessDomainsSingleResponseResponse,
  UpdateAccessDomainsSingleResponseResponse,
  UpdateAccessDomainsSingleRequest,
  CreateAccessDomainsSingleSyncResponseResponse,
  CreateAccessDomainsSingleSyncRequest,
  GetAccessTicketResponseResponse,
  CreateAccessTicketResponseResponse,
  CreateAccessTicketRequest,
  UpdateAccessPasswordResponseResponse,
  UpdateAccessPasswordRequest,
  CreateAccessTfaResponseResponse,
  CreateAccessTfaRequest,
  UpdateAccessTfaResponseResponse,
  UpdateAccessTfaRequest,
  GetAccessPermissionsResponseResponse,
  GetPoolsResponseResponse,
  CreatePoolResponseResponse,
  CreatePoolRequest,
  DeletePoolResponseResponse,
  GetPoolResponseResponse,
  UpdatePoolResponseResponse,
  UpdatePoolRequest,
  GetVersionResponseResponse,
} from "./model";
import { apiInstance } from "../../../api/apiInstance";
import type { ErrorType } from "../../../api/apiInstance";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * Cluster index.
 * @summary getCluster
 */
export const getCluster = (signal?: AbortSignal) => {
  return apiInstance<GetClusterResponseResponse>({
    url: `/cluster`,
    method: "get",
    signal,
  });
};

export const getGetClusterQueryKey = () => [`/cluster`] as const;

export const getGetClusterQueryOptions = <
  TData = Awaited<ReturnType<typeof getCluster>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCluster>>,
    TError,
    TData
  >;
}): UseQueryOptions<Awaited<ReturnType<typeof getCluster>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCluster>>> = ({
    signal,
  }) => getCluster(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCluster>>
>;
export type GetClusterQueryError = ErrorType<unknown>;

/**
 * @summary getCluster
 */
export const useGetCluster = <
  TData = Awaited<ReturnType<typeof getCluster>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCluster>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List replication jobs.
 * @summary getClusterReplication
 */
export const getClusterReplication = (signal?: AbortSignal) => {
  return apiInstance<GetClusterReplicationResponseResponse>({
    url: `/cluster/replication`,
    method: "get",
    signal,
  });
};

export const getGetClusterReplicationQueryKey = () =>
  [`/cluster/replication`] as const;

export const getGetClusterReplicationQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterReplication>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterReplication>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterReplication>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterReplicationQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterReplication>>
  > = ({ signal }) => getClusterReplication(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterReplicationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterReplication>>
>;
export type GetClusterReplicationQueryError = ErrorType<unknown>;

/**
 * @summary getClusterReplication
 */
export const useGetClusterReplication = <
  TData = Awaited<ReturnType<typeof getClusterReplication>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterReplication>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterReplicationQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new replication job
 * @summary createClusterReplication
 */
export const createClusterReplication = (
  createClusterReplicationRequest: CreateClusterReplicationRequest,
) => {
  return apiInstance<CreateClusterReplicationResponseResponse>({
    url: `/cluster/replication`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterReplicationRequest,
  });
};

export const getCreateClusterReplicationMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterReplication>>,
    TError,
    { data: CreateClusterReplicationRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterReplication>>,
  TError,
  { data: CreateClusterReplicationRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterReplication>>,
    { data: CreateClusterReplicationRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterReplication(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterReplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterReplication>>
>;
export type CreateClusterReplicationMutationBody =
  CreateClusterReplicationRequest;
export type CreateClusterReplicationMutationError = ErrorType<unknown>;

/**
 * @summary createClusterReplication
 */
export const useCreateClusterReplication = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterReplication>>,
    TError,
    { data: CreateClusterReplicationRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterReplicationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Mark replication job for removal.
 * @summary deleteClusterReplicationSingle
 */
export const deleteClusterReplicationSingle = (id: string) => {
  return apiInstance<DeleteClusterReplicationSingleResponseResponse>({
    url: `/cluster/replication/${id}`,
    method: "delete",
  });
};

export const getDeleteClusterReplicationSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterReplicationSingle>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterReplicationSingle>>,
  TError,
  { id: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterReplicationSingle>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteClusterReplicationSingle(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterReplicationSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterReplicationSingle>>
>;

export type DeleteClusterReplicationSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterReplicationSingle
 */
export const useDeleteClusterReplicationSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterReplicationSingle>>,
    TError,
    { id: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteClusterReplicationSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read replication job configuration.
 * @summary getClusterReplicationSingle
 */
export const getClusterReplicationSingle = (
  id: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterReplicationSingleResponseResponse>({
    url: `/cluster/replication/${id}`,
    method: "get",
    signal,
  });
};

export const getGetClusterReplicationSingleQueryKey = (id: string) =>
  [`/cluster/replication/${id}`] as const;

export const getGetClusterReplicationSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterReplicationSingle>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterReplicationSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterReplicationSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterReplicationSingleQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterReplicationSingle>>
  > = ({ signal }) => getClusterReplicationSingle(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type GetClusterReplicationSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterReplicationSingle>>
>;
export type GetClusterReplicationSingleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterReplicationSingle
 */
export const useGetClusterReplicationSingle = <
  TData = Awaited<ReturnType<typeof getClusterReplicationSingle>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterReplicationSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterReplicationSingleQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update replication job configuration.
 * @summary updateClusterReplicationSingle
 */
export const updateClusterReplicationSingle = (
  id: string,
  updateClusterReplicationSingleRequest: UpdateClusterReplicationSingleRequest,
) => {
  return apiInstance<UpdateClusterReplicationSingleResponseResponse>({
    url: `/cluster/replication/${id}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterReplicationSingleRequest,
  });
};

export const getUpdateClusterReplicationSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterReplicationSingle>>,
    TError,
    { id: string; data: UpdateClusterReplicationSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterReplicationSingle>>,
  TError,
  { id: string; data: UpdateClusterReplicationSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterReplicationSingle>>,
    { id: string; data: UpdateClusterReplicationSingleRequest }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateClusterReplicationSingle(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterReplicationSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterReplicationSingle>>
>;
export type UpdateClusterReplicationSingleMutationBody =
  UpdateClusterReplicationSingleRequest;
export type UpdateClusterReplicationSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterReplicationSingle
 */
export const useUpdateClusterReplicationSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterReplicationSingle>>,
    TError,
    { id: string; data: UpdateClusterReplicationSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterReplicationSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Metrics index.
 * @summary getClusterMetrics
 */
export const getClusterMetrics = (signal?: AbortSignal) => {
  return apiInstance<GetClusterMetricsResponseResponse>({
    url: `/cluster/metrics`,
    method: "get",
    signal,
  });
};

export const getGetClusterMetricsQueryKey = () => [`/cluster/metrics`] as const;

export const getGetClusterMetricsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterMetrics>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterMetrics>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterMetrics>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterMetricsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterMetrics>>
  > = ({ signal }) => getClusterMetrics(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterMetricsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterMetrics>>
>;
export type GetClusterMetricsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterMetrics
 */
export const useGetClusterMetrics = <
  TData = Awaited<ReturnType<typeof getClusterMetrics>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterMetrics>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterMetricsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List configured metric servers.
 * @summary getClusterMetricsServer
 */
export const getClusterMetricsServer = (signal?: AbortSignal) => {
  return apiInstance<GetClusterMetricsServerResponseResponse>({
    url: `/cluster/metrics/server`,
    method: "get",
    signal,
  });
};

export const getGetClusterMetricsServerQueryKey = () =>
  [`/cluster/metrics/server`] as const;

export const getGetClusterMetricsServerQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterMetricsServer>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterMetricsServer>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterMetricsServer>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterMetricsServerQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterMetricsServer>>
  > = ({ signal }) => getClusterMetricsServer(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterMetricsServerQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterMetricsServer>>
>;
export type GetClusterMetricsServerQueryError = ErrorType<unknown>;

/**
 * @summary getClusterMetricsServer
 */
export const useGetClusterMetricsServer = <
  TData = Awaited<ReturnType<typeof getClusterMetricsServer>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterMetricsServer>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterMetricsServerQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Remove Metric server.
 * @summary deleteClusterMetricsServerSingle
 */
export const deleteClusterMetricsServerSingle = (id: string) => {
  return apiInstance<DeleteClusterMetricsServerSingleResponseResponse>({
    url: `/cluster/metrics/server/${id}`,
    method: "delete",
  });
};

export const getDeleteClusterMetricsServerSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterMetricsServerSingle>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterMetricsServerSingle>>,
  TError,
  { id: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterMetricsServerSingle>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteClusterMetricsServerSingle(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterMetricsServerSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterMetricsServerSingle>>
>;

export type DeleteClusterMetricsServerSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterMetricsServerSingle
 */
export const useDeleteClusterMetricsServerSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterMetricsServerSingle>>,
    TError,
    { id: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteClusterMetricsServerSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read metric server configuration.
 * @summary getClusterMetricsServerSingle
 */
export const getClusterMetricsServerSingle = (
  id: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterMetricsServerSingleResponseResponse>({
    url: `/cluster/metrics/server/${id}`,
    method: "get",
    signal,
  });
};

export const getGetClusterMetricsServerSingleQueryKey = (id: string) =>
  [`/cluster/metrics/server/${id}`] as const;

export const getGetClusterMetricsServerSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterMetricsServerSingle>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterMetricsServerSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterMetricsServerSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterMetricsServerSingleQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterMetricsServerSingle>>
  > = ({ signal }) => getClusterMetricsServerSingle(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type GetClusterMetricsServerSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterMetricsServerSingle>>
>;
export type GetClusterMetricsServerSingleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterMetricsServerSingle
 */
export const useGetClusterMetricsServerSingle = <
  TData = Awaited<ReturnType<typeof getClusterMetricsServerSingle>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterMetricsServerSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterMetricsServerSingleQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new external metric server config
 * @summary createClusterMetricsServerSingle
 */
export const createClusterMetricsServerSingle = (
  id: string,
  createClusterMetricsServerSingleRequest: CreateClusterMetricsServerSingleRequest,
) => {
  return apiInstance<CreateClusterMetricsServerSingleResponseResponse>({
    url: `/cluster/metrics/server/${id}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterMetricsServerSingleRequest,
  });
};

export const getCreateClusterMetricsServerSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterMetricsServerSingle>>,
    TError,
    { id: string; data: CreateClusterMetricsServerSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterMetricsServerSingle>>,
  TError,
  { id: string; data: CreateClusterMetricsServerSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterMetricsServerSingle>>,
    { id: string; data: CreateClusterMetricsServerSingleRequest }
  > = (props) => {
    const { id, data } = props ?? {};

    return createClusterMetricsServerSingle(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterMetricsServerSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterMetricsServerSingle>>
>;
export type CreateClusterMetricsServerSingleMutationBody =
  CreateClusterMetricsServerSingleRequest;
export type CreateClusterMetricsServerSingleMutationError = ErrorType<unknown>;

/**
 * @summary createClusterMetricsServerSingle
 */
export const useCreateClusterMetricsServerSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterMetricsServerSingle>>,
    TError,
    { id: string; data: CreateClusterMetricsServerSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateClusterMetricsServerSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Update metric server configuration.
 * @summary updateClusterMetricsServerSingle
 */
export const updateClusterMetricsServerSingle = (
  id: string,
  updateClusterMetricsServerSingleRequest: UpdateClusterMetricsServerSingleRequest,
) => {
  return apiInstance<UpdateClusterMetricsServerSingleResponseResponse>({
    url: `/cluster/metrics/server/${id}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterMetricsServerSingleRequest,
  });
};

export const getUpdateClusterMetricsServerSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterMetricsServerSingle>>,
    TError,
    { id: string; data: UpdateClusterMetricsServerSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterMetricsServerSingle>>,
  TError,
  { id: string; data: UpdateClusterMetricsServerSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterMetricsServerSingle>>,
    { id: string; data: UpdateClusterMetricsServerSingleRequest }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateClusterMetricsServerSingle(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterMetricsServerSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterMetricsServerSingle>>
>;
export type UpdateClusterMetricsServerSingleMutationBody =
  UpdateClusterMetricsServerSingleRequest;
export type UpdateClusterMetricsServerSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterMetricsServerSingle
 */
export const useUpdateClusterMetricsServerSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterMetricsServerSingle>>,
    TError,
    { id: string; data: UpdateClusterMetricsServerSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterMetricsServerSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index.
 * @summary getClusterConfig
 */
export const getClusterConfig = (signal?: AbortSignal) => {
  return apiInstance<GetClusterConfigResponseResponse>({
    url: `/cluster/config`,
    method: "get",
    signal,
  });
};

export const getGetClusterConfigQueryKey = () => [`/cluster/config`] as const;

export const getGetClusterConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterConfig>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfig>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterConfig>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterConfigQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterConfig>>
  > = ({ signal }) => getClusterConfig(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterConfig>>
>;
export type GetClusterConfigQueryError = ErrorType<unknown>;

/**
 * @summary getClusterConfig
 */
export const useGetClusterConfig = <
  TData = Awaited<ReturnType<typeof getClusterConfig>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfig>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterConfigQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Generate new cluster configuration. If no links given, default to local IP address as link0.
 * @summary createClusterConfig
 */
export const createClusterConfig = (
  createClusterConfigRequest: CreateClusterConfigRequest,
) => {
  return apiInstance<CreateClusterConfigResponseResponse>({
    url: `/cluster/config`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterConfigRequest,
  });
};

export const getCreateClusterConfigMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterConfig>>,
    TError,
    { data: CreateClusterConfigRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterConfig>>,
  TError,
  { data: CreateClusterConfigRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterConfig>>,
    { data: CreateClusterConfigRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterConfig(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterConfig>>
>;
export type CreateClusterConfigMutationBody = CreateClusterConfigRequest;
export type CreateClusterConfigMutationError = ErrorType<unknown>;

/**
 * @summary createClusterConfig
 */
export const useCreateClusterConfig = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterConfig>>,
    TError,
    { data: CreateClusterConfigRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Return the version of the cluster join API available on this node.
 * @summary getClusterConfigApiversion
 */
export const getClusterConfigApiversion = (signal?: AbortSignal) => {
  return apiInstance<GetClusterConfigApiversionResponseResponse>({
    url: `/cluster/config/apiversion`,
    method: "get",
    signal,
  });
};

export const getGetClusterConfigApiversionQueryKey = () =>
  [`/cluster/config/apiversion`] as const;

export const getGetClusterConfigApiversionQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterConfigApiversion>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigApiversion>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterConfigApiversion>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterConfigApiversionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterConfigApiversion>>
  > = ({ signal }) => getClusterConfigApiversion(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterConfigApiversionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterConfigApiversion>>
>;
export type GetClusterConfigApiversionQueryError = ErrorType<unknown>;

/**
 * @summary getClusterConfigApiversion
 */
export const useGetClusterConfigApiversion = <
  TData = Awaited<ReturnType<typeof getClusterConfigApiversion>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigApiversion>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterConfigApiversionQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Corosync node list.
 * @summary getClusterConfigNodes
 */
export const getClusterConfigNodes = (signal?: AbortSignal) => {
  return apiInstance<GetClusterConfigNodesResponseResponse>({
    url: `/cluster/config/nodes`,
    method: "get",
    signal,
  });
};

export const getGetClusterConfigNodesQueryKey = () =>
  [`/cluster/config/nodes`] as const;

export const getGetClusterConfigNodesQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterConfigNodes>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigNodes>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterConfigNodes>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterConfigNodesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterConfigNodes>>
  > = ({ signal }) => getClusterConfigNodes(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterConfigNodesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterConfigNodes>>
>;
export type GetClusterConfigNodesQueryError = ErrorType<unknown>;

/**
 * @summary getClusterConfigNodes
 */
export const useGetClusterConfigNodes = <
  TData = Awaited<ReturnType<typeof getClusterConfigNodes>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigNodes>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterConfigNodesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Removes a node from the cluster configuration.
 * @summary deleteClusterConfigNodesSingle
 */
export const deleteClusterConfigNodesSingle = (node: string) => {
  return apiInstance<DeleteClusterConfigNodesSingleResponseResponse>({
    url: `/cluster/config/nodes/${node}`,
    method: "delete",
  });
};

export const getDeleteClusterConfigNodesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterConfigNodesSingle>>,
    TError,
    { node: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterConfigNodesSingle>>,
  TError,
  { node: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterConfigNodesSingle>>,
    { node: string }
  > = (props) => {
    const { node } = props ?? {};

    return deleteClusterConfigNodesSingle(node);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterConfigNodesSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterConfigNodesSingle>>
>;

export type DeleteClusterConfigNodesSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterConfigNodesSingle
 */
export const useDeleteClusterConfigNodesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterConfigNodesSingle>>,
    TError,
    { node: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteClusterConfigNodesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Adds a node to the cluster configuration. This call is for internal use.
 * @summary createClusterConfigNodesSingle
 */
export const createClusterConfigNodesSingle = (
  node: string,
  createClusterConfigNodesSingleRequest: CreateClusterConfigNodesSingleRequest,
) => {
  return apiInstance<CreateClusterConfigNodesSingleResponseResponse>({
    url: `/cluster/config/nodes/${node}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterConfigNodesSingleRequest,
  });
};

export const getCreateClusterConfigNodesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterConfigNodesSingle>>,
    TError,
    { node: string; data: CreateClusterConfigNodesSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterConfigNodesSingle>>,
  TError,
  { node: string; data: CreateClusterConfigNodesSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterConfigNodesSingle>>,
    { node: string; data: CreateClusterConfigNodesSingleRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createClusterConfigNodesSingle(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterConfigNodesSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterConfigNodesSingle>>
>;
export type CreateClusterConfigNodesSingleMutationBody =
  CreateClusterConfigNodesSingleRequest;
export type CreateClusterConfigNodesSingleMutationError = ErrorType<unknown>;

/**
 * @summary createClusterConfigNodesSingle
 */
export const useCreateClusterConfigNodesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterConfigNodesSingle>>,
    TError,
    { node: string; data: CreateClusterConfigNodesSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateClusterConfigNodesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get information needed to join this cluster over the connected node.
 * @summary getClusterConfigJoin
 */
export const getClusterConfigJoin = (signal?: AbortSignal) => {
  return apiInstance<GetClusterConfigJoinResponseResponse>({
    url: `/cluster/config/join`,
    method: "get",
    signal,
  });
};

export const getGetClusterConfigJoinQueryKey = () =>
  [`/cluster/config/join`] as const;

export const getGetClusterConfigJoinQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterConfigJoin>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigJoin>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterConfigJoin>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterConfigJoinQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterConfigJoin>>
  > = ({ signal }) => getClusterConfigJoin(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterConfigJoinQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterConfigJoin>>
>;
export type GetClusterConfigJoinQueryError = ErrorType<unknown>;

/**
 * @summary getClusterConfigJoin
 */
export const useGetClusterConfigJoin = <
  TData = Awaited<ReturnType<typeof getClusterConfigJoin>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigJoin>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterConfigJoinQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Joins this node into an existing cluster. If no links are given, default to IP resolved by node's hostname on single link (fallback fails for clusters with multiple links).
 * @summary createClusterConfigJoin
 */
export const createClusterConfigJoin = (
  createClusterConfigJoinRequest: CreateClusterConfigJoinRequest,
) => {
  return apiInstance<CreateClusterConfigJoinResponseResponse>({
    url: `/cluster/config/join`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterConfigJoinRequest,
  });
};

export const getCreateClusterConfigJoinMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterConfigJoin>>,
    TError,
    { data: CreateClusterConfigJoinRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterConfigJoin>>,
  TError,
  { data: CreateClusterConfigJoinRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterConfigJoin>>,
    { data: CreateClusterConfigJoinRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterConfigJoin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterConfigJoinMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterConfigJoin>>
>;
export type CreateClusterConfigJoinMutationBody =
  CreateClusterConfigJoinRequest;
export type CreateClusterConfigJoinMutationError = ErrorType<unknown>;

/**
 * @summary createClusterConfigJoin
 */
export const useCreateClusterConfigJoin = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterConfigJoin>>,
    TError,
    { data: CreateClusterConfigJoinRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterConfigJoinMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get corosync totem protocol settings.
 * @summary getClusterConfigTotem
 */
export const getClusterConfigTotem = (signal?: AbortSignal) => {
  return apiInstance<GetClusterConfigTotemResponseResponse>({
    url: `/cluster/config/totem`,
    method: "get",
    signal,
  });
};

export const getGetClusterConfigTotemQueryKey = () =>
  [`/cluster/config/totem`] as const;

export const getGetClusterConfigTotemQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterConfigTotem>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigTotem>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterConfigTotem>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterConfigTotemQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterConfigTotem>>
  > = ({ signal }) => getClusterConfigTotem(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterConfigTotemQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterConfigTotem>>
>;
export type GetClusterConfigTotemQueryError = ErrorType<unknown>;

/**
 * @summary getClusterConfigTotem
 */
export const useGetClusterConfigTotem = <
  TData = Awaited<ReturnType<typeof getClusterConfigTotem>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigTotem>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterConfigTotemQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get QDevice status
 * @summary getClusterConfigQdevice
 */
export const getClusterConfigQdevice = (signal?: AbortSignal) => {
  return apiInstance<GetClusterConfigQdeviceResponseResponse>({
    url: `/cluster/config/qdevice`,
    method: "get",
    signal,
  });
};

export const getGetClusterConfigQdeviceQueryKey = () =>
  [`/cluster/config/qdevice`] as const;

export const getGetClusterConfigQdeviceQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterConfigQdevice>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigQdevice>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterConfigQdevice>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterConfigQdeviceQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterConfigQdevice>>
  > = ({ signal }) => getClusterConfigQdevice(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterConfigQdeviceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterConfigQdevice>>
>;
export type GetClusterConfigQdeviceQueryError = ErrorType<unknown>;

/**
 * @summary getClusterConfigQdevice
 */
export const useGetClusterConfigQdevice = <
  TData = Awaited<ReturnType<typeof getClusterConfigQdevice>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfigQdevice>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterConfigQdeviceQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Directory index.
 * @summary getClusterFirewall
 */
export const getClusterFirewall = (signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallResponseResponse>({
    url: `/cluster/firewall`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallQueryKey = () =>
  [`/cluster/firewall`] as const;

export const getGetClusterFirewallQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewall>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewall>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewall>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterFirewallQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewall>>
  > = ({ signal }) => getClusterFirewall(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterFirewallQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewall>>
>;
export type GetClusterFirewallQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewall
 */
export const useGetClusterFirewall = <
  TData = Awaited<ReturnType<typeof getClusterFirewall>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewall>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List security groups.
 * @summary getClusterFirewallGroups
 */
export const getClusterFirewallGroups = (signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallGroupsResponseResponse>({
    url: `/cluster/firewall/groups`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallGroupsQueryKey = () =>
  [`/cluster/firewall/groups`] as const;

export const getGetClusterFirewallGroupsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallGroups>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallGroups>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallGroups>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallGroupsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallGroups>>
  > = ({ signal }) => getClusterFirewallGroups(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterFirewallGroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallGroups>>
>;
export type GetClusterFirewallGroupsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallGroups
 */
export const useGetClusterFirewallGroups = <
  TData = Awaited<ReturnType<typeof getClusterFirewallGroups>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallGroups>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallGroupsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new security group.
 * @summary createClusterFirewallGroup
 */
export const createClusterFirewallGroup = (
  createClusterFirewallGroupRequest: CreateClusterFirewallGroupRequest,
) => {
  return apiInstance<CreateClusterFirewallGroupResponseResponse>({
    url: `/cluster/firewall/groups`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterFirewallGroupRequest,
  });
};

export const getCreateClusterFirewallGroupMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterFirewallGroup>>,
    TError,
    { data: CreateClusterFirewallGroupRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterFirewallGroup>>,
  TError,
  { data: CreateClusterFirewallGroupRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterFirewallGroup>>,
    { data: CreateClusterFirewallGroupRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterFirewallGroup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterFirewallGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterFirewallGroup>>
>;
export type CreateClusterFirewallGroupMutationBody =
  CreateClusterFirewallGroupRequest;
export type CreateClusterFirewallGroupMutationError = ErrorType<unknown>;

/**
 * @summary createClusterFirewallGroup
 */
export const useCreateClusterFirewallGroup = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterFirewallGroup>>,
    TError,
    { data: CreateClusterFirewallGroupRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterFirewallGroupMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete security group.
 * @summary deleteClusterFirewallGroup
 */
export const deleteClusterFirewallGroup = (group: string) => {
  return apiInstance<DeleteClusterFirewallGroupResponseResponse>({
    url: `/cluster/firewall/groups/${group}`,
    method: "delete",
  });
};

export const getDeleteClusterFirewallGroupMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterFirewallGroup>>,
    TError,
    { group: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterFirewallGroup>>,
  TError,
  { group: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterFirewallGroup>>,
    { group: string }
  > = (props) => {
    const { group } = props ?? {};

    return deleteClusterFirewallGroup(group);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterFirewallGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterFirewallGroup>>
>;

export type DeleteClusterFirewallGroupMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterFirewallGroup
 */
export const useDeleteClusterFirewallGroup = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterFirewallGroup>>,
    TError,
    { group: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteClusterFirewallGroupMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List rules.
 * @summary getClusterFirewallGroupRules
 */
export const getClusterFirewallGroupRules = (
  group: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterFirewallGroupRulesResponseResponse>({
    url: `/cluster/firewall/groups/${group}`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallGroupRulesQueryKey = (group: string) =>
  [`/cluster/firewall/groups/${group}`] as const;

export const getGetClusterFirewallGroupRulesQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallGroupRules>>,
  TError = ErrorType<unknown>,
>(
  group: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallGroupRules>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallGroupRules>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallGroupRulesQueryKey(group);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallGroupRules>>
  > = ({ signal }) => getClusterFirewallGroupRules(group, signal);

  return { queryKey, queryFn, enabled: !!group, ...queryOptions };
};

export type GetClusterFirewallGroupRulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallGroupRules>>
>;
export type GetClusterFirewallGroupRulesQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallGroupRules
 */
export const useGetClusterFirewallGroupRules = <
  TData = Awaited<ReturnType<typeof getClusterFirewallGroupRules>>,
  TError = ErrorType<unknown>,
>(
  group: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallGroupRules>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallGroupRulesQueryOptions(
    group,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new rule.
 * @summary addClusterFirewallGroupRule
 */
export const addClusterFirewallGroupRule = (
  group: string,
  addClusterFirewallGroupRuleRequest: AddClusterFirewallGroupRuleRequest,
) => {
  return apiInstance<AddClusterFirewallGroupRuleResponseResponse>({
    url: `/cluster/firewall/groups/${group}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: addClusterFirewallGroupRuleRequest,
  });
};

export const getAddClusterFirewallGroupRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addClusterFirewallGroupRule>>,
    TError,
    { group: string; data: AddClusterFirewallGroupRuleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addClusterFirewallGroupRule>>,
  TError,
  { group: string; data: AddClusterFirewallGroupRuleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addClusterFirewallGroupRule>>,
    { group: string; data: AddClusterFirewallGroupRuleRequest }
  > = (props) => {
    const { group, data } = props ?? {};

    return addClusterFirewallGroupRule(group, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddClusterFirewallGroupRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof addClusterFirewallGroupRule>>
>;
export type AddClusterFirewallGroupRuleMutationBody =
  AddClusterFirewallGroupRuleRequest;
export type AddClusterFirewallGroupRuleMutationError = ErrorType<unknown>;

/**
 * @summary addClusterFirewallGroupRule
 */
export const useAddClusterFirewallGroupRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addClusterFirewallGroupRule>>,
    TError,
    { group: string; data: AddClusterFirewallGroupRuleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getAddClusterFirewallGroupRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete rule.
 * @summary removeClusterFirewallGroupRule
 */
export const removeClusterFirewallGroupRule = (group: string, pos: number) => {
  return apiInstance<RemoveClusterFirewallGroupRuleResponseResponse>({
    url: `/cluster/firewall/groups/${group}/${pos}`,
    method: "delete",
  });
};

export const getRemoveClusterFirewallGroupRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeClusterFirewallGroupRule>>,
    TError,
    { group: string; pos: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeClusterFirewallGroupRule>>,
  TError,
  { group: string; pos: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeClusterFirewallGroupRule>>,
    { group: string; pos: number }
  > = (props) => {
    const { group, pos } = props ?? {};

    return removeClusterFirewallGroupRule(group, pos);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveClusterFirewallGroupRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeClusterFirewallGroupRule>>
>;

export type RemoveClusterFirewallGroupRuleMutationError = ErrorType<unknown>;

/**
 * @summary removeClusterFirewallGroupRule
 */
export const useRemoveClusterFirewallGroupRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeClusterFirewallGroupRule>>,
    TError,
    { group: string; pos: number },
    TContext
  >;
}) => {
  const mutationOptions =
    getRemoveClusterFirewallGroupRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get single rule data.
 * @summary getClusterFirewallGroupRule
 */
export const getClusterFirewallGroupRule = (
  group: string,
  pos: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterFirewallGroupRuleResponseResponse>({
    url: `/cluster/firewall/groups/${group}/${pos}`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallGroupRuleQueryKey = (
  group: string,
  pos: number,
) => [`/cluster/firewall/groups/${group}/${pos}`] as const;

export const getGetClusterFirewallGroupRuleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallGroupRule>>,
  TError = ErrorType<unknown>,
>(
  group: string,
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallGroupRule>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallGroupRule>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetClusterFirewallGroupRuleQueryKey(group, pos);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallGroupRule>>
  > = ({ signal }) => getClusterFirewallGroupRule(group, pos, signal);

  return { queryKey, queryFn, enabled: !!(group && pos), ...queryOptions };
};

export type GetClusterFirewallGroupRuleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallGroupRule>>
>;
export type GetClusterFirewallGroupRuleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallGroupRule
 */
export const useGetClusterFirewallGroupRule = <
  TData = Awaited<ReturnType<typeof getClusterFirewallGroupRule>>,
  TError = ErrorType<unknown>,
>(
  group: string,
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallGroupRule>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallGroupRuleQueryOptions(
    group,
    pos,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Modify rule data.
 * @summary updateClusterFirewallGroupRule
 */
export const updateClusterFirewallGroupRule = (
  group: string,
  pos: number,
  updateClusterFirewallGroupRuleRequest: UpdateClusterFirewallGroupRuleRequest,
) => {
  return apiInstance<UpdateClusterFirewallGroupRuleResponseResponse>({
    url: `/cluster/firewall/groups/${group}/${pos}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterFirewallGroupRuleRequest,
  });
};

export const getUpdateClusterFirewallGroupRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallGroupRule>>,
    TError,
    { group: string; pos: number; data: UpdateClusterFirewallGroupRuleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterFirewallGroupRule>>,
  TError,
  { group: string; pos: number; data: UpdateClusterFirewallGroupRuleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterFirewallGroupRule>>,
    { group: string; pos: number; data: UpdateClusterFirewallGroupRuleRequest }
  > = (props) => {
    const { group, pos, data } = props ?? {};

    return updateClusterFirewallGroupRule(group, pos, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterFirewallGroupRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterFirewallGroupRule>>
>;
export type UpdateClusterFirewallGroupRuleMutationBody =
  UpdateClusterFirewallGroupRuleRequest;
export type UpdateClusterFirewallGroupRuleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterFirewallGroupRule
 */
export const useUpdateClusterFirewallGroupRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallGroupRule>>,
    TError,
    { group: string; pos: number; data: UpdateClusterFirewallGroupRuleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterFirewallGroupRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List rules.
 * @summary getClusterFirewallRules
 */
export const getClusterFirewallRules = (signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallRulesResponseResponse>({
    url: `/cluster/firewall/rules`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallRulesQueryKey = () =>
  [`/cluster/firewall/rules`] as const;

export const getGetClusterFirewallRulesQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallRules>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallRules>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallRules>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallRulesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallRules>>
  > = ({ signal }) => getClusterFirewallRules(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterFirewallRulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallRules>>
>;
export type GetClusterFirewallRulesQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallRules
 */
export const useGetClusterFirewallRules = <
  TData = Awaited<ReturnType<typeof getClusterFirewallRules>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallRules>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallRulesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new rule.
 * @summary addClusterFirewallRule
 */
export const addClusterFirewallRule = (
  addClusterFirewallRuleRequest: AddClusterFirewallRuleRequest,
) => {
  return apiInstance<AddClusterFirewallRuleResponseResponse>({
    url: `/cluster/firewall/rules`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: addClusterFirewallRuleRequest,
  });
};

export const getAddClusterFirewallRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addClusterFirewallRule>>,
    TError,
    { data: AddClusterFirewallRuleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addClusterFirewallRule>>,
  TError,
  { data: AddClusterFirewallRuleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addClusterFirewallRule>>,
    { data: AddClusterFirewallRuleRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addClusterFirewallRule(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddClusterFirewallRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof addClusterFirewallRule>>
>;
export type AddClusterFirewallRuleMutationBody = AddClusterFirewallRuleRequest;
export type AddClusterFirewallRuleMutationError = ErrorType<unknown>;

/**
 * @summary addClusterFirewallRule
 */
export const useAddClusterFirewallRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addClusterFirewallRule>>,
    TError,
    { data: AddClusterFirewallRuleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getAddClusterFirewallRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete rule.
 * @summary removeClusterFirewallRule
 */
export const removeClusterFirewallRule = (pos: number) => {
  return apiInstance<RemoveClusterFirewallRuleResponseResponse>({
    url: `/cluster/firewall/rules/${pos}`,
    method: "delete",
  });
};

export const getRemoveClusterFirewallRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeClusterFirewallRule>>,
    TError,
    { pos: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeClusterFirewallRule>>,
  TError,
  { pos: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeClusterFirewallRule>>,
    { pos: number }
  > = (props) => {
    const { pos } = props ?? {};

    return removeClusterFirewallRule(pos);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveClusterFirewallRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeClusterFirewallRule>>
>;

export type RemoveClusterFirewallRuleMutationError = ErrorType<unknown>;

/**
 * @summary removeClusterFirewallRule
 */
export const useRemoveClusterFirewallRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeClusterFirewallRule>>,
    TError,
    { pos: number },
    TContext
  >;
}) => {
  const mutationOptions = getRemoveClusterFirewallRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get single rule data.
 * @summary getClusterFirewallRule
 */
export const getClusterFirewallRule = (pos: number, signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallRuleResponseResponse>({
    url: `/cluster/firewall/rules/${pos}`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallRuleQueryKey = (pos: number) =>
  [`/cluster/firewall/rules/${pos}`] as const;

export const getGetClusterFirewallRuleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallRule>>,
  TError = ErrorType<unknown>,
>(
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallRule>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallRule>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallRuleQueryKey(pos);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallRule>>
  > = ({ signal }) => getClusterFirewallRule(pos, signal);

  return { queryKey, queryFn, enabled: !!pos, ...queryOptions };
};

export type GetClusterFirewallRuleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallRule>>
>;
export type GetClusterFirewallRuleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallRule
 */
export const useGetClusterFirewallRule = <
  TData = Awaited<ReturnType<typeof getClusterFirewallRule>>,
  TError = ErrorType<unknown>,
>(
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallRule>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallRuleQueryOptions(pos, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Modify rule data.
 * @summary updateClusterFirewallRule
 */
export const updateClusterFirewallRule = (
  pos: number,
  updateClusterFirewallRuleRequest: UpdateClusterFirewallRuleRequest,
) => {
  return apiInstance<UpdateClusterFirewallRuleResponseResponse>({
    url: `/cluster/firewall/rules/${pos}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterFirewallRuleRequest,
  });
};

export const getUpdateClusterFirewallRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallRule>>,
    TError,
    { pos: number; data: UpdateClusterFirewallRuleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterFirewallRule>>,
  TError,
  { pos: number; data: UpdateClusterFirewallRuleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterFirewallRule>>,
    { pos: number; data: UpdateClusterFirewallRuleRequest }
  > = (props) => {
    const { pos, data } = props ?? {};

    return updateClusterFirewallRule(pos, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterFirewallRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterFirewallRule>>
>;
export type UpdateClusterFirewallRuleMutationBody =
  UpdateClusterFirewallRuleRequest;
export type UpdateClusterFirewallRuleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterFirewallRule
 */
export const useUpdateClusterFirewallRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallRule>>,
    TError,
    { pos: number; data: UpdateClusterFirewallRuleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateClusterFirewallRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List IPSets
 * @summary getClusterFirewallIPSets
 */
export const getClusterFirewallIPSets = (signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallIPSetsResponseResponse>({
    url: `/cluster/firewall/ipset`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallIPSetsQueryKey = () =>
  [`/cluster/firewall/ipset`] as const;

export const getGetClusterFirewallIPSetsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallIPSets>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallIPSets>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallIPSets>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallIPSetsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallIPSets>>
  > = ({ signal }) => getClusterFirewallIPSets(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterFirewallIPSetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallIPSets>>
>;
export type GetClusterFirewallIPSetsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallIPSets
 */
export const useGetClusterFirewallIPSets = <
  TData = Awaited<ReturnType<typeof getClusterFirewallIPSets>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallIPSets>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallIPSetsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new IPSet
 * @summary createClusterFirewallIPSet
 */
export const createClusterFirewallIPSet = (
  createClusterFirewallIPSetRequest: CreateClusterFirewallIPSetRequest,
) => {
  return apiInstance<CreateClusterFirewallIPSetResponseResponse>({
    url: `/cluster/firewall/ipset`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterFirewallIPSetRequest,
  });
};

export const getCreateClusterFirewallIPSetMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterFirewallIPSet>>,
    TError,
    { data: CreateClusterFirewallIPSetRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterFirewallIPSet>>,
  TError,
  { data: CreateClusterFirewallIPSetRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterFirewallIPSet>>,
    { data: CreateClusterFirewallIPSetRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterFirewallIPSet(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterFirewallIPSetMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterFirewallIPSet>>
>;
export type CreateClusterFirewallIPSetMutationBody =
  CreateClusterFirewallIPSetRequest;
export type CreateClusterFirewallIPSetMutationError = ErrorType<unknown>;

/**
 * @summary createClusterFirewallIPSet
 */
export const useCreateClusterFirewallIPSet = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterFirewallIPSet>>,
    TError,
    { data: CreateClusterFirewallIPSetRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterFirewallIPSetMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete IPSet
 * @summary deleteClusterFirewallIPSet
 */
export const deleteClusterFirewallIPSet = (name: string) => {
  return apiInstance<DeleteClusterFirewallIPSetResponseResponse>({
    url: `/cluster/firewall/ipset/${name}`,
    method: "delete",
  });
};

export const getDeleteClusterFirewallIPSetMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterFirewallIPSet>>,
    TError,
    { name: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterFirewallIPSet>>,
  TError,
  { name: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterFirewallIPSet>>,
    { name: string }
  > = (props) => {
    const { name } = props ?? {};

    return deleteClusterFirewallIPSet(name);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterFirewallIPSetMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterFirewallIPSet>>
>;

export type DeleteClusterFirewallIPSetMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterFirewallIPSet
 */
export const useDeleteClusterFirewallIPSet = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterFirewallIPSet>>,
    TError,
    { name: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteClusterFirewallIPSetMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List IPSet content
 * @summary getClusterFirewallIPSet
 */
export const getClusterFirewallIPSet = (name: string, signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallIPSetResponseResponse>({
    url: `/cluster/firewall/ipset/${name}`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallIPSetQueryKey = (name: string) =>
  [`/cluster/firewall/ipset/${name}`] as const;

export const getGetClusterFirewallIPSetQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallIPSet>>,
  TError = ErrorType<unknown>,
>(
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallIPSet>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallIPSet>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallIPSetQueryKey(name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallIPSet>>
  > = ({ signal }) => getClusterFirewallIPSet(name, signal);

  return { queryKey, queryFn, enabled: !!name, ...queryOptions };
};

export type GetClusterFirewallIPSetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallIPSet>>
>;
export type GetClusterFirewallIPSetQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallIPSet
 */
export const useGetClusterFirewallIPSet = <
  TData = Awaited<ReturnType<typeof getClusterFirewallIPSet>>,
  TError = ErrorType<unknown>,
>(
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallIPSet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallIPSetQueryOptions(name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Add IP or Network to IPSet.
 * @summary addClusterFirewallIPSetIP
 */
export const addClusterFirewallIPSetIP = (
  name: string,
  addClusterFirewallIPSetIPRequest: AddClusterFirewallIPSetIPRequest,
) => {
  return apiInstance<AddClusterFirewallIPSetIPResponseResponse>({
    url: `/cluster/firewall/ipset/${name}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: addClusterFirewallIPSetIPRequest,
  });
};

export const getAddClusterFirewallIPSetIPMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addClusterFirewallIPSetIP>>,
    TError,
    { name: string; data: AddClusterFirewallIPSetIPRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addClusterFirewallIPSetIP>>,
  TError,
  { name: string; data: AddClusterFirewallIPSetIPRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addClusterFirewallIPSetIP>>,
    { name: string; data: AddClusterFirewallIPSetIPRequest }
  > = (props) => {
    const { name, data } = props ?? {};

    return addClusterFirewallIPSetIP(name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddClusterFirewallIPSetIPMutationResult = NonNullable<
  Awaited<ReturnType<typeof addClusterFirewallIPSetIP>>
>;
export type AddClusterFirewallIPSetIPMutationBody =
  AddClusterFirewallIPSetIPRequest;
export type AddClusterFirewallIPSetIPMutationError = ErrorType<unknown>;

/**
 * @summary addClusterFirewallIPSetIP
 */
export const useAddClusterFirewallIPSetIP = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addClusterFirewallIPSetIP>>,
    TError,
    { name: string; data: AddClusterFirewallIPSetIPRequest },
    TContext
  >;
}) => {
  const mutationOptions = getAddClusterFirewallIPSetIPMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove IP or Network from IPSet.
 * @summary removeClusterFirewallIPSetIP
 */
export const removeClusterFirewallIPSetIP = (name: string, cidr: string) => {
  return apiInstance<RemoveClusterFirewallIPSetIPResponseResponse>({
    url: `/cluster/firewall/ipset/${name}/${cidr}`,
    method: "delete",
  });
};

export const getRemoveClusterFirewallIPSetIPMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeClusterFirewallIPSetIP>>,
    TError,
    { name: string; cidr: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeClusterFirewallIPSetIP>>,
  TError,
  { name: string; cidr: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeClusterFirewallIPSetIP>>,
    { name: string; cidr: string }
  > = (props) => {
    const { name, cidr } = props ?? {};

    return removeClusterFirewallIPSetIP(name, cidr);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveClusterFirewallIPSetIPMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeClusterFirewallIPSetIP>>
>;

export type RemoveClusterFirewallIPSetIPMutationError = ErrorType<unknown>;

/**
 * @summary removeClusterFirewallIPSetIP
 */
export const useRemoveClusterFirewallIPSetIP = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeClusterFirewallIPSetIP>>,
    TError,
    { name: string; cidr: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getRemoveClusterFirewallIPSetIPMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read IP or Network settings from IPSet.
 * @summary getClusterFirewallIPSetIP
 */
export const getClusterFirewallIPSetIP = (
  name: string,
  cidr: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterFirewallIPSetIPResponseResponse>({
    url: `/cluster/firewall/ipset/${name}/${cidr}`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallIPSetIPQueryKey = (
  name: string,
  cidr: string,
) => [`/cluster/firewall/ipset/${name}/${cidr}`] as const;

export const getGetClusterFirewallIPSetIPQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallIPSetIP>>,
  TError = ErrorType<unknown>,
>(
  name: string,
  cidr: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallIPSetIP>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallIPSetIP>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallIPSetIPQueryKey(name, cidr);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallIPSetIP>>
  > = ({ signal }) => getClusterFirewallIPSetIP(name, cidr, signal);

  return { queryKey, queryFn, enabled: !!(name && cidr), ...queryOptions };
};

export type GetClusterFirewallIPSetIPQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallIPSetIP>>
>;
export type GetClusterFirewallIPSetIPQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallIPSetIP
 */
export const useGetClusterFirewallIPSetIP = <
  TData = Awaited<ReturnType<typeof getClusterFirewallIPSetIP>>,
  TError = ErrorType<unknown>,
>(
  name: string,
  cidr: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallIPSetIP>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallIPSetIPQueryOptions(
    name,
    cidr,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update IP or Network settings
 * @summary updateClusterFirewallIPSetIP
 */
export const updateClusterFirewallIPSetIP = (
  name: string,
  cidr: string,
  updateClusterFirewallIPSetIPRequest: UpdateClusterFirewallIPSetIPRequest,
) => {
  return apiInstance<UpdateClusterFirewallIPSetIPResponseResponse>({
    url: `/cluster/firewall/ipset/${name}/${cidr}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterFirewallIPSetIPRequest,
  });
};

export const getUpdateClusterFirewallIPSetIPMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallIPSetIP>>,
    TError,
    { name: string; cidr: string; data: UpdateClusterFirewallIPSetIPRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterFirewallIPSetIP>>,
  TError,
  { name: string; cidr: string; data: UpdateClusterFirewallIPSetIPRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterFirewallIPSetIP>>,
    { name: string; cidr: string; data: UpdateClusterFirewallIPSetIPRequest }
  > = (props) => {
    const { name, cidr, data } = props ?? {};

    return updateClusterFirewallIPSetIP(name, cidr, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterFirewallIPSetIPMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterFirewallIPSetIP>>
>;
export type UpdateClusterFirewallIPSetIPMutationBody =
  UpdateClusterFirewallIPSetIPRequest;
export type UpdateClusterFirewallIPSetIPMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterFirewallIPSetIP
 */
export const useUpdateClusterFirewallIPSetIP = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallIPSetIP>>,
    TError,
    { name: string; cidr: string; data: UpdateClusterFirewallIPSetIPRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterFirewallIPSetIPMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List aliases
 * @summary getClusterFirewallAliases
 */
export const getClusterFirewallAliases = (signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallAliasesResponseResponse>({
    url: `/cluster/firewall/aliases`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallAliasesQueryKey = () =>
  [`/cluster/firewall/aliases`] as const;

export const getGetClusterFirewallAliasesQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallAliases>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallAliases>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallAliases>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallAliasesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallAliases>>
  > = ({ signal }) => getClusterFirewallAliases(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterFirewallAliasesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallAliases>>
>;
export type GetClusterFirewallAliasesQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallAliases
 */
export const useGetClusterFirewallAliases = <
  TData = Awaited<ReturnType<typeof getClusterFirewallAliases>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallAliases>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallAliasesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create IP or Network Alias.
 * @summary createClusterFirewallAliases
 */
export const createClusterFirewallAliases = (
  createClusterFirewallAliasesRequest: CreateClusterFirewallAliasesRequest,
) => {
  return apiInstance<CreateClusterFirewallAliasesResponseResponse>({
    url: `/cluster/firewall/aliases`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterFirewallAliasesRequest,
  });
};

export const getCreateClusterFirewallAliasesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterFirewallAliases>>,
    TError,
    { data: CreateClusterFirewallAliasesRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterFirewallAliases>>,
  TError,
  { data: CreateClusterFirewallAliasesRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterFirewallAliases>>,
    { data: CreateClusterFirewallAliasesRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterFirewallAliases(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterFirewallAliasesMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterFirewallAliases>>
>;
export type CreateClusterFirewallAliasesMutationBody =
  CreateClusterFirewallAliasesRequest;
export type CreateClusterFirewallAliasesMutationError = ErrorType<unknown>;

/**
 * @summary createClusterFirewallAliases
 */
export const useCreateClusterFirewallAliases = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterFirewallAliases>>,
    TError,
    { data: CreateClusterFirewallAliasesRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateClusterFirewallAliasesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove IP or Network alias.
 * @summary deleteClusterFirewallAliasesSingle
 */
export const deleteClusterFirewallAliasesSingle = (name: string) => {
  return apiInstance<DeleteClusterFirewallAliasesSingleResponseResponse>({
    url: `/cluster/firewall/aliases/${name}`,
    method: "delete",
  });
};

export const getDeleteClusterFirewallAliasesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterFirewallAliasesSingle>>,
    TError,
    { name: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterFirewallAliasesSingle>>,
  TError,
  { name: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterFirewallAliasesSingle>>,
    { name: string }
  > = (props) => {
    const { name } = props ?? {};

    return deleteClusterFirewallAliasesSingle(name);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterFirewallAliasesSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterFirewallAliasesSingle>>
>;

export type DeleteClusterFirewallAliasesSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteClusterFirewallAliasesSingle
 */
export const useDeleteClusterFirewallAliasesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterFirewallAliasesSingle>>,
    TError,
    { name: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteClusterFirewallAliasesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read alias.
 * @summary getClusterFirewallAliasesSingle
 */
export const getClusterFirewallAliasesSingle = (
  name: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterFirewallAliasesSingleResponseResponse>({
    url: `/cluster/firewall/aliases/${name}`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallAliasesSingleQueryKey = (name: string) =>
  [`/cluster/firewall/aliases/${name}`] as const;

export const getGetClusterFirewallAliasesSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallAliasesSingle>>,
  TError = ErrorType<unknown>,
>(
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallAliasesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallAliasesSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallAliasesSingleQueryKey(name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallAliasesSingle>>
  > = ({ signal }) => getClusterFirewallAliasesSingle(name, signal);

  return { queryKey, queryFn, enabled: !!name, ...queryOptions };
};

export type GetClusterFirewallAliasesSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallAliasesSingle>>
>;
export type GetClusterFirewallAliasesSingleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallAliasesSingle
 */
export const useGetClusterFirewallAliasesSingle = <
  TData = Awaited<ReturnType<typeof getClusterFirewallAliasesSingle>>,
  TError = ErrorType<unknown>,
>(
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterFirewallAliasesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallAliasesSingleQueryOptions(
    name,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update IP or Network alias.
 * @summary updateClusterFirewallAliasesSingle
 */
export const updateClusterFirewallAliasesSingle = (
  name: string,
  updateClusterFirewallAliasesSingleRequest: UpdateClusterFirewallAliasesSingleRequest,
) => {
  return apiInstance<UpdateClusterFirewallAliasesSingleResponseResponse>({
    url: `/cluster/firewall/aliases/${name}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterFirewallAliasesSingleRequest,
  });
};

export const getUpdateClusterFirewallAliasesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallAliasesSingle>>,
    TError,
    { name: string; data: UpdateClusterFirewallAliasesSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterFirewallAliasesSingle>>,
  TError,
  { name: string; data: UpdateClusterFirewallAliasesSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterFirewallAliasesSingle>>,
    { name: string; data: UpdateClusterFirewallAliasesSingleRequest }
  > = (props) => {
    const { name, data } = props ?? {};

    return updateClusterFirewallAliasesSingle(name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterFirewallAliasesSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterFirewallAliasesSingle>>
>;
export type UpdateClusterFirewallAliasesSingleMutationBody =
  UpdateClusterFirewallAliasesSingleRequest;
export type UpdateClusterFirewallAliasesSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary updateClusterFirewallAliasesSingle
 */
export const useUpdateClusterFirewallAliasesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallAliasesSingle>>,
    TError,
    { name: string; data: UpdateClusterFirewallAliasesSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterFirewallAliasesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get Firewall options.
 * @summary getClusterFirewallOptions
 */
export const getClusterFirewallOptions = (signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallOptionsResponseResponse>({
    url: `/cluster/firewall/options`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallOptionsQueryKey = () =>
  [`/cluster/firewall/options`] as const;

export const getGetClusterFirewallOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallOptions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallOptions>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallOptions>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallOptions>>
  > = ({ signal }) => getClusterFirewallOptions(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterFirewallOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallOptions>>
>;
export type GetClusterFirewallOptionsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallOptions
 */
export const useGetClusterFirewallOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallOptions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallOptions>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallOptionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set Firewall options.
 * @summary updateClusterFirewallOptions
 */
export const updateClusterFirewallOptions = (
  updateClusterFirewallOptionsRequest: UpdateClusterFirewallOptionsRequest,
) => {
  return apiInstance<UpdateClusterFirewallOptionsResponseResponse>({
    url: `/cluster/firewall/options`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterFirewallOptionsRequest,
  });
};

export const getUpdateClusterFirewallOptionsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallOptions>>,
    TError,
    { data: UpdateClusterFirewallOptionsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterFirewallOptions>>,
  TError,
  { data: UpdateClusterFirewallOptionsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterFirewallOptions>>,
    { data: UpdateClusterFirewallOptionsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateClusterFirewallOptions(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterFirewallOptionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterFirewallOptions>>
>;
export type UpdateClusterFirewallOptionsMutationBody =
  UpdateClusterFirewallOptionsRequest;
export type UpdateClusterFirewallOptionsMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterFirewallOptions
 */
export const useUpdateClusterFirewallOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterFirewallOptions>>,
    TError,
    { data: UpdateClusterFirewallOptionsRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterFirewallOptionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List available macros
 * @summary getClusterFirewallMacros
 */
export const getClusterFirewallMacros = (signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallMacrosResponseResponse>({
    url: `/cluster/firewall/macros`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallMacrosQueryKey = () =>
  [`/cluster/firewall/macros`] as const;

export const getGetClusterFirewallMacrosQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallMacros>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallMacros>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallMacros>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallMacrosQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallMacros>>
  > = ({ signal }) => getClusterFirewallMacros(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterFirewallMacrosQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallMacros>>
>;
export type GetClusterFirewallMacrosQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallMacros
 */
export const useGetClusterFirewallMacros = <
  TData = Awaited<ReturnType<typeof getClusterFirewallMacros>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallMacros>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallMacrosQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Lists possible IPSet/Alias reference which are allowed in source/dest properties.
 * @summary getClusterFirewallRefs
 */
export const getClusterFirewallRefs = (signal?: AbortSignal) => {
  return apiInstance<GetClusterFirewallRefsResponseResponse>({
    url: `/cluster/firewall/refs`,
    method: "get",
    signal,
  });
};

export const getGetClusterFirewallRefsQueryKey = () =>
  [`/cluster/firewall/refs`] as const;

export const getGetClusterFirewallRefsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterFirewallRefs>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallRefs>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterFirewallRefs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterFirewallRefsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterFirewallRefs>>
  > = ({ signal }) => getClusterFirewallRefs(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterFirewallRefsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterFirewallRefs>>
>;
export type GetClusterFirewallRefsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterFirewallRefs
 */
export const useGetClusterFirewallRefs = <
  TData = Awaited<ReturnType<typeof getClusterFirewallRefs>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterFirewallRefs>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterFirewallRefsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List vzdump backup schedule.
 * @summary getClusterBackup
 */
export const getClusterBackup = (signal?: AbortSignal) => {
  return apiInstance<GetClusterBackupResponseResponse>({
    url: `/cluster/backup`,
    method: "get",
    signal,
  });
};

export const getGetClusterBackupQueryKey = () => [`/cluster/backup`] as const;

export const getGetClusterBackupQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterBackup>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterBackup>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterBackup>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterBackupQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterBackup>>
  > = ({ signal }) => getClusterBackup(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterBackupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterBackup>>
>;
export type GetClusterBackupQueryError = ErrorType<unknown>;

/**
 * @summary getClusterBackup
 */
export const useGetClusterBackup = <
  TData = Awaited<ReturnType<typeof getClusterBackup>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterBackup>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterBackupQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new vzdump backup job.
 * @summary createClusterBackup
 */
export const createClusterBackup = (
  createClusterBackupRequest: CreateClusterBackupRequest,
) => {
  return apiInstance<CreateClusterBackupResponseResponse>({
    url: `/cluster/backup`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterBackupRequest,
  });
};

export const getCreateClusterBackupMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterBackup>>,
    TError,
    { data: CreateClusterBackupRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterBackup>>,
  TError,
  { data: CreateClusterBackupRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterBackup>>,
    { data: CreateClusterBackupRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterBackup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterBackupMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterBackup>>
>;
export type CreateClusterBackupMutationBody = CreateClusterBackupRequest;
export type CreateClusterBackupMutationError = ErrorType<unknown>;

/**
 * @summary createClusterBackup
 */
export const useCreateClusterBackup = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterBackup>>,
    TError,
    { data: CreateClusterBackupRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterBackupMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete vzdump backup job definition.
 * @summary deleteClusterBackupSingle
 */
export const deleteClusterBackupSingle = (id: string) => {
  return apiInstance<DeleteClusterBackupSingleResponseResponse>({
    url: `/cluster/backup/${id}`,
    method: "delete",
  });
};

export const getDeleteClusterBackupSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterBackupSingle>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterBackupSingle>>,
  TError,
  { id: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterBackupSingle>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteClusterBackupSingle(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterBackupSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterBackupSingle>>
>;

export type DeleteClusterBackupSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterBackupSingle
 */
export const useDeleteClusterBackupSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterBackupSingle>>,
    TError,
    { id: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteClusterBackupSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read vzdump backup job definition.
 * @summary getClusterBackupSingle
 */
export const getClusterBackupSingle = (id: string, signal?: AbortSignal) => {
  return apiInstance<GetClusterBackupSingleResponseResponse>({
    url: `/cluster/backup/${id}`,
    method: "get",
    signal,
  });
};

export const getGetClusterBackupSingleQueryKey = (id: string) =>
  [`/cluster/backup/${id}`] as const;

export const getGetClusterBackupSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterBackupSingle>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterBackupSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterBackupSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterBackupSingleQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterBackupSingle>>
  > = ({ signal }) => getClusterBackupSingle(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type GetClusterBackupSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterBackupSingle>>
>;
export type GetClusterBackupSingleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterBackupSingle
 */
export const useGetClusterBackupSingle = <
  TData = Awaited<ReturnType<typeof getClusterBackupSingle>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterBackupSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterBackupSingleQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update vzdump backup job definition.
 * @summary updateClusterBackupSingle
 */
export const updateClusterBackupSingle = (
  id: string,
  updateClusterBackupSingleRequest: UpdateClusterBackupSingleRequest,
) => {
  return apiInstance<UpdateClusterBackupSingleResponseResponse>({
    url: `/cluster/backup/${id}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterBackupSingleRequest,
  });
};

export const getUpdateClusterBackupSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterBackupSingle>>,
    TError,
    { id: string; data: UpdateClusterBackupSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterBackupSingle>>,
  TError,
  { id: string; data: UpdateClusterBackupSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterBackupSingle>>,
    { id: string; data: UpdateClusterBackupSingleRequest }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateClusterBackupSingle(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterBackupSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterBackupSingle>>
>;
export type UpdateClusterBackupSingleMutationBody =
  UpdateClusterBackupSingleRequest;
export type UpdateClusterBackupSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterBackupSingle
 */
export const useUpdateClusterBackupSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterBackupSingle>>,
    TError,
    { id: string; data: UpdateClusterBackupSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateClusterBackupSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Returns included guests and the backup status of their disks. Optimized to be used in ExtJS tree views.
 * @summary getClusterBackupSingleIncludedvolumes
 */
export const getClusterBackupSingleIncludedvolumes = (
  id: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterBackupSingleIncludedvolumesResponseResponse>({
    url: `/cluster/backup/${id}/included_volumes`,
    method: "get",
    signal,
  });
};

export const getGetClusterBackupSingleIncludedvolumesQueryKey = (id: string) =>
  [`/cluster/backup/${id}/included_volumes`] as const;

export const getGetClusterBackupSingleIncludedvolumesQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterBackupSingleIncludedvolumes>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterBackupSingleIncludedvolumes>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterBackupSingleIncludedvolumes>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetClusterBackupSingleIncludedvolumesQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterBackupSingleIncludedvolumes>>
  > = ({ signal }) => getClusterBackupSingleIncludedvolumes(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type GetClusterBackupSingleIncludedvolumesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterBackupSingleIncludedvolumes>>
>;
export type GetClusterBackupSingleIncludedvolumesQueryError =
  ErrorType<unknown>;

/**
 * @summary getClusterBackupSingleIncludedvolumes
 */
export const useGetClusterBackupSingleIncludedvolumes = <
  TData = Awaited<ReturnType<typeof getClusterBackupSingleIncludedvolumes>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterBackupSingleIncludedvolumes>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterBackupSingleIncludedvolumesQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Stub, waits for future use.
 * @summary getClusterBackupinfo
 */
export const getClusterBackupinfo = (signal?: AbortSignal) => {
  return apiInstance<GetClusterBackupinfoResponseResponse>({
    url: `/cluster/backupinfo`,
    method: "get",
    signal,
  });
};

export const getGetClusterBackupinfoQueryKey = () =>
  [`/cluster/backupinfo`] as const;

export const getGetClusterBackupinfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterBackupinfo>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterBackupinfo>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterBackupinfo>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterBackupinfoQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterBackupinfo>>
  > = ({ signal }) => getClusterBackupinfo(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterBackupinfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterBackupinfo>>
>;
export type GetClusterBackupinfoQueryError = ErrorType<unknown>;

/**
 * @summary getClusterBackupinfo
 */
export const useGetClusterBackupinfo = <
  TData = Awaited<ReturnType<typeof getClusterBackupinfo>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterBackupinfo>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterBackupinfoQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Shows all guests which are not covered by any backup job.
 * @summary getClusterBackupinfoNotbackedup
 */
export const getClusterBackupinfoNotbackedup = (signal?: AbortSignal) => {
  return apiInstance<GetClusterBackupinfoNotbackedupResponseResponse>({
    url: `/cluster/backupinfo/not_backed_up`,
    method: "get",
    signal,
  });
};

export const getGetClusterBackupinfoNotbackedupQueryKey = () =>
  [`/cluster/backupinfo/not_backed_up`] as const;

export const getGetClusterBackupinfoNotbackedupQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterBackupinfoNotbackedup>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterBackupinfoNotbackedup>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterBackupinfoNotbackedup>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterBackupinfoNotbackedupQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterBackupinfoNotbackedup>>
  > = ({ signal }) => getClusterBackupinfoNotbackedup(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterBackupinfoNotbackedupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterBackupinfoNotbackedup>>
>;
export type GetClusterBackupinfoNotbackedupQueryError = ErrorType<unknown>;

/**
 * @summary getClusterBackupinfoNotbackedup
 */
export const useGetClusterBackupinfoNotbackedup = <
  TData = Awaited<ReturnType<typeof getClusterBackupinfoNotbackedup>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterBackupinfoNotbackedup>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterBackupinfoNotbackedupQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Directory index.
 * @summary getClusterHa
 */
export const getClusterHa = (signal?: AbortSignal) => {
  return apiInstance<GetClusterHaResponseResponse>({
    url: `/cluster/ha`,
    method: "get",
    signal,
  });
};

export const getGetClusterHaQueryKey = () => [`/cluster/ha`] as const;

export const getGetClusterHaQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterHa>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHa>>,
    TError,
    TData
  >;
}): UseQueryOptions<Awaited<ReturnType<typeof getClusterHa>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterHaQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClusterHa>>> = ({
    signal,
  }) => getClusterHa(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterHaQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterHa>>
>;
export type GetClusterHaQueryError = ErrorType<unknown>;

/**
 * @summary getClusterHa
 */
export const useGetClusterHa = <
  TData = Awaited<ReturnType<typeof getClusterHa>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHa>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterHaQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List HA resources.
 * @summary getClusterHaResources
 */
export const getClusterHaResources = (signal?: AbortSignal) => {
  return apiInstance<GetClusterHaResourcesResponseResponse>({
    url: `/cluster/ha/resources`,
    method: "get",
    signal,
  });
};

export const getGetClusterHaResourcesQueryKey = () =>
  [`/cluster/ha/resources`] as const;

export const getGetClusterHaResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterHaResources>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaResources>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterHaResources>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterHaResourcesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterHaResources>>
  > = ({ signal }) => getClusterHaResources(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterHaResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterHaResources>>
>;
export type GetClusterHaResourcesQueryError = ErrorType<unknown>;

/**
 * @summary getClusterHaResources
 */
export const useGetClusterHaResources = <
  TData = Awaited<ReturnType<typeof getClusterHaResources>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaResources>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterHaResourcesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new HA resource.
 * @summary createClusterHaResources
 */
export const createClusterHaResources = (
  createClusterHaResourcesRequest: CreateClusterHaResourcesRequest,
) => {
  return apiInstance<CreateClusterHaResourcesResponseResponse>({
    url: `/cluster/ha/resources`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterHaResourcesRequest,
  });
};

export const getCreateClusterHaResourcesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterHaResources>>,
    TError,
    { data: CreateClusterHaResourcesRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterHaResources>>,
  TError,
  { data: CreateClusterHaResourcesRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterHaResources>>,
    { data: CreateClusterHaResourcesRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterHaResources(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterHaResourcesMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterHaResources>>
>;
export type CreateClusterHaResourcesMutationBody =
  CreateClusterHaResourcesRequest;
export type CreateClusterHaResourcesMutationError = ErrorType<unknown>;

/**
 * @summary createClusterHaResources
 */
export const useCreateClusterHaResources = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterHaResources>>,
    TError,
    { data: CreateClusterHaResourcesRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterHaResourcesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete resource configuration.
 * @summary deleteClusterHaResourcesSingle
 */
export const deleteClusterHaResourcesSingle = (sid: string) => {
  return apiInstance<DeleteClusterHaResourcesSingleResponseResponse>({
    url: `/cluster/ha/resources/${sid}`,
    method: "delete",
  });
};

export const getDeleteClusterHaResourcesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterHaResourcesSingle>>,
    TError,
    { sid: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterHaResourcesSingle>>,
  TError,
  { sid: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterHaResourcesSingle>>,
    { sid: string }
  > = (props) => {
    const { sid } = props ?? {};

    return deleteClusterHaResourcesSingle(sid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterHaResourcesSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterHaResourcesSingle>>
>;

export type DeleteClusterHaResourcesSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterHaResourcesSingle
 */
export const useDeleteClusterHaResourcesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterHaResourcesSingle>>,
    TError,
    { sid: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteClusterHaResourcesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read resource configuration.
 * @summary getClusterHaResourcesSingle
 */
export const getClusterHaResourcesSingle = (
  sid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterHaResourcesSingleResponseResponse>({
    url: `/cluster/ha/resources/${sid}`,
    method: "get",
    signal,
  });
};

export const getGetClusterHaResourcesSingleQueryKey = (sid: string) =>
  [`/cluster/ha/resources/${sid}`] as const;

export const getGetClusterHaResourcesSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterHaResourcesSingle>>,
  TError = ErrorType<unknown>,
>(
  sid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterHaResourcesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterHaResourcesSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterHaResourcesSingleQueryKey(sid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterHaResourcesSingle>>
  > = ({ signal }) => getClusterHaResourcesSingle(sid, signal);

  return { queryKey, queryFn, enabled: !!sid, ...queryOptions };
};

export type GetClusterHaResourcesSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterHaResourcesSingle>>
>;
export type GetClusterHaResourcesSingleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterHaResourcesSingle
 */
export const useGetClusterHaResourcesSingle = <
  TData = Awaited<ReturnType<typeof getClusterHaResourcesSingle>>,
  TError = ErrorType<unknown>,
>(
  sid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterHaResourcesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterHaResourcesSingleQueryOptions(sid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update resource configuration.
 * @summary updateClusterHaResourcesSingle
 */
export const updateClusterHaResourcesSingle = (
  sid: string,
  updateClusterHaResourcesSingleRequest: UpdateClusterHaResourcesSingleRequest,
) => {
  return apiInstance<UpdateClusterHaResourcesSingleResponseResponse>({
    url: `/cluster/ha/resources/${sid}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterHaResourcesSingleRequest,
  });
};

export const getUpdateClusterHaResourcesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterHaResourcesSingle>>,
    TError,
    { sid: string; data: UpdateClusterHaResourcesSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterHaResourcesSingle>>,
  TError,
  { sid: string; data: UpdateClusterHaResourcesSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterHaResourcesSingle>>,
    { sid: string; data: UpdateClusterHaResourcesSingleRequest }
  > = (props) => {
    const { sid, data } = props ?? {};

    return updateClusterHaResourcesSingle(sid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterHaResourcesSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterHaResourcesSingle>>
>;
export type UpdateClusterHaResourcesSingleMutationBody =
  UpdateClusterHaResourcesSingleRequest;
export type UpdateClusterHaResourcesSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterHaResourcesSingle
 */
export const useUpdateClusterHaResourcesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterHaResourcesSingle>>,
    TError,
    { sid: string; data: UpdateClusterHaResourcesSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterHaResourcesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Request resource migration (online) to another node.
 * @summary createClusterHaResourcesSingleMigrate
 */
export const createClusterHaResourcesSingleMigrate = (
  sid: string,
  createClusterHaResourcesSingleMigrateRequest: CreateClusterHaResourcesSingleMigrateRequest,
) => {
  return apiInstance<CreateClusterHaResourcesSingleMigrateResponseResponse>({
    url: `/cluster/ha/resources/${sid}/migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterHaResourcesSingleMigrateRequest,
  });
};

export const getCreateClusterHaResourcesSingleMigrateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterHaResourcesSingleMigrate>>,
    TError,
    { sid: string; data: CreateClusterHaResourcesSingleMigrateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterHaResourcesSingleMigrate>>,
  TError,
  { sid: string; data: CreateClusterHaResourcesSingleMigrateRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterHaResourcesSingleMigrate>>,
    { sid: string; data: CreateClusterHaResourcesSingleMigrateRequest }
  > = (props) => {
    const { sid, data } = props ?? {};

    return createClusterHaResourcesSingleMigrate(sid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterHaResourcesSingleMigrateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterHaResourcesSingleMigrate>>
>;
export type CreateClusterHaResourcesSingleMigrateMutationBody =
  CreateClusterHaResourcesSingleMigrateRequest;
export type CreateClusterHaResourcesSingleMigrateMutationError =
  ErrorType<unknown>;

/**
 * @summary createClusterHaResourcesSingleMigrate
 */
export const useCreateClusterHaResourcesSingleMigrate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterHaResourcesSingleMigrate>>,
    TError,
    { sid: string; data: CreateClusterHaResourcesSingleMigrateRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateClusterHaResourcesSingleMigrateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Request resource relocatzion to another node. This stops the service on the old node, and restarts it on the target node.
 * @summary createClusterHaResourcesSingleRelocate
 */
export const createClusterHaResourcesSingleRelocate = (
  sid: string,
  createClusterHaResourcesSingleRelocateRequest: CreateClusterHaResourcesSingleRelocateRequest,
) => {
  return apiInstance<CreateClusterHaResourcesSingleRelocateResponseResponse>({
    url: `/cluster/ha/resources/${sid}/relocate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterHaResourcesSingleRelocateRequest,
  });
};

export const getCreateClusterHaResourcesSingleRelocateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterHaResourcesSingleRelocate>>,
    TError,
    { sid: string; data: CreateClusterHaResourcesSingleRelocateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterHaResourcesSingleRelocate>>,
  TError,
  { sid: string; data: CreateClusterHaResourcesSingleRelocateRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterHaResourcesSingleRelocate>>,
    { sid: string; data: CreateClusterHaResourcesSingleRelocateRequest }
  > = (props) => {
    const { sid, data } = props ?? {};

    return createClusterHaResourcesSingleRelocate(sid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterHaResourcesSingleRelocateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterHaResourcesSingleRelocate>>
>;
export type CreateClusterHaResourcesSingleRelocateMutationBody =
  CreateClusterHaResourcesSingleRelocateRequest;
export type CreateClusterHaResourcesSingleRelocateMutationError =
  ErrorType<unknown>;

/**
 * @summary createClusterHaResourcesSingleRelocate
 */
export const useCreateClusterHaResourcesSingleRelocate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterHaResourcesSingleRelocate>>,
    TError,
    { sid: string; data: CreateClusterHaResourcesSingleRelocateRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateClusterHaResourcesSingleRelocateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get HA groups.
 * @summary getClusterHaGroups
 */
export const getClusterHaGroups = (signal?: AbortSignal) => {
  return apiInstance<GetClusterHaGroupsResponseResponse>({
    url: `/cluster/ha/groups`,
    method: "get",
    signal,
  });
};

export const getGetClusterHaGroupsQueryKey = () =>
  [`/cluster/ha/groups`] as const;

export const getGetClusterHaGroupsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterHaGroups>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaGroups>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterHaGroups>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterHaGroupsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterHaGroups>>
  > = ({ signal }) => getClusterHaGroups(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterHaGroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterHaGroups>>
>;
export type GetClusterHaGroupsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterHaGroups
 */
export const useGetClusterHaGroups = <
  TData = Awaited<ReturnType<typeof getClusterHaGroups>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaGroups>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterHaGroupsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new HA group.
 * @summary createClusterHaGroups
 */
export const createClusterHaGroups = (
  createClusterHaGroupsRequest: CreateClusterHaGroupsRequest,
) => {
  return apiInstance<CreateClusterHaGroupsResponseResponse>({
    url: `/cluster/ha/groups`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterHaGroupsRequest,
  });
};

export const getCreateClusterHaGroupsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterHaGroups>>,
    TError,
    { data: CreateClusterHaGroupsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterHaGroups>>,
  TError,
  { data: CreateClusterHaGroupsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterHaGroups>>,
    { data: CreateClusterHaGroupsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterHaGroups(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterHaGroupsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterHaGroups>>
>;
export type CreateClusterHaGroupsMutationBody = CreateClusterHaGroupsRequest;
export type CreateClusterHaGroupsMutationError = ErrorType<unknown>;

/**
 * @summary createClusterHaGroups
 */
export const useCreateClusterHaGroups = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterHaGroups>>,
    TError,
    { data: CreateClusterHaGroupsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterHaGroupsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete ha group configuration.
 * @summary deleteClusterHaGroupsSingle
 */
export const deleteClusterHaGroupsSingle = (group: string) => {
  return apiInstance<DeleteClusterHaGroupsSingleResponseResponse>({
    url: `/cluster/ha/groups/${group}`,
    method: "delete",
  });
};

export const getDeleteClusterHaGroupsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterHaGroupsSingle>>,
    TError,
    { group: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterHaGroupsSingle>>,
  TError,
  { group: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterHaGroupsSingle>>,
    { group: string }
  > = (props) => {
    const { group } = props ?? {};

    return deleteClusterHaGroupsSingle(group);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterHaGroupsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterHaGroupsSingle>>
>;

export type DeleteClusterHaGroupsSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterHaGroupsSingle
 */
export const useDeleteClusterHaGroupsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterHaGroupsSingle>>,
    TError,
    { group: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteClusterHaGroupsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read ha group configuration.
 * @summary getClusterHaGroupsSingle
 */
export const getClusterHaGroupsSingle = (
  group: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterHaGroupsSingleResponseResponse>({
    url: `/cluster/ha/groups/${group}`,
    method: "get",
    signal,
  });
};

export const getGetClusterHaGroupsSingleQueryKey = (group: string) =>
  [`/cluster/ha/groups/${group}`] as const;

export const getGetClusterHaGroupsSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterHaGroupsSingle>>,
  TError = ErrorType<unknown>,
>(
  group: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterHaGroupsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterHaGroupsSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterHaGroupsSingleQueryKey(group);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterHaGroupsSingle>>
  > = ({ signal }) => getClusterHaGroupsSingle(group, signal);

  return { queryKey, queryFn, enabled: !!group, ...queryOptions };
};

export type GetClusterHaGroupsSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterHaGroupsSingle>>
>;
export type GetClusterHaGroupsSingleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterHaGroupsSingle
 */
export const useGetClusterHaGroupsSingle = <
  TData = Awaited<ReturnType<typeof getClusterHaGroupsSingle>>,
  TError = ErrorType<unknown>,
>(
  group: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterHaGroupsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterHaGroupsSingleQueryOptions(group, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update ha group configuration.
 * @summary updateClusterHaGroupsSingle
 */
export const updateClusterHaGroupsSingle = (
  group: string,
  updateClusterHaGroupsSingleRequest: UpdateClusterHaGroupsSingleRequest,
) => {
  return apiInstance<UpdateClusterHaGroupsSingleResponseResponse>({
    url: `/cluster/ha/groups/${group}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterHaGroupsSingleRequest,
  });
};

export const getUpdateClusterHaGroupsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterHaGroupsSingle>>,
    TError,
    { group: string; data: UpdateClusterHaGroupsSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterHaGroupsSingle>>,
  TError,
  { group: string; data: UpdateClusterHaGroupsSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterHaGroupsSingle>>,
    { group: string; data: UpdateClusterHaGroupsSingleRequest }
  > = (props) => {
    const { group, data } = props ?? {};

    return updateClusterHaGroupsSingle(group, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterHaGroupsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterHaGroupsSingle>>
>;
export type UpdateClusterHaGroupsSingleMutationBody =
  UpdateClusterHaGroupsSingleRequest;
export type UpdateClusterHaGroupsSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterHaGroupsSingle
 */
export const useUpdateClusterHaGroupsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterHaGroupsSingle>>,
    TError,
    { group: string; data: UpdateClusterHaGroupsSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterHaGroupsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index.
 * @summary getClusterHaStatus
 */
export const getClusterHaStatus = (signal?: AbortSignal) => {
  return apiInstance<GetClusterHaStatusResponseResponse>({
    url: `/cluster/ha/status`,
    method: "get",
    signal,
  });
};

export const getGetClusterHaStatusQueryKey = () =>
  [`/cluster/ha/status`] as const;

export const getGetClusterHaStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterHaStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaStatus>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterHaStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterHaStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterHaStatus>>
  > = ({ signal }) => getClusterHaStatus(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterHaStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterHaStatus>>
>;
export type GetClusterHaStatusQueryError = ErrorType<unknown>;

/**
 * @summary getClusterHaStatus
 */
export const useGetClusterHaStatus = <
  TData = Awaited<ReturnType<typeof getClusterHaStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaStatus>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterHaStatusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get HA manger status.
 * @summary getClusterHaStatusCurrent
 */
export const getClusterHaStatusCurrent = (signal?: AbortSignal) => {
  return apiInstance<GetClusterHaStatusCurrentResponseResponse>({
    url: `/cluster/ha/status/current`,
    method: "get",
    signal,
  });
};

export const getGetClusterHaStatusCurrentQueryKey = () =>
  [`/cluster/ha/status/current`] as const;

export const getGetClusterHaStatusCurrentQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterHaStatusCurrent>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaStatusCurrent>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterHaStatusCurrent>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterHaStatusCurrentQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterHaStatusCurrent>>
  > = ({ signal }) => getClusterHaStatusCurrent(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterHaStatusCurrentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterHaStatusCurrent>>
>;
export type GetClusterHaStatusCurrentQueryError = ErrorType<unknown>;

/**
 * @summary getClusterHaStatusCurrent
 */
export const useGetClusterHaStatusCurrent = <
  TData = Awaited<ReturnType<typeof getClusterHaStatusCurrent>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaStatusCurrent>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterHaStatusCurrentQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get full HA manger status, including LRM status.
 * @summary getClusterHaStatusManagerstatus
 */
export const getClusterHaStatusManagerstatus = (signal?: AbortSignal) => {
  return apiInstance<GetClusterHaStatusManagerstatusResponseResponse>({
    url: `/cluster/ha/status/manager_status`,
    method: "get",
    signal,
  });
};

export const getGetClusterHaStatusManagerstatusQueryKey = () =>
  [`/cluster/ha/status/manager_status`] as const;

export const getGetClusterHaStatusManagerstatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterHaStatusManagerstatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaStatusManagerstatus>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterHaStatusManagerstatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterHaStatusManagerstatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterHaStatusManagerstatus>>
  > = ({ signal }) => getClusterHaStatusManagerstatus(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterHaStatusManagerstatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterHaStatusManagerstatus>>
>;
export type GetClusterHaStatusManagerstatusQueryError = ErrorType<unknown>;

/**
 * @summary getClusterHaStatusManagerstatus
 */
export const useGetClusterHaStatusManagerstatus = <
  TData = Awaited<ReturnType<typeof getClusterHaStatusManagerstatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterHaStatusManagerstatus>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterHaStatusManagerstatusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * ACMEAccount index.
 * @summary getClusterAcme
 */
export const getClusterAcme = (signal?: AbortSignal) => {
  return apiInstance<GetClusterAcmeResponseResponse>({
    url: `/cluster/acme`,
    method: "get",
    signal,
  });
};

export const getGetClusterAcmeQueryKey = () => [`/cluster/acme`] as const;

export const getGetClusterAcmeQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterAcme>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcme>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterAcme>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterAcmeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClusterAcme>>> = ({
    signal,
  }) => getClusterAcme(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterAcmeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterAcme>>
>;
export type GetClusterAcmeQueryError = ErrorType<unknown>;

/**
 * @summary getClusterAcme
 */
export const useGetClusterAcme = <
  TData = Awaited<ReturnType<typeof getClusterAcme>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcme>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterAcmeQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * ACME plugin index.
 * @summary getClusterAcmePlugins
 */
export const getClusterAcmePlugins = (signal?: AbortSignal) => {
  return apiInstance<GetClusterAcmePluginsResponseResponse>({
    url: `/cluster/acme/plugins`,
    method: "get",
    signal,
  });
};

export const getGetClusterAcmePluginsQueryKey = () =>
  [`/cluster/acme/plugins`] as const;

export const getGetClusterAcmePluginsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterAcmePlugins>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmePlugins>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterAcmePlugins>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterAcmePluginsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterAcmePlugins>>
  > = ({ signal }) => getClusterAcmePlugins(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterAcmePluginsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterAcmePlugins>>
>;
export type GetClusterAcmePluginsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterAcmePlugins
 */
export const useGetClusterAcmePlugins = <
  TData = Awaited<ReturnType<typeof getClusterAcmePlugins>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmePlugins>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterAcmePluginsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Add ACME plugin configuration.
 * @summary createClusterAcmePlugins
 */
export const createClusterAcmePlugins = (
  createClusterAcmePluginsRequest: CreateClusterAcmePluginsRequest,
) => {
  return apiInstance<CreateClusterAcmePluginsResponseResponse>({
    url: `/cluster/acme/plugins`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterAcmePluginsRequest,
  });
};

export const getCreateClusterAcmePluginsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterAcmePlugins>>,
    TError,
    { data: CreateClusterAcmePluginsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterAcmePlugins>>,
  TError,
  { data: CreateClusterAcmePluginsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterAcmePlugins>>,
    { data: CreateClusterAcmePluginsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterAcmePlugins(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterAcmePluginsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterAcmePlugins>>
>;
export type CreateClusterAcmePluginsMutationBody =
  CreateClusterAcmePluginsRequest;
export type CreateClusterAcmePluginsMutationError = ErrorType<unknown>;

/**
 * @summary createClusterAcmePlugins
 */
export const useCreateClusterAcmePlugins = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterAcmePlugins>>,
    TError,
    { data: CreateClusterAcmePluginsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterAcmePluginsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete ACME plugin configuration.
 * @summary deleteClusterAcmePluginsSingle
 */
export const deleteClusterAcmePluginsSingle = (id: string) => {
  return apiInstance<DeleteClusterAcmePluginsSingleResponseResponse>({
    url: `/cluster/acme/plugins/${id}`,
    method: "delete",
  });
};

export const getDeleteClusterAcmePluginsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterAcmePluginsSingle>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterAcmePluginsSingle>>,
  TError,
  { id: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterAcmePluginsSingle>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteClusterAcmePluginsSingle(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterAcmePluginsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterAcmePluginsSingle>>
>;

export type DeleteClusterAcmePluginsSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterAcmePluginsSingle
 */
export const useDeleteClusterAcmePluginsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterAcmePluginsSingle>>,
    TError,
    { id: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteClusterAcmePluginsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get ACME plugin configuration.
 * @summary getClusterAcmePluginsSingle
 */
export const getClusterAcmePluginsSingle = (
  id: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterAcmePluginsSingleResponseResponse>({
    url: `/cluster/acme/plugins/${id}`,
    method: "get",
    signal,
  });
};

export const getGetClusterAcmePluginsSingleQueryKey = (id: string) =>
  [`/cluster/acme/plugins/${id}`] as const;

export const getGetClusterAcmePluginsSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterAcmePluginsSingle>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterAcmePluginsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterAcmePluginsSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterAcmePluginsSingleQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterAcmePluginsSingle>>
  > = ({ signal }) => getClusterAcmePluginsSingle(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type GetClusterAcmePluginsSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterAcmePluginsSingle>>
>;
export type GetClusterAcmePluginsSingleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterAcmePluginsSingle
 */
export const useGetClusterAcmePluginsSingle = <
  TData = Awaited<ReturnType<typeof getClusterAcmePluginsSingle>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterAcmePluginsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterAcmePluginsSingleQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update ACME plugin configuration.
 * @summary updateClusterAcmePluginsSingle
 */
export const updateClusterAcmePluginsSingle = (
  id: string,
  updateClusterAcmePluginsSingleRequest: UpdateClusterAcmePluginsSingleRequest,
) => {
  return apiInstance<UpdateClusterAcmePluginsSingleResponseResponse>({
    url: `/cluster/acme/plugins/${id}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterAcmePluginsSingleRequest,
  });
};

export const getUpdateClusterAcmePluginsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterAcmePluginsSingle>>,
    TError,
    { id: string; data: UpdateClusterAcmePluginsSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterAcmePluginsSingle>>,
  TError,
  { id: string; data: UpdateClusterAcmePluginsSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterAcmePluginsSingle>>,
    { id: string; data: UpdateClusterAcmePluginsSingleRequest }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateClusterAcmePluginsSingle(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterAcmePluginsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterAcmePluginsSingle>>
>;
export type UpdateClusterAcmePluginsSingleMutationBody =
  UpdateClusterAcmePluginsSingleRequest;
export type UpdateClusterAcmePluginsSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterAcmePluginsSingle
 */
export const useUpdateClusterAcmePluginsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterAcmePluginsSingle>>,
    TError,
    { id: string; data: UpdateClusterAcmePluginsSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterAcmePluginsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ACMEAccount index.
 * @summary getClusterAcmeAccount
 */
export const getClusterAcmeAccount = (signal?: AbortSignal) => {
  return apiInstance<GetClusterAcmeAccountResponseResponse>({
    url: `/cluster/acme/account`,
    method: "get",
    signal,
  });
};

export const getGetClusterAcmeAccountQueryKey = () =>
  [`/cluster/acme/account`] as const;

export const getGetClusterAcmeAccountQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterAcmeAccount>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmeAccount>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterAcmeAccount>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterAcmeAccountQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterAcmeAccount>>
  > = ({ signal }) => getClusterAcmeAccount(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterAcmeAccountQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterAcmeAccount>>
>;
export type GetClusterAcmeAccountQueryError = ErrorType<unknown>;

/**
 * @summary getClusterAcmeAccount
 */
export const useGetClusterAcmeAccount = <
  TData = Awaited<ReturnType<typeof getClusterAcmeAccount>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmeAccount>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterAcmeAccountQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Register a new ACME account with CA.
 * @summary createClusterAcmeAccount
 */
export const createClusterAcmeAccount = (
  createClusterAcmeAccountRequest: CreateClusterAcmeAccountRequest,
) => {
  return apiInstance<CreateClusterAcmeAccountResponseResponse>({
    url: `/cluster/acme/account`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterAcmeAccountRequest,
  });
};

export const getCreateClusterAcmeAccountMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterAcmeAccount>>,
    TError,
    { data: CreateClusterAcmeAccountRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterAcmeAccount>>,
  TError,
  { data: CreateClusterAcmeAccountRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterAcmeAccount>>,
    { data: CreateClusterAcmeAccountRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterAcmeAccount(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterAcmeAccountMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterAcmeAccount>>
>;
export type CreateClusterAcmeAccountMutationBody =
  CreateClusterAcmeAccountRequest;
export type CreateClusterAcmeAccountMutationError = ErrorType<unknown>;

/**
 * @summary createClusterAcmeAccount
 */
export const useCreateClusterAcmeAccount = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterAcmeAccount>>,
    TError,
    { data: CreateClusterAcmeAccountRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterAcmeAccountMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Deactivate existing ACME account at CA.
 * @summary deleteClusterAcmeAccountSingle
 */
export const deleteClusterAcmeAccountSingle = (name: string) => {
  return apiInstance<DeleteClusterAcmeAccountSingleResponseResponse>({
    url: `/cluster/acme/account/${name}`,
    method: "delete",
  });
};

export const getDeleteClusterAcmeAccountSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterAcmeAccountSingle>>,
    TError,
    { name: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterAcmeAccountSingle>>,
  TError,
  { name: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterAcmeAccountSingle>>,
    { name: string }
  > = (props) => {
    const { name } = props ?? {};

    return deleteClusterAcmeAccountSingle(name);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterAcmeAccountSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterAcmeAccountSingle>>
>;

export type DeleteClusterAcmeAccountSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterAcmeAccountSingle
 */
export const useDeleteClusterAcmeAccountSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterAcmeAccountSingle>>,
    TError,
    { name: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteClusterAcmeAccountSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Return existing ACME account information.
 * @summary getClusterAcmeAccountSingle
 */
export const getClusterAcmeAccountSingle = (
  name: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterAcmeAccountSingleResponseResponse>({
    url: `/cluster/acme/account/${name}`,
    method: "get",
    signal,
  });
};

export const getGetClusterAcmeAccountSingleQueryKey = (name: string) =>
  [`/cluster/acme/account/${name}`] as const;

export const getGetClusterAcmeAccountSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterAcmeAccountSingle>>,
  TError = ErrorType<unknown>,
>(
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterAcmeAccountSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterAcmeAccountSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterAcmeAccountSingleQueryKey(name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterAcmeAccountSingle>>
  > = ({ signal }) => getClusterAcmeAccountSingle(name, signal);

  return { queryKey, queryFn, enabled: !!name, ...queryOptions };
};

export type GetClusterAcmeAccountSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterAcmeAccountSingle>>
>;
export type GetClusterAcmeAccountSingleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterAcmeAccountSingle
 */
export const useGetClusterAcmeAccountSingle = <
  TData = Awaited<ReturnType<typeof getClusterAcmeAccountSingle>>,
  TError = ErrorType<unknown>,
>(
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterAcmeAccountSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterAcmeAccountSingleQueryOptions(
    name,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update existing ACME account information with CA. Note: not specifying any new account information triggers a refresh.
 * @summary updateClusterAcmeAccountSingle
 */
export const updateClusterAcmeAccountSingle = (
  name: string,
  updateClusterAcmeAccountSingleRequest: UpdateClusterAcmeAccountSingleRequest,
) => {
  return apiInstance<UpdateClusterAcmeAccountSingleResponseResponse>({
    url: `/cluster/acme/account/${name}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterAcmeAccountSingleRequest,
  });
};

export const getUpdateClusterAcmeAccountSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterAcmeAccountSingle>>,
    TError,
    { name: string; data: UpdateClusterAcmeAccountSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterAcmeAccountSingle>>,
  TError,
  { name: string; data: UpdateClusterAcmeAccountSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterAcmeAccountSingle>>,
    { name: string; data: UpdateClusterAcmeAccountSingleRequest }
  > = (props) => {
    const { name, data } = props ?? {};

    return updateClusterAcmeAccountSingle(name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterAcmeAccountSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterAcmeAccountSingle>>
>;
export type UpdateClusterAcmeAccountSingleMutationBody =
  UpdateClusterAcmeAccountSingleRequest;
export type UpdateClusterAcmeAccountSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterAcmeAccountSingle
 */
export const useUpdateClusterAcmeAccountSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterAcmeAccountSingle>>,
    TError,
    { name: string; data: UpdateClusterAcmeAccountSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterAcmeAccountSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve ACME TermsOfService URL from CA.
 * @summary getClusterAcmeTos
 */
export const getClusterAcmeTos = (signal?: AbortSignal) => {
  return apiInstance<GetClusterAcmeTosResponseResponse>({
    url: `/cluster/acme/tos`,
    method: "get",
    signal,
  });
};

export const getGetClusterAcmeTosQueryKey = () =>
  [`/cluster/acme/tos`] as const;

export const getGetClusterAcmeTosQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterAcmeTos>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmeTos>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterAcmeTos>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterAcmeTosQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterAcmeTos>>
  > = ({ signal }) => getClusterAcmeTos(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterAcmeTosQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterAcmeTos>>
>;
export type GetClusterAcmeTosQueryError = ErrorType<unknown>;

/**
 * @summary getClusterAcmeTos
 */
export const useGetClusterAcmeTos = <
  TData = Awaited<ReturnType<typeof getClusterAcmeTos>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmeTos>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterAcmeTosQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get named known ACME directory endpoints.
 * @summary getClusterAcmeDirectories
 */
export const getClusterAcmeDirectories = (signal?: AbortSignal) => {
  return apiInstance<GetClusterAcmeDirectoriesResponseResponse>({
    url: `/cluster/acme/directories`,
    method: "get",
    signal,
  });
};

export const getGetClusterAcmeDirectoriesQueryKey = () =>
  [`/cluster/acme/directories`] as const;

export const getGetClusterAcmeDirectoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterAcmeDirectories>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmeDirectories>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterAcmeDirectories>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterAcmeDirectoriesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterAcmeDirectories>>
  > = ({ signal }) => getClusterAcmeDirectories(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterAcmeDirectoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterAcmeDirectories>>
>;
export type GetClusterAcmeDirectoriesQueryError = ErrorType<unknown>;

/**
 * @summary getClusterAcmeDirectories
 */
export const useGetClusterAcmeDirectories = <
  TData = Awaited<ReturnType<typeof getClusterAcmeDirectories>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmeDirectories>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterAcmeDirectoriesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get schema of ACME challenge types.
 * @summary getClusterAcmeChallengeschema
 */
export const getClusterAcmeChallengeschema = (signal?: AbortSignal) => {
  return apiInstance<GetClusterAcmeChallengeschemaResponseResponse>({
    url: `/cluster/acme/challenge-schema`,
    method: "get",
    signal,
  });
};

export const getGetClusterAcmeChallengeschemaQueryKey = () =>
  [`/cluster/acme/challenge-schema`] as const;

export const getGetClusterAcmeChallengeschemaQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterAcmeChallengeschema>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmeChallengeschema>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterAcmeChallengeschema>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterAcmeChallengeschemaQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterAcmeChallengeschema>>
  > = ({ signal }) => getClusterAcmeChallengeschema(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterAcmeChallengeschemaQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterAcmeChallengeschema>>
>;
export type GetClusterAcmeChallengeschemaQueryError = ErrorType<unknown>;

/**
 * @summary getClusterAcmeChallengeschema
 */
export const useGetClusterAcmeChallengeschema = <
  TData = Awaited<ReturnType<typeof getClusterAcmeChallengeschema>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterAcmeChallengeschema>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterAcmeChallengeschemaQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Cluster ceph index.
 * @summary getClusterCeph
 */
export const getClusterCeph = (signal?: AbortSignal) => {
  return apiInstance<GetClusterCephResponseResponse>({
    url: `/cluster/ceph`,
    method: "get",
    signal,
  });
};

export const getGetClusterCephQueryKey = () => [`/cluster/ceph`] as const;

export const getGetClusterCephQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterCeph>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterCeph>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterCeph>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterCephQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClusterCeph>>> = ({
    signal,
  }) => getClusterCeph(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterCephQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterCeph>>
>;
export type GetClusterCephQueryError = ErrorType<unknown>;

/**
 * @summary getClusterCeph
 */
export const useGetClusterCeph = <
  TData = Awaited<ReturnType<typeof getClusterCeph>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterCeph>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterCephQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get ceph metadata.
 * @summary getClusterCephMetadata
 */
export const getClusterCephMetadata = (signal?: AbortSignal) => {
  return apiInstance<GetClusterCephMetadataResponseResponse>({
    url: `/cluster/ceph/metadata`,
    method: "get",
    signal,
  });
};

export const getGetClusterCephMetadataQueryKey = () =>
  [`/cluster/ceph/metadata`] as const;

export const getGetClusterCephMetadataQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterCephMetadata>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterCephMetadata>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterCephMetadata>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterCephMetadataQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterCephMetadata>>
  > = ({ signal }) => getClusterCephMetadata(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterCephMetadataQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterCephMetadata>>
>;
export type GetClusterCephMetadataQueryError = ErrorType<unknown>;

/**
 * @summary getClusterCephMetadata
 */
export const useGetClusterCephMetadata = <
  TData = Awaited<ReturnType<typeof getClusterCephMetadata>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterCephMetadata>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterCephMetadataQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get ceph status.
 * @summary getClusterCephStatus
 */
export const getClusterCephStatus = (signal?: AbortSignal) => {
  return apiInstance<GetClusterCephStatusResponseResponse>({
    url: `/cluster/ceph/status`,
    method: "get",
    signal,
  });
};

export const getGetClusterCephStatusQueryKey = () =>
  [`/cluster/ceph/status`] as const;

export const getGetClusterCephStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterCephStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterCephStatus>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterCephStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterCephStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterCephStatus>>
  > = ({ signal }) => getClusterCephStatus(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterCephStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterCephStatus>>
>;
export type GetClusterCephStatusQueryError = ErrorType<unknown>;

/**
 * @summary getClusterCephStatus
 */
export const useGetClusterCephStatus = <
  TData = Awaited<ReturnType<typeof getClusterCephStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterCephStatus>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterCephStatusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * get the status of all ceph flags
 * @summary getClusterCephFlags
 */
export const getClusterCephFlags = (signal?: AbortSignal) => {
  return apiInstance<GetClusterCephFlagsResponseResponse>({
    url: `/cluster/ceph/flags`,
    method: "get",
    signal,
  });
};

export const getGetClusterCephFlagsQueryKey = () =>
  [`/cluster/ceph/flags`] as const;

export const getGetClusterCephFlagsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterCephFlags>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterCephFlags>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterCephFlags>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterCephFlagsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterCephFlags>>
  > = ({ signal }) => getClusterCephFlags(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterCephFlagsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterCephFlags>>
>;
export type GetClusterCephFlagsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterCephFlags
 */
export const useGetClusterCephFlags = <
  TData = Awaited<ReturnType<typeof getClusterCephFlags>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterCephFlags>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterCephFlagsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set/Unset multiple ceph flags at once.
 * @summary updateClusterCephFlags
 */
export const updateClusterCephFlags = (
  updateClusterCephFlagsRequest: UpdateClusterCephFlagsRequest,
) => {
  return apiInstance<UpdateClusterCephFlagsResponseResponse>({
    url: `/cluster/ceph/flags`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterCephFlagsRequest,
  });
};

export const getUpdateClusterCephFlagsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterCephFlags>>,
    TError,
    { data: UpdateClusterCephFlagsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterCephFlags>>,
  TError,
  { data: UpdateClusterCephFlagsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterCephFlags>>,
    { data: UpdateClusterCephFlagsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateClusterCephFlags(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterCephFlagsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterCephFlags>>
>;
export type UpdateClusterCephFlagsMutationBody = UpdateClusterCephFlagsRequest;
export type UpdateClusterCephFlagsMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterCephFlags
 */
export const useUpdateClusterCephFlags = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterCephFlags>>,
    TError,
    { data: UpdateClusterCephFlagsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateClusterCephFlagsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get the status of a specific ceph flag.
 * @summary getClusterCephFlagsSingle
 */
export const getClusterCephFlagsSingle = (
  flag: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterCephFlagsSingleResponseResponse>({
    url: `/cluster/ceph/flags/${flag}`,
    method: "get",
    signal,
  });
};

export const getGetClusterCephFlagsSingleQueryKey = (flag: string) =>
  [`/cluster/ceph/flags/${flag}`] as const;

export const getGetClusterCephFlagsSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterCephFlagsSingle>>,
  TError = ErrorType<unknown>,
>(
  flag: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterCephFlagsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterCephFlagsSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterCephFlagsSingleQueryKey(flag);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterCephFlagsSingle>>
  > = ({ signal }) => getClusterCephFlagsSingle(flag, signal);

  return { queryKey, queryFn, enabled: !!flag, ...queryOptions };
};

export type GetClusterCephFlagsSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterCephFlagsSingle>>
>;
export type GetClusterCephFlagsSingleQueryError = ErrorType<unknown>;

/**
 * @summary getClusterCephFlagsSingle
 */
export const useGetClusterCephFlagsSingle = <
  TData = Awaited<ReturnType<typeof getClusterCephFlagsSingle>>,
  TError = ErrorType<unknown>,
>(
  flag: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterCephFlagsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterCephFlagsSingleQueryOptions(flag, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set or clear (unset) a specific ceph flag
 * @summary updateClusterCephFlagsSingle
 */
export const updateClusterCephFlagsSingle = (
  flag: string,
  updateClusterCephFlagsSingleRequest: UpdateClusterCephFlagsSingleRequest,
) => {
  return apiInstance<UpdateClusterCephFlagsSingleResponseResponse>({
    url: `/cluster/ceph/flags/${flag}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterCephFlagsSingleRequest,
  });
};

export const getUpdateClusterCephFlagsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterCephFlagsSingle>>,
    TError,
    { flag: string; data: UpdateClusterCephFlagsSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterCephFlagsSingle>>,
  TError,
  { flag: string; data: UpdateClusterCephFlagsSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterCephFlagsSingle>>,
    { flag: string; data: UpdateClusterCephFlagsSingleRequest }
  > = (props) => {
    const { flag, data } = props ?? {};

    return updateClusterCephFlagsSingle(flag, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterCephFlagsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterCephFlagsSingle>>
>;
export type UpdateClusterCephFlagsSingleMutationBody =
  UpdateClusterCephFlagsSingleRequest;
export type UpdateClusterCephFlagsSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterCephFlagsSingle
 */
export const useUpdateClusterCephFlagsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterCephFlagsSingle>>,
    TError,
    { flag: string; data: UpdateClusterCephFlagsSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateClusterCephFlagsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index.
 * @summary getClusterSDN
 */
export const getClusterSDN = (signal?: AbortSignal) => {
  return apiInstance<GetClusterSDNResponseResponse>({
    url: `/cluster/sdn`,
    method: "get",
    signal,
  });
};

export const getGetClusterSDNQueryKey = () => [`/cluster/sdn`] as const;

export const getGetClusterSDNQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterSDN>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterSDN>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterSDN>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterSDNQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClusterSDN>>> = ({
    signal,
  }) => getClusterSDN(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterSDNQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterSDN>>
>;
export type GetClusterSDNQueryError = ErrorType<unknown>;

/**
 * @summary getClusterSDN
 */
export const useGetClusterSDN = <
  TData = Awaited<ReturnType<typeof getClusterSDN>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterSDN>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterSDNQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Apply sdn controller changes && reload.
 * @summary updateClusterSDN
 */
export const updateClusterSDN = (
  updateClusterSDNRequest: UpdateClusterSDNRequest,
) => {
  return apiInstance<UpdateClusterSDNResponseResponse>({
    url: `/cluster/sdn`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterSDNRequest,
  });
};

export const getUpdateClusterSDNMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterSDN>>,
    TError,
    { data: UpdateClusterSDNRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterSDN>>,
  TError,
  { data: UpdateClusterSDNRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterSDN>>,
    { data: UpdateClusterSDNRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateClusterSDN(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterSDNMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterSDN>>
>;
export type UpdateClusterSDNMutationBody = UpdateClusterSDNRequest;
export type UpdateClusterSDNMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterSDN
 */
export const useUpdateClusterSDN = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterSDN>>,
    TError,
    { data: UpdateClusterSDNRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateClusterSDNMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * SDN vnets index.
 * @summary getClusterSDNVnets
 */
export const getClusterSDNVnets = (signal?: AbortSignal) => {
  return apiInstance<GetClusterSDNVnetsResponseResponse>({
    url: `/cluster/sdn/vnets`,
    method: "get",
    signal,
  });
};

export const getGetClusterSDNVnetsQueryKey = () =>
  [`/cluster/sdn/vnets`] as const;

export const getGetClusterSDNVnetsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterSDNVnets>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterSDNVnets>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterSDNVnets>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterSDNVnetsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterSDNVnets>>
  > = ({ signal }) => getClusterSDNVnets(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterSDNVnetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterSDNVnets>>
>;
export type GetClusterSDNVnetsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterSDNVnets
 */
export const useGetClusterSDNVnets = <
  TData = Awaited<ReturnType<typeof getClusterSDNVnets>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterSDNVnets>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterSDNVnetsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new sdn vnet object.
 * @summary createClusterSDNVnet
 */
export const createClusterSDNVnet = (
  createClusterSDNVnetRequest: CreateClusterSDNVnetRequest,
) => {
  return apiInstance<CreateClusterSDNVnetResponseResponse>({
    url: `/cluster/sdn/vnets`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterSDNVnetRequest,
  });
};

export const getCreateClusterSDNVnetMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterSDNVnet>>,
    TError,
    { data: CreateClusterSDNVnetRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterSDNVnet>>,
  TError,
  { data: CreateClusterSDNVnetRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterSDNVnet>>,
    { data: CreateClusterSDNVnetRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterSDNVnet(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterSDNVnetMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterSDNVnet>>
>;
export type CreateClusterSDNVnetMutationBody = CreateClusterSDNVnetRequest;
export type CreateClusterSDNVnetMutationError = ErrorType<unknown>;

/**
 * @summary createClusterSDNVnet
 */
export const useCreateClusterSDNVnet = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterSDNVnet>>,
    TError,
    { data: CreateClusterSDNVnetRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterSDNVnetMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete sdn vnet object configuration.
 * @summary deleteClusterSDNVnet
 */
export const deleteClusterSDNVnet = (vnet: string) => {
  return apiInstance<DeleteClusterSDNVnetResponseResponse>({
    url: `/cluster/sdn/vnets/${vnet}`,
    method: "delete",
  });
};

export const getDeleteClusterSDNVnetMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterSDNVnet>>,
    TError,
    { vnet: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterSDNVnet>>,
  TError,
  { vnet: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterSDNVnet>>,
    { vnet: string }
  > = (props) => {
    const { vnet } = props ?? {};

    return deleteClusterSDNVnet(vnet);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterSDNVnetMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterSDNVnet>>
>;

export type DeleteClusterSDNVnetMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterSDNVnet
 */
export const useDeleteClusterSDNVnet = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterSDNVnet>>,
    TError,
    { vnet: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteClusterSDNVnetMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read sdn vnet configuration.
 * @summary getClusterSDNVnet
 */
export const getClusterSDNVnet = (vnet: string, signal?: AbortSignal) => {
  return apiInstance<GetClusterSDNVnetResponseResponse>({
    url: `/cluster/sdn/vnets/${vnet}`,
    method: "get",
    signal,
  });
};

export const getGetClusterSDNVnetQueryKey = (vnet: string) =>
  [`/cluster/sdn/vnets/${vnet}`] as const;

export const getGetClusterSDNVnetQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterSDNVnet>>,
  TError = ErrorType<unknown>,
>(
  vnet: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterSDNVnet>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterSDNVnet>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterSDNVnetQueryKey(vnet);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterSDNVnet>>
  > = ({ signal }) => getClusterSDNVnet(vnet, signal);

  return { queryKey, queryFn, enabled: !!vnet, ...queryOptions };
};

export type GetClusterSDNVnetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterSDNVnet>>
>;
export type GetClusterSDNVnetQueryError = ErrorType<unknown>;

/**
 * @summary getClusterSDNVnet
 */
export const useGetClusterSDNVnet = <
  TData = Awaited<ReturnType<typeof getClusterSDNVnet>>,
  TError = ErrorType<unknown>,
>(
  vnet: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterSDNVnet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterSDNVnetQueryOptions(vnet, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update sdn vnet object configuration.
 * @summary updateClusterSDNVnet
 */
export const updateClusterSDNVnet = (
  vnet: string,
  updateClusterSDNVnetRequest: UpdateClusterSDNVnetRequest,
) => {
  return apiInstance<UpdateClusterSDNVnetResponseResponse>({
    url: `/cluster/sdn/vnets/${vnet}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterSDNVnetRequest,
  });
};

export const getUpdateClusterSDNVnetMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterSDNVnet>>,
    TError,
    { vnet: string; data: UpdateClusterSDNVnetRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterSDNVnet>>,
  TError,
  { vnet: string; data: UpdateClusterSDNVnetRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterSDNVnet>>,
    { vnet: string; data: UpdateClusterSDNVnetRequest }
  > = (props) => {
    const { vnet, data } = props ?? {};

    return updateClusterSDNVnet(vnet, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterSDNVnetMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterSDNVnet>>
>;
export type UpdateClusterSDNVnetMutationBody = UpdateClusterSDNVnetRequest;
export type UpdateClusterSDNVnetMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterSDNVnet
 */
export const useUpdateClusterSDNVnet = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterSDNVnet>>,
    TError,
    { vnet: string; data: UpdateClusterSDNVnetRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateClusterSDNVnetMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * SDN zones index.
 * @summary getClusterSDNZones
 */
export const getClusterSDNZones = (signal?: AbortSignal) => {
  return apiInstance<GetClusterSDNZonesResponseResponse>({
    url: `/cluster/sdn/zones`,
    method: "get",
    signal,
  });
};

export const getGetClusterSDNZonesQueryKey = () =>
  [`/cluster/sdn/zones`] as const;

export const getGetClusterSDNZonesQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterSDNZones>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterSDNZones>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterSDNZones>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterSDNZonesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterSDNZones>>
  > = ({ signal }) => getClusterSDNZones(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterSDNZonesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterSDNZones>>
>;
export type GetClusterSDNZonesQueryError = ErrorType<unknown>;

/**
 * @summary getClusterSDNZones
 */
export const useGetClusterSDNZones = <
  TData = Awaited<ReturnType<typeof getClusterSDNZones>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterSDNZones>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterSDNZonesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new sdn zone object.
 * @summary createClusterSDNZone
 */
export const createClusterSDNZone = (
  createClusterSDNZoneRequest: CreateClusterSDNZoneRequest,
) => {
  return apiInstance<CreateClusterSDNZoneResponseResponse>({
    url: `/cluster/sdn/zones`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterSDNZoneRequest,
  });
};

export const getCreateClusterSDNZoneMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterSDNZone>>,
    TError,
    { data: CreateClusterSDNZoneRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterSDNZone>>,
  TError,
  { data: CreateClusterSDNZoneRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterSDNZone>>,
    { data: CreateClusterSDNZoneRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterSDNZone(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterSDNZoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterSDNZone>>
>;
export type CreateClusterSDNZoneMutationBody = CreateClusterSDNZoneRequest;
export type CreateClusterSDNZoneMutationError = ErrorType<unknown>;

/**
 * @summary createClusterSDNZone
 */
export const useCreateClusterSDNZone = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterSDNZone>>,
    TError,
    { data: CreateClusterSDNZoneRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterSDNZoneMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete sdn zone object configuration.
 * @summary deleteClusterSDNZone
 */
export const deleteClusterSDNZone = (zone: string) => {
  return apiInstance<DeleteClusterSDNZoneResponseResponse>({
    url: `/cluster/sdn/zones/${zone}`,
    method: "delete",
  });
};

export const getDeleteClusterSDNZoneMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterSDNZone>>,
    TError,
    { zone: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterSDNZone>>,
  TError,
  { zone: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterSDNZone>>,
    { zone: string }
  > = (props) => {
    const { zone } = props ?? {};

    return deleteClusterSDNZone(zone);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterSDNZoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterSDNZone>>
>;

export type DeleteClusterSDNZoneMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterSDNZone
 */
export const useDeleteClusterSDNZone = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterSDNZone>>,
    TError,
    { zone: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteClusterSDNZoneMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read sdn zone configuration.
 * @summary getClusterSDNZone
 */
export const getClusterSDNZone = (zone: string, signal?: AbortSignal) => {
  return apiInstance<GetClusterSDNZoneResponseResponse>({
    url: `/cluster/sdn/zones/${zone}`,
    method: "get",
    signal,
  });
};

export const getGetClusterSDNZoneQueryKey = (zone: string) =>
  [`/cluster/sdn/zones/${zone}`] as const;

export const getGetClusterSDNZoneQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterSDNZone>>,
  TError = ErrorType<unknown>,
>(
  zone: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterSDNZone>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterSDNZone>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterSDNZoneQueryKey(zone);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterSDNZone>>
  > = ({ signal }) => getClusterSDNZone(zone, signal);

  return { queryKey, queryFn, enabled: !!zone, ...queryOptions };
};

export type GetClusterSDNZoneQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterSDNZone>>
>;
export type GetClusterSDNZoneQueryError = ErrorType<unknown>;

/**
 * @summary getClusterSDNZone
 */
export const useGetClusterSDNZone = <
  TData = Awaited<ReturnType<typeof getClusterSDNZone>>,
  TError = ErrorType<unknown>,
>(
  zone: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterSDNZone>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterSDNZoneQueryOptions(zone, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update sdn zone object configuration.
 * @summary updateClusterSDNZone
 */
export const updateClusterSDNZone = (
  zone: string,
  updateClusterSDNZoneRequest: UpdateClusterSDNZoneRequest,
) => {
  return apiInstance<UpdateClusterSDNZoneResponseResponse>({
    url: `/cluster/sdn/zones/${zone}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterSDNZoneRequest,
  });
};

export const getUpdateClusterSDNZoneMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterSDNZone>>,
    TError,
    { zone: string; data: UpdateClusterSDNZoneRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterSDNZone>>,
  TError,
  { zone: string; data: UpdateClusterSDNZoneRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterSDNZone>>,
    { zone: string; data: UpdateClusterSDNZoneRequest }
  > = (props) => {
    const { zone, data } = props ?? {};

    return updateClusterSDNZone(zone, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterSDNZoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterSDNZone>>
>;
export type UpdateClusterSDNZoneMutationBody = UpdateClusterSDNZoneRequest;
export type UpdateClusterSDNZoneMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterSDNZone
 */
export const useUpdateClusterSDNZone = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterSDNZone>>,
    TError,
    { zone: string; data: UpdateClusterSDNZoneRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateClusterSDNZoneMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * SDN controllers index.
 * @summary getClusterSDNControllers
 */
export const getClusterSDNControllers = (signal?: AbortSignal) => {
  return apiInstance<GetClusterSDNControllersResponseResponse>({
    url: `/cluster/sdn/controllers`,
    method: "get",
    signal,
  });
};

export const getGetClusterSDNControllersQueryKey = () =>
  [`/cluster/sdn/controllers`] as const;

export const getGetClusterSDNControllersQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterSDNControllers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterSDNControllers>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterSDNControllers>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterSDNControllersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterSDNControllers>>
  > = ({ signal }) => getClusterSDNControllers(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterSDNControllersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterSDNControllers>>
>;
export type GetClusterSDNControllersQueryError = ErrorType<unknown>;

/**
 * @summary getClusterSDNControllers
 */
export const useGetClusterSDNControllers = <
  TData = Awaited<ReturnType<typeof getClusterSDNControllers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterSDNControllers>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterSDNControllersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new sdn controller object.
 * @summary createClusterSDNController
 */
export const createClusterSDNController = (
  createClusterSDNControllerRequest: CreateClusterSDNControllerRequest,
) => {
  return apiInstance<CreateClusterSDNControllerResponseResponse>({
    url: `/cluster/sdn/controllers`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createClusterSDNControllerRequest,
  });
};

export const getCreateClusterSDNControllerMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterSDNController>>,
    TError,
    { data: CreateClusterSDNControllerRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClusterSDNController>>,
  TError,
  { data: CreateClusterSDNControllerRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClusterSDNController>>,
    { data: CreateClusterSDNControllerRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createClusterSDNController(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClusterSDNControllerMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClusterSDNController>>
>;
export type CreateClusterSDNControllerMutationBody =
  CreateClusterSDNControllerRequest;
export type CreateClusterSDNControllerMutationError = ErrorType<unknown>;

/**
 * @summary createClusterSDNController
 */
export const useCreateClusterSDNController = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClusterSDNController>>,
    TError,
    { data: CreateClusterSDNControllerRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateClusterSDNControllerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete sdn controller object configuration.
 * @summary deleteClusterSDNController
 */
export const deleteClusterSDNController = (controller: string) => {
  return apiInstance<DeleteClusterSDNControllerResponseResponse>({
    url: `/cluster/sdn/controllers/${controller}`,
    method: "delete",
  });
};

export const getDeleteClusterSDNControllerMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterSDNController>>,
    TError,
    { controller: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterSDNController>>,
  TError,
  { controller: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterSDNController>>,
    { controller: string }
  > = (props) => {
    const { controller } = props ?? {};

    return deleteClusterSDNController(controller);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterSDNControllerMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterSDNController>>
>;

export type DeleteClusterSDNControllerMutationError = ErrorType<unknown>;

/**
 * @summary deleteClusterSDNController
 */
export const useDeleteClusterSDNController = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterSDNController>>,
    TError,
    { controller: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteClusterSDNControllerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read sdn controller configuration.
 * @summary getClusterSDNController
 */
export const getClusterSDNController = (
  controller: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetClusterSDNControllerResponseResponse>({
    url: `/cluster/sdn/controllers/${controller}`,
    method: "get",
    signal,
  });
};

export const getGetClusterSDNControllerQueryKey = (controller: string) =>
  [`/cluster/sdn/controllers/${controller}`] as const;

export const getGetClusterSDNControllerQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterSDNController>>,
  TError = ErrorType<unknown>,
>(
  controller: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterSDNController>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterSDNController>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterSDNControllerQueryKey(controller);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterSDNController>>
  > = ({ signal }) => getClusterSDNController(controller, signal);

  return { queryKey, queryFn, enabled: !!controller, ...queryOptions };
};

export type GetClusterSDNControllerQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterSDNController>>
>;
export type GetClusterSDNControllerQueryError = ErrorType<unknown>;

/**
 * @summary getClusterSDNController
 */
export const useGetClusterSDNController = <
  TData = Awaited<ReturnType<typeof getClusterSDNController>>,
  TError = ErrorType<unknown>,
>(
  controller: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getClusterSDNController>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterSDNControllerQueryOptions(
    controller,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update sdn controller object configuration.
 * @summary updateClusterSDNController
 */
export const updateClusterSDNController = (
  controller: string,
  updateClusterSDNControllerRequest: UpdateClusterSDNControllerRequest,
) => {
  return apiInstance<UpdateClusterSDNControllerResponseResponse>({
    url: `/cluster/sdn/controllers/${controller}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterSDNControllerRequest,
  });
};

export const getUpdateClusterSDNControllerMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterSDNController>>,
    TError,
    { controller: string; data: UpdateClusterSDNControllerRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterSDNController>>,
  TError,
  { controller: string; data: UpdateClusterSDNControllerRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterSDNController>>,
    { controller: string; data: UpdateClusterSDNControllerRequest }
  > = (props) => {
    const { controller, data } = props ?? {};

    return updateClusterSDNController(controller, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterSDNControllerMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterSDNController>>
>;
export type UpdateClusterSDNControllerMutationBody =
  UpdateClusterSDNControllerRequest;
export type UpdateClusterSDNControllerMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterSDNController
 */
export const useUpdateClusterSDNController = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterSDNController>>,
    TError,
    { controller: string; data: UpdateClusterSDNControllerRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateClusterSDNControllerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read cluster log
 * @summary getClusterLog
 */
export const getClusterLog = (signal?: AbortSignal) => {
  return apiInstance<GetClusterLogResponseResponse>({
    url: `/cluster/log`,
    method: "get",
    signal,
  });
};

export const getGetClusterLogQueryKey = () => [`/cluster/log`] as const;

export const getGetClusterLogQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterLog>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterLog>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterLog>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterLogQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClusterLog>>> = ({
    signal,
  }) => getClusterLog(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterLogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterLog>>
>;
export type GetClusterLogQueryError = ErrorType<unknown>;

/**
 * @summary getClusterLog
 */
export const useGetClusterLog = <
  TData = Awaited<ReturnType<typeof getClusterLog>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterLog>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterLogQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Resources index (cluster wide).
 * @summary getClusterResources
 */
export const getClusterResources = (signal?: AbortSignal) => {
  return apiInstance<GetClusterResourcesResponseResponse>({
    url: `/cluster/resources`,
    method: "get",
    signal,
  });
};

export const getGetClusterResourcesQueryKey = () =>
  [`/cluster/resources`] as const;

export const getGetClusterResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterResources>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterResources>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterResources>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterResourcesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterResources>>
  > = ({ signal }) => getClusterResources(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterResources>>
>;
export type GetClusterResourcesQueryError = ErrorType<unknown>;

/**
 * @summary getClusterResources
 */
export const useGetClusterResources = <
  TData = Awaited<ReturnType<typeof getClusterResources>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterResources>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterResourcesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List recent tasks (cluster wide).
 * @summary getClusterTasks
 */
export const getClusterTasks = (signal?: AbortSignal) => {
  return apiInstance<GetClusterTasksResponseResponse>({
    url: `/cluster/tasks`,
    method: "get",
    signal,
  });
};

export const getGetClusterTasksQueryKey = () => [`/cluster/tasks`] as const;

export const getGetClusterTasksQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterTasks>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterTasks>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterTasks>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterTasksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClusterTasks>>> = ({
    signal,
  }) => getClusterTasks(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterTasksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterTasks>>
>;
export type GetClusterTasksQueryError = ErrorType<unknown>;

/**
 * @summary getClusterTasks
 */
export const useGetClusterTasks = <
  TData = Awaited<ReturnType<typeof getClusterTasks>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterTasks>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterTasksQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get datacenter options.
 * @summary getClusterOptions
 */
export const getClusterOptions = (signal?: AbortSignal) => {
  return apiInstance<GetClusterOptionsResponseResponse>({
    url: `/cluster/options`,
    method: "get",
    signal,
  });
};

export const getGetClusterOptionsQueryKey = () => [`/cluster/options`] as const;

export const getGetClusterOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterOptions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterOptions>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterOptions>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterOptions>>
  > = ({ signal }) => getClusterOptions(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterOptions>>
>;
export type GetClusterOptionsQueryError = ErrorType<unknown>;

/**
 * @summary getClusterOptions
 */
export const useGetClusterOptions = <
  TData = Awaited<ReturnType<typeof getClusterOptions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterOptions>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterOptionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set datacenter options.
 * @summary updateClusterOptions
 */
export const updateClusterOptions = (
  updateClusterOptionsRequest: UpdateClusterOptionsRequest,
) => {
  return apiInstance<UpdateClusterOptionsResponseResponse>({
    url: `/cluster/options`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateClusterOptionsRequest,
  });
};

export const getUpdateClusterOptionsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterOptions>>,
    TError,
    { data: UpdateClusterOptionsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClusterOptions>>,
  TError,
  { data: UpdateClusterOptionsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClusterOptions>>,
    { data: UpdateClusterOptionsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateClusterOptions(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClusterOptionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClusterOptions>>
>;
export type UpdateClusterOptionsMutationBody = UpdateClusterOptionsRequest;
export type UpdateClusterOptionsMutationError = ErrorType<unknown>;

/**
 * @summary updateClusterOptions
 */
export const useUpdateClusterOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClusterOptions>>,
    TError,
    { data: UpdateClusterOptionsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateClusterOptionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get cluster status information.
 * @summary getClusterStatus
 */
export const getClusterStatus = (signal?: AbortSignal) => {
  return apiInstance<GetClusterStatusResponseResponse>({
    url: `/cluster/status`,
    method: "get",
    signal,
  });
};

export const getGetClusterStatusQueryKey = () => [`/cluster/status`] as const;

export const getGetClusterStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterStatus>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterStatus>>
  > = ({ signal }) => getClusterStatus(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterStatus>>
>;
export type GetClusterStatusQueryError = ErrorType<unknown>;

/**
 * @summary getClusterStatus
 */
export const useGetClusterStatus = <
  TData = Awaited<ReturnType<typeof getClusterStatus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterStatus>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterStatusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get next free VMID. If you pass an VMID it will raise an error if the ID is already used.
 * @summary getClusterNextid
 */
export const getClusterNextid = (signal?: AbortSignal) => {
  return apiInstance<GetClusterNextidResponseResponse>({
    url: `/cluster/nextid`,
    method: "get",
    signal,
  });
};

export const getGetClusterNextidQueryKey = () => [`/cluster/nextid`] as const;

export const getGetClusterNextidQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterNextid>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterNextid>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getClusterNextid>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterNextidQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClusterNextid>>
  > = ({ signal }) => getClusterNextid(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetClusterNextidQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterNextid>>
>;
export type GetClusterNextidQueryError = ErrorType<unknown>;

/**
 * @summary getClusterNextid
 */
export const useGetClusterNextid = <
  TData = Awaited<ReturnType<typeof getClusterNextid>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getClusterNextid>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetClusterNextidQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Cluster node index.
 * @summary getNodes
 */
export const getNodes = (signal?: AbortSignal) => {
  return apiInstance<GetNodesResponseResponse>({
    url: `/nodes`,
    method: "get",
    signal,
  });
};

export const getGetNodesQueryKey = () => [`/nodes`] as const;

export const getGetNodesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>;
}): UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodes>>> = ({
    signal,
  }) => getNodes(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetNodesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodes>>
>;
export type GetNodesQueryError = ErrorType<unknown>;

/**
 * @summary getNodes
 */
export const useGetNodes = <
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Node index.
 * @summary getNode
 */
export const getNode = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodeResponseResponse>({
    url: `/nodes/${node}`,
    method: "get",
    signal,
  });
};

export const getGetNodeQueryKey = (node: string) => [`/nodes/${node}`] as const;

export const getGetNodeQueryOptions = <
  TData = Awaited<ReturnType<typeof getNode>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeQueryKey(node);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNode>>> = ({
    signal,
  }) => getNode(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNode>>
>;
export type GetNodeQueryError = ErrorType<unknown>;

/**
 * @summary getNode
 */
export const useGetNode = <
  TData = Awaited<ReturnType<typeof getNode>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Virtual machine index (per node).
 * @summary getVMs
 */
export const getVMs = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetVMsResponseResponse>({
    url: `/nodes/${node}/qemu`,
    method: "get",
    signal,
  });
};

export const getGetVMsQueryKey = (node: string) =>
  [`/nodes/${node}/qemu`] as const;

export const getGetVMsQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getVMs>>, TError, TData>;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getVMs>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVMsQueryKey(node);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVMs>>> = ({
    signal,
  }) => getVMs(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetVMsQueryResult = NonNullable<Awaited<ReturnType<typeof getVMs>>>;
export type GetVMsQueryError = ErrorType<unknown>;

/**
 * @summary getVMs
 */
export const useGetVMs = <
  TData = Awaited<ReturnType<typeof getVMs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getVMs>>, TError, TData>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create or restore a virtual machine.
 * @summary createVM
 */
export const createVM = (node: string, createVMRequest: CreateVMRequest) => {
  return apiInstance<CreateVMResponseResponse>({
    url: `/nodes/${node}/qemu`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createVMRequest,
  });
};

export const getCreateVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVM>>,
    TError,
    { node: string; data: CreateVMRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createVM>>,
  TError,
  { node: string; data: CreateVMRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createVM>>,
    { node: string; data: CreateVMRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createVM(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof createVM>>
>;
export type CreateVMMutationBody = CreateVMRequest;
export type CreateVMMutationError = ErrorType<unknown>;

/**
 * @summary createVM
 */
export const useCreateVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVM>>,
    TError,
    { node: string; data: CreateVMRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Destroy the vm (also delete all used/owned volumes).
 * @summary deleteVM
 */
export const deleteVM = (node: string, vmid: number) => {
  return apiInstance<DeleteVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}`,
    method: "delete",
  });
};

export const getDeleteVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVM>>,
    TError,
    { node: string; vmid: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteVM>>,
  TError,
  { node: string; vmid: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteVM>>,
    { node: string; vmid: number }
  > = (props) => {
    const { node, vmid } = props ?? {};

    return deleteVM(node, vmid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteVM>>
>;

export type DeleteVMMutationError = ErrorType<unknown>;

/**
 * @summary deleteVM
 */
export const useDeleteVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVM>>,
    TError,
    { node: string; vmid: number },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index
 * @summary getVM
 */
export const getVM = (node: string, vmid: number, signal?: AbortSignal) => {
  return apiInstance<GetVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}`,
    method: "get",
    signal,
  });
};

export const getGetVMQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}`] as const;

export const getGetVMQueryOptions = <
  TData = Awaited<ReturnType<typeof getVM>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getVM>>, TError, TData>;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getVM>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVMQueryKey(node, vmid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVM>>> = ({
    signal,
  }) => getVM(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMQueryResult = NonNullable<Awaited<ReturnType<typeof getVM>>>;
export type GetVMQueryError = ErrorType<unknown>;

/**
 * @summary getVM
 */
export const useGetVM = <
  TData = Awaited<ReturnType<typeof getVM>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getVM>>, TError, TData>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Directory index.
 * @summary getVMFirewall
 */
export const getVMFirewall = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMFirewallResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall`,
    method: "get",
    signal,
  });
};

export const getGetVMFirewallQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/firewall`] as const;

export const getGetVMFirewallQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMFirewall>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewall>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getVMFirewall>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMFirewallQueryKey(node, vmid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVMFirewall>>> = ({
    signal,
  }) => getVMFirewall(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMFirewallQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMFirewall>>
>;
export type GetVMFirewallQueryError = ErrorType<unknown>;

/**
 * @summary getVMFirewall
 */
export const useGetVMFirewall = <
  TData = Awaited<ReturnType<typeof getVMFirewall>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewall>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMFirewallQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List rules.
 * @summary getVMFirewallRules
 */
export const getVMFirewallRules = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMFirewallRulesResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/rules`,
    method: "get",
    signal,
  });
};

export const getGetVMFirewallRulesQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/firewall/rules`] as const;

export const getGetVMFirewallRulesQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMFirewallRules>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallRules>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getVMFirewallRules>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMFirewallRulesQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVMFirewallRules>>
  > = ({ signal }) => getVMFirewallRules(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMFirewallRulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMFirewallRules>>
>;
export type GetVMFirewallRulesQueryError = ErrorType<unknown>;

/**
 * @summary getVMFirewallRules
 */
export const useGetVMFirewallRules = <
  TData = Awaited<ReturnType<typeof getVMFirewallRules>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallRules>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMFirewallRulesQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new rule.
 * @summary createVMFirewallRule
 */
export const createVMFirewallRule = (
  node: string,
  vmid: number,
  createVMFirewallRuleRequest: CreateVMFirewallRuleRequest,
) => {
  return apiInstance<CreateVMFirewallRuleResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/rules`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createVMFirewallRuleRequest,
  });
};

export const getCreateVMFirewallRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVMFirewallRule>>,
    TError,
    { node: string; vmid: number; data: CreateVMFirewallRuleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createVMFirewallRule>>,
  TError,
  { node: string; vmid: number; data: CreateVMFirewallRuleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createVMFirewallRule>>,
    { node: string; vmid: number; data: CreateVMFirewallRuleRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createVMFirewallRule(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateVMFirewallRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createVMFirewallRule>>
>;
export type CreateVMFirewallRuleMutationBody = CreateVMFirewallRuleRequest;
export type CreateVMFirewallRuleMutationError = ErrorType<unknown>;

/**
 * @summary createVMFirewallRule
 */
export const useCreateVMFirewallRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVMFirewallRule>>,
    TError,
    { node: string; vmid: number; data: CreateVMFirewallRuleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateVMFirewallRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete rule.
 * @summary deleteVMFirewallRule
 */
export const deleteVMFirewallRule = (
  node: string,
  vmid: number,
  pos: number,
) => {
  return apiInstance<DeleteVMFirewallRuleResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/rules/${pos}`,
    method: "delete",
  });
};

export const getDeleteVMFirewallRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVMFirewallRule>>,
    TError,
    { node: string; vmid: number; pos: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteVMFirewallRule>>,
  TError,
  { node: string; vmid: number; pos: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteVMFirewallRule>>,
    { node: string; vmid: number; pos: number }
  > = (props) => {
    const { node, vmid, pos } = props ?? {};

    return deleteVMFirewallRule(node, vmid, pos);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteVMFirewallRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteVMFirewallRule>>
>;

export type DeleteVMFirewallRuleMutationError = ErrorType<unknown>;

/**
 * @summary deleteVMFirewallRule
 */
export const useDeleteVMFirewallRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVMFirewallRule>>,
    TError,
    { node: string; vmid: number; pos: number },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteVMFirewallRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get single rule data.
 * @summary getVMFirewallRule
 */
export const getVMFirewallRule = (
  node: string,
  vmid: number,
  pos: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMFirewallRuleResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/rules/${pos}`,
    method: "get",
    signal,
  });
};

export const getGetVMFirewallRuleQueryKey = (
  node: string,
  vmid: number,
  pos: number,
) => [`/nodes/${node}/qemu/${vmid}/firewall/rules/${pos}`] as const;

export const getGetVMFirewallRuleQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMFirewallRule>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallRule>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getVMFirewallRule>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMFirewallRuleQueryKey(node, vmid, pos);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVMFirewallRule>>
  > = ({ signal }) => getVMFirewallRule(node, vmid, pos, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && pos),
    ...queryOptions,
  };
};

export type GetVMFirewallRuleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMFirewallRule>>
>;
export type GetVMFirewallRuleQueryError = ErrorType<unknown>;

/**
 * @summary getVMFirewallRule
 */
export const useGetVMFirewallRule = <
  TData = Awaited<ReturnType<typeof getVMFirewallRule>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallRule>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMFirewallRuleQueryOptions(
    node,
    vmid,
    pos,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Modify rule data.
 * @summary updateVMFirewallRule
 */
export const updateVMFirewallRule = (
  node: string,
  vmid: number,
  pos: number,
  updateVMFirewallRuleRequest: UpdateVMFirewallRuleRequest,
) => {
  return apiInstance<UpdateVMFirewallRuleResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/rules/${pos}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateVMFirewallRuleRequest,
  });
};

export const getUpdateVMFirewallRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMFirewallRule>>,
    TError,
    {
      node: string;
      vmid: number;
      pos: number;
      data: UpdateVMFirewallRuleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateVMFirewallRule>>,
  TError,
  {
    node: string;
    vmid: number;
    pos: number;
    data: UpdateVMFirewallRuleRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateVMFirewallRule>>,
    {
      node: string;
      vmid: number;
      pos: number;
      data: UpdateVMFirewallRuleRequest;
    }
  > = (props) => {
    const { node, vmid, pos, data } = props ?? {};

    return updateVMFirewallRule(node, vmid, pos, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateVMFirewallRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateVMFirewallRule>>
>;
export type UpdateVMFirewallRuleMutationBody = UpdateVMFirewallRuleRequest;
export type UpdateVMFirewallRuleMutationError = ErrorType<unknown>;

/**
 * @summary updateVMFirewallRule
 */
export const useUpdateVMFirewallRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMFirewallRule>>,
    TError,
    {
      node: string;
      vmid: number;
      pos: number;
      data: UpdateVMFirewallRuleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateVMFirewallRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List aliases
 * @summary getNodesSingleQemuSingleFirewallAliases
 */
export const getNodesSingleQemuSingleFirewallAliases = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleFirewallAliasesResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/aliases`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleFirewallAliasesQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/firewall/aliases`] as const;

export const getGetNodesSingleQemuSingleFirewallAliasesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliases>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliases>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliases>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleFirewallAliasesQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliases>>
  > = ({ signal }) =>
    getNodesSingleQemuSingleFirewallAliases(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleFirewallAliasesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliases>>
>;
export type GetNodesSingleQemuSingleFirewallAliasesQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleFirewallAliases
 */
export const useGetNodesSingleQemuSingleFirewallAliases = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliases>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliases>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleFirewallAliasesQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create IP or Network Alias.
 * @summary createNodesSingleQemuSingleFirewallAliases
 */
export const createNodesSingleQemuSingleFirewallAliases = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleFirewallAliasesRequest: CreateNodesSingleQemuSingleFirewallAliasesRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleFirewallAliasesResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/firewall/aliases`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleQemuSingleFirewallAliasesRequest,
    },
  );
};

export const getCreateNodesSingleQemuSingleFirewallAliasesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleFirewallAliases>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleFirewallAliasesRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleFirewallAliases>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleFirewallAliasesRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleFirewallAliases>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleFirewallAliasesRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleFirewallAliases(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleFirewallAliasesMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleFirewallAliases>>
  >;
export type CreateNodesSingleQemuSingleFirewallAliasesMutationBody =
  CreateNodesSingleQemuSingleFirewallAliasesRequest;
export type CreateNodesSingleQemuSingleFirewallAliasesMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleFirewallAliases
 */
export const useCreateNodesSingleQemuSingleFirewallAliases = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleFirewallAliases>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleFirewallAliasesRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleFirewallAliasesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove IP or Network alias.
 * @summary deleteNodesSingleQemuSingleFirewallAliasesSingle
 */
export const deleteNodesSingleQemuSingleFirewallAliasesSingle = (
  node: string,
  vmid: number,
  name: string,
) => {
  return apiInstance<DeleteNodesSingleQemuSingleFirewallAliasesSingleResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/firewall/aliases/${name}`,
      method: "delete",
    },
  );
};

export const getDeleteNodesSingleQemuSingleFirewallAliasesSingleMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteNodesSingleQemuSingleFirewallAliasesSingle>
      >,
      TError,
      { node: string; vmid: number; name: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteNodesSingleQemuSingleFirewallAliasesSingle>
    >,
    TError,
    { node: string; vmid: number; name: string },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof deleteNodesSingleQemuSingleFirewallAliasesSingle>
      >,
      { node: string; vmid: number; name: string }
    > = (props) => {
      const { node, vmid, name } = props ?? {};

      return deleteNodesSingleQemuSingleFirewallAliasesSingle(node, vmid, name);
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteNodesSingleQemuSingleFirewallAliasesSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteNodesSingleQemuSingleFirewallAliasesSingle>>
  >;

export type DeleteNodesSingleQemuSingleFirewallAliasesSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleQemuSingleFirewallAliasesSingle
 */
export const useDeleteNodesSingleQemuSingleFirewallAliasesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteNodesSingleQemuSingleFirewallAliasesSingle>
    >,
    TError,
    { node: string; vmid: number; name: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleQemuSingleFirewallAliasesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read alias.
 * @summary getNodesSingleQemuSingleFirewallAliasesSingle
 */
export const getNodesSingleQemuSingleFirewallAliasesSingle = (
  node: string,
  vmid: number,
  name: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleFirewallAliasesSingleResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/firewall/aliases/${name}`,
      method: "get",
      signal,
    },
  );
};

export const getGetNodesSingleQemuSingleFirewallAliasesSingleQueryKey = (
  node: string,
  vmid: number,
  name: string,
) => [`/nodes/${node}/qemu/${vmid}/firewall/aliases/${name}`] as const;

export const getGetNodesSingleQemuSingleFirewallAliasesSingleQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleQemuSingleFirewallAliasesSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliasesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliasesSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleFirewallAliasesSingleQueryKey(node, vmid, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliasesSingle>>
  > = ({ signal }) =>
    getNodesSingleQemuSingleFirewallAliasesSingle(node, vmid, name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && name),
    ...queryOptions,
  };
};

export type GetNodesSingleQemuSingleFirewallAliasesSingleQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliasesSingle>>
  >;
export type GetNodesSingleQemuSingleFirewallAliasesSingleQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleFirewallAliasesSingle
 */
export const useGetNodesSingleQemuSingleFirewallAliasesSingle = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleQemuSingleFirewallAliasesSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallAliasesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetNodesSingleQemuSingleFirewallAliasesSingleQueryOptions(
      node,
      vmid,
      name,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update IP or Network alias.
 * @summary updateNodesSingleQemuSingleFirewallAliasesSingle
 */
export const updateNodesSingleQemuSingleFirewallAliasesSingle = (
  node: string,
  vmid: number,
  name: string,
  updateNodesSingleQemuSingleFirewallAliasesSingleRequest: UpdateNodesSingleQemuSingleFirewallAliasesSingleRequest,
) => {
  return apiInstance<UpdateNodesSingleQemuSingleFirewallAliasesSingleResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/firewall/aliases/${name}`,
      method: "put",
      headers: { "Content-Type": "application/json" },
      data: updateNodesSingleQemuSingleFirewallAliasesSingleRequest,
    },
  );
};

export const getUpdateNodesSingleQemuSingleFirewallAliasesSingleMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateNodesSingleQemuSingleFirewallAliasesSingle>
      >,
      TError,
      {
        node: string;
        vmid: number;
        name: string;
        data: UpdateNodesSingleQemuSingleFirewallAliasesSingleRequest;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof updateNodesSingleQemuSingleFirewallAliasesSingle>
    >,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      data: UpdateNodesSingleQemuSingleFirewallAliasesSingleRequest;
    },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateNodesSingleQemuSingleFirewallAliasesSingle>
      >,
      {
        node: string;
        vmid: number;
        name: string;
        data: UpdateNodesSingleQemuSingleFirewallAliasesSingleRequest;
      }
    > = (props) => {
      const { node, vmid, name, data } = props ?? {};

      return updateNodesSingleQemuSingleFirewallAliasesSingle(
        node,
        vmid,
        name,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateNodesSingleQemuSingleFirewallAliasesSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateNodesSingleQemuSingleFirewallAliasesSingle>>
  >;
export type UpdateNodesSingleQemuSingleFirewallAliasesSingleMutationBody =
  UpdateNodesSingleQemuSingleFirewallAliasesSingleRequest;
export type UpdateNodesSingleQemuSingleFirewallAliasesSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary updateNodesSingleQemuSingleFirewallAliasesSingle
 */
export const useUpdateNodesSingleQemuSingleFirewallAliasesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof updateNodesSingleQemuSingleFirewallAliasesSingle>
    >,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      data: UpdateNodesSingleQemuSingleFirewallAliasesSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleQemuSingleFirewallAliasesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List IPSets
 * @summary getVMFirewallIPSets
 */
export const getVMFirewallIPSets = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMFirewallIPSetsResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/ipset`,
    method: "get",
    signal,
  });
};

export const getGetVMFirewallIPSetsQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/firewall/ipset`] as const;

export const getGetVMFirewallIPSetsQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMFirewallIPSets>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallIPSets>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getVMFirewallIPSets>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMFirewallIPSetsQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVMFirewallIPSets>>
  > = ({ signal }) => getVMFirewallIPSets(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMFirewallIPSetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMFirewallIPSets>>
>;
export type GetVMFirewallIPSetsQueryError = ErrorType<unknown>;

/**
 * @summary getVMFirewallIPSets
 */
export const useGetVMFirewallIPSets = <
  TData = Awaited<ReturnType<typeof getVMFirewallIPSets>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallIPSets>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMFirewallIPSetsQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new IPSet
 * @summary createVMFirewallIPSet
 */
export const createVMFirewallIPSet = (
  node: string,
  vmid: number,
  createVMFirewallIPSetRequest: CreateVMFirewallIPSetRequest,
) => {
  return apiInstance<CreateVMFirewallIPSetResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/ipset`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createVMFirewallIPSetRequest,
  });
};

export const getCreateVMFirewallIPSetMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVMFirewallIPSet>>,
    TError,
    { node: string; vmid: number; data: CreateVMFirewallIPSetRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createVMFirewallIPSet>>,
  TError,
  { node: string; vmid: number; data: CreateVMFirewallIPSetRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createVMFirewallIPSet>>,
    { node: string; vmid: number; data: CreateVMFirewallIPSetRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createVMFirewallIPSet(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateVMFirewallIPSetMutationResult = NonNullable<
  Awaited<ReturnType<typeof createVMFirewallIPSet>>
>;
export type CreateVMFirewallIPSetMutationBody = CreateVMFirewallIPSetRequest;
export type CreateVMFirewallIPSetMutationError = ErrorType<unknown>;

/**
 * @summary createVMFirewallIPSet
 */
export const useCreateVMFirewallIPSet = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVMFirewallIPSet>>,
    TError,
    { node: string; vmid: number; data: CreateVMFirewallIPSetRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateVMFirewallIPSetMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete IPSet
 * @summary deleteVMFirewallIPSet
 */
export const deleteVMFirewallIPSet = (
  node: string,
  vmid: number,
  name: string,
) => {
  return apiInstance<DeleteVMFirewallIPSetResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/ipset/${name}`,
    method: "delete",
  });
};

export const getDeleteVMFirewallIPSetMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVMFirewallIPSet>>,
    TError,
    { node: string; vmid: number; name: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteVMFirewallIPSet>>,
  TError,
  { node: string; vmid: number; name: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteVMFirewallIPSet>>,
    { node: string; vmid: number; name: string }
  > = (props) => {
    const { node, vmid, name } = props ?? {};

    return deleteVMFirewallIPSet(node, vmid, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteVMFirewallIPSetMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteVMFirewallIPSet>>
>;

export type DeleteVMFirewallIPSetMutationError = ErrorType<unknown>;

/**
 * @summary deleteVMFirewallIPSet
 */
export const useDeleteVMFirewallIPSet = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVMFirewallIPSet>>,
    TError,
    { node: string; vmid: number; name: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteVMFirewallIPSetMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List IPSet content
 * @summary getVMFirewallIPSet
 */
export const getVMFirewallIPSet = (
  node: string,
  vmid: number,
  name: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMFirewallIPSetResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/ipset/${name}`,
    method: "get",
    signal,
  });
};

export const getGetVMFirewallIPSetQueryKey = (
  node: string,
  vmid: number,
  name: string,
) => [`/nodes/${node}/qemu/${vmid}/firewall/ipset/${name}`] as const;

export const getGetVMFirewallIPSetQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMFirewallIPSet>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallIPSet>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getVMFirewallIPSet>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMFirewallIPSetQueryKey(node, vmid, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVMFirewallIPSet>>
  > = ({ signal }) => getVMFirewallIPSet(node, vmid, name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && name),
    ...queryOptions,
  };
};

export type GetVMFirewallIPSetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMFirewallIPSet>>
>;
export type GetVMFirewallIPSetQueryError = ErrorType<unknown>;

/**
 * @summary getVMFirewallIPSet
 */
export const useGetVMFirewallIPSet = <
  TData = Awaited<ReturnType<typeof getVMFirewallIPSet>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallIPSet>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMFirewallIPSetQueryOptions(
    node,
    vmid,
    name,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Add IP or Network to IPSet.
 * @summary addVMFirewallIPSetIP
 */
export const addVMFirewallIPSetIP = (
  node: string,
  vmid: number,
  name: string,
  addVMFirewallIPSetIPRequest: AddVMFirewallIPSetIPRequest,
) => {
  return apiInstance<AddVMFirewallIPSetIPResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/ipset/${name}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: addVMFirewallIPSetIPRequest,
  });
};

export const getAddVMFirewallIPSetIPMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addVMFirewallIPSetIP>>,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      data: AddVMFirewallIPSetIPRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addVMFirewallIPSetIP>>,
  TError,
  {
    node: string;
    vmid: number;
    name: string;
    data: AddVMFirewallIPSetIPRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addVMFirewallIPSetIP>>,
    {
      node: string;
      vmid: number;
      name: string;
      data: AddVMFirewallIPSetIPRequest;
    }
  > = (props) => {
    const { node, vmid, name, data } = props ?? {};

    return addVMFirewallIPSetIP(node, vmid, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddVMFirewallIPSetIPMutationResult = NonNullable<
  Awaited<ReturnType<typeof addVMFirewallIPSetIP>>
>;
export type AddVMFirewallIPSetIPMutationBody = AddVMFirewallIPSetIPRequest;
export type AddVMFirewallIPSetIPMutationError = ErrorType<unknown>;

/**
 * @summary addVMFirewallIPSetIP
 */
export const useAddVMFirewallIPSetIP = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addVMFirewallIPSetIP>>,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      data: AddVMFirewallIPSetIPRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions = getAddVMFirewallIPSetIPMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove IP or Network from IPSet.
 * @summary removeVMFirewallIPSetIP
 */
export const removeVMFirewallIPSetIP = (
  node: string,
  vmid: number,
  name: string,
  cidr: string,
) => {
  return apiInstance<RemoveVMFirewallIPSetIPResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/ipset/${name}/${cidr}`,
    method: "delete",
  });
};

export const getRemoveVMFirewallIPSetIPMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeVMFirewallIPSetIP>>,
    TError,
    { node: string; vmid: number; name: string; cidr: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeVMFirewallIPSetIP>>,
  TError,
  { node: string; vmid: number; name: string; cidr: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeVMFirewallIPSetIP>>,
    { node: string; vmid: number; name: string; cidr: string }
  > = (props) => {
    const { node, vmid, name, cidr } = props ?? {};

    return removeVMFirewallIPSetIP(node, vmid, name, cidr);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveVMFirewallIPSetIPMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeVMFirewallIPSetIP>>
>;

export type RemoveVMFirewallIPSetIPMutationError = ErrorType<unknown>;

/**
 * @summary removeVMFirewallIPSetIP
 */
export const useRemoveVMFirewallIPSetIP = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeVMFirewallIPSetIP>>,
    TError,
    { node: string; vmid: number; name: string; cidr: string },
    TContext
  >;
}) => {
  const mutationOptions = getRemoveVMFirewallIPSetIPMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read IP or Network settings from IPSet.
 * @summary getVMFirewallIPSetIP
 */
export const getVMFirewallIPSetIP = (
  node: string,
  vmid: number,
  name: string,
  cidr: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMFirewallIPSetIPResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/ipset/${name}/${cidr}`,
    method: "get",
    signal,
  });
};

export const getGetVMFirewallIPSetIPQueryKey = (
  node: string,
  vmid: number,
  name: string,
  cidr: string,
) => [`/nodes/${node}/qemu/${vmid}/firewall/ipset/${name}/${cidr}`] as const;

export const getGetVMFirewallIPSetIPQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMFirewallIPSetIP>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  cidr: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallIPSetIP>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getVMFirewallIPSetIP>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetVMFirewallIPSetIPQueryKey(node, vmid, name, cidr);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVMFirewallIPSetIP>>
  > = ({ signal }) => getVMFirewallIPSetIP(node, vmid, name, cidr, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && name && cidr),
    ...queryOptions,
  };
};

export type GetVMFirewallIPSetIPQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMFirewallIPSetIP>>
>;
export type GetVMFirewallIPSetIPQueryError = ErrorType<unknown>;

/**
 * @summary getVMFirewallIPSetIP
 */
export const useGetVMFirewallIPSetIP = <
  TData = Awaited<ReturnType<typeof getVMFirewallIPSetIP>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  cidr: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallIPSetIP>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMFirewallIPSetIPQueryOptions(
    node,
    vmid,
    name,
    cidr,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update IP or Network settings
 * @summary updateVMFirewallIPSetIP
 */
export const updateVMFirewallIPSetIP = (
  node: string,
  vmid: number,
  name: string,
  cidr: string,
  updateVMFirewallIPSetIPRequest: UpdateVMFirewallIPSetIPRequest,
) => {
  return apiInstance<UpdateVMFirewallIPSetIPResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/ipset/${name}/${cidr}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateVMFirewallIPSetIPRequest,
  });
};

export const getUpdateVMFirewallIPSetIPMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMFirewallIPSetIP>>,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      cidr: string;
      data: UpdateVMFirewallIPSetIPRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateVMFirewallIPSetIP>>,
  TError,
  {
    node: string;
    vmid: number;
    name: string;
    cidr: string;
    data: UpdateVMFirewallIPSetIPRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateVMFirewallIPSetIP>>,
    {
      node: string;
      vmid: number;
      name: string;
      cidr: string;
      data: UpdateVMFirewallIPSetIPRequest;
    }
  > = (props) => {
    const { node, vmid, name, cidr, data } = props ?? {};

    return updateVMFirewallIPSetIP(node, vmid, name, cidr, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateVMFirewallIPSetIPMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateVMFirewallIPSetIP>>
>;
export type UpdateVMFirewallIPSetIPMutationBody =
  UpdateVMFirewallIPSetIPRequest;
export type UpdateVMFirewallIPSetIPMutationError = ErrorType<unknown>;

/**
 * @summary updateVMFirewallIPSetIP
 */
export const useUpdateVMFirewallIPSetIP = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMFirewallIPSetIP>>,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      cidr: string;
      data: UpdateVMFirewallIPSetIPRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateVMFirewallIPSetIPMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get VM firewall options.
 * @summary getVMFirewallOptions
 */
export const getVMFirewallOptions = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMFirewallOptionsResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/options`,
    method: "get",
    signal,
  });
};

export const getGetVMFirewallOptionsQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/firewall/options`] as const;

export const getGetVMFirewallOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMFirewallOptions>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallOptions>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getVMFirewallOptions>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMFirewallOptionsQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVMFirewallOptions>>
  > = ({ signal }) => getVMFirewallOptions(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMFirewallOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMFirewallOptions>>
>;
export type GetVMFirewallOptionsQueryError = ErrorType<unknown>;

/**
 * @summary getVMFirewallOptions
 */
export const useGetVMFirewallOptions = <
  TData = Awaited<ReturnType<typeof getVMFirewallOptions>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMFirewallOptions>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMFirewallOptionsQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set Firewall options.
 * @summary updateVMFirewallOptions
 */
export const updateVMFirewallOptions = (
  node: string,
  vmid: number,
  updateVMFirewallOptionsRequest: UpdateVMFirewallOptionsRequest,
) => {
  return apiInstance<UpdateVMFirewallOptionsResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/options`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateVMFirewallOptionsRequest,
  });
};

export const getUpdateVMFirewallOptionsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMFirewallOptions>>,
    TError,
    { node: string; vmid: number; data: UpdateVMFirewallOptionsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateVMFirewallOptions>>,
  TError,
  { node: string; vmid: number; data: UpdateVMFirewallOptionsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateVMFirewallOptions>>,
    { node: string; vmid: number; data: UpdateVMFirewallOptionsRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return updateVMFirewallOptions(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateVMFirewallOptionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateVMFirewallOptions>>
>;
export type UpdateVMFirewallOptionsMutationBody =
  UpdateVMFirewallOptionsRequest;
export type UpdateVMFirewallOptionsMutationError = ErrorType<unknown>;

/**
 * @summary updateVMFirewallOptions
 */
export const useUpdateVMFirewallOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMFirewallOptions>>,
    TError,
    { node: string; vmid: number; data: UpdateVMFirewallOptionsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateVMFirewallOptionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read firewall log
 * @summary getNodesSingleQemuSingleFirewallLog
 */
export const getNodesSingleQemuSingleFirewallLog = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleFirewallLogResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/log`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleFirewallLogQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/firewall/log`] as const;

export const getGetNodesSingleQemuSingleFirewallLogQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallLog>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallLog>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleFirewallLogQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallLog>>
  > = ({ signal }) => getNodesSingleQemuSingleFirewallLog(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleFirewallLogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallLog>>
>;
export type GetNodesSingleQemuSingleFirewallLogQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleFirewallLog
 */
export const useGetNodesSingleQemuSingleFirewallLog = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallLog>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleFirewallLogQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Lists possible IPSet/Alias reference which are allowed in source/dest properties.
 * @summary getNodesSingleQemuSingleFirewallRefs
 */
export const getNodesSingleQemuSingleFirewallRefs = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleFirewallRefsResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/firewall/refs`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleFirewallRefsQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/firewall/refs`] as const;

export const getGetNodesSingleQemuSingleFirewallRefsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallRefs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallRefs>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallRefs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleFirewallRefsQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallRefs>>
  > = ({ signal }) => getNodesSingleQemuSingleFirewallRefs(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleFirewallRefsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallRefs>>
>;
export type GetNodesSingleQemuSingleFirewallRefsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleFirewallRefs
 */
export const useGetNodesSingleQemuSingleFirewallRefs = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallRefs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFirewallRefs>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleFirewallRefsQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Qemu Agent command index.
 * @summary getNodesSingleQemuSingleAgent
 */
export const getNodesSingleQemuSingleAgent = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent`] as const;

export const getGetNodesSingleQemuSingleAgentQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgent>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgent>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgent>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgent>>
  > = ({ signal }) => getNodesSingleQemuSingleAgent(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgent>>
>;
export type GetNodesSingleQemuSingleAgentQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgent
 */
export const useGetNodesSingleQemuSingleAgent = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgent>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgent>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute Qemu Guest Agent commands.
 * @summary createNodesSingleQemuSingleAgent
 */
export const createNodesSingleQemuSingleAgent = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentRequest: CreateNodesSingleQemuSingleAgentRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleAgentRequest,
  });
};

export const getCreateNodesSingleQemuSingleAgentMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgent>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgent>>,
  TError,
  { node: string; vmid: number; data: CreateNodesSingleQemuSingleAgentRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgent>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgent(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgent>>
>;
export type CreateNodesSingleQemuSingleAgentMutationBody =
  CreateNodesSingleQemuSingleAgentRequest;
export type CreateNodesSingleQemuSingleAgentMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgent
 */
export const useCreateNodesSingleQemuSingleAgent = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgent>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute fsfreeze-freeze.
 * @summary createNodesSingleQemuSingleAgentFsfreezefreeze
 */
export const createNodesSingleQemuSingleAgentFsfreezefreeze = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentFsfreezefreezeRequest: CreateNodesSingleQemuSingleAgentFsfreezefreezeRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentFsfreezefreezeResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/fsfreeze-freeze`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleQemuSingleAgentFsfreezefreezeRequest,
    },
  );
};

export const getCreateNodesSingleQemuSingleAgentFsfreezefreezeMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezefreeze>
      >,
      TError,
      {
        node: string;
        vmid: number;
        data: CreateNodesSingleQemuSingleAgentFsfreezefreezeRequest;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezefreeze>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFsfreezefreezeRequest;
    },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezefreeze>
      >,
      {
        node: string;
        vmid: number;
        data: CreateNodesSingleQemuSingleAgentFsfreezefreezeRequest;
      }
    > = (props) => {
      const { node, vmid, data } = props ?? {};

      return createNodesSingleQemuSingleAgentFsfreezefreeze(node, vmid, data);
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateNodesSingleQemuSingleAgentFsfreezefreezeMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezefreeze>>
  >;
export type CreateNodesSingleQemuSingleAgentFsfreezefreezeMutationBody =
  CreateNodesSingleQemuSingleAgentFsfreezefreezeRequest;
export type CreateNodesSingleQemuSingleAgentFsfreezefreezeMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentFsfreezefreeze
 */
export const useCreateNodesSingleQemuSingleAgentFsfreezefreeze = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezefreeze>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFsfreezefreezeRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentFsfreezefreezeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute fsfreeze-status.
 * @summary createNodesSingleQemuSingleAgentFsfreezestatus
 */
export const createNodesSingleQemuSingleAgentFsfreezestatus = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentFsfreezestatusRequest: CreateNodesSingleQemuSingleAgentFsfreezestatusRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentFsfreezestatusResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/fsfreeze-status`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleQemuSingleAgentFsfreezestatusRequest,
    },
  );
};

export const getCreateNodesSingleQemuSingleAgentFsfreezestatusMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezestatus>
      >,
      TError,
      {
        node: string;
        vmid: number;
        data: CreateNodesSingleQemuSingleAgentFsfreezestatusRequest;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezestatus>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFsfreezestatusRequest;
    },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezestatus>
      >,
      {
        node: string;
        vmid: number;
        data: CreateNodesSingleQemuSingleAgentFsfreezestatusRequest;
      }
    > = (props) => {
      const { node, vmid, data } = props ?? {};

      return createNodesSingleQemuSingleAgentFsfreezestatus(node, vmid, data);
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateNodesSingleQemuSingleAgentFsfreezestatusMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezestatus>>
  >;
export type CreateNodesSingleQemuSingleAgentFsfreezestatusMutationBody =
  CreateNodesSingleQemuSingleAgentFsfreezestatusRequest;
export type CreateNodesSingleQemuSingleAgentFsfreezestatusMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentFsfreezestatus
 */
export const useCreateNodesSingleQemuSingleAgentFsfreezestatus = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezestatus>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFsfreezestatusRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentFsfreezestatusMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute fsfreeze-thaw.
 * @summary createNodesSingleQemuSingleAgentFsfreezethaw
 */
export const createNodesSingleQemuSingleAgentFsfreezethaw = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentFsfreezethawRequest: CreateNodesSingleQemuSingleAgentFsfreezethawRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentFsfreezethawResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/fsfreeze-thaw`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleQemuSingleAgentFsfreezethawRequest,
    },
  );
};

export const getCreateNodesSingleQemuSingleAgentFsfreezethawMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezethaw>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFsfreezethawRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezethaw>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleAgentFsfreezethawRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezethaw>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFsfreezethawRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgentFsfreezethaw(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentFsfreezethawMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezethaw>>
  >;
export type CreateNodesSingleQemuSingleAgentFsfreezethawMutationBody =
  CreateNodesSingleQemuSingleAgentFsfreezethawRequest;
export type CreateNodesSingleQemuSingleAgentFsfreezethawMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentFsfreezethaw
 */
export const useCreateNodesSingleQemuSingleAgentFsfreezethaw = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFsfreezethaw>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFsfreezethawRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentFsfreezethawMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute fstrim.
 * @summary createNodesSingleQemuSingleAgentFstrim
 */
export const createNodesSingleQemuSingleAgentFstrim = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentFstrimRequest: CreateNodesSingleQemuSingleAgentFstrimRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentFstrimResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/fstrim`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleAgentFstrimRequest,
  });
};

export const getCreateNodesSingleQemuSingleAgentFstrimMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFstrim>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFstrimRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFstrim>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleAgentFstrimRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFstrim>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFstrimRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgentFstrim(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentFstrimMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFstrim>>
>;
export type CreateNodesSingleQemuSingleAgentFstrimMutationBody =
  CreateNodesSingleQemuSingleAgentFstrimRequest;
export type CreateNodesSingleQemuSingleAgentFstrimMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentFstrim
 */
export const useCreateNodesSingleQemuSingleAgentFstrim = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFstrim>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFstrimRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentFstrimMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute get-fsinfo.
 * @summary getNodesSingleQemuSingleAgentGetfsinfo
 */
export const getNodesSingleQemuSingleAgentGetfsinfo = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentGetfsinfoResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/get-fsinfo`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentGetfsinfoQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/get-fsinfo`] as const;

export const getGetNodesSingleQemuSingleAgentGetfsinfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetfsinfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetfsinfo>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetfsinfo>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentGetfsinfoQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetfsinfo>>
  > = ({ signal }) =>
    getNodesSingleQemuSingleAgentGetfsinfo(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentGetfsinfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetfsinfo>>
>;
export type GetNodesSingleQemuSingleAgentGetfsinfoQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentGetfsinfo
 */
export const useGetNodesSingleQemuSingleAgentGetfsinfo = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetfsinfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetfsinfo>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentGetfsinfoQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute get-host-name.
 * @summary getNodesSingleQemuSingleAgentGethostname
 */
export const getNodesSingleQemuSingleAgentGethostname = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentGethostnameResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/get-host-name`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentGethostnameQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/get-host-name`] as const;

export const getGetNodesSingleQemuSingleAgentGethostnameQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGethostname>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGethostname>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGethostname>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentGethostnameQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGethostname>>
  > = ({ signal }) =>
    getNodesSingleQemuSingleAgentGethostname(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentGethostnameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGethostname>>
>;
export type GetNodesSingleQemuSingleAgentGethostnameQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentGethostname
 */
export const useGetNodesSingleQemuSingleAgentGethostname = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGethostname>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGethostname>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentGethostnameQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute get-memory-block-info.
 * @summary getNodesSingleQemuSingleAgentGetmemoryblockinfo
 */
export const getNodesSingleQemuSingleAgentGetmemoryblockinfo = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentGetmemoryblockinfoResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/get-memory-block-info`,
      method: "get",
      signal,
    },
  );
};

export const getGetNodesSingleQemuSingleAgentGetmemoryblockinfoQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/get-memory-block-info`] as const;

export const getGetNodesSingleQemuSingleAgentGetmemoryblockinfoQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblockinfo>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblockinfo>
      >,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblockinfo>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentGetmemoryblockinfoQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblockinfo>>
  > = ({ signal }) =>
    getNodesSingleQemuSingleAgentGetmemoryblockinfo(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentGetmemoryblockinfoQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblockinfo>>
  >;
export type GetNodesSingleQemuSingleAgentGetmemoryblockinfoQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentGetmemoryblockinfo
 */
export const useGetNodesSingleQemuSingleAgentGetmemoryblockinfo = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblockinfo>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblockinfo>
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetNodesSingleQemuSingleAgentGetmemoryblockinfoQueryOptions(
      node,
      vmid,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute get-memory-blocks.
 * @summary getNodesSingleQemuSingleAgentGetmemoryblocks
 */
export const getNodesSingleQemuSingleAgentGetmemoryblocks = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentGetmemoryblocksResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/get-memory-blocks`,
      method: "get",
      signal,
    },
  );
};

export const getGetNodesSingleQemuSingleAgentGetmemoryblocksQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/get-memory-blocks`] as const;

export const getGetNodesSingleQemuSingleAgentGetmemoryblocksQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblocks>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblocks>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblocks>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentGetmemoryblocksQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblocks>>
  > = ({ signal }) =>
    getNodesSingleQemuSingleAgentGetmemoryblocks(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentGetmemoryblocksQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblocks>>
  >;
export type GetNodesSingleQemuSingleAgentGetmemoryblocksQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentGetmemoryblocks
 */
export const useGetNodesSingleQemuSingleAgentGetmemoryblocks = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblocks>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetmemoryblocks>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetNodesSingleQemuSingleAgentGetmemoryblocksQueryOptions(
      node,
      vmid,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute get-osinfo.
 * @summary getNodesSingleQemuSingleAgentGetosinfo
 */
export const getNodesSingleQemuSingleAgentGetosinfo = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentGetosinfoResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/get-osinfo`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentGetosinfoQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/get-osinfo`] as const;

export const getGetNodesSingleQemuSingleAgentGetosinfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetosinfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetosinfo>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetosinfo>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentGetosinfoQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetosinfo>>
  > = ({ signal }) =>
    getNodesSingleQemuSingleAgentGetosinfo(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentGetosinfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetosinfo>>
>;
export type GetNodesSingleQemuSingleAgentGetosinfoQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentGetosinfo
 */
export const useGetNodesSingleQemuSingleAgentGetosinfo = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetosinfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetosinfo>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentGetosinfoQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute get-time.
 * @summary getNodesSingleQemuSingleAgentGettime
 */
export const getNodesSingleQemuSingleAgentGettime = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentGettimeResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/get-time`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentGettimeQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/get-time`] as const;

export const getGetNodesSingleQemuSingleAgentGettimeQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettime>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettime>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettime>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentGettimeQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettime>>
  > = ({ signal }) => getNodesSingleQemuSingleAgentGettime(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentGettimeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettime>>
>;
export type GetNodesSingleQemuSingleAgentGettimeQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentGettime
 */
export const useGetNodesSingleQemuSingleAgentGettime = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettime>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettime>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentGettimeQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute get-timezone.
 * @summary getNodesSingleQemuSingleAgentGettimezone
 */
export const getNodesSingleQemuSingleAgentGettimezone = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentGettimezoneResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/get-timezone`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentGettimezoneQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/get-timezone`] as const;

export const getGetNodesSingleQemuSingleAgentGettimezoneQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettimezone>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettimezone>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettimezone>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentGettimezoneQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettimezone>>
  > = ({ signal }) =>
    getNodesSingleQemuSingleAgentGettimezone(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentGettimezoneQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettimezone>>
>;
export type GetNodesSingleQemuSingleAgentGettimezoneQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentGettimezone
 */
export const useGetNodesSingleQemuSingleAgentGettimezone = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettimezone>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGettimezone>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentGettimezoneQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute get-users.
 * @summary getNodesSingleQemuSingleAgentGetusers
 */
export const getNodesSingleQemuSingleAgentGetusers = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentGetusersResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/get-users`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentGetusersQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/get-users`] as const;

export const getGetNodesSingleQemuSingleAgentGetusersQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetusers>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetusers>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetusers>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentGetusersQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetusers>>
  > = ({ signal }) => getNodesSingleQemuSingleAgentGetusers(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentGetusersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetusers>>
>;
export type GetNodesSingleQemuSingleAgentGetusersQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentGetusers
 */
export const useGetNodesSingleQemuSingleAgentGetusers = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetusers>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetusers>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentGetusersQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute get-vcpus.
 * @summary getNodesSingleQemuSingleAgentGetvcpus
 */
export const getNodesSingleQemuSingleAgentGetvcpus = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentGetvcpusResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/get-vcpus`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentGetvcpusQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/get-vcpus`] as const;

export const getGetNodesSingleQemuSingleAgentGetvcpusQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetvcpus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetvcpus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetvcpus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentGetvcpusQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetvcpus>>
  > = ({ signal }) => getNodesSingleQemuSingleAgentGetvcpus(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentGetvcpusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetvcpus>>
>;
export type GetNodesSingleQemuSingleAgentGetvcpusQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentGetvcpus
 */
export const useGetNodesSingleQemuSingleAgentGetvcpus = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetvcpus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentGetvcpus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentGetvcpusQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute info.
 * @summary getNodesSingleQemuSingleAgentInfo
 */
export const getNodesSingleQemuSingleAgentInfo = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentInfoResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/info`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentInfoQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/info`] as const;

export const getGetNodesSingleQemuSingleAgentInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentInfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentInfo>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentInfo>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentInfoQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentInfo>>
  > = ({ signal }) => getNodesSingleQemuSingleAgentInfo(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentInfo>>
>;
export type GetNodesSingleQemuSingleAgentInfoQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentInfo
 */
export const useGetNodesSingleQemuSingleAgentInfo = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentInfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentInfo>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentInfoQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute network-get-interfaces.
 * @summary getNodesSingleQemuSingleAgentNetworkgetinterfaces
 */
export const getNodesSingleQemuSingleAgentNetworkgetinterfaces = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentNetworkgetinterfacesResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/network-get-interfaces`,
      method: "get",
      signal,
    },
  );
};

export const getGetNodesSingleQemuSingleAgentNetworkgetinterfacesQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/network-get-interfaces`] as const;

export const getGetNodesSingleQemuSingleAgentNetworkgetinterfacesQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getNodesSingleQemuSingleAgentNetworkgetinterfaces>
    >,
    TError = ErrorType<unknown>,
  >(
    node: string,
    vmid: number,
    options?: {
      query?: UseQueryOptions<
        Awaited<
          ReturnType<typeof getNodesSingleQemuSingleAgentNetworkgetinterfaces>
        >,
        TError,
        TData
      >;
    },
  ): UseQueryOptions<
    Awaited<
      ReturnType<typeof getNodesSingleQemuSingleAgentNetworkgetinterfaces>
    >,
    TError,
    TData
  > & { queryKey: QueryKey } => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetNodesSingleQemuSingleAgentNetworkgetinterfacesQueryKey(node, vmid);

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getNodesSingleQemuSingleAgentNetworkgetinterfaces>
      >
    > = ({ signal }) =>
      getNodesSingleQemuSingleAgentNetworkgetinterfaces(node, vmid, signal);

    return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
  };

export type GetNodesSingleQemuSingleAgentNetworkgetinterfacesQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getNodesSingleQemuSingleAgentNetworkgetinterfaces>
    >
  >;
export type GetNodesSingleQemuSingleAgentNetworkgetinterfacesQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentNetworkgetinterfaces
 */
export const useGetNodesSingleQemuSingleAgentNetworkgetinterfaces = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleQemuSingleAgentNetworkgetinterfaces>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof getNodesSingleQemuSingleAgentNetworkgetinterfaces>
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetNodesSingleQemuSingleAgentNetworkgetinterfacesQueryOptions(
      node,
      vmid,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute ping.
 * @summary createNodesSingleQemuSingleAgentPing
 */
export const createNodesSingleQemuSingleAgentPing = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentPingRequest: CreateNodesSingleQemuSingleAgentPingRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentPingResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/ping`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleAgentPingRequest,
  });
};

export const getCreateNodesSingleQemuSingleAgentPingMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentPing>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentPingRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentPing>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleAgentPingRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentPing>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentPingRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgentPing(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentPingMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentPing>>
>;
export type CreateNodesSingleQemuSingleAgentPingMutationBody =
  CreateNodesSingleQemuSingleAgentPingRequest;
export type CreateNodesSingleQemuSingleAgentPingMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentPing
 */
export const useCreateNodesSingleQemuSingleAgentPing = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentPing>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentPingRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentPingMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute shutdown.
 * @summary createNodesSingleQemuSingleAgentShutdown
 */
export const createNodesSingleQemuSingleAgentShutdown = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentShutdownRequest: CreateNodesSingleQemuSingleAgentShutdownRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentShutdownResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/shutdown`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleAgentShutdownRequest,
  });
};

export const getCreateNodesSingleQemuSingleAgentShutdownMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentShutdown>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentShutdownRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentShutdown>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleAgentShutdownRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentShutdown>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentShutdownRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgentShutdown(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentShutdownMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentShutdown>>
  >;
export type CreateNodesSingleQemuSingleAgentShutdownMutationBody =
  CreateNodesSingleQemuSingleAgentShutdownRequest;
export type CreateNodesSingleQemuSingleAgentShutdownMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentShutdown
 */
export const useCreateNodesSingleQemuSingleAgentShutdown = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentShutdown>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentShutdownRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentShutdownMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute suspend-disk.
 * @summary createNodesSingleQemuSingleAgentSuspenddisk
 */
export const createNodesSingleQemuSingleAgentSuspenddisk = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentSuspenddiskRequest: CreateNodesSingleQemuSingleAgentSuspenddiskRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentSuspenddiskResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/suspend-disk`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleQemuSingleAgentSuspenddiskRequest,
    },
  );
};

export const getCreateNodesSingleQemuSingleAgentSuspenddiskMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspenddisk>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSuspenddiskRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspenddisk>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleAgentSuspenddiskRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspenddisk>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSuspenddiskRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgentSuspenddisk(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentSuspenddiskMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspenddisk>>
  >;
export type CreateNodesSingleQemuSingleAgentSuspenddiskMutationBody =
  CreateNodesSingleQemuSingleAgentSuspenddiskRequest;
export type CreateNodesSingleQemuSingleAgentSuspenddiskMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentSuspenddisk
 */
export const useCreateNodesSingleQemuSingleAgentSuspenddisk = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspenddisk>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSuspenddiskRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentSuspenddiskMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute suspend-hybrid.
 * @summary createNodesSingleQemuSingleAgentSuspendhybrid
 */
export const createNodesSingleQemuSingleAgentSuspendhybrid = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentSuspendhybridRequest: CreateNodesSingleQemuSingleAgentSuspendhybridRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentSuspendhybridResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/suspend-hybrid`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleQemuSingleAgentSuspendhybridRequest,
    },
  );
};

export const getCreateNodesSingleQemuSingleAgentSuspendhybridMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendhybrid>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSuspendhybridRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendhybrid>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleAgentSuspendhybridRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendhybrid>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSuspendhybridRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgentSuspendhybrid(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentSuspendhybridMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendhybrid>>
  >;
export type CreateNodesSingleQemuSingleAgentSuspendhybridMutationBody =
  CreateNodesSingleQemuSingleAgentSuspendhybridRequest;
export type CreateNodesSingleQemuSingleAgentSuspendhybridMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentSuspendhybrid
 */
export const useCreateNodesSingleQemuSingleAgentSuspendhybrid = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendhybrid>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSuspendhybridRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentSuspendhybridMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute suspend-ram.
 * @summary createNodesSingleQemuSingleAgentSuspendram
 */
export const createNodesSingleQemuSingleAgentSuspendram = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentSuspendramRequest: CreateNodesSingleQemuSingleAgentSuspendramRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentSuspendramResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/suspend-ram`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleQemuSingleAgentSuspendramRequest,
    },
  );
};

export const getCreateNodesSingleQemuSingleAgentSuspendramMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendram>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSuspendramRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendram>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleAgentSuspendramRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendram>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSuspendramRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgentSuspendram(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentSuspendramMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendram>>
  >;
export type CreateNodesSingleQemuSingleAgentSuspendramMutationBody =
  CreateNodesSingleQemuSingleAgentSuspendramRequest;
export type CreateNodesSingleQemuSingleAgentSuspendramMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentSuspendram
 */
export const useCreateNodesSingleQemuSingleAgentSuspendram = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSuspendram>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSuspendramRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentSuspendramMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Sets the password for the given user to the given password
 * @summary createNodesSingleQemuSingleAgentSetuserpassword
 */
export const createNodesSingleQemuSingleAgentSetuserpassword = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentSetuserpasswordRequest: CreateNodesSingleQemuSingleAgentSetuserpasswordRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentSetuserpasswordResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/set-user-password`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleQemuSingleAgentSetuserpasswordRequest,
    },
  );
};

export const getCreateNodesSingleQemuSingleAgentSetuserpasswordMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createNodesSingleQemuSingleAgentSetuserpassword>
      >,
      TError,
      {
        node: string;
        vmid: number;
        data: CreateNodesSingleQemuSingleAgentSetuserpasswordRequest;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSetuserpassword>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSetuserpasswordRequest;
    },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof createNodesSingleQemuSingleAgentSetuserpassword>
      >,
      {
        node: string;
        vmid: number;
        data: CreateNodesSingleQemuSingleAgentSetuserpasswordRequest;
      }
    > = (props) => {
      const { node, vmid, data } = props ?? {};

      return createNodesSingleQemuSingleAgentSetuserpassword(node, vmid, data);
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateNodesSingleQemuSingleAgentSetuserpasswordMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSetuserpassword>>
  >;
export type CreateNodesSingleQemuSingleAgentSetuserpasswordMutationBody =
  CreateNodesSingleQemuSingleAgentSetuserpasswordRequest;
export type CreateNodesSingleQemuSingleAgentSetuserpasswordMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentSetuserpassword
 */
export const useCreateNodesSingleQemuSingleAgentSetuserpassword = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentSetuserpassword>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentSetuserpasswordRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentSetuserpasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Executes the given command in the vm via the guest-agent and returns an object with the pid.
 * @summary createNodesSingleQemuSingleAgentExec
 */
export const createNodesSingleQemuSingleAgentExec = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentExecRequest: CreateNodesSingleQemuSingleAgentExecRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentExecResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/exec`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleAgentExecRequest,
  });
};

export const getCreateNodesSingleQemuSingleAgentExecMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentExec>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentExecRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentExec>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleAgentExecRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentExec>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentExecRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgentExec(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentExecMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentExec>>
>;
export type CreateNodesSingleQemuSingleAgentExecMutationBody =
  CreateNodesSingleQemuSingleAgentExecRequest;
export type CreateNodesSingleQemuSingleAgentExecMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentExec
 */
export const useCreateNodesSingleQemuSingleAgentExec = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentExec>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentExecRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentExecMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Gets the status of the given pid started by the guest-agent
 * @summary getNodesSingleQemuSingleAgentExecstatus
 */
export const getNodesSingleQemuSingleAgentExecstatus = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentExecstatusResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/exec-status`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentExecstatusQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/exec-status`] as const;

export const getGetNodesSingleQemuSingleAgentExecstatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentExecstatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentExecstatus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentExecstatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentExecstatusQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentExecstatus>>
  > = ({ signal }) =>
    getNodesSingleQemuSingleAgentExecstatus(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentExecstatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentExecstatus>>
>;
export type GetNodesSingleQemuSingleAgentExecstatusQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentExecstatus
 */
export const useGetNodesSingleQemuSingleAgentExecstatus = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentExecstatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentExecstatus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentExecstatusQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Reads the given file via guest agent. Is limited to 16777216 bytes.
 * @summary getNodesSingleQemuSingleAgentFileread
 */
export const getNodesSingleQemuSingleAgentFileread = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleAgentFilereadResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/agent/file-read`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleAgentFilereadQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/agent/file-read`] as const;

export const getGetNodesSingleQemuSingleAgentFilereadQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentFileread>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentFileread>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentFileread>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleAgentFilereadQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentFileread>>
  > = ({ signal }) => getNodesSingleQemuSingleAgentFileread(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleAgentFilereadQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentFileread>>
>;
export type GetNodesSingleQemuSingleAgentFilereadQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleAgentFileread
 */
export const useGetNodesSingleQemuSingleAgentFileread = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentFileread>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleAgentFileread>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleAgentFilereadQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Writes the given file via guest agent.
 * @summary createNodesSingleQemuSingleAgentFilewrite
 */
export const createNodesSingleQemuSingleAgentFilewrite = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleAgentFilewriteRequest: CreateNodesSingleQemuSingleAgentFilewriteRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleAgentFilewriteResponseResponse>(
    {
      url: `/nodes/${node}/qemu/${vmid}/agent/file-write`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleQemuSingleAgentFilewriteRequest,
    },
  );
};

export const getCreateNodesSingleQemuSingleAgentFilewriteMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFilewrite>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFilewriteRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFilewrite>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleAgentFilewriteRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFilewrite>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFilewriteRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleAgentFilewrite(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleAgentFilewriteMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFilewrite>>
  >;
export type CreateNodesSingleQemuSingleAgentFilewriteMutationBody =
  CreateNodesSingleQemuSingleAgentFilewriteRequest;
export type CreateNodesSingleQemuSingleAgentFilewriteMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleAgentFilewrite
 */
export const useCreateNodesSingleQemuSingleAgentFilewrite = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleAgentFilewrite>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleAgentFilewriteRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleAgentFilewriteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read VM RRD statistics (returns PNG)
 * @summary getVMRRD
 */
export const getVMRRD = (node: string, vmid: number, signal?: AbortSignal) => {
  return apiInstance<GetVMRRDResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/rrd`,
    method: "get",
    signal,
  });
};

export const getGetVMRRDQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/rrd`] as const;

export const getGetVMRRDQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMRRD>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMRRD>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getVMRRD>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVMRRDQueryKey(node, vmid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVMRRD>>> = ({
    signal,
  }) => getVMRRD(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMRRDQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMRRD>>
>;
export type GetVMRRDQueryError = ErrorType<unknown>;

/**
 * @summary getVMRRD
 */
export const useGetVMRRD = <
  TData = Awaited<ReturnType<typeof getVMRRD>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMRRD>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMRRDQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read VM RRD statistics
 * @summary getVMRRDData
 */
export const getVMRRDData = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMRRDDataResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/rrddata`,
    method: "get",
    signal,
  });
};

export const getGetVMRRDDataQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/rrddata`] as const;

export const getGetVMRRDDataQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMRRDData>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMRRDData>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getVMRRDData>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMRRDDataQueryKey(node, vmid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVMRRDData>>> = ({
    signal,
  }) => getVMRRDData(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMRRDDataQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMRRDData>>
>;
export type GetVMRRDDataQueryError = ErrorType<unknown>;

/**
 * @summary getVMRRDData
 */
export const useGetVMRRDData = <
  TData = Awaited<ReturnType<typeof getVMRRDData>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMRRDData>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMRRDDataQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get the virtual machine configuration with pending configuration changes applied. Set the 'current' parameter to get the current configuration instead.
 * @summary getVMConfig
 */
export const getVMConfig = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMConfigResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/config`,
    method: "get",
    signal,
  });
};

export const getGetVMConfigQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/config`] as const;

export const getGetVMConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMConfig>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getVMConfig>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVMConfigQueryKey(node, vmid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVMConfig>>> = ({
    signal,
  }) => getVMConfig(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMConfig>>
>;
export type GetVMConfigQueryError = ErrorType<unknown>;

/**
 * @summary getVMConfig
 */
export const useGetVMConfig = <
  TData = Awaited<ReturnType<typeof getVMConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMConfig>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMConfigQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set virtual machine options (asynchrounous API).
 * @summary updateVMConfig
 */
export const updateVMConfig = (
  node: string,
  vmid: number,
  updateVMConfigRequest: UpdateVMConfigRequest,
) => {
  return apiInstance<UpdateVMConfigResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/config`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: updateVMConfigRequest,
  });
};

export const getUpdateVMConfigMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMConfig>>,
    TError,
    { node: string; vmid: number; data: UpdateVMConfigRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateVMConfig>>,
  TError,
  { node: string; vmid: number; data: UpdateVMConfigRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateVMConfig>>,
    { node: string; vmid: number; data: UpdateVMConfigRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return updateVMConfig(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateVMConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateVMConfig>>
>;
export type UpdateVMConfigMutationBody = UpdateVMConfigRequest;
export type UpdateVMConfigMutationError = ErrorType<unknown>;

/**
 * @summary updateVMConfig
 */
export const useUpdateVMConfig = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMConfig>>,
    TError,
    { node: string; vmid: number; data: UpdateVMConfigRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateVMConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Set virtual machine options (synchrounous API) - You should consider using the POST method instead for any actions involving hotplug or storage allocation.
 * @summary updateVMConfigSync
 */
export const updateVMConfigSync = (
  node: string,
  vmid: number,
  updateVMConfigSyncRequest: UpdateVMConfigSyncRequest,
) => {
  return apiInstance<UpdateVMConfigSyncResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/config`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateVMConfigSyncRequest,
  });
};

export const getUpdateVMConfigSyncMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMConfigSync>>,
    TError,
    { node: string; vmid: number; data: UpdateVMConfigSyncRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateVMConfigSync>>,
  TError,
  { node: string; vmid: number; data: UpdateVMConfigSyncRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateVMConfigSync>>,
    { node: string; vmid: number; data: UpdateVMConfigSyncRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return updateVMConfigSync(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateVMConfigSyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateVMConfigSync>>
>;
export type UpdateVMConfigSyncMutationBody = UpdateVMConfigSyncRequest;
export type UpdateVMConfigSyncMutationError = ErrorType<unknown>;

/**
 * @summary updateVMConfigSync
 */
export const useUpdateVMConfigSync = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMConfigSync>>,
    TError,
    { node: string; vmid: number; data: UpdateVMConfigSyncRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateVMConfigSyncMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get the virtual machine configuration with both current and pending values.
 * @summary getVMConfigPending
 */
export const getVMConfigPending = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMConfigPendingResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/pending`,
    method: "get",
    signal,
  });
};

export const getGetVMConfigPendingQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/pending`] as const;

export const getGetVMConfigPendingQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMConfigPending>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMConfigPending>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getVMConfigPending>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMConfigPendingQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVMConfigPending>>
  > = ({ signal }) => getVMConfigPending(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMConfigPendingQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMConfigPending>>
>;
export type GetVMConfigPendingQueryError = ErrorType<unknown>;

/**
 * @summary getVMConfigPending
 */
export const useGetVMConfigPending = <
  TData = Awaited<ReturnType<typeof getVMConfigPending>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMConfigPending>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMConfigPendingQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Unlink/delete disk images.
 * @summary unlinkVMDiskImages
 */
export const unlinkVMDiskImages = (
  node: string,
  vmid: number,
  unlinkVMDiskImagesRequest: UnlinkVMDiskImagesRequest,
) => {
  return apiInstance<UnlinkVMDiskImagesResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/unlink`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: unlinkVMDiskImagesRequest,
  });
};

export const getUnlinkVMDiskImagesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unlinkVMDiskImages>>,
    TError,
    { node: string; vmid: number; data: UnlinkVMDiskImagesRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unlinkVMDiskImages>>,
  TError,
  { node: string; vmid: number; data: UnlinkVMDiskImagesRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unlinkVMDiskImages>>,
    { node: string; vmid: number; data: UnlinkVMDiskImagesRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return unlinkVMDiskImages(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnlinkVMDiskImagesMutationResult = NonNullable<
  Awaited<ReturnType<typeof unlinkVMDiskImages>>
>;
export type UnlinkVMDiskImagesMutationBody = UnlinkVMDiskImagesRequest;
export type UnlinkVMDiskImagesMutationError = ErrorType<unknown>;

/**
 * @summary unlinkVMDiskImages
 */
export const useUnlinkVMDiskImages = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unlinkVMDiskImages>>,
    TError,
    { node: string; vmid: number; data: UnlinkVMDiskImagesRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUnlinkVMDiskImagesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Creates a TCP VNC proxy connections.
 * @summary createNodesSingleQemuSingleVncproxy
 */
export const createNodesSingleQemuSingleVncproxy = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleVncproxyRequest: CreateNodesSingleQemuSingleVncproxyRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleVncproxyResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/vncproxy`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleVncproxyRequest,
  });
};

export const getCreateNodesSingleQemuSingleVncproxyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleVncproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleVncproxyRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleVncproxy>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleVncproxyRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleVncproxy>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleVncproxyRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleVncproxy(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleVncproxyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleVncproxy>>
>;
export type CreateNodesSingleQemuSingleVncproxyMutationBody =
  CreateNodesSingleQemuSingleVncproxyRequest;
export type CreateNodesSingleQemuSingleVncproxyMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleVncproxy
 */
export const useCreateNodesSingleQemuSingleVncproxy = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleVncproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleVncproxyRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleVncproxyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Creates a TCP proxy connections.
 * @summary createNodesSingleQemuSingleTermproxy
 */
export const createNodesSingleQemuSingleTermproxy = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleTermproxyRequest: CreateNodesSingleQemuSingleTermproxyRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleTermproxyResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/termproxy`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleTermproxyRequest,
  });
};

export const getCreateNodesSingleQemuSingleTermproxyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleTermproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleTermproxyRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleTermproxy>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleTermproxyRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleTermproxy>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleTermproxyRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleTermproxy(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleTermproxyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleTermproxy>>
>;
export type CreateNodesSingleQemuSingleTermproxyMutationBody =
  CreateNodesSingleQemuSingleTermproxyRequest;
export type CreateNodesSingleQemuSingleTermproxyMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleTermproxy
 */
export const useCreateNodesSingleQemuSingleTermproxy = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleTermproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleTermproxyRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleTermproxyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Opens a weksocket for VNC traffic.
 * @summary getNodesSingleQemuSingleVncwebsocket
 */
export const getNodesSingleQemuSingleVncwebsocket = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleVncwebsocketResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/vncwebsocket`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleVncwebsocketQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/vncwebsocket`] as const;

export const getGetNodesSingleQemuSingleVncwebsocketQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleVncwebsocket>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleVncwebsocket>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleVncwebsocket>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleVncwebsocketQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleVncwebsocket>>
  > = ({ signal }) => getNodesSingleQemuSingleVncwebsocket(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleVncwebsocketQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleVncwebsocket>>
>;
export type GetNodesSingleQemuSingleVncwebsocketQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleVncwebsocket
 */
export const useGetNodesSingleQemuSingleVncwebsocket = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleVncwebsocket>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleVncwebsocket>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleVncwebsocketQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a SPICE configuration to connect to the VM.
 * @summary createNodesSingleQemuSingleSpiceproxy
 */
export const createNodesSingleQemuSingleSpiceproxy = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleSpiceproxyRequest: CreateNodesSingleQemuSingleSpiceproxyRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleSpiceproxyResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/spiceproxy`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleSpiceproxyRequest,
  });
};

export const getCreateNodesSingleQemuSingleSpiceproxyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleSpiceproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleSpiceproxyRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleSpiceproxy>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleSpiceproxyRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleSpiceproxy>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleSpiceproxyRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleSpiceproxy(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleSpiceproxyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleSpiceproxy>>
>;
export type CreateNodesSingleQemuSingleSpiceproxyMutationBody =
  CreateNodesSingleQemuSingleSpiceproxyRequest;
export type CreateNodesSingleQemuSingleSpiceproxyMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleSpiceproxy
 */
export const useCreateNodesSingleQemuSingleSpiceproxy = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleSpiceproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleSpiceproxyRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleSpiceproxyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index
 * @summary getVMStatus
 */
export const getVMStatus = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMStatusResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/status`,
    method: "get",
    signal,
  });
};

export const getGetVMStatusQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/status`] as const;

export const getGetVMStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMStatus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getVMStatus>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVMStatusQueryKey(node, vmid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVMStatus>>> = ({
    signal,
  }) => getVMStatus(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMStatus>>
>;
export type GetVMStatusQueryError = ErrorType<unknown>;

/**
 * @summary getVMStatus
 */
export const useGetVMStatus = <
  TData = Awaited<ReturnType<typeof getVMStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMStatus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMStatusQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get virtual machine status.
 * @summary getCurrentVMStatus
 */
export const getCurrentVMStatus = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetCurrentVMStatusResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/status/current`,
    method: "get",
    signal,
  });
};

export const getGetCurrentVMStatusQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/status/current`] as const;

export const getGetCurrentVMStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getCurrentVMStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getCurrentVMStatus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getCurrentVMStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCurrentVMStatusQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCurrentVMStatus>>
  > = ({ signal }) => getCurrentVMStatus(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetCurrentVMStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCurrentVMStatus>>
>;
export type GetCurrentVMStatusQueryError = ErrorType<unknown>;

/**
 * @summary getCurrentVMStatus
 */
export const useGetCurrentVMStatus = <
  TData = Awaited<ReturnType<typeof getCurrentVMStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getCurrentVMStatus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCurrentVMStatusQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Start virtual machine.
 * @summary startVM
 */
export const startVM = (
  node: string,
  vmid: number,
  startVMRequest: StartVMRequest,
) => {
  return apiInstance<StartVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/status/start`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: startVMRequest,
  });
};

export const getStartVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof startVM>>,
    TError,
    { node: string; vmid: number; data: StartVMRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof startVM>>,
  TError,
  { node: string; vmid: number; data: StartVMRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof startVM>>,
    { node: string; vmid: number; data: StartVMRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return startVM(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type StartVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof startVM>>
>;
export type StartVMMutationBody = StartVMRequest;
export type StartVMMutationError = ErrorType<unknown>;

/**
 * @summary startVM
 */
export const useStartVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof startVM>>,
    TError,
    { node: string; vmid: number; data: StartVMRequest },
    TContext
  >;
}) => {
  const mutationOptions = getStartVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Stop virtual machine. The qemu process will exit immediately. Thisis akin to pulling the power plug of a running computer and may damage the VM data
 * @summary stopVM
 */
export const stopVM = (
  node: string,
  vmid: number,
  stopVMRequest: StopVMRequest,
) => {
  return apiInstance<StopVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/status/stop`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: stopVMRequest,
  });
};

export const getStopVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopVM>>,
    TError,
    { node: string; vmid: number; data: StopVMRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stopVM>>,
  TError,
  { node: string; vmid: number; data: StopVMRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stopVM>>,
    { node: string; vmid: number; data: StopVMRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return stopVM(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type StopVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof stopVM>>
>;
export type StopVMMutationBody = StopVMRequest;
export type StopVMMutationError = ErrorType<unknown>;

/**
 * @summary stopVM
 */
export const useStopVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopVM>>,
    TError,
    { node: string; vmid: number; data: StopVMRequest },
    TContext
  >;
}) => {
  const mutationOptions = getStopVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reset virtual machine.
 * @summary resetVM
 */
export const resetVM = (
  node: string,
  vmid: number,
  resetVMRequest: ResetVMRequest,
) => {
  return apiInstance<ResetVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/status/reset`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: resetVMRequest,
  });
};

export const getResetVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetVM>>,
    TError,
    { node: string; vmid: number; data: ResetVMRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetVM>>,
  TError,
  { node: string; vmid: number; data: ResetVMRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetVM>>,
    { node: string; vmid: number; data: ResetVMRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return resetVM(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetVM>>
>;
export type ResetVMMutationBody = ResetVMRequest;
export type ResetVMMutationError = ErrorType<unknown>;

/**
 * @summary resetVM
 */
export const useResetVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetVM>>,
    TError,
    { node: string; vmid: number; data: ResetVMRequest },
    TContext
  >;
}) => {
  const mutationOptions = getResetVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Shutdown virtual machine. This is similar to pressing the power button on a physical machine.This will send an ACPI event for the guest OS, which should then proceed to a clean shutdown.
 * @summary shutdownVM
 */
export const shutdownVM = (
  node: string,
  vmid: number,
  shutdownVMRequest: ShutdownVMRequest,
) => {
  return apiInstance<ShutdownVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/status/shutdown`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: shutdownVMRequest,
  });
};

export const getShutdownVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof shutdownVM>>,
    TError,
    { node: string; vmid: number; data: ShutdownVMRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof shutdownVM>>,
  TError,
  { node: string; vmid: number; data: ShutdownVMRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof shutdownVM>>,
    { node: string; vmid: number; data: ShutdownVMRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return shutdownVM(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ShutdownVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof shutdownVM>>
>;
export type ShutdownVMMutationBody = ShutdownVMRequest;
export type ShutdownVMMutationError = ErrorType<unknown>;

/**
 * @summary shutdownVM
 */
export const useShutdownVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof shutdownVM>>,
    TError,
    { node: string; vmid: number; data: ShutdownVMRequest },
    TContext
  >;
}) => {
  const mutationOptions = getShutdownVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reboot the VM by shutting it down, and starting it again. Applies pending changes.
 * @summary rebootVM
 */
export const rebootVM = (
  node: string,
  vmid: number,
  rebootVMRequest: RebootVMRequest,
) => {
  return apiInstance<RebootVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/status/reboot`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: rebootVMRequest,
  });
};

export const getRebootVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rebootVM>>,
    TError,
    { node: string; vmid: number; data: RebootVMRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rebootVM>>,
  TError,
  { node: string; vmid: number; data: RebootVMRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rebootVM>>,
    { node: string; vmid: number; data: RebootVMRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return rebootVM(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RebootVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof rebootVM>>
>;
export type RebootVMMutationBody = RebootVMRequest;
export type RebootVMMutationError = ErrorType<unknown>;

/**
 * @summary rebootVM
 */
export const useRebootVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rebootVM>>,
    TError,
    { node: string; vmid: number; data: RebootVMRequest },
    TContext
  >;
}) => {
  const mutationOptions = getRebootVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Suspend virtual machine.
 * @summary suspendVM
 */
export const suspendVM = (
  node: string,
  vmid: number,
  suspendVMRequest: SuspendVMRequest,
) => {
  return apiInstance<SuspendVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/status/suspend`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: suspendVMRequest,
  });
};

export const getSuspendVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suspendVM>>,
    TError,
    { node: string; vmid: number; data: SuspendVMRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suspendVM>>,
  TError,
  { node: string; vmid: number; data: SuspendVMRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suspendVM>>,
    { node: string; vmid: number; data: SuspendVMRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return suspendVM(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuspendVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof suspendVM>>
>;
export type SuspendVMMutationBody = SuspendVMRequest;
export type SuspendVMMutationError = ErrorType<unknown>;

/**
 * @summary suspendVM
 */
export const useSuspendVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suspendVM>>,
    TError,
    { node: string; vmid: number; data: SuspendVMRequest },
    TContext
  >;
}) => {
  const mutationOptions = getSuspendVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Resume virtual machine.
 * @summary resumeVM
 */
export const resumeVM = (
  node: string,
  vmid: number,
  resumeVMRequest: ResumeVMRequest,
) => {
  return apiInstance<ResumeVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/status/resume`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: resumeVMRequest,
  });
};

export const getResumeVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resumeVM>>,
    TError,
    { node: string; vmid: number; data: ResumeVMRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resumeVM>>,
  TError,
  { node: string; vmid: number; data: ResumeVMRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resumeVM>>,
    { node: string; vmid: number; data: ResumeVMRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return resumeVM(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResumeVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof resumeVM>>
>;
export type ResumeVMMutationBody = ResumeVMRequest;
export type ResumeVMMutationError = ErrorType<unknown>;

/**
 * @summary resumeVM
 */
export const useResumeVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resumeVM>>,
    TError,
    { node: string; vmid: number; data: ResumeVMRequest },
    TContext
  >;
}) => {
  const mutationOptions = getResumeVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Send key event to virtual machine.
 * @summary updateNodesSingleQemuSingleSendkey
 */
export const updateNodesSingleQemuSingleSendkey = (
  node: string,
  vmid: number,
  updateNodesSingleQemuSingleSendkeyRequest: UpdateNodesSingleQemuSingleSendkeyRequest,
) => {
  return apiInstance<UpdateNodesSingleQemuSingleSendkeyResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/sendkey`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleQemuSingleSendkeyRequest,
  });
};

export const getUpdateNodesSingleQemuSingleSendkeyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleQemuSingleSendkey>>,
    TError,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleQemuSingleSendkeyRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleQemuSingleSendkey>>,
  TError,
  {
    node: string;
    vmid: number;
    data: UpdateNodesSingleQemuSingleSendkeyRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleQemuSingleSendkey>>,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleQemuSingleSendkeyRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return updateNodesSingleQemuSingleSendkey(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleQemuSingleSendkeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleQemuSingleSendkey>>
>;
export type UpdateNodesSingleQemuSingleSendkeyMutationBody =
  UpdateNodesSingleQemuSingleSendkeyRequest;
export type UpdateNodesSingleQemuSingleSendkeyMutationError =
  ErrorType<unknown>;

/**
 * @summary updateNodesSingleQemuSingleSendkey
 */
export const useUpdateNodesSingleQemuSingleSendkey = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleQemuSingleSendkey>>,
    TError,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleQemuSingleSendkeyRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleQemuSingleSendkeyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Check if feature for virtual machine is available.
 * @summary getNodesSingleQemuSingleFeature
 */
export const getNodesSingleQemuSingleFeature = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleFeatureResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/feature`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleFeatureQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/feature`] as const;

export const getGetNodesSingleQemuSingleFeatureQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleFeature>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFeature>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleFeature>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleFeatureQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleFeature>>
  > = ({ signal }) => getNodesSingleQemuSingleFeature(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleFeatureQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleFeature>>
>;
export type GetNodesSingleQemuSingleFeatureQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleFeature
 */
export const useGetNodesSingleQemuSingleFeature = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleFeature>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleFeature>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleFeatureQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a copy of virtual machine/template.
 * @summary cloneVM
 */
export const cloneVM = (
  node: string,
  vmid: number,
  cloneVMRequest: CloneVMRequest,
) => {
  return apiInstance<CloneVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/clone`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: cloneVMRequest,
  });
};

export const getCloneVMMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cloneVM>>,
    TError,
    { node: string; vmid: number; data: CloneVMRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cloneVM>>,
  TError,
  { node: string; vmid: number; data: CloneVMRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cloneVM>>,
    { node: string; vmid: number; data: CloneVMRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return cloneVM(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CloneVMMutationResult = NonNullable<
  Awaited<ReturnType<typeof cloneVM>>
>;
export type CloneVMMutationBody = CloneVMRequest;
export type CloneVMMutationError = ErrorType<unknown>;

/**
 * @summary cloneVM
 */
export const useCloneVM = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cloneVM>>,
    TError,
    { node: string; vmid: number; data: CloneVMRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCloneVMMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Move volume to different storage.
 * @summary createNodesSingleQemuSingleMovedisk
 */
export const createNodesSingleQemuSingleMovedisk = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleMovediskRequest: CreateNodesSingleQemuSingleMovediskRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleMovediskResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/move_disk`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleMovediskRequest,
  });
};

export const getCreateNodesSingleQemuSingleMovediskMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleMovedisk>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleMovediskRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleMovedisk>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleMovediskRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleMovedisk>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleMovediskRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleMovedisk(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleMovediskMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleMovedisk>>
>;
export type CreateNodesSingleQemuSingleMovediskMutationBody =
  CreateNodesSingleQemuSingleMovediskRequest;
export type CreateNodesSingleQemuSingleMovediskMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleMovedisk
 */
export const useCreateNodesSingleQemuSingleMovedisk = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleMovedisk>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleMovediskRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleMovediskMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get preconditions for migration.
 * @summary migrateVM
 */
export const migrateVM = (node: string, vmid: number, signal?: AbortSignal) => {
  return apiInstance<MigrateVMResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/migrate`,
    method: "get",
    signal,
  });
};

export const getMigrateVMQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/migrate`] as const;

export const getMigrateVMQueryOptions = <
  TData = Awaited<ReturnType<typeof migrateVM>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof migrateVM>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof migrateVM>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMigrateVMQueryKey(node, vmid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof migrateVM>>> = ({
    signal,
  }) => migrateVM(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type MigrateVMQueryResult = NonNullable<
  Awaited<ReturnType<typeof migrateVM>>
>;
export type MigrateVMQueryError = ErrorType<unknown>;

/**
 * @summary migrateVM
 */
export const useMigrateVM = <
  TData = Awaited<ReturnType<typeof migrateVM>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof migrateVM>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getMigrateVMQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Migrate virtual machine. Creates a new migration task.
 * @summary createNodesSingleQemuSingleMigrate
 */
export const createNodesSingleQemuSingleMigrate = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleMigrateRequest: CreateNodesSingleQemuSingleMigrateRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleMigrateResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleMigrateRequest,
  });
};

export const getCreateNodesSingleQemuSingleMigrateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleMigrate>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleMigrateRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleMigrate>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleMigrateRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleMigrate>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleMigrateRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleMigrate(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleMigrateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleMigrate>>
>;
export type CreateNodesSingleQemuSingleMigrateMutationBody =
  CreateNodesSingleQemuSingleMigrateRequest;
export type CreateNodesSingleQemuSingleMigrateMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleMigrate
 */
export const useCreateNodesSingleQemuSingleMigrate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleMigrate>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleMigrateRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleMigrateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Execute Qemu monitor commands.
 * @summary createNodesSingleQemuSingleMonitor
 */
export const createNodesSingleQemuSingleMonitor = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleMonitorRequest: CreateNodesSingleQemuSingleMonitorRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleMonitorResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/monitor`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleMonitorRequest,
  });
};

export const getCreateNodesSingleQemuSingleMonitorMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleMonitor>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleMonitorRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleMonitor>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleMonitorRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleMonitor>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleMonitorRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleMonitor(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleMonitorMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleMonitor>>
>;
export type CreateNodesSingleQemuSingleMonitorMutationBody =
  CreateNodesSingleQemuSingleMonitorRequest;
export type CreateNodesSingleQemuSingleMonitorMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleMonitor
 */
export const useCreateNodesSingleQemuSingleMonitor = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleMonitor>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleMonitorRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleMonitorMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Extend volume size.
 * @summary resizeVMDisk
 */
export const resizeVMDisk = (
  node: string,
  vmid: number,
  resizeVMDiskRequest: ResizeVMDiskRequest,
) => {
  return apiInstance<ResizeVMDiskResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/resize`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: resizeVMDiskRequest,
  });
};

export const getResizeVMDiskMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resizeVMDisk>>,
    TError,
    { node: string; vmid: number; data: ResizeVMDiskRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resizeVMDisk>>,
  TError,
  { node: string; vmid: number; data: ResizeVMDiskRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resizeVMDisk>>,
    { node: string; vmid: number; data: ResizeVMDiskRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return resizeVMDisk(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResizeVMDiskMutationResult = NonNullable<
  Awaited<ReturnType<typeof resizeVMDisk>>
>;
export type ResizeVMDiskMutationBody = ResizeVMDiskRequest;
export type ResizeVMDiskMutationError = ErrorType<unknown>;

/**
 * @summary resizeVMDisk
 */
export const useResizeVMDisk = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resizeVMDisk>>,
    TError,
    { node: string; vmid: number; data: ResizeVMDiskRequest },
    TContext
  >;
}) => {
  const mutationOptions = getResizeVMDiskMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List all snapshots.
 * @summary getVMSnapshots
 */
export const getVMSnapshots = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMSnapshotsResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/snapshot`,
    method: "get",
    signal,
  });
};

export const getGetVMSnapshotsQueryKey = (node: string, vmid: number) =>
  [`/nodes/${node}/qemu/${vmid}/snapshot`] as const;

export const getGetVMSnapshotsQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMSnapshots>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMSnapshots>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getVMSnapshots>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMSnapshotsQueryKey(node, vmid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVMSnapshots>>> = ({
    signal,
  }) => getVMSnapshots(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetVMSnapshotsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMSnapshots>>
>;
export type GetVMSnapshotsQueryError = ErrorType<unknown>;

/**
 * @summary getVMSnapshots
 */
export const useGetVMSnapshots = <
  TData = Awaited<ReturnType<typeof getVMSnapshots>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMSnapshots>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMSnapshotsQueryOptions(node, vmid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Snapshot a VM.
 * @summary createVMSnapshot
 */
export const createVMSnapshot = (
  node: string,
  vmid: number,
  createVMSnapshotRequest: CreateVMSnapshotRequest,
) => {
  return apiInstance<CreateVMSnapshotResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/snapshot`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createVMSnapshotRequest,
  });
};

export const getCreateVMSnapshotMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVMSnapshot>>,
    TError,
    { node: string; vmid: number; data: CreateVMSnapshotRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createVMSnapshot>>,
  TError,
  { node: string; vmid: number; data: CreateVMSnapshotRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createVMSnapshot>>,
    { node: string; vmid: number; data: CreateVMSnapshotRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createVMSnapshot(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateVMSnapshotMutationResult = NonNullable<
  Awaited<ReturnType<typeof createVMSnapshot>>
>;
export type CreateVMSnapshotMutationBody = CreateVMSnapshotRequest;
export type CreateVMSnapshotMutationError = ErrorType<unknown>;

/**
 * @summary createVMSnapshot
 */
export const useCreateVMSnapshot = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVMSnapshot>>,
    TError,
    { node: string; vmid: number; data: CreateVMSnapshotRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateVMSnapshotMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete a VM snapshot.
 * @summary deleteVMSnapshot
 */
export const deleteVMSnapshot = (
  node: string,
  vmid: number,
  snapname: string,
) => {
  return apiInstance<DeleteVMSnapshotResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/snapshot/${snapname}`,
    method: "delete",
  });
};

export const getDeleteVMSnapshotMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVMSnapshot>>,
    TError,
    { node: string; vmid: number; snapname: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteVMSnapshot>>,
  TError,
  { node: string; vmid: number; snapname: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteVMSnapshot>>,
    { node: string; vmid: number; snapname: string }
  > = (props) => {
    const { node, vmid, snapname } = props ?? {};

    return deleteVMSnapshot(node, vmid, snapname);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteVMSnapshotMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteVMSnapshot>>
>;

export type DeleteVMSnapshotMutationError = ErrorType<unknown>;

/**
 * @summary deleteVMSnapshot
 */
export const useDeleteVMSnapshot = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVMSnapshot>>,
    TError,
    { node: string; vmid: number; snapname: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteVMSnapshotMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * getVMSnapshot
 * @summary getVMSnapshot
 */
export const getVMSnapshot = (
  node: string,
  vmid: number,
  snapname: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMSnapshotResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/snapshot/${snapname}`,
    method: "get",
    signal,
  });
};

export const getGetVMSnapshotQueryKey = (
  node: string,
  vmid: number,
  snapname: string,
) => [`/nodes/${node}/qemu/${vmid}/snapshot/${snapname}`] as const;

export const getGetVMSnapshotQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMSnapshot>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  snapname: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMSnapshot>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getVMSnapshot>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVMSnapshotQueryKey(node, vmid, snapname);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVMSnapshot>>> = ({
    signal,
  }) => getVMSnapshot(node, vmid, snapname, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && snapname),
    ...queryOptions,
  };
};

export type GetVMSnapshotQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMSnapshot>>
>;
export type GetVMSnapshotQueryError = ErrorType<unknown>;

/**
 * @summary getVMSnapshot
 */
export const useGetVMSnapshot = <
  TData = Awaited<ReturnType<typeof getVMSnapshot>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  snapname: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMSnapshot>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMSnapshotQueryOptions(
    node,
    vmid,
    snapname,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get snapshot configuration
 * @summary getVMSnapshotConfig
 */
export const getVMSnapshotConfig = (
  node: string,
  vmid: number,
  snapname: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetVMSnapshotConfigResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/snapshot/${snapname}/config`,
    method: "get",
    signal,
  });
};

export const getGetVMSnapshotConfigQueryKey = (
  node: string,
  vmid: number,
  snapname: string,
) => [`/nodes/${node}/qemu/${vmid}/snapshot/${snapname}/config`] as const;

export const getGetVMSnapshotConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getVMSnapshotConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  snapname: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMSnapshotConfig>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getVMSnapshotConfig>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetVMSnapshotConfigQueryKey(node, vmid, snapname);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVMSnapshotConfig>>
  > = ({ signal }) => getVMSnapshotConfig(node, vmid, snapname, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && snapname),
    ...queryOptions,
  };
};

export type GetVMSnapshotConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVMSnapshotConfig>>
>;
export type GetVMSnapshotConfigQueryError = ErrorType<unknown>;

/**
 * @summary getVMSnapshotConfig
 */
export const useGetVMSnapshotConfig = <
  TData = Awaited<ReturnType<typeof getVMSnapshotConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  snapname: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVMSnapshotConfig>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVMSnapshotConfigQueryOptions(
    node,
    vmid,
    snapname,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update snapshot metadata.
 * @summary updateVMSnapshotConfig
 */
export const updateVMSnapshotConfig = (
  node: string,
  vmid: number,
  snapname: string,
  updateVMSnapshotConfigRequest: UpdateVMSnapshotConfigRequest,
) => {
  return apiInstance<UpdateVMSnapshotConfigResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/snapshot/${snapname}/config`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateVMSnapshotConfigRequest,
  });
};

export const getUpdateVMSnapshotConfigMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMSnapshotConfig>>,
    TError,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: UpdateVMSnapshotConfigRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateVMSnapshotConfig>>,
  TError,
  {
    node: string;
    vmid: number;
    snapname: string;
    data: UpdateVMSnapshotConfigRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateVMSnapshotConfig>>,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: UpdateVMSnapshotConfigRequest;
    }
  > = (props) => {
    const { node, vmid, snapname, data } = props ?? {};

    return updateVMSnapshotConfig(node, vmid, snapname, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateVMSnapshotConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateVMSnapshotConfig>>
>;
export type UpdateVMSnapshotConfigMutationBody = UpdateVMSnapshotConfigRequest;
export type UpdateVMSnapshotConfigMutationError = ErrorType<unknown>;

/**
 * @summary updateVMSnapshotConfig
 */
export const useUpdateVMSnapshotConfig = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVMSnapshotConfig>>,
    TError,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: UpdateVMSnapshotConfigRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateVMSnapshotConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Rollback VM state to specified snapshot.
 * @summary rollbackVMSnapshot
 */
export const rollbackVMSnapshot = (
  node: string,
  vmid: number,
  snapname: string,
  rollbackVMSnapshotRequest: RollbackVMSnapshotRequest,
) => {
  return apiInstance<RollbackVMSnapshotResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/snapshot/${snapname}/rollback`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: rollbackVMSnapshotRequest,
  });
};

export const getRollbackVMSnapshotMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rollbackVMSnapshot>>,
    TError,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: RollbackVMSnapshotRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rollbackVMSnapshot>>,
  TError,
  {
    node: string;
    vmid: number;
    snapname: string;
    data: RollbackVMSnapshotRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rollbackVMSnapshot>>,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: RollbackVMSnapshotRequest;
    }
  > = (props) => {
    const { node, vmid, snapname, data } = props ?? {};

    return rollbackVMSnapshot(node, vmid, snapname, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RollbackVMSnapshotMutationResult = NonNullable<
  Awaited<ReturnType<typeof rollbackVMSnapshot>>
>;
export type RollbackVMSnapshotMutationBody = RollbackVMSnapshotRequest;
export type RollbackVMSnapshotMutationError = ErrorType<unknown>;

/**
 * @summary rollbackVMSnapshot
 */
export const useRollbackVMSnapshot = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rollbackVMSnapshot>>,
    TError,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: RollbackVMSnapshotRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions = getRollbackVMSnapshotMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create a Template.
 * @summary createNodesSingleQemuSingleTemplate
 */
export const createNodesSingleQemuSingleTemplate = (
  node: string,
  vmid: number,
  createNodesSingleQemuSingleTemplateRequest: CreateNodesSingleQemuSingleTemplateRequest,
) => {
  return apiInstance<CreateNodesSingleQemuSingleTemplateResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/template`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleQemuSingleTemplateRequest,
  });
};

export const getCreateNodesSingleQemuSingleTemplateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleTemplate>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleTemplateRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleTemplate>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleQemuSingleTemplateRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleTemplate>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleTemplateRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleQemuSingleTemplate(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleQemuSingleTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleQemuSingleTemplate>>
>;
export type CreateNodesSingleQemuSingleTemplateMutationBody =
  CreateNodesSingleQemuSingleTemplateRequest;
export type CreateNodesSingleQemuSingleTemplateMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleQemuSingleTemplate
 */
export const useCreateNodesSingleQemuSingleTemplate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleQemuSingleTemplate>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleQemuSingleTemplateRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleQemuSingleTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get automatically generated cloudinit config.
 * @summary getNodesSingleQemuSingleCloudinitDump
 */
export const getNodesSingleQemuSingleCloudinitDump = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleQemuSingleCloudinitDumpResponseResponse>({
    url: `/nodes/${node}/qemu/${vmid}/cloudinit/dump`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleQemuSingleCloudinitDumpQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/qemu/${vmid}/cloudinit/dump`] as const;

export const getGetNodesSingleQemuSingleCloudinitDumpQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleCloudinitDump>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleCloudinitDump>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleCloudinitDump>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleQemuSingleCloudinitDumpQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleQemuSingleCloudinitDump>>
  > = ({ signal }) => getNodesSingleQemuSingleCloudinitDump(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleQemuSingleCloudinitDumpQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleQemuSingleCloudinitDump>>
>;
export type GetNodesSingleQemuSingleCloudinitDumpQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleQemuSingleCloudinitDump
 */
export const useGetNodesSingleQemuSingleCloudinitDump = <
  TData = Awaited<ReturnType<typeof getNodesSingleQemuSingleCloudinitDump>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleQemuSingleCloudinitDump>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleQemuSingleCloudinitDumpQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List all custom and default CPU models.
 * @summary getNodesSingleCpu
 */
export const getNodesSingleCpu = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCpuResponseResponse>({
    url: `/nodes/${node}/cpu`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCpuQueryKey = (node: string) =>
  [`/nodes/${node}/cpu`] as const;

export const getGetNodesSingleCpuQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCpu>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCpu>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCpu>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodesSingleCpuQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCpu>>
  > = ({ signal }) => getNodesSingleCpu(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCpuQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCpu>>
>;
export type GetNodesSingleCpuQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCpu
 */
export const useGetNodesSingleCpu = <
  TData = Awaited<ReturnType<typeof getNodesSingleCpu>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCpu>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCpuQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * LXC container index (per node).
 * @summary getNodesSingleLxc
 */
export const getNodesSingleLxc = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleLxcResponseResponse>({
    url: `/nodes/${node}/lxc`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcQueryKey = (node: string) =>
  [`/nodes/${node}/lxc`] as const;

export const getGetNodesSingleLxcQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxc>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxc>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxc>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodesSingleLxcQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxc>>
  > = ({ signal }) => getNodesSingleLxc(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleLxcQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxc>>
>;
export type GetNodesSingleLxcQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxc
 */
export const useGetNodesSingleLxc = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxc>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxc>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create or restore a container.
 * @summary createNodesSingleLxc
 */
export const createNodesSingleLxc = (
  node: string,
  createNodesSingleLxcRequest: CreateNodesSingleLxcRequest,
) => {
  return apiInstance<CreateNodesSingleLxcResponseResponse>({
    url: `/nodes/${node}/lxc`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcRequest,
  });
};

export const getCreateNodesSingleLxcMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxc>>,
    TError,
    { node: string; data: CreateNodesSingleLxcRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxc>>,
  TError,
  { node: string; data: CreateNodesSingleLxcRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxc>>,
    { node: string; data: CreateNodesSingleLxcRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleLxc(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxc>>
>;
export type CreateNodesSingleLxcMutationBody = CreateNodesSingleLxcRequest;
export type CreateNodesSingleLxcMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleLxc
 */
export const useCreateNodesSingleLxc = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxc>>,
    TError,
    { node: string; data: CreateNodesSingleLxcRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleLxcMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Destroy the container (also delete all uses files).
 * @summary deleteNodesSingleLxcSingle
 */
export const deleteNodesSingleLxcSingle = (node: string, vmid: number) => {
  return apiInstance<DeleteNodesSingleLxcSingleResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}`,
    method: "delete",
  });
};

export const getDeleteNodesSingleLxcSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingle>>,
    TError,
    { node: string; vmid: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleLxcSingle>>,
  TError,
  { node: string; vmid: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingle>>,
    { node: string; vmid: number }
  > = (props) => {
    const { node, vmid } = props ?? {};

    return deleteNodesSingleLxcSingle(node, vmid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleLxcSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleLxcSingle>>
>;

export type DeleteNodesSingleLxcSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleLxcSingle
 */
export const useDeleteNodesSingleLxcSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingle>>,
    TError,
    { node: string; vmid: number },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteNodesSingleLxcSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index
 * @summary getNodesSingleLxcSingle
 */
export const getNodesSingleLxcSingle = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}`] as const;

export const getGetNodesSingleLxcSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleLxcSingleQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingle>>
  > = ({ signal }) => getNodesSingleLxcSingle(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingle>>
>;
export type GetNodesSingleLxcSingleQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingle
 */
export const useGetNodesSingleLxcSingle = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get container configuration.
 * @summary getNodesSingleLxcSingleConfig
 */
export const getNodesSingleLxcSingleConfig = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleConfigResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/config`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleConfigQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/config`] as const;

export const getGetNodesSingleLxcSingleConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleConfig>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleConfig>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleConfigQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleConfig>>
  > = ({ signal }) => getNodesSingleLxcSingleConfig(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleConfig>>
>;
export type GetNodesSingleLxcSingleConfigQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleConfig
 */
export const useGetNodesSingleLxcSingleConfig = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleConfig>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleConfigQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set container options.
 * @summary updateNodesSingleLxcSingleConfig
 */
export const updateNodesSingleLxcSingleConfig = (
  node: string,
  vmid: number,
  updateNodesSingleLxcSingleConfigRequest: UpdateNodesSingleLxcSingleConfigRequest,
) => {
  return apiInstance<UpdateNodesSingleLxcSingleConfigResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/config`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleLxcSingleConfigRequest,
  });
};

export const getUpdateNodesSingleLxcSingleConfigMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleConfig>>,
    TError,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleLxcSingleConfigRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleLxcSingleConfig>>,
  TError,
  { node: string; vmid: number; data: UpdateNodesSingleLxcSingleConfigRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleConfig>>,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleLxcSingleConfigRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return updateNodesSingleLxcSingleConfig(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleLxcSingleConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleLxcSingleConfig>>
>;
export type UpdateNodesSingleLxcSingleConfigMutationBody =
  UpdateNodesSingleLxcSingleConfigRequest;
export type UpdateNodesSingleLxcSingleConfigMutationError = ErrorType<unknown>;

/**
 * @summary updateNodesSingleLxcSingleConfig
 */
export const useUpdateNodesSingleLxcSingleConfig = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleConfig>>,
    TError,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleLxcSingleConfigRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleLxcSingleConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index
 * @summary getNodesSingleLxcSingleStatus
 */
export const getNodesSingleLxcSingleStatus = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleStatusResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/status`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleStatusQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/status`] as const;

export const getGetNodesSingleLxcSingleStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleStatus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleStatusQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleStatus>>
  > = ({ signal }) => getNodesSingleLxcSingleStatus(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleStatus>>
>;
export type GetNodesSingleLxcSingleStatusQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleStatus
 */
export const useGetNodesSingleLxcSingleStatus = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleStatus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleStatusQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get virtual machine status.
 * @summary getNodesSingleLxcSingleStatusCurrent
 */
export const getNodesSingleLxcSingleStatusCurrent = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleStatusCurrentResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/status/current`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleStatusCurrentQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/status/current`] as const;

export const getGetNodesSingleLxcSingleStatusCurrentQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleStatusCurrent>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleStatusCurrent>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleStatusCurrent>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleStatusCurrentQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleStatusCurrent>>
  > = ({ signal }) => getNodesSingleLxcSingleStatusCurrent(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleStatusCurrentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleStatusCurrent>>
>;
export type GetNodesSingleLxcSingleStatusCurrentQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleStatusCurrent
 */
export const useGetNodesSingleLxcSingleStatusCurrent = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleStatusCurrent>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleStatusCurrent>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleStatusCurrentQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Start the container.
 * @summary createNodesSingleLxcSingleStatusStart
 */
export const createNodesSingleLxcSingleStatusStart = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleStatusStartRequest: CreateNodesSingleLxcSingleStatusStartRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleStatusStartResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/status/start`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleStatusStartRequest,
  });
};

export const getCreateNodesSingleLxcSingleStatusStartMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStart>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusStartRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStart>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleStatusStartRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStart>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusStartRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleStatusStart(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleStatusStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStart>>
>;
export type CreateNodesSingleLxcSingleStatusStartMutationBody =
  CreateNodesSingleLxcSingleStatusStartRequest;
export type CreateNodesSingleLxcSingleStatusStartMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleStatusStart
 */
export const useCreateNodesSingleLxcSingleStatusStart = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStart>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusStartRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleStatusStartMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Stop the container. This will abruptly stop all processes running in the container.
 * @summary createNodesSingleLxcSingleStatusStop
 */
export const createNodesSingleLxcSingleStatusStop = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleStatusStopRequest: CreateNodesSingleLxcSingleStatusStopRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleStatusStopResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/status/stop`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleStatusStopRequest,
  });
};

export const getCreateNodesSingleLxcSingleStatusStopMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStop>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusStopRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStop>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleStatusStopRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStop>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusStopRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleStatusStop(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleStatusStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStop>>
>;
export type CreateNodesSingleLxcSingleStatusStopMutationBody =
  CreateNodesSingleLxcSingleStatusStopRequest;
export type CreateNodesSingleLxcSingleStatusStopMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleStatusStop
 */
export const useCreateNodesSingleLxcSingleStatusStop = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusStop>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusStopRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleStatusStopMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Shutdown the container. This will trigger a clean shutdown of the container, see lxc-stop(1) for details.
 * @summary createNodesSingleLxcSingleStatusShutdown
 */
export const createNodesSingleLxcSingleStatusShutdown = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleStatusShutdownRequest: CreateNodesSingleLxcSingleStatusShutdownRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleStatusShutdownResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/status/shutdown`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleStatusShutdownRequest,
  });
};

export const getCreateNodesSingleLxcSingleStatusShutdownMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusShutdown>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusShutdownRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusShutdown>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleStatusShutdownRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusShutdown>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusShutdownRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleStatusShutdown(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleStatusShutdownMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusShutdown>>
  >;
export type CreateNodesSingleLxcSingleStatusShutdownMutationBody =
  CreateNodesSingleLxcSingleStatusShutdownRequest;
export type CreateNodesSingleLxcSingleStatusShutdownMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleStatusShutdown
 */
export const useCreateNodesSingleLxcSingleStatusShutdown = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusShutdown>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusShutdownRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleStatusShutdownMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Suspend the container.
 * @summary createNodesSingleLxcSingleStatusSuspend
 */
export const createNodesSingleLxcSingleStatusSuspend = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleStatusSuspendRequest: CreateNodesSingleLxcSingleStatusSuspendRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleStatusSuspendResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/status/suspend`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleStatusSuspendRequest,
  });
};

export const getCreateNodesSingleLxcSingleStatusSuspendMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusSuspend>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusSuspendRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusSuspend>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleStatusSuspendRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusSuspend>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusSuspendRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleStatusSuspend(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleStatusSuspendMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusSuspend>>
>;
export type CreateNodesSingleLxcSingleStatusSuspendMutationBody =
  CreateNodesSingleLxcSingleStatusSuspendRequest;
export type CreateNodesSingleLxcSingleStatusSuspendMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleStatusSuspend
 */
export const useCreateNodesSingleLxcSingleStatusSuspend = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusSuspend>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusSuspendRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleStatusSuspendMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Resume the container.
 * @summary createNodesSingleLxcSingleStatusResume
 */
export const createNodesSingleLxcSingleStatusResume = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleStatusResumeRequest: CreateNodesSingleLxcSingleStatusResumeRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleStatusResumeResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/status/resume`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleStatusResumeRequest,
  });
};

export const getCreateNodesSingleLxcSingleStatusResumeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusResume>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusResumeRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusResume>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleStatusResumeRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusResume>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusResumeRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleStatusResume(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleStatusResumeMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusResume>>
>;
export type CreateNodesSingleLxcSingleStatusResumeMutationBody =
  CreateNodesSingleLxcSingleStatusResumeRequest;
export type CreateNodesSingleLxcSingleStatusResumeMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleStatusResume
 */
export const useCreateNodesSingleLxcSingleStatusResume = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusResume>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusResumeRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleStatusResumeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reboot the container by shutting it down, and starting it again. Applies pending changes.
 * @summary createNodesSingleLxcSingleStatusReboot
 */
export const createNodesSingleLxcSingleStatusReboot = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleStatusRebootRequest: CreateNodesSingleLxcSingleStatusRebootRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleStatusRebootResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/status/reboot`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleStatusRebootRequest,
  });
};

export const getCreateNodesSingleLxcSingleStatusRebootMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusReboot>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusRebootRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusReboot>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleStatusRebootRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusReboot>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusRebootRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleStatusReboot(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleStatusRebootMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusReboot>>
>;
export type CreateNodesSingleLxcSingleStatusRebootMutationBody =
  CreateNodesSingleLxcSingleStatusRebootRequest;
export type CreateNodesSingleLxcSingleStatusRebootMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleStatusReboot
 */
export const useCreateNodesSingleLxcSingleStatusReboot = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleStatusReboot>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleStatusRebootRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleStatusRebootMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List all snapshots.
 * @summary getNodesSingleLxcSingleSnapshot
 */
export const getNodesSingleLxcSingleSnapshot = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleSnapshotResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/snapshot`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleSnapshotQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/snapshot`] as const;

export const getGetNodesSingleLxcSingleSnapshotQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshot>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshot>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshot>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleSnapshotQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshot>>
  > = ({ signal }) => getNodesSingleLxcSingleSnapshot(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleSnapshotQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshot>>
>;
export type GetNodesSingleLxcSingleSnapshotQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleSnapshot
 */
export const useGetNodesSingleLxcSingleSnapshot = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshot>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshot>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleSnapshotQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Snapshot a container.
 * @summary createNodesSingleLxcSingleSnapshot
 */
export const createNodesSingleLxcSingleSnapshot = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleSnapshotRequest: CreateNodesSingleLxcSingleSnapshotRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleSnapshotResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/snapshot`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleSnapshotRequest,
  });
};

export const getCreateNodesSingleLxcSingleSnapshotMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleSnapshot>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleSnapshotRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleSnapshot>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleSnapshotRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleSnapshot>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleSnapshotRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleSnapshot(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleSnapshotMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleSnapshot>>
>;
export type CreateNodesSingleLxcSingleSnapshotMutationBody =
  CreateNodesSingleLxcSingleSnapshotRequest;
export type CreateNodesSingleLxcSingleSnapshotMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleSnapshot
 */
export const useCreateNodesSingleLxcSingleSnapshot = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleSnapshot>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleSnapshotRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleSnapshotMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete a LXC snapshot.
 * @summary deleteNodesSingleLxcSingleSnapshotSingle
 */
export const deleteNodesSingleLxcSingleSnapshotSingle = (
  node: string,
  vmid: number,
  snapname: string,
) => {
  return apiInstance<DeleteNodesSingleLxcSingleSnapshotSingleResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/snapshot/${snapname}`,
    method: "delete",
  });
};

export const getDeleteNodesSingleLxcSingleSnapshotSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleSnapshotSingle>>,
    TError,
    { node: string; vmid: number; snapname: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleLxcSingleSnapshotSingle>>,
  TError,
  { node: string; vmid: number; snapname: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleSnapshotSingle>>,
    { node: string; vmid: number; snapname: string }
  > = (props) => {
    const { node, vmid, snapname } = props ?? {};

    return deleteNodesSingleLxcSingleSnapshotSingle(node, vmid, snapname);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleLxcSingleSnapshotSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleSnapshotSingle>>
  >;

export type DeleteNodesSingleLxcSingleSnapshotSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleLxcSingleSnapshotSingle
 */
export const useDeleteNodesSingleLxcSingleSnapshotSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleSnapshotSingle>>,
    TError,
    { node: string; vmid: number; snapname: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleLxcSingleSnapshotSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * getNodesSingleLxcSingleSnapshotSingle
 * @summary getNodesSingleLxcSingleSnapshotSingle
 */
export const getNodesSingleLxcSingleSnapshotSingle = (
  node: string,
  vmid: number,
  snapname: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleSnapshotSingleResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/snapshot/${snapname}`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleSnapshotSingleQueryKey = (
  node: string,
  vmid: number,
  snapname: string,
) => [`/nodes/${node}/lxc/${vmid}/snapshot/${snapname}`] as const;

export const getGetNodesSingleLxcSingleSnapshotSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  snapname: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleSnapshotSingleQueryKey(node, vmid, snapname);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingle>>
  > = ({ signal }) =>
    getNodesSingleLxcSingleSnapshotSingle(node, vmid, snapname, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && snapname),
    ...queryOptions,
  };
};

export type GetNodesSingleLxcSingleSnapshotSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingle>>
>;
export type GetNodesSingleLxcSingleSnapshotSingleQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleSnapshotSingle
 */
export const useGetNodesSingleLxcSingleSnapshotSingle = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  snapname: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleSnapshotSingleQueryOptions(
    node,
    vmid,
    snapname,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Rollback LXC state to specified snapshot.
 * @summary createNodesSingleLxcSingleSnapshotSingleRollback
 */
export const createNodesSingleLxcSingleSnapshotSingleRollback = (
  node: string,
  vmid: number,
  snapname: string,
  createNodesSingleLxcSingleSnapshotSingleRollbackRequest: CreateNodesSingleLxcSingleSnapshotSingleRollbackRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleSnapshotSingleRollbackResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/snapshot/${snapname}/rollback`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleLxcSingleSnapshotSingleRollbackRequest,
    },
  );
};

export const getCreateNodesSingleLxcSingleSnapshotSingleRollbackMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createNodesSingleLxcSingleSnapshotSingleRollback>
      >,
      TError,
      {
        node: string;
        vmid: number;
        snapname: string;
        data: CreateNodesSingleLxcSingleSnapshotSingleRollbackRequest;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof createNodesSingleLxcSingleSnapshotSingleRollback>
    >,
    TError,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: CreateNodesSingleLxcSingleSnapshotSingleRollbackRequest;
    },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof createNodesSingleLxcSingleSnapshotSingleRollback>
      >,
      {
        node: string;
        vmid: number;
        snapname: string;
        data: CreateNodesSingleLxcSingleSnapshotSingleRollbackRequest;
      }
    > = (props) => {
      const { node, vmid, snapname, data } = props ?? {};

      return createNodesSingleLxcSingleSnapshotSingleRollback(
        node,
        vmid,
        snapname,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateNodesSingleLxcSingleSnapshotSingleRollbackMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleSnapshotSingleRollback>>
  >;
export type CreateNodesSingleLxcSingleSnapshotSingleRollbackMutationBody =
  CreateNodesSingleLxcSingleSnapshotSingleRollbackRequest;
export type CreateNodesSingleLxcSingleSnapshotSingleRollbackMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleSnapshotSingleRollback
 */
export const useCreateNodesSingleLxcSingleSnapshotSingleRollback = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof createNodesSingleLxcSingleSnapshotSingleRollback>
    >,
    TError,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: CreateNodesSingleLxcSingleSnapshotSingleRollbackRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleSnapshotSingleRollbackMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get snapshot configuration
 * @summary getNodesSingleLxcSingleSnapshotSingleConfig
 */
export const getNodesSingleLxcSingleSnapshotSingleConfig = (
  node: string,
  vmid: number,
  snapname: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleSnapshotSingleConfigResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/snapshot/${snapname}/config`,
      method: "get",
      signal,
    },
  );
};

export const getGetNodesSingleLxcSingleSnapshotSingleConfigQueryKey = (
  node: string,
  vmid: number,
  snapname: string,
) => [`/nodes/${node}/lxc/${vmid}/snapshot/${snapname}/config`] as const;

export const getGetNodesSingleLxcSingleSnapshotSingleConfigQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleSnapshotSingleConfig>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  snapname: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingleConfig>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingleConfig>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleSnapshotSingleConfigQueryKey(
      node,
      vmid,
      snapname,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingleConfig>>
  > = ({ signal }) =>
    getNodesSingleLxcSingleSnapshotSingleConfig(node, vmid, snapname, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && snapname),
    ...queryOptions,
  };
};

export type GetNodesSingleLxcSingleSnapshotSingleConfigQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingleConfig>>
  >;
export type GetNodesSingleLxcSingleSnapshotSingleConfigQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleSnapshotSingleConfig
 */
export const useGetNodesSingleLxcSingleSnapshotSingleConfig = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleSnapshotSingleConfig>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  snapname: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleSnapshotSingleConfig>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetNodesSingleLxcSingleSnapshotSingleConfigQueryOptions(
      node,
      vmid,
      snapname,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update snapshot metadata.
 * @summary updateNodesSingleLxcSingleSnapshotSingleConfig
 */
export const updateNodesSingleLxcSingleSnapshotSingleConfig = (
  node: string,
  vmid: number,
  snapname: string,
  updateNodesSingleLxcSingleSnapshotSingleConfigRequest: UpdateNodesSingleLxcSingleSnapshotSingleConfigRequest,
) => {
  return apiInstance<UpdateNodesSingleLxcSingleSnapshotSingleConfigResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/snapshot/${snapname}/config`,
      method: "put",
      headers: { "Content-Type": "application/json" },
      data: updateNodesSingleLxcSingleSnapshotSingleConfigRequest,
    },
  );
};

export const getUpdateNodesSingleLxcSingleSnapshotSingleConfigMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateNodesSingleLxcSingleSnapshotSingleConfig>
      >,
      TError,
      {
        node: string;
        vmid: number;
        snapname: string;
        data: UpdateNodesSingleLxcSingleSnapshotSingleConfigRequest;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleSnapshotSingleConfig>>,
    TError,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: UpdateNodesSingleLxcSingleSnapshotSingleConfigRequest;
    },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateNodesSingleLxcSingleSnapshotSingleConfig>
      >,
      {
        node: string;
        vmid: number;
        snapname: string;
        data: UpdateNodesSingleLxcSingleSnapshotSingleConfigRequest;
      }
    > = (props) => {
      const { node, vmid, snapname, data } = props ?? {};

      return updateNodesSingleLxcSingleSnapshotSingleConfig(
        node,
        vmid,
        snapname,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateNodesSingleLxcSingleSnapshotSingleConfigMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleSnapshotSingleConfig>>
  >;
export type UpdateNodesSingleLxcSingleSnapshotSingleConfigMutationBody =
  UpdateNodesSingleLxcSingleSnapshotSingleConfigRequest;
export type UpdateNodesSingleLxcSingleSnapshotSingleConfigMutationError =
  ErrorType<unknown>;

/**
 * @summary updateNodesSingleLxcSingleSnapshotSingleConfig
 */
export const useUpdateNodesSingleLxcSingleSnapshotSingleConfig = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleSnapshotSingleConfig>>,
    TError,
    {
      node: string;
      vmid: number;
      snapname: string;
      data: UpdateNodesSingleLxcSingleSnapshotSingleConfigRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleLxcSingleSnapshotSingleConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index.
 * @summary getNodesSingleLxcSingleFirewall
 */
export const getNodesSingleLxcSingleFirewall = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/firewall`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleFirewallQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/firewall`] as const;

export const getGetNodesSingleLxcSingleFirewallQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewall>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewall>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewall>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewall>>
  > = ({ signal }) => getNodesSingleLxcSingleFirewall(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleFirewallQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewall>>
>;
export type GetNodesSingleLxcSingleFirewallQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewall
 */
export const useGetNodesSingleLxcSingleFirewall = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewall>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewall>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleFirewallQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List rules.
 * @summary getNodesSingleLxcSingleFirewallRules
 */
export const getNodesSingleLxcSingleFirewallRules = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallRulesResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/firewall/rules`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleFirewallRulesQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/firewall/rules`] as const;

export const getGetNodesSingleLxcSingleFirewallRulesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRules>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRules>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRules>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallRulesQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRules>>
  > = ({ signal }) => getNodesSingleLxcSingleFirewallRules(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleFirewallRulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRules>>
>;
export type GetNodesSingleLxcSingleFirewallRulesQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallRules
 */
export const useGetNodesSingleLxcSingleFirewallRules = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRules>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRules>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleFirewallRulesQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new rule.
 * @summary createNodesSingleLxcSingleFirewallRules
 */
export const createNodesSingleLxcSingleFirewallRules = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleFirewallRulesRequest: CreateNodesSingleLxcSingleFirewallRulesRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleFirewallRulesResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/firewall/rules`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleFirewallRulesRequest,
  });
};

export const getCreateNodesSingleLxcSingleFirewallRulesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallRules>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleFirewallRulesRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallRules>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleFirewallRulesRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallRules>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleFirewallRulesRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleFirewallRules(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleFirewallRulesMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallRules>>
>;
export type CreateNodesSingleLxcSingleFirewallRulesMutationBody =
  CreateNodesSingleLxcSingleFirewallRulesRequest;
export type CreateNodesSingleLxcSingleFirewallRulesMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleFirewallRules
 */
export const useCreateNodesSingleLxcSingleFirewallRules = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallRules>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleFirewallRulesRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleFirewallRulesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete rule.
 * @summary deleteNodesSingleLxcSingleFirewallRulesSingle
 */
export const deleteNodesSingleLxcSingleFirewallRulesSingle = (
  node: string,
  vmid: number,
  pos: number,
) => {
  return apiInstance<DeleteNodesSingleLxcSingleFirewallRulesSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/rules/${pos}`,
      method: "delete",
    },
  );
};

export const getDeleteNodesSingleLxcSingleFirewallRulesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallRulesSingle>>,
    TError,
    { node: string; vmid: number; pos: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallRulesSingle>>,
  TError,
  { node: string; vmid: number; pos: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallRulesSingle>>,
    { node: string; vmid: number; pos: number }
  > = (props) => {
    const { node, vmid, pos } = props ?? {};

    return deleteNodesSingleLxcSingleFirewallRulesSingle(node, vmid, pos);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleLxcSingleFirewallRulesSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallRulesSingle>>
  >;

export type DeleteNodesSingleLxcSingleFirewallRulesSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleLxcSingleFirewallRulesSingle
 */
export const useDeleteNodesSingleLxcSingleFirewallRulesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallRulesSingle>>,
    TError,
    { node: string; vmid: number; pos: number },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleLxcSingleFirewallRulesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get single rule data.
 * @summary getNodesSingleLxcSingleFirewallRulesSingle
 */
export const getNodesSingleLxcSingleFirewallRulesSingle = (
  node: string,
  vmid: number,
  pos: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallRulesSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/rules/${pos}`,
      method: "get",
      signal,
    },
  );
};

export const getGetNodesSingleLxcSingleFirewallRulesSingleQueryKey = (
  node: string,
  vmid: number,
  pos: number,
) => [`/nodes/${node}/lxc/${vmid}/firewall/rules/${pos}`] as const;

export const getGetNodesSingleLxcSingleFirewallRulesSingleQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleFirewallRulesSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRulesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRulesSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallRulesSingleQueryKey(node, vmid, pos);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRulesSingle>>
  > = ({ signal }) =>
    getNodesSingleLxcSingleFirewallRulesSingle(node, vmid, pos, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && pos),
    ...queryOptions,
  };
};

export type GetNodesSingleLxcSingleFirewallRulesSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRulesSingle>>
>;
export type GetNodesSingleLxcSingleFirewallRulesSingleQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallRulesSingle
 */
export const useGetNodesSingleLxcSingleFirewallRulesSingle = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleFirewallRulesSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRulesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetNodesSingleLxcSingleFirewallRulesSingleQueryOptions(
      node,
      vmid,
      pos,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Modify rule data.
 * @summary updateNodesSingleLxcSingleFirewallRulesSingle
 */
export const updateNodesSingleLxcSingleFirewallRulesSingle = (
  node: string,
  vmid: number,
  pos: number,
  updateNodesSingleLxcSingleFirewallRulesSingleRequest: UpdateNodesSingleLxcSingleFirewallRulesSingleRequest,
) => {
  return apiInstance<UpdateNodesSingleLxcSingleFirewallRulesSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/rules/${pos}`,
      method: "put",
      headers: { "Content-Type": "application/json" },
      data: updateNodesSingleLxcSingleFirewallRulesSingleRequest,
    },
  );
};

export const getUpdateNodesSingleLxcSingleFirewallRulesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallRulesSingle>>,
    TError,
    {
      node: string;
      vmid: number;
      pos: number;
      data: UpdateNodesSingleLxcSingleFirewallRulesSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallRulesSingle>>,
  TError,
  {
    node: string;
    vmid: number;
    pos: number;
    data: UpdateNodesSingleLxcSingleFirewallRulesSingleRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallRulesSingle>>,
    {
      node: string;
      vmid: number;
      pos: number;
      data: UpdateNodesSingleLxcSingleFirewallRulesSingleRequest;
    }
  > = (props) => {
    const { node, vmid, pos, data } = props ?? {};

    return updateNodesSingleLxcSingleFirewallRulesSingle(node, vmid, pos, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleLxcSingleFirewallRulesSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallRulesSingle>>
  >;
export type UpdateNodesSingleLxcSingleFirewallRulesSingleMutationBody =
  UpdateNodesSingleLxcSingleFirewallRulesSingleRequest;
export type UpdateNodesSingleLxcSingleFirewallRulesSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary updateNodesSingleLxcSingleFirewallRulesSingle
 */
export const useUpdateNodesSingleLxcSingleFirewallRulesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallRulesSingle>>,
    TError,
    {
      node: string;
      vmid: number;
      pos: number;
      data: UpdateNodesSingleLxcSingleFirewallRulesSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleLxcSingleFirewallRulesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List aliases
 * @summary getNodesSingleLxcSingleFirewallAliases
 */
export const getNodesSingleLxcSingleFirewallAliases = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallAliasesResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/firewall/aliases`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleFirewallAliasesQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/firewall/aliases`] as const;

export const getGetNodesSingleLxcSingleFirewallAliasesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliases>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliases>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliases>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallAliasesQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliases>>
  > = ({ signal }) =>
    getNodesSingleLxcSingleFirewallAliases(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleFirewallAliasesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliases>>
>;
export type GetNodesSingleLxcSingleFirewallAliasesQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallAliases
 */
export const useGetNodesSingleLxcSingleFirewallAliases = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliases>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliases>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleFirewallAliasesQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create IP or Network Alias.
 * @summary createNodesSingleLxcSingleFirewallAliases
 */
export const createNodesSingleLxcSingleFirewallAliases = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleFirewallAliasesRequest: CreateNodesSingleLxcSingleFirewallAliasesRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleFirewallAliasesResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/aliases`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleLxcSingleFirewallAliasesRequest,
    },
  );
};

export const getCreateNodesSingleLxcSingleFirewallAliasesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallAliases>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleFirewallAliasesRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallAliases>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleFirewallAliasesRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallAliases>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleFirewallAliasesRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleFirewallAliases(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleFirewallAliasesMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallAliases>>
  >;
export type CreateNodesSingleLxcSingleFirewallAliasesMutationBody =
  CreateNodesSingleLxcSingleFirewallAliasesRequest;
export type CreateNodesSingleLxcSingleFirewallAliasesMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleFirewallAliases
 */
export const useCreateNodesSingleLxcSingleFirewallAliases = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallAliases>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleFirewallAliasesRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleFirewallAliasesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove IP or Network alias.
 * @summary deleteNodesSingleLxcSingleFirewallAliasesSingle
 */
export const deleteNodesSingleLxcSingleFirewallAliasesSingle = (
  node: string,
  vmid: number,
  name: string,
) => {
  return apiInstance<DeleteNodesSingleLxcSingleFirewallAliasesSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/aliases/${name}`,
      method: "delete",
    },
  );
};

export const getDeleteNodesSingleLxcSingleFirewallAliasesSingleMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteNodesSingleLxcSingleFirewallAliasesSingle>
      >,
      TError,
      { node: string; vmid: number; name: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallAliasesSingle>>,
    TError,
    { node: string; vmid: number; name: string },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof deleteNodesSingleLxcSingleFirewallAliasesSingle>
      >,
      { node: string; vmid: number; name: string }
    > = (props) => {
      const { node, vmid, name } = props ?? {};

      return deleteNodesSingleLxcSingleFirewallAliasesSingle(node, vmid, name);
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteNodesSingleLxcSingleFirewallAliasesSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallAliasesSingle>>
  >;

export type DeleteNodesSingleLxcSingleFirewallAliasesSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleLxcSingleFirewallAliasesSingle
 */
export const useDeleteNodesSingleLxcSingleFirewallAliasesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallAliasesSingle>>,
    TError,
    { node: string; vmid: number; name: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleLxcSingleFirewallAliasesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read alias.
 * @summary getNodesSingleLxcSingleFirewallAliasesSingle
 */
export const getNodesSingleLxcSingleFirewallAliasesSingle = (
  node: string,
  vmid: number,
  name: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallAliasesSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/aliases/${name}`,
      method: "get",
      signal,
    },
  );
};

export const getGetNodesSingleLxcSingleFirewallAliasesSingleQueryKey = (
  node: string,
  vmid: number,
  name: string,
) => [`/nodes/${node}/lxc/${vmid}/firewall/aliases/${name}`] as const;

export const getGetNodesSingleLxcSingleFirewallAliasesSingleQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleFirewallAliasesSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliasesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliasesSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallAliasesSingleQueryKey(node, vmid, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliasesSingle>>
  > = ({ signal }) =>
    getNodesSingleLxcSingleFirewallAliasesSingle(node, vmid, name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && name),
    ...queryOptions,
  };
};

export type GetNodesSingleLxcSingleFirewallAliasesSingleQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliasesSingle>>
  >;
export type GetNodesSingleLxcSingleFirewallAliasesSingleQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallAliasesSingle
 */
export const useGetNodesSingleLxcSingleFirewallAliasesSingle = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleFirewallAliasesSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallAliasesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetNodesSingleLxcSingleFirewallAliasesSingleQueryOptions(
      node,
      vmid,
      name,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update IP or Network alias.
 * @summary updateNodesSingleLxcSingleFirewallAliasesSingle
 */
export const updateNodesSingleLxcSingleFirewallAliasesSingle = (
  node: string,
  vmid: number,
  name: string,
  updateNodesSingleLxcSingleFirewallAliasesSingleRequest: UpdateNodesSingleLxcSingleFirewallAliasesSingleRequest,
) => {
  return apiInstance<UpdateNodesSingleLxcSingleFirewallAliasesSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/aliases/${name}`,
      method: "put",
      headers: { "Content-Type": "application/json" },
      data: updateNodesSingleLxcSingleFirewallAliasesSingleRequest,
    },
  );
};

export const getUpdateNodesSingleLxcSingleFirewallAliasesSingleMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateNodesSingleLxcSingleFirewallAliasesSingle>
      >,
      TError,
      {
        node: string;
        vmid: number;
        name: string;
        data: UpdateNodesSingleLxcSingleFirewallAliasesSingleRequest;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallAliasesSingle>>,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      data: UpdateNodesSingleLxcSingleFirewallAliasesSingleRequest;
    },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateNodesSingleLxcSingleFirewallAliasesSingle>
      >,
      {
        node: string;
        vmid: number;
        name: string;
        data: UpdateNodesSingleLxcSingleFirewallAliasesSingleRequest;
      }
    > = (props) => {
      const { node, vmid, name, data } = props ?? {};

      return updateNodesSingleLxcSingleFirewallAliasesSingle(
        node,
        vmid,
        name,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateNodesSingleLxcSingleFirewallAliasesSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallAliasesSingle>>
  >;
export type UpdateNodesSingleLxcSingleFirewallAliasesSingleMutationBody =
  UpdateNodesSingleLxcSingleFirewallAliasesSingleRequest;
export type UpdateNodesSingleLxcSingleFirewallAliasesSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary updateNodesSingleLxcSingleFirewallAliasesSingle
 */
export const useUpdateNodesSingleLxcSingleFirewallAliasesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallAliasesSingle>>,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      data: UpdateNodesSingleLxcSingleFirewallAliasesSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleLxcSingleFirewallAliasesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List IPSets
 * @summary getNodesSingleLxcSingleFirewallIpset
 */
export const getNodesSingleLxcSingleFirewallIpset = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallIpsetResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/firewall/ipset`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleFirewallIpsetQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/firewall/ipset`] as const;

export const getGetNodesSingleLxcSingleFirewallIpsetQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpset>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpset>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpset>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallIpsetQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpset>>
  > = ({ signal }) => getNodesSingleLxcSingleFirewallIpset(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleFirewallIpsetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpset>>
>;
export type GetNodesSingleLxcSingleFirewallIpsetQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallIpset
 */
export const useGetNodesSingleLxcSingleFirewallIpset = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpset>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpset>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleFirewallIpsetQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new IPSet
 * @summary createNodesSingleLxcSingleFirewallIpset
 */
export const createNodesSingleLxcSingleFirewallIpset = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleFirewallIpsetRequest: CreateNodesSingleLxcSingleFirewallIpsetRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleFirewallIpsetResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/firewall/ipset`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleFirewallIpsetRequest,
  });
};

export const getCreateNodesSingleLxcSingleFirewallIpsetMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpset>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleFirewallIpsetRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpset>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleFirewallIpsetRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpset>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleFirewallIpsetRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleFirewallIpset(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleFirewallIpsetMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpset>>
>;
export type CreateNodesSingleLxcSingleFirewallIpsetMutationBody =
  CreateNodesSingleLxcSingleFirewallIpsetRequest;
export type CreateNodesSingleLxcSingleFirewallIpsetMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleFirewallIpset
 */
export const useCreateNodesSingleLxcSingleFirewallIpset = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpset>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleFirewallIpsetRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleFirewallIpsetMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete IPSet
 * @summary deleteNodesSingleLxcSingleFirewallIpsetSingle
 */
export const deleteNodesSingleLxcSingleFirewallIpsetSingle = (
  node: string,
  vmid: number,
  name: string,
) => {
  return apiInstance<DeleteNodesSingleLxcSingleFirewallIpsetSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/ipset/${name}`,
      method: "delete",
    },
  );
};

export const getDeleteNodesSingleLxcSingleFirewallIpsetSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingle>>,
    TError,
    { node: string; vmid: number; name: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingle>>,
  TError,
  { node: string; vmid: number; name: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingle>>,
    { node: string; vmid: number; name: string }
  > = (props) => {
    const { node, vmid, name } = props ?? {};

    return deleteNodesSingleLxcSingleFirewallIpsetSingle(node, vmid, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleLxcSingleFirewallIpsetSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingle>>
  >;

export type DeleteNodesSingleLxcSingleFirewallIpsetSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleLxcSingleFirewallIpsetSingle
 */
export const useDeleteNodesSingleLxcSingleFirewallIpsetSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingle>>,
    TError,
    { node: string; vmid: number; name: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleLxcSingleFirewallIpsetSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List IPSet content
 * @summary getNodesSingleLxcSingleFirewallIpsetSingle
 */
export const getNodesSingleLxcSingleFirewallIpsetSingle = (
  node: string,
  vmid: number,
  name: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallIpsetSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/ipset/${name}`,
      method: "get",
      signal,
    },
  );
};

export const getGetNodesSingleLxcSingleFirewallIpsetSingleQueryKey = (
  node: string,
  vmid: number,
  name: string,
) => [`/nodes/${node}/lxc/${vmid}/firewall/ipset/${name}`] as const;

export const getGetNodesSingleLxcSingleFirewallIpsetSingleQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallIpsetSingleQueryKey(node, vmid, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingle>>
  > = ({ signal }) =>
    getNodesSingleLxcSingleFirewallIpsetSingle(node, vmid, name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && name),
    ...queryOptions,
  };
};

export type GetNodesSingleLxcSingleFirewallIpsetSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingle>>
>;
export type GetNodesSingleLxcSingleFirewallIpsetSingleQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallIpsetSingle
 */
export const useGetNodesSingleLxcSingleFirewallIpsetSingle = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetNodesSingleLxcSingleFirewallIpsetSingleQueryOptions(
      node,
      vmid,
      name,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Add IP or Network to IPSet.
 * @summary createNodesSingleLxcSingleFirewallIpsetSingle
 */
export const createNodesSingleLxcSingleFirewallIpsetSingle = (
  node: string,
  vmid: number,
  name: string,
  createNodesSingleLxcSingleFirewallIpsetSingleRequest: CreateNodesSingleLxcSingleFirewallIpsetSingleRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleFirewallIpsetSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/ipset/${name}`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleLxcSingleFirewallIpsetSingleRequest,
    },
  );
};

export const getCreateNodesSingleLxcSingleFirewallIpsetSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpsetSingle>>,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      data: CreateNodesSingleLxcSingleFirewallIpsetSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpsetSingle>>,
  TError,
  {
    node: string;
    vmid: number;
    name: string;
    data: CreateNodesSingleLxcSingleFirewallIpsetSingleRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpsetSingle>>,
    {
      node: string;
      vmid: number;
      name: string;
      data: CreateNodesSingleLxcSingleFirewallIpsetSingleRequest;
    }
  > = (props) => {
    const { node, vmid, name, data } = props ?? {};

    return createNodesSingleLxcSingleFirewallIpsetSingle(
      node,
      vmid,
      name,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleFirewallIpsetSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpsetSingle>>
  >;
export type CreateNodesSingleLxcSingleFirewallIpsetSingleMutationBody =
  CreateNodesSingleLxcSingleFirewallIpsetSingleRequest;
export type CreateNodesSingleLxcSingleFirewallIpsetSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleFirewallIpsetSingle
 */
export const useCreateNodesSingleLxcSingleFirewallIpsetSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleFirewallIpsetSingle>>,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      data: CreateNodesSingleLxcSingleFirewallIpsetSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleFirewallIpsetSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove IP or Network from IPSet.
 * @summary deleteNodesSingleLxcSingleFirewallIpsetSingleSingle
 */
export const deleteNodesSingleLxcSingleFirewallIpsetSingleSingle = (
  node: string,
  vmid: number,
  name: string,
  cidr: string,
) => {
  return apiInstance<DeleteNodesSingleLxcSingleFirewallIpsetSingleSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/ipset/${name}/${cidr}`,
      method: "delete",
    },
  );
};

export const getDeleteNodesSingleLxcSingleFirewallIpsetSingleSingleMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingleSingle>
      >,
      TError,
      { node: string; vmid: number; name: string; cidr: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingleSingle>
    >,
    TError,
    { node: string; vmid: number; name: string; cidr: string },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingleSingle>
      >,
      { node: string; vmid: number; name: string; cidr: string }
    > = (props) => {
      const { node, vmid, name, cidr } = props ?? {};

      return deleteNodesSingleLxcSingleFirewallIpsetSingleSingle(
        node,
        vmid,
        name,
        cidr,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteNodesSingleLxcSingleFirewallIpsetSingleSingleMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingleSingle>
    >
  >;

export type DeleteNodesSingleLxcSingleFirewallIpsetSingleSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleLxcSingleFirewallIpsetSingleSingle
 */
export const useDeleteNodesSingleLxcSingleFirewallIpsetSingleSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteNodesSingleLxcSingleFirewallIpsetSingleSingle>
    >,
    TError,
    { node: string; vmid: number; name: string; cidr: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleLxcSingleFirewallIpsetSingleSingleMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};

/**
 * Read IP or Network settings from IPSet.
 * @summary getNodesSingleLxcSingleFirewallIpsetSingleSingle
 */
export const getNodesSingleLxcSingleFirewallIpsetSingleSingle = (
  node: string,
  vmid: number,
  name: string,
  cidr: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallIpsetSingleSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/ipset/${name}/${cidr}`,
      method: "get",
      signal,
    },
  );
};

export const getGetNodesSingleLxcSingleFirewallIpsetSingleSingleQueryKey = (
  node: string,
  vmid: number,
  name: string,
  cidr: string,
) => [`/nodes/${node}/lxc/${vmid}/firewall/ipset/${name}/${cidr}`] as const;

export const getGetNodesSingleLxcSingleFirewallIpsetSingleSingleQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingleSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  cidr: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingleSingle>
      >,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingleSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallIpsetSingleSingleQueryKey(
      node,
      vmid,
      name,
      cidr,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingleSingle>>
  > = ({ signal }) =>
    getNodesSingleLxcSingleFirewallIpsetSingleSingle(
      node,
      vmid,
      name,
      cidr,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(node && vmid && name && cidr),
    ...queryOptions,
  };
};

export type GetNodesSingleLxcSingleFirewallIpsetSingleSingleQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingleSingle>>
  >;
export type GetNodesSingleLxcSingleFirewallIpsetSingleSingleQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallIpsetSingleSingle
 */
export const useGetNodesSingleLxcSingleFirewallIpsetSingleSingle = <
  TData = Awaited<
    ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingleSingle>
  >,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  name: string,
  cidr: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof getNodesSingleLxcSingleFirewallIpsetSingleSingle>
      >,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetNodesSingleLxcSingleFirewallIpsetSingleSingleQueryOptions(
      node,
      vmid,
      name,
      cidr,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update IP or Network settings
 * @summary updateNodesSingleLxcSingleFirewallIpsetSingleSingle
 */
export const updateNodesSingleLxcSingleFirewallIpsetSingleSingle = (
  node: string,
  vmid: number,
  name: string,
  cidr: string,
  updateNodesSingleLxcSingleFirewallIpsetSingleSingleRequest: UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleRequest,
) => {
  return apiInstance<UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/ipset/${name}/${cidr}`,
      method: "put",
      headers: { "Content-Type": "application/json" },
      data: updateNodesSingleLxcSingleFirewallIpsetSingleSingleRequest,
    },
  );
};

export const getUpdateNodesSingleLxcSingleFirewallIpsetSingleSingleMutationOptions =
  <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateNodesSingleLxcSingleFirewallIpsetSingleSingle>
      >,
      TError,
      {
        node: string;
        vmid: number;
        name: string;
        cidr: string;
        data: UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleRequest;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof updateNodesSingleLxcSingleFirewallIpsetSingleSingle>
    >,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      cidr: string;
      data: UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleRequest;
    },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateNodesSingleLxcSingleFirewallIpsetSingleSingle>
      >,
      {
        node: string;
        vmid: number;
        name: string;
        cidr: string;
        data: UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleRequest;
      }
    > = (props) => {
      const { node, vmid, name, cidr, data } = props ?? {};

      return updateNodesSingleLxcSingleFirewallIpsetSingleSingle(
        node,
        vmid,
        name,
        cidr,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof updateNodesSingleLxcSingleFirewallIpsetSingleSingle>
    >
  >;
export type UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleMutationBody =
  UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleRequest;
export type UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary updateNodesSingleLxcSingleFirewallIpsetSingleSingle
 */
export const useUpdateNodesSingleLxcSingleFirewallIpsetSingleSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof updateNodesSingleLxcSingleFirewallIpsetSingleSingle>
    >,
    TError,
    {
      node: string;
      vmid: number;
      name: string;
      cidr: string;
      data: UpdateNodesSingleLxcSingleFirewallIpsetSingleSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleLxcSingleFirewallIpsetSingleSingleMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};

/**
 * Get VM firewall options.
 * @summary getNodesSingleLxcSingleFirewallOptions
 */
export const getNodesSingleLxcSingleFirewallOptions = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallOptionsResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/firewall/options`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleFirewallOptionsQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/firewall/options`] as const;

export const getGetNodesSingleLxcSingleFirewallOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallOptions>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallOptions>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallOptions>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallOptionsQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallOptions>>
  > = ({ signal }) =>
    getNodesSingleLxcSingleFirewallOptions(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleFirewallOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallOptions>>
>;
export type GetNodesSingleLxcSingleFirewallOptionsQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallOptions
 */
export const useGetNodesSingleLxcSingleFirewallOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallOptions>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallOptions>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleFirewallOptionsQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set Firewall options.
 * @summary updateNodesSingleLxcSingleFirewallOptions
 */
export const updateNodesSingleLxcSingleFirewallOptions = (
  node: string,
  vmid: number,
  updateNodesSingleLxcSingleFirewallOptionsRequest: UpdateNodesSingleLxcSingleFirewallOptionsRequest,
) => {
  return apiInstance<UpdateNodesSingleLxcSingleFirewallOptionsResponseResponse>(
    {
      url: `/nodes/${node}/lxc/${vmid}/firewall/options`,
      method: "put",
      headers: { "Content-Type": "application/json" },
      data: updateNodesSingleLxcSingleFirewallOptionsRequest,
    },
  );
};

export const getUpdateNodesSingleLxcSingleFirewallOptionsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallOptions>>,
    TError,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleLxcSingleFirewallOptionsRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallOptions>>,
  TError,
  {
    node: string;
    vmid: number;
    data: UpdateNodesSingleLxcSingleFirewallOptionsRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallOptions>>,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleLxcSingleFirewallOptionsRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return updateNodesSingleLxcSingleFirewallOptions(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleLxcSingleFirewallOptionsMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallOptions>>
  >;
export type UpdateNodesSingleLxcSingleFirewallOptionsMutationBody =
  UpdateNodesSingleLxcSingleFirewallOptionsRequest;
export type UpdateNodesSingleLxcSingleFirewallOptionsMutationError =
  ErrorType<unknown>;

/**
 * @summary updateNodesSingleLxcSingleFirewallOptions
 */
export const useUpdateNodesSingleLxcSingleFirewallOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleFirewallOptions>>,
    TError,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleLxcSingleFirewallOptionsRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleLxcSingleFirewallOptionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read firewall log
 * @summary getNodesSingleLxcSingleFirewallLog
 */
export const getNodesSingleLxcSingleFirewallLog = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallLogResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/firewall/log`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleFirewallLogQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/firewall/log`] as const;

export const getGetNodesSingleLxcSingleFirewallLogQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallLog>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallLog>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallLogQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallLog>>
  > = ({ signal }) => getNodesSingleLxcSingleFirewallLog(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleFirewallLogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallLog>>
>;
export type GetNodesSingleLxcSingleFirewallLogQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallLog
 */
export const useGetNodesSingleLxcSingleFirewallLog = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallLog>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleFirewallLogQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Lists possible IPSet/Alias reference which are allowed in source/dest properties.
 * @summary getNodesSingleLxcSingleFirewallRefs
 */
export const getNodesSingleLxcSingleFirewallRefs = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFirewallRefsResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/firewall/refs`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleFirewallRefsQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/firewall/refs`] as const;

export const getGetNodesSingleLxcSingleFirewallRefsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRefs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRefs>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRefs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFirewallRefsQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRefs>>
  > = ({ signal }) => getNodesSingleLxcSingleFirewallRefs(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleFirewallRefsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRefs>>
>;
export type GetNodesSingleLxcSingleFirewallRefsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFirewallRefs
 */
export const useGetNodesSingleLxcSingleFirewallRefs = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRefs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFirewallRefs>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleFirewallRefsQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read VM RRD statistics (returns PNG)
 * @summary getNodesSingleLxcSingleRrd
 */
export const getNodesSingleLxcSingleRrd = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleRrdResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/rrd`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleRrdQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/rrd`] as const;

export const getGetNodesSingleLxcSingleRrdQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleRrd>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleRrd>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleRrd>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleLxcSingleRrdQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleRrd>>
  > = ({ signal }) => getNodesSingleLxcSingleRrd(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleRrdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleRrd>>
>;
export type GetNodesSingleLxcSingleRrdQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleRrd
 */
export const useGetNodesSingleLxcSingleRrd = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleRrd>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleRrd>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleRrdQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read VM RRD statistics
 * @summary getNodesSingleLxcSingleRrddata
 */
export const getNodesSingleLxcSingleRrddata = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleRrddataResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/rrddata`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleRrddataQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/rrddata`] as const;

export const getGetNodesSingleLxcSingleRrddataQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleRrddata>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleRrddata>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleRrddata>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleRrddataQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleRrddata>>
  > = ({ signal }) => getNodesSingleLxcSingleRrddata(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleRrddataQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleRrddata>>
>;
export type GetNodesSingleLxcSingleRrddataQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleRrddata
 */
export const useGetNodesSingleLxcSingleRrddata = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleRrddata>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleRrddata>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleRrddataQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Creates a TCP VNC proxy connections.
 * @summary createNodesSingleLxcSingleVncproxy
 */
export const createNodesSingleLxcSingleVncproxy = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleVncproxyRequest: CreateNodesSingleLxcSingleVncproxyRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleVncproxyResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/vncproxy`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleVncproxyRequest,
  });
};

export const getCreateNodesSingleLxcSingleVncproxyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleVncproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleVncproxyRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleVncproxy>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleVncproxyRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleVncproxy>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleVncproxyRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleVncproxy(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleVncproxyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleVncproxy>>
>;
export type CreateNodesSingleLxcSingleVncproxyMutationBody =
  CreateNodesSingleLxcSingleVncproxyRequest;
export type CreateNodesSingleLxcSingleVncproxyMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleVncproxy
 */
export const useCreateNodesSingleLxcSingleVncproxy = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleVncproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleVncproxyRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleVncproxyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Creates a TCP proxy connection.
 * @summary createNodesSingleLxcSingleTermproxy
 */
export const createNodesSingleLxcSingleTermproxy = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleTermproxyRequest: CreateNodesSingleLxcSingleTermproxyRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleTermproxyResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/termproxy`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleTermproxyRequest,
  });
};

export const getCreateNodesSingleLxcSingleTermproxyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleTermproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleTermproxyRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleTermproxy>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleTermproxyRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleTermproxy>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleTermproxyRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleTermproxy(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleTermproxyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleTermproxy>>
>;
export type CreateNodesSingleLxcSingleTermproxyMutationBody =
  CreateNodesSingleLxcSingleTermproxyRequest;
export type CreateNodesSingleLxcSingleTermproxyMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleTermproxy
 */
export const useCreateNodesSingleLxcSingleTermproxy = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleTermproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleTermproxyRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleTermproxyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Opens a weksocket for VNC traffic.
 * @summary getNodesSingleLxcSingleVncwebsocket
 */
export const getNodesSingleLxcSingleVncwebsocket = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleVncwebsocketResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/vncwebsocket`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleVncwebsocketQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/vncwebsocket`] as const;

export const getGetNodesSingleLxcSingleVncwebsocketQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleVncwebsocket>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleVncwebsocket>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleVncwebsocket>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleVncwebsocketQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleVncwebsocket>>
  > = ({ signal }) => getNodesSingleLxcSingleVncwebsocket(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleVncwebsocketQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleVncwebsocket>>
>;
export type GetNodesSingleLxcSingleVncwebsocketQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleVncwebsocket
 */
export const useGetNodesSingleLxcSingleVncwebsocket = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleVncwebsocket>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleVncwebsocket>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleVncwebsocketQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a SPICE configuration to connect to the CT.
 * @summary createNodesSingleLxcSingleSpiceproxy
 */
export const createNodesSingleLxcSingleSpiceproxy = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleSpiceproxyRequest: CreateNodesSingleLxcSingleSpiceproxyRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleSpiceproxyResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/spiceproxy`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleSpiceproxyRequest,
  });
};

export const getCreateNodesSingleLxcSingleSpiceproxyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleSpiceproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleSpiceproxyRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleSpiceproxy>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleSpiceproxyRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleSpiceproxy>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleSpiceproxyRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleSpiceproxy(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleSpiceproxyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleSpiceproxy>>
>;
export type CreateNodesSingleLxcSingleSpiceproxyMutationBody =
  CreateNodesSingleLxcSingleSpiceproxyRequest;
export type CreateNodesSingleLxcSingleSpiceproxyMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleSpiceproxy
 */
export const useCreateNodesSingleLxcSingleSpiceproxy = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleSpiceproxy>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleSpiceproxyRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleSpiceproxyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Migrate the container to another node. Creates a new migration task.
 * @summary createNodesSingleLxcSingleMigrate
 */
export const createNodesSingleLxcSingleMigrate = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleMigrateRequest: CreateNodesSingleLxcSingleMigrateRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleMigrateResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleMigrateRequest,
  });
};

export const getCreateNodesSingleLxcSingleMigrateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleMigrate>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleMigrateRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleMigrate>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleMigrateRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleMigrate>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleMigrateRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleMigrate(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleMigrateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleMigrate>>
>;
export type CreateNodesSingleLxcSingleMigrateMutationBody =
  CreateNodesSingleLxcSingleMigrateRequest;
export type CreateNodesSingleLxcSingleMigrateMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleMigrate
 */
export const useCreateNodesSingleLxcSingleMigrate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleMigrate>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleMigrateRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleMigrateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Check if feature for virtual machine is available.
 * @summary getNodesSingleLxcSingleFeature
 */
export const getNodesSingleLxcSingleFeature = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSingleFeatureResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/feature`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSingleFeatureQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/feature`] as const;

export const getGetNodesSingleLxcSingleFeatureQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFeature>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFeature>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFeature>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSingleFeatureQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSingleFeature>>
  > = ({ signal }) => getNodesSingleLxcSingleFeature(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSingleFeatureQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSingleFeature>>
>;
export type GetNodesSingleLxcSingleFeatureQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSingleFeature
 */
export const useGetNodesSingleLxcSingleFeature = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSingleFeature>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSingleFeature>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSingleFeatureQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a Template.
 * @summary createNodesSingleLxcSingleTemplate
 */
export const createNodesSingleLxcSingleTemplate = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleTemplateRequest: CreateNodesSingleLxcSingleTemplateRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleTemplateResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/template`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleTemplateRequest,
  });
};

export const getCreateNodesSingleLxcSingleTemplateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleTemplate>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleTemplateRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleTemplate>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleTemplateRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleTemplate>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleTemplateRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleTemplate(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleTemplate>>
>;
export type CreateNodesSingleLxcSingleTemplateMutationBody =
  CreateNodesSingleLxcSingleTemplateRequest;
export type CreateNodesSingleLxcSingleTemplateMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleTemplate
 */
export const useCreateNodesSingleLxcSingleTemplate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleTemplate>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleTemplateRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create a container clone/copy
 * @summary createNodesSingleLxcSingleClone
 */
export const createNodesSingleLxcSingleClone = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleCloneRequest: CreateNodesSingleLxcSingleCloneRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleCloneResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/clone`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleCloneRequest,
  });
};

export const getCreateNodesSingleLxcSingleCloneMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleClone>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleCloneRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleClone>>,
  TError,
  { node: string; vmid: number; data: CreateNodesSingleLxcSingleCloneRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleClone>>,
    { node: string; vmid: number; data: CreateNodesSingleLxcSingleCloneRequest }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleClone(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleCloneMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleClone>>
>;
export type CreateNodesSingleLxcSingleCloneMutationBody =
  CreateNodesSingleLxcSingleCloneRequest;
export type CreateNodesSingleLxcSingleCloneMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleClone
 */
export const useCreateNodesSingleLxcSingleClone = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleClone>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleCloneRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleCloneMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Resize a container mount point.
 * @summary updateNodesSingleLxcSingleResize
 */
export const updateNodesSingleLxcSingleResize = (
  node: string,
  vmid: number,
  updateNodesSingleLxcSingleResizeRequest: UpdateNodesSingleLxcSingleResizeRequest,
) => {
  return apiInstance<UpdateNodesSingleLxcSingleResizeResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/resize`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleLxcSingleResizeRequest,
  });
};

export const getUpdateNodesSingleLxcSingleResizeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleResize>>,
    TError,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleLxcSingleResizeRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleLxcSingleResize>>,
  TError,
  { node: string; vmid: number; data: UpdateNodesSingleLxcSingleResizeRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleResize>>,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleLxcSingleResizeRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return updateNodesSingleLxcSingleResize(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleLxcSingleResizeMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleLxcSingleResize>>
>;
export type UpdateNodesSingleLxcSingleResizeMutationBody =
  UpdateNodesSingleLxcSingleResizeRequest;
export type UpdateNodesSingleLxcSingleResizeMutationError = ErrorType<unknown>;

/**
 * @summary updateNodesSingleLxcSingleResize
 */
export const useUpdateNodesSingleLxcSingleResize = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleLxcSingleResize>>,
    TError,
    {
      node: string;
      vmid: number;
      data: UpdateNodesSingleLxcSingleResizeRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleLxcSingleResizeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Move a rootfs-/mp-volume to a different storage
 * @summary createNodesSingleLxcSingleMovevolume
 */
export const createNodesSingleLxcSingleMovevolume = (
  node: string,
  vmid: number,
  createNodesSingleLxcSingleMovevolumeRequest: CreateNodesSingleLxcSingleMovevolumeRequest,
) => {
  return apiInstance<CreateNodesSingleLxcSingleMovevolumeResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/move_volume`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleLxcSingleMovevolumeRequest,
  });
};

export const getCreateNodesSingleLxcSingleMovevolumeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleMovevolume>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleMovevolumeRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleMovevolume>>,
  TError,
  {
    node: string;
    vmid: number;
    data: CreateNodesSingleLxcSingleMovevolumeRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleMovevolume>>,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleMovevolumeRequest;
    }
  > = (props) => {
    const { node, vmid, data } = props ?? {};

    return createNodesSingleLxcSingleMovevolume(node, vmid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleLxcSingleMovevolumeMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleLxcSingleMovevolume>>
>;
export type CreateNodesSingleLxcSingleMovevolumeMutationBody =
  CreateNodesSingleLxcSingleMovevolumeRequest;
export type CreateNodesSingleLxcSingleMovevolumeMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleLxcSingleMovevolume
 */
export const useCreateNodesSingleLxcSingleMovevolume = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleLxcSingleMovevolume>>,
    TError,
    {
      node: string;
      vmid: number;
      data: CreateNodesSingleLxcSingleMovevolumeRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleLxcSingleMovevolumeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get container configuration, including pending changes.
 * @summary getNodesSingleLxcSinglePending
 */
export const getNodesSingleLxcSinglePending = (
  node: string,
  vmid: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleLxcSinglePendingResponseResponse>({
    url: `/nodes/${node}/lxc/${vmid}/pending`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleLxcSinglePendingQueryKey = (
  node: string,
  vmid: number,
) => [`/nodes/${node}/lxc/${vmid}/pending`] as const;

export const getGetNodesSingleLxcSinglePendingQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSinglePending>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSinglePending>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleLxcSinglePending>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleLxcSinglePendingQueryKey(node, vmid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleLxcSinglePending>>
  > = ({ signal }) => getNodesSingleLxcSinglePending(node, vmid, signal);

  return { queryKey, queryFn, enabled: !!(node && vmid), ...queryOptions };
};

export type GetNodesSingleLxcSinglePendingQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleLxcSinglePending>>
>;
export type GetNodesSingleLxcSinglePendingQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleLxcSinglePending
 */
export const useGetNodesSingleLxcSinglePending = <
  TData = Awaited<ReturnType<typeof getNodesSingleLxcSinglePending>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  vmid: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleLxcSinglePending>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleLxcSinglePendingQueryOptions(
    node,
    vmid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Directory index.
 * @summary getNodesSingleCeph
 */
export const getNodesSingleCeph = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephResponseResponse>({
    url: `/nodes/${node}/ceph`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephQueryKey = (node: string) =>
  [`/nodes/${node}/ceph`] as const;

export const getGetNodesSingleCephQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCeph>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCeph>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCeph>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCeph>>
  > = ({ signal }) => getNodesSingleCeph(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCeph>>
>;
export type GetNodesSingleCephQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCeph
 */
export const useGetNodesSingleCeph = <
  TData = Awaited<ReturnType<typeof getNodesSingleCeph>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCeph>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get Ceph osd list/tree.
 * @summary getNodesSingleCephOsd
 */
export const getNodesSingleCephOsd = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephOsdResponseResponse>({
    url: `/nodes/${node}/ceph/osd`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephOsdQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/osd`] as const;

export const getGetNodesSingleCephOsdQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephOsd>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephOsd>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephOsd>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephOsdQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephOsd>>
  > = ({ signal }) => getNodesSingleCephOsd(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephOsdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephOsd>>
>;
export type GetNodesSingleCephOsdQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephOsd
 */
export const useGetNodesSingleCephOsd = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephOsd>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephOsd>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephOsdQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create OSD
 * @summary createNodesSingleCephOsd
 */
export const createNodesSingleCephOsd = (
  node: string,
  createNodesSingleCephOsdRequest: CreateNodesSingleCephOsdRequest,
) => {
  return apiInstance<CreateNodesSingleCephOsdResponseResponse>({
    url: `/nodes/${node}/ceph/osd`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephOsdRequest,
  });
};

export const getCreateNodesSingleCephOsdMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephOsd>>,
    TError,
    { node: string; data: CreateNodesSingleCephOsdRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephOsd>>,
  TError,
  { node: string; data: CreateNodesSingleCephOsdRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephOsd>>,
    { node: string; data: CreateNodesSingleCephOsdRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleCephOsd(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephOsdMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephOsd>>
>;
export type CreateNodesSingleCephOsdMutationBody =
  CreateNodesSingleCephOsdRequest;
export type CreateNodesSingleCephOsdMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephOsd
 */
export const useCreateNodesSingleCephOsd = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephOsd>>,
    TError,
    { node: string; data: CreateNodesSingleCephOsdRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleCephOsdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Destroy OSD
 * @summary deleteNodesSingleCephOsdSingle
 */
export const deleteNodesSingleCephOsdSingle = (node: string, osdid: number) => {
  return apiInstance<DeleteNodesSingleCephOsdSingleResponseResponse>({
    url: `/nodes/${node}/ceph/osd/${osdid}`,
    method: "delete",
  });
};

export const getDeleteNodesSingleCephOsdSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephOsdSingle>>,
    TError,
    { node: string; osdid: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleCephOsdSingle>>,
  TError,
  { node: string; osdid: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleCephOsdSingle>>,
    { node: string; osdid: number }
  > = (props) => {
    const { node, osdid } = props ?? {};

    return deleteNodesSingleCephOsdSingle(node, osdid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleCephOsdSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleCephOsdSingle>>
>;

export type DeleteNodesSingleCephOsdSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleCephOsdSingle
 */
export const useDeleteNodesSingleCephOsdSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephOsdSingle>>,
    TError,
    { node: string; osdid: number },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleCephOsdSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ceph osd in
 * @summary createNodesSingleCephOsdSingleIn
 */
export const createNodesSingleCephOsdSingleIn = (
  node: string,
  osdid: number,
  createNodesSingleCephOsdSingleInRequest: CreateNodesSingleCephOsdSingleInRequest,
) => {
  return apiInstance<CreateNodesSingleCephOsdSingleInResponseResponse>({
    url: `/nodes/${node}/ceph/osd/${osdid}/in`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephOsdSingleInRequest,
  });
};

export const getCreateNodesSingleCephOsdSingleInMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephOsdSingleIn>>,
    TError,
    {
      node: string;
      osdid: number;
      data: CreateNodesSingleCephOsdSingleInRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephOsdSingleIn>>,
  TError,
  {
    node: string;
    osdid: number;
    data: CreateNodesSingleCephOsdSingleInRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephOsdSingleIn>>,
    {
      node: string;
      osdid: number;
      data: CreateNodesSingleCephOsdSingleInRequest;
    }
  > = (props) => {
    const { node, osdid, data } = props ?? {};

    return createNodesSingleCephOsdSingleIn(node, osdid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephOsdSingleInMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephOsdSingleIn>>
>;
export type CreateNodesSingleCephOsdSingleInMutationBody =
  CreateNodesSingleCephOsdSingleInRequest;
export type CreateNodesSingleCephOsdSingleInMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephOsdSingleIn
 */
export const useCreateNodesSingleCephOsdSingleIn = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephOsdSingleIn>>,
    TError,
    {
      node: string;
      osdid: number;
      data: CreateNodesSingleCephOsdSingleInRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCephOsdSingleInMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ceph osd out
 * @summary createNodesSingleCephOsdSingleOut
 */
export const createNodesSingleCephOsdSingleOut = (
  node: string,
  osdid: number,
  createNodesSingleCephOsdSingleOutRequest: CreateNodesSingleCephOsdSingleOutRequest,
) => {
  return apiInstance<CreateNodesSingleCephOsdSingleOutResponseResponse>({
    url: `/nodes/${node}/ceph/osd/${osdid}/out`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephOsdSingleOutRequest,
  });
};

export const getCreateNodesSingleCephOsdSingleOutMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephOsdSingleOut>>,
    TError,
    {
      node: string;
      osdid: number;
      data: CreateNodesSingleCephOsdSingleOutRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephOsdSingleOut>>,
  TError,
  {
    node: string;
    osdid: number;
    data: CreateNodesSingleCephOsdSingleOutRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephOsdSingleOut>>,
    {
      node: string;
      osdid: number;
      data: CreateNodesSingleCephOsdSingleOutRequest;
    }
  > = (props) => {
    const { node, osdid, data } = props ?? {};

    return createNodesSingleCephOsdSingleOut(node, osdid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephOsdSingleOutMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephOsdSingleOut>>
>;
export type CreateNodesSingleCephOsdSingleOutMutationBody =
  CreateNodesSingleCephOsdSingleOutRequest;
export type CreateNodesSingleCephOsdSingleOutMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephOsdSingleOut
 */
export const useCreateNodesSingleCephOsdSingleOut = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephOsdSingleOut>>,
    TError,
    {
      node: string;
      osdid: number;
      data: CreateNodesSingleCephOsdSingleOutRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCephOsdSingleOutMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Instruct the OSD to scrub.
 * @summary createNodesSingleCephOsdSingleScrub
 */
export const createNodesSingleCephOsdSingleScrub = (
  node: string,
  osdid: number,
  createNodesSingleCephOsdSingleScrubRequest: CreateNodesSingleCephOsdSingleScrubRequest,
) => {
  return apiInstance<CreateNodesSingleCephOsdSingleScrubResponseResponse>({
    url: `/nodes/${node}/ceph/osd/${osdid}/scrub`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephOsdSingleScrubRequest,
  });
};

export const getCreateNodesSingleCephOsdSingleScrubMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephOsdSingleScrub>>,
    TError,
    {
      node: string;
      osdid: number;
      data: CreateNodesSingleCephOsdSingleScrubRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephOsdSingleScrub>>,
  TError,
  {
    node: string;
    osdid: number;
    data: CreateNodesSingleCephOsdSingleScrubRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephOsdSingleScrub>>,
    {
      node: string;
      osdid: number;
      data: CreateNodesSingleCephOsdSingleScrubRequest;
    }
  > = (props) => {
    const { node, osdid, data } = props ?? {};

    return createNodesSingleCephOsdSingleScrub(node, osdid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephOsdSingleScrubMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephOsdSingleScrub>>
>;
export type CreateNodesSingleCephOsdSingleScrubMutationBody =
  CreateNodesSingleCephOsdSingleScrubRequest;
export type CreateNodesSingleCephOsdSingleScrubMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleCephOsdSingleScrub
 */
export const useCreateNodesSingleCephOsdSingleScrub = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephOsdSingleScrub>>,
    TError,
    {
      node: string;
      osdid: number;
      data: CreateNodesSingleCephOsdSingleScrubRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCephOsdSingleScrubMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * MDS directory index.
 * @summary getNodesSingleCephMds
 */
export const getNodesSingleCephMds = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephMdsResponseResponse>({
    url: `/nodes/${node}/ceph/mds`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephMdsQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/mds`] as const;

export const getGetNodesSingleCephMdsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephMds>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephMds>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephMds>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephMdsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephMds>>
  > = ({ signal }) => getNodesSingleCephMds(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephMdsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephMds>>
>;
export type GetNodesSingleCephMdsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephMds
 */
export const useGetNodesSingleCephMds = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephMds>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephMds>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephMdsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Destroy Ceph Metadata Server
 * @summary deleteNodesSingleCephMdsSingle
 */
export const deleteNodesSingleCephMdsSingle = (node: string, name: string) => {
  return apiInstance<DeleteNodesSingleCephMdsSingleResponseResponse>({
    url: `/nodes/${node}/ceph/mds/${name}`,
    method: "delete",
  });
};

export const getDeleteNodesSingleCephMdsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephMdsSingle>>,
    TError,
    { node: string; name: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleCephMdsSingle>>,
  TError,
  { node: string; name: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleCephMdsSingle>>,
    { node: string; name: string }
  > = (props) => {
    const { node, name } = props ?? {};

    return deleteNodesSingleCephMdsSingle(node, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleCephMdsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleCephMdsSingle>>
>;

export type DeleteNodesSingleCephMdsSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleCephMdsSingle
 */
export const useDeleteNodesSingleCephMdsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephMdsSingle>>,
    TError,
    { node: string; name: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleCephMdsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create Ceph Metadata Server (MDS)
 * @summary createNodesSingleCephMdsSingle
 */
export const createNodesSingleCephMdsSingle = (
  node: string,
  name: string,
  createNodesSingleCephMdsSingleRequest: CreateNodesSingleCephMdsSingleRequest,
) => {
  return apiInstance<CreateNodesSingleCephMdsSingleResponseResponse>({
    url: `/nodes/${node}/ceph/mds/${name}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephMdsSingleRequest,
  });
};

export const getCreateNodesSingleCephMdsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephMdsSingle>>,
    TError,
    { node: string; name: string; data: CreateNodesSingleCephMdsSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephMdsSingle>>,
  TError,
  { node: string; name: string; data: CreateNodesSingleCephMdsSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephMdsSingle>>,
    { node: string; name: string; data: CreateNodesSingleCephMdsSingleRequest }
  > = (props) => {
    const { node, name, data } = props ?? {};

    return createNodesSingleCephMdsSingle(node, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephMdsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephMdsSingle>>
>;
export type CreateNodesSingleCephMdsSingleMutationBody =
  CreateNodesSingleCephMdsSingleRequest;
export type CreateNodesSingleCephMdsSingleMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephMdsSingle
 */
export const useCreateNodesSingleCephMdsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephMdsSingle>>,
    TError,
    { node: string; name: string; data: CreateNodesSingleCephMdsSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCephMdsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * MGR directory index.
 * @summary getNodesSingleCephMgr
 */
export const getNodesSingleCephMgr = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephMgrResponseResponse>({
    url: `/nodes/${node}/ceph/mgr`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephMgrQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/mgr`] as const;

export const getGetNodesSingleCephMgrQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephMgr>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephMgr>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephMgr>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephMgrQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephMgr>>
  > = ({ signal }) => getNodesSingleCephMgr(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephMgrQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephMgr>>
>;
export type GetNodesSingleCephMgrQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephMgr
 */
export const useGetNodesSingleCephMgr = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephMgr>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephMgr>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephMgrQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Destroy Ceph Manager.
 * @summary deleteNodesSingleCephMgrSingle
 */
export const deleteNodesSingleCephMgrSingle = (node: string, id: string) => {
  return apiInstance<DeleteNodesSingleCephMgrSingleResponseResponse>({
    url: `/nodes/${node}/ceph/mgr/${id}`,
    method: "delete",
  });
};

export const getDeleteNodesSingleCephMgrSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephMgrSingle>>,
    TError,
    { node: string; id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleCephMgrSingle>>,
  TError,
  { node: string; id: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleCephMgrSingle>>,
    { node: string; id: string }
  > = (props) => {
    const { node, id } = props ?? {};

    return deleteNodesSingleCephMgrSingle(node, id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleCephMgrSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleCephMgrSingle>>
>;

export type DeleteNodesSingleCephMgrSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleCephMgrSingle
 */
export const useDeleteNodesSingleCephMgrSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephMgrSingle>>,
    TError,
    { node: string; id: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleCephMgrSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create Ceph Manager
 * @summary createNodesSingleCephMgrSingle
 */
export const createNodesSingleCephMgrSingle = (
  node: string,
  id: string,
  createNodesSingleCephMgrSingleRequest: CreateNodesSingleCephMgrSingleRequest,
) => {
  return apiInstance<CreateNodesSingleCephMgrSingleResponseResponse>({
    url: `/nodes/${node}/ceph/mgr/${id}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephMgrSingleRequest,
  });
};

export const getCreateNodesSingleCephMgrSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephMgrSingle>>,
    TError,
    { node: string; id: string; data: CreateNodesSingleCephMgrSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephMgrSingle>>,
  TError,
  { node: string; id: string; data: CreateNodesSingleCephMgrSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephMgrSingle>>,
    { node: string; id: string; data: CreateNodesSingleCephMgrSingleRequest }
  > = (props) => {
    const { node, id, data } = props ?? {};

    return createNodesSingleCephMgrSingle(node, id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephMgrSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephMgrSingle>>
>;
export type CreateNodesSingleCephMgrSingleMutationBody =
  CreateNodesSingleCephMgrSingleRequest;
export type CreateNodesSingleCephMgrSingleMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephMgrSingle
 */
export const useCreateNodesSingleCephMgrSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephMgrSingle>>,
    TError,
    { node: string; id: string; data: CreateNodesSingleCephMgrSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCephMgrSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get Ceph monitor list.
 * @summary getNodesSingleCephMon
 */
export const getNodesSingleCephMon = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephMonResponseResponse>({
    url: `/nodes/${node}/ceph/mon`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephMonQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/mon`] as const;

export const getGetNodesSingleCephMonQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephMon>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephMon>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephMon>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephMonQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephMon>>
  > = ({ signal }) => getNodesSingleCephMon(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephMonQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephMon>>
>;
export type GetNodesSingleCephMonQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephMon
 */
export const useGetNodesSingleCephMon = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephMon>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephMon>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephMonQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Destroy Ceph Monitor and Manager.
 * @summary deleteNodesSingleCephMonSingle
 */
export const deleteNodesSingleCephMonSingle = (node: string, monid: string) => {
  return apiInstance<DeleteNodesSingleCephMonSingleResponseResponse>({
    url: `/nodes/${node}/ceph/mon/${monid}`,
    method: "delete",
  });
};

export const getDeleteNodesSingleCephMonSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephMonSingle>>,
    TError,
    { node: string; monid: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleCephMonSingle>>,
  TError,
  { node: string; monid: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleCephMonSingle>>,
    { node: string; monid: string }
  > = (props) => {
    const { node, monid } = props ?? {};

    return deleteNodesSingleCephMonSingle(node, monid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleCephMonSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleCephMonSingle>>
>;

export type DeleteNodesSingleCephMonSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleCephMonSingle
 */
export const useDeleteNodesSingleCephMonSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephMonSingle>>,
    TError,
    { node: string; monid: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleCephMonSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Create Ceph Monitor and Manager
 * @summary createNodesSingleCephMonSingle
 */
export const createNodesSingleCephMonSingle = (
  node: string,
  monid: string,
  createNodesSingleCephMonSingleRequest: CreateNodesSingleCephMonSingleRequest,
) => {
  return apiInstance<CreateNodesSingleCephMonSingleResponseResponse>({
    url: `/nodes/${node}/ceph/mon/${monid}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephMonSingleRequest,
  });
};

export const getCreateNodesSingleCephMonSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephMonSingle>>,
    TError,
    {
      node: string;
      monid: string;
      data: CreateNodesSingleCephMonSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephMonSingle>>,
  TError,
  { node: string; monid: string; data: CreateNodesSingleCephMonSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephMonSingle>>,
    { node: string; monid: string; data: CreateNodesSingleCephMonSingleRequest }
  > = (props) => {
    const { node, monid, data } = props ?? {};

    return createNodesSingleCephMonSingle(node, monid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephMonSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephMonSingle>>
>;
export type CreateNodesSingleCephMonSingleMutationBody =
  CreateNodesSingleCephMonSingleRequest;
export type CreateNodesSingleCephMonSingleMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephMonSingle
 */
export const useCreateNodesSingleCephMonSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephMonSingle>>,
    TError,
    {
      node: string;
      monid: string;
      data: CreateNodesSingleCephMonSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCephMonSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index.
 * @summary getNodesSingleCephFs
 */
export const getNodesSingleCephFs = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephFsResponseResponse>({
    url: `/nodes/${node}/ceph/fs`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephFsQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/fs`] as const;

export const getGetNodesSingleCephFsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephFs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephFs>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephFs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephFsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephFs>>
  > = ({ signal }) => getNodesSingleCephFs(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephFsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephFs>>
>;
export type GetNodesSingleCephFsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephFs
 */
export const useGetNodesSingleCephFs = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephFs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephFs>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephFsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a Ceph filesystem
 * @summary createNodesSingleCephFsSingle
 */
export const createNodesSingleCephFsSingle = (
  node: string,
  name: string,
  createNodesSingleCephFsSingleRequest: CreateNodesSingleCephFsSingleRequest,
) => {
  return apiInstance<CreateNodesSingleCephFsSingleResponseResponse>({
    url: `/nodes/${node}/ceph/fs/${name}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephFsSingleRequest,
  });
};

export const getCreateNodesSingleCephFsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephFsSingle>>,
    TError,
    { node: string; name: string; data: CreateNodesSingleCephFsSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephFsSingle>>,
  TError,
  { node: string; name: string; data: CreateNodesSingleCephFsSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephFsSingle>>,
    { node: string; name: string; data: CreateNodesSingleCephFsSingleRequest }
  > = (props) => {
    const { node, name, data } = props ?? {};

    return createNodesSingleCephFsSingle(node, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephFsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephFsSingle>>
>;
export type CreateNodesSingleCephFsSingleMutationBody =
  CreateNodesSingleCephFsSingleRequest;
export type CreateNodesSingleCephFsSingleMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephFsSingle
 */
export const useCreateNodesSingleCephFsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephFsSingle>>,
    TError,
    { node: string; name: string; data: CreateNodesSingleCephFsSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCephFsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List local disks.
 * @summary getNodesSingleCephDisks
 */
export const getNodesSingleCephDisks = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephDisksResponseResponse>({
    url: `/nodes/${node}/ceph/disks`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephDisksQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/disks`] as const;

export const getGetNodesSingleCephDisksQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephDisks>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephDisks>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephDisks>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephDisksQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephDisks>>
  > = ({ signal }) => getNodesSingleCephDisks(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephDisksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephDisks>>
>;
export type GetNodesSingleCephDisksQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephDisks
 */
export const useGetNodesSingleCephDisks = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephDisks>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephDisks>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephDisksQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get Ceph configuration.
 * @summary getNodesSingleCephConfig
 */
export const getNodesSingleCephConfig = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleCephConfigResponseResponse>({
    url: `/nodes/${node}/ceph/config`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephConfigQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/config`] as const;

export const getGetNodesSingleCephConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephConfig>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephConfig>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephConfigQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephConfig>>
  > = ({ signal }) => getNodesSingleCephConfig(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephConfig>>
>;
export type GetNodesSingleCephConfigQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephConfig
 */
export const useGetNodesSingleCephConfig = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephConfig>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephConfigQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get Ceph configuration database.
 * @summary getNodesSingleCephConfigdb
 */
export const getNodesSingleCephConfigdb = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleCephConfigdbResponseResponse>({
    url: `/nodes/${node}/ceph/configdb`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephConfigdbQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/configdb`] as const;

export const getGetNodesSingleCephConfigdbQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephConfigdb>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephConfigdb>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephConfigdb>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephConfigdbQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephConfigdb>>
  > = ({ signal }) => getNodesSingleCephConfigdb(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephConfigdbQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephConfigdb>>
>;
export type GetNodesSingleCephConfigdbQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephConfigdb
 */
export const useGetNodesSingleCephConfigdb = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephConfigdb>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephConfigdb>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephConfigdbQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create initial ceph default configuration and setup symlinks.
 * @summary createNodesSingleCephInit
 */
export const createNodesSingleCephInit = (
  node: string,
  createNodesSingleCephInitRequest: CreateNodesSingleCephInitRequest,
) => {
  return apiInstance<CreateNodesSingleCephInitResponseResponse>({
    url: `/nodes/${node}/ceph/init`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephInitRequest,
  });
};

export const getCreateNodesSingleCephInitMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephInit>>,
    TError,
    { node: string; data: CreateNodesSingleCephInitRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephInit>>,
  TError,
  { node: string; data: CreateNodesSingleCephInitRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephInit>>,
    { node: string; data: CreateNodesSingleCephInitRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleCephInit(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephInitMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephInit>>
>;
export type CreateNodesSingleCephInitMutationBody =
  CreateNodesSingleCephInitRequest;
export type CreateNodesSingleCephInitMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephInit
 */
export const useCreateNodesSingleCephInit = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephInit>>,
    TError,
    { node: string; data: CreateNodesSingleCephInitRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleCephInitMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Stop ceph services.
 * @summary createNodesSingleCephStop
 */
export const createNodesSingleCephStop = (
  node: string,
  createNodesSingleCephStopRequest: CreateNodesSingleCephStopRequest,
) => {
  return apiInstance<CreateNodesSingleCephStopResponseResponse>({
    url: `/nodes/${node}/ceph/stop`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephStopRequest,
  });
};

export const getCreateNodesSingleCephStopMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephStop>>,
    TError,
    { node: string; data: CreateNodesSingleCephStopRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephStop>>,
  TError,
  { node: string; data: CreateNodesSingleCephStopRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephStop>>,
    { node: string; data: CreateNodesSingleCephStopRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleCephStop(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephStop>>
>;
export type CreateNodesSingleCephStopMutationBody =
  CreateNodesSingleCephStopRequest;
export type CreateNodesSingleCephStopMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephStop
 */
export const useCreateNodesSingleCephStop = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephStop>>,
    TError,
    { node: string; data: CreateNodesSingleCephStopRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleCephStopMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Start ceph services.
 * @summary createNodesSingleCephStart
 */
export const createNodesSingleCephStart = (
  node: string,
  createNodesSingleCephStartRequest: CreateNodesSingleCephStartRequest,
) => {
  return apiInstance<CreateNodesSingleCephStartResponseResponse>({
    url: `/nodes/${node}/ceph/start`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephStartRequest,
  });
};

export const getCreateNodesSingleCephStartMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephStart>>,
    TError,
    { node: string; data: CreateNodesSingleCephStartRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephStart>>,
  TError,
  { node: string; data: CreateNodesSingleCephStartRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephStart>>,
    { node: string; data: CreateNodesSingleCephStartRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleCephStart(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephStart>>
>;
export type CreateNodesSingleCephStartMutationBody =
  CreateNodesSingleCephStartRequest;
export type CreateNodesSingleCephStartMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephStart
 */
export const useCreateNodesSingleCephStart = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephStart>>,
    TError,
    { node: string; data: CreateNodesSingleCephStartRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleCephStartMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Restart ceph services.
 * @summary createNodesSingleCephRestart
 */
export const createNodesSingleCephRestart = (
  node: string,
  createNodesSingleCephRestartRequest: CreateNodesSingleCephRestartRequest,
) => {
  return apiInstance<CreateNodesSingleCephRestartResponseResponse>({
    url: `/nodes/${node}/ceph/restart`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephRestartRequest,
  });
};

export const getCreateNodesSingleCephRestartMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephRestart>>,
    TError,
    { node: string; data: CreateNodesSingleCephRestartRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephRestart>>,
  TError,
  { node: string; data: CreateNodesSingleCephRestartRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephRestart>>,
    { node: string; data: CreateNodesSingleCephRestartRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleCephRestart(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephRestartMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephRestart>>
>;
export type CreateNodesSingleCephRestartMutationBody =
  CreateNodesSingleCephRestartRequest;
export type CreateNodesSingleCephRestartMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephRestart
 */
export const useCreateNodesSingleCephRestart = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephRestart>>,
    TError,
    { node: string; data: CreateNodesSingleCephRestartRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCephRestartMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get ceph status.
 * @summary getNodesSingleCephStatus
 */
export const getNodesSingleCephStatus = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleCephStatusResponseResponse>({
    url: `/nodes/${node}/ceph/status`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephStatusQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/status`] as const;

export const getGetNodesSingleCephStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephStatus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephStatusQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephStatus>>
  > = ({ signal }) => getNodesSingleCephStatus(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephStatus>>
>;
export type GetNodesSingleCephStatusQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephStatus
 */
export const useGetNodesSingleCephStatus = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephStatus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephStatusQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List all pools.
 * @summary getNodesSingleCephPools
 */
export const getNodesSingleCephPools = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephPoolsResponseResponse>({
    url: `/nodes/${node}/ceph/pools`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephPoolsQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/pools`] as const;

export const getGetNodesSingleCephPoolsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephPools>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephPools>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephPools>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephPoolsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephPools>>
  > = ({ signal }) => getNodesSingleCephPools(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephPoolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephPools>>
>;
export type GetNodesSingleCephPoolsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephPools
 */
export const useGetNodesSingleCephPools = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephPools>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephPools>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephPoolsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create POOL
 * @summary createNodesSingleCephPools
 */
export const createNodesSingleCephPools = (
  node: string,
  createNodesSingleCephPoolsRequest: CreateNodesSingleCephPoolsRequest,
) => {
  return apiInstance<CreateNodesSingleCephPoolsResponseResponse>({
    url: `/nodes/${node}/ceph/pools`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephPoolsRequest,
  });
};

export const getCreateNodesSingleCephPoolsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephPools>>,
    TError,
    { node: string; data: CreateNodesSingleCephPoolsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephPools>>,
  TError,
  { node: string; data: CreateNodesSingleCephPoolsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephPools>>,
    { node: string; data: CreateNodesSingleCephPoolsRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleCephPools(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephPoolsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephPools>>
>;
export type CreateNodesSingleCephPoolsMutationBody =
  CreateNodesSingleCephPoolsRequest;
export type CreateNodesSingleCephPoolsMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephPools
 */
export const useCreateNodesSingleCephPools = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephPools>>,
    TError,
    { node: string; data: CreateNodesSingleCephPoolsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleCephPoolsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Destroy pool
 * @summary deleteNodesSingleCephPoolsSingle
 */
export const deleteNodesSingleCephPoolsSingle = (
  node: string,
  name: string,
) => {
  return apiInstance<DeleteNodesSingleCephPoolsSingleResponseResponse>({
    url: `/nodes/${node}/ceph/pools/${name}`,
    method: "delete",
  });
};

export const getDeleteNodesSingleCephPoolsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephPoolsSingle>>,
    TError,
    { node: string; name: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleCephPoolsSingle>>,
  TError,
  { node: string; name: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleCephPoolsSingle>>,
    { node: string; name: string }
  > = (props) => {
    const { node, name } = props ?? {};

    return deleteNodesSingleCephPoolsSingle(node, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleCephPoolsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleCephPoolsSingle>>
>;

export type DeleteNodesSingleCephPoolsSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleCephPoolsSingle
 */
export const useDeleteNodesSingleCephPoolsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephPoolsSingle>>,
    TError,
    { node: string; name: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleCephPoolsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Change POOL settings
 * @summary updateNodesSingleCephPoolsSingle
 */
export const updateNodesSingleCephPoolsSingle = (
  node: string,
  name: string,
  updateNodesSingleCephPoolsSingleRequest: UpdateNodesSingleCephPoolsSingleRequest,
) => {
  return apiInstance<UpdateNodesSingleCephPoolsSingleResponseResponse>({
    url: `/nodes/${node}/ceph/pools/${name}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleCephPoolsSingleRequest,
  });
};

export const getUpdateNodesSingleCephPoolsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleCephPoolsSingle>>,
    TError,
    {
      node: string;
      name: string;
      data: UpdateNodesSingleCephPoolsSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleCephPoolsSingle>>,
  TError,
  { node: string; name: string; data: UpdateNodesSingleCephPoolsSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleCephPoolsSingle>>,
    {
      node: string;
      name: string;
      data: UpdateNodesSingleCephPoolsSingleRequest;
    }
  > = (props) => {
    const { node, name, data } = props ?? {};

    return updateNodesSingleCephPoolsSingle(node, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleCephPoolsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleCephPoolsSingle>>
>;
export type UpdateNodesSingleCephPoolsSingleMutationBody =
  UpdateNodesSingleCephPoolsSingleRequest;
export type UpdateNodesSingleCephPoolsSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateNodesSingleCephPoolsSingle
 */
export const useUpdateNodesSingleCephPoolsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleCephPoolsSingle>>,
    TError,
    {
      node: string;
      name: string;
      data: UpdateNodesSingleCephPoolsSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleCephPoolsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * get all set ceph flags
 * @summary getNodesSingleCephFlags
 */
export const getNodesSingleCephFlags = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephFlagsResponseResponse>({
    url: `/nodes/${node}/ceph/flags`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephFlagsQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/flags`] as const;

export const getGetNodesSingleCephFlagsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephFlags>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephFlags>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephFlags>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephFlagsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephFlags>>
  > = ({ signal }) => getNodesSingleCephFlags(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephFlagsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephFlags>>
>;
export type GetNodesSingleCephFlagsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephFlags
 */
export const useGetNodesSingleCephFlags = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephFlags>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephFlags>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephFlagsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Unset a ceph flag
 * @summary deleteNodesSingleCephFlagsSingle
 */
export const deleteNodesSingleCephFlagsSingle = (
  node: string,
  flag: string,
) => {
  return apiInstance<DeleteNodesSingleCephFlagsSingleResponseResponse>({
    url: `/nodes/${node}/ceph/flags/${flag}`,
    method: "delete",
  });
};

export const getDeleteNodesSingleCephFlagsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephFlagsSingle>>,
    TError,
    { node: string; flag: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleCephFlagsSingle>>,
  TError,
  { node: string; flag: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleCephFlagsSingle>>,
    { node: string; flag: string }
  > = (props) => {
    const { node, flag } = props ?? {};

    return deleteNodesSingleCephFlagsSingle(node, flag);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleCephFlagsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleCephFlagsSingle>>
>;

export type DeleteNodesSingleCephFlagsSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleCephFlagsSingle
 */
export const useDeleteNodesSingleCephFlagsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCephFlagsSingle>>,
    TError,
    { node: string; flag: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleCephFlagsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Set a specific ceph flag
 * @summary createNodesSingleCephFlagsSingle
 */
export const createNodesSingleCephFlagsSingle = (
  node: string,
  flag: string,
  createNodesSingleCephFlagsSingleRequest: CreateNodesSingleCephFlagsSingleRequest,
) => {
  return apiInstance<CreateNodesSingleCephFlagsSingleResponseResponse>({
    url: `/nodes/${node}/ceph/flags/${flag}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCephFlagsSingleRequest,
  });
};

export const getCreateNodesSingleCephFlagsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephFlagsSingle>>,
    TError,
    {
      node: string;
      flag: string;
      data: CreateNodesSingleCephFlagsSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCephFlagsSingle>>,
  TError,
  { node: string; flag: string; data: CreateNodesSingleCephFlagsSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCephFlagsSingle>>,
    {
      node: string;
      flag: string;
      data: CreateNodesSingleCephFlagsSingleRequest;
    }
  > = (props) => {
    const { node, flag, data } = props ?? {};

    return createNodesSingleCephFlagsSingle(node, flag, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCephFlagsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCephFlagsSingle>>
>;
export type CreateNodesSingleCephFlagsSingleMutationBody =
  CreateNodesSingleCephFlagsSingleRequest;
export type CreateNodesSingleCephFlagsSingleMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleCephFlagsSingle
 */
export const useCreateNodesSingleCephFlagsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCephFlagsSingle>>,
    TError,
    {
      node: string;
      flag: string;
      data: CreateNodesSingleCephFlagsSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCephFlagsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get OSD crush map
 * @summary getNodesSingleCephCrush
 */
export const getNodesSingleCephCrush = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephCrushResponseResponse>({
    url: `/nodes/${node}/ceph/crush`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephCrushQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/crush`] as const;

export const getGetNodesSingleCephCrushQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephCrush>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephCrush>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephCrush>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephCrushQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephCrush>>
  > = ({ signal }) => getNodesSingleCephCrush(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephCrushQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephCrush>>
>;
export type GetNodesSingleCephCrushQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephCrush
 */
export const useGetNodesSingleCephCrush = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephCrush>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephCrush>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephCrushQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read ceph log
 * @summary getNodesSingleCephLog
 */
export const getNodesSingleCephLog = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephLogResponseResponse>({
    url: `/nodes/${node}/ceph/log`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephLogQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/log`] as const;

export const getGetNodesSingleCephLogQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephLog>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephLog>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephLogQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephLog>>
  > = ({ signal }) => getNodesSingleCephLog(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephLogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephLog>>
>;
export type GetNodesSingleCephLogQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephLog
 */
export const useGetNodesSingleCephLog = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephLog>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephLogQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List ceph rules.
 * @summary getNodesSingleCephRules
 */
export const getNodesSingleCephRules = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleCephRulesResponseResponse>({
    url: `/nodes/${node}/ceph/rules`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCephRulesQueryKey = (node: string) =>
  [`/nodes/${node}/ceph/rules`] as const;

export const getGetNodesSingleCephRulesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephRules>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephRules>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCephRules>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCephRulesQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCephRules>>
  > = ({ signal }) => getNodesSingleCephRules(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCephRulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCephRules>>
>;
export type GetNodesSingleCephRulesQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCephRules
 */
export const useGetNodesSingleCephRules = <
  TData = Awaited<ReturnType<typeof getNodesSingleCephRules>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCephRules>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCephRulesQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create backup.
 * @summary createNodesSingleVzdump
 */
export const createNodesSingleVzdump = (
  node: string,
  createNodesSingleVzdumpRequest: CreateNodesSingleVzdumpRequest,
) => {
  return apiInstance<CreateNodesSingleVzdumpResponseResponse>({
    url: `/nodes/${node}/vzdump`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleVzdumpRequest,
  });
};

export const getCreateNodesSingleVzdumpMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleVzdump>>,
    TError,
    { node: string; data: CreateNodesSingleVzdumpRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleVzdump>>,
  TError,
  { node: string; data: CreateNodesSingleVzdumpRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleVzdump>>,
    { node: string; data: CreateNodesSingleVzdumpRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleVzdump(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleVzdumpMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleVzdump>>
>;
export type CreateNodesSingleVzdumpMutationBody =
  CreateNodesSingleVzdumpRequest;
export type CreateNodesSingleVzdumpMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleVzdump
 */
export const useCreateNodesSingleVzdump = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleVzdump>>,
    TError,
    { node: string; data: CreateNodesSingleVzdumpRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleVzdumpMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Extract configuration from vzdump backup archive.
 * @summary getNodesSingleVzdumpExtractconfig
 */
export const getNodesSingleVzdumpExtractconfig = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleVzdumpExtractconfigResponseResponse>({
    url: `/nodes/${node}/vzdump/extractconfig`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleVzdumpExtractconfigQueryKey = (node: string) =>
  [`/nodes/${node}/vzdump/extractconfig`] as const;

export const getGetNodesSingleVzdumpExtractconfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleVzdumpExtractconfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleVzdumpExtractconfig>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleVzdumpExtractconfig>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleVzdumpExtractconfigQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleVzdumpExtractconfig>>
  > = ({ signal }) => getNodesSingleVzdumpExtractconfig(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleVzdumpExtractconfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleVzdumpExtractconfig>>
>;
export type GetNodesSingleVzdumpExtractconfigQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleVzdumpExtractconfig
 */
export const useGetNodesSingleVzdumpExtractconfig = <
  TData = Awaited<ReturnType<typeof getNodesSingleVzdumpExtractconfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleVzdumpExtractconfig>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleVzdumpExtractconfigQueryOptions(
    node,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Service list.
 * @summary getNodesSingleServices
 */
export const getNodesSingleServices = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleServicesResponseResponse>({
    url: `/nodes/${node}/services`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleServicesQueryKey = (node: string) =>
  [`/nodes/${node}/services`] as const;

export const getGetNodesSingleServicesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleServices>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleServices>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleServices>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleServicesQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleServices>>
  > = ({ signal }) => getNodesSingleServices(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleServicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleServices>>
>;
export type GetNodesSingleServicesQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleServices
 */
export const useGetNodesSingleServices = <
  TData = Awaited<ReturnType<typeof getNodesSingleServices>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleServices>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleServicesQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Directory index
 * @summary getNodesSingleServicesSingle
 */
export const getNodesSingleServicesSingle = (
  node: string,
  service: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleServicesSingleResponseResponse>({
    url: `/nodes/${node}/services/${service}`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleServicesSingleQueryKey = (
  node: string,
  service: string,
) => [`/nodes/${node}/services/${service}`] as const;

export const getGetNodesSingleServicesSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleServicesSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  service: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleServicesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleServicesSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleServicesSingleQueryKey(node, service);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleServicesSingle>>
  > = ({ signal }) => getNodesSingleServicesSingle(node, service, signal);

  return { queryKey, queryFn, enabled: !!(node && service), ...queryOptions };
};

export type GetNodesSingleServicesSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleServicesSingle>>
>;
export type GetNodesSingleServicesSingleQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleServicesSingle
 */
export const useGetNodesSingleServicesSingle = <
  TData = Awaited<ReturnType<typeof getNodesSingleServicesSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  service: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleServicesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleServicesSingleQueryOptions(
    node,
    service,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read service properties
 * @summary getNodesSingleServicesSingleState
 */
export const getNodesSingleServicesSingleState = (
  node: string,
  service: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleServicesSingleStateResponseResponse>({
    url: `/nodes/${node}/services/${service}/state`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleServicesSingleStateQueryKey = (
  node: string,
  service: string,
) => [`/nodes/${node}/services/${service}/state`] as const;

export const getGetNodesSingleServicesSingleStateQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleServicesSingleState>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  service: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleServicesSingleState>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleServicesSingleState>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleServicesSingleStateQueryKey(node, service);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleServicesSingleState>>
  > = ({ signal }) => getNodesSingleServicesSingleState(node, service, signal);

  return { queryKey, queryFn, enabled: !!(node && service), ...queryOptions };
};

export type GetNodesSingleServicesSingleStateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleServicesSingleState>>
>;
export type GetNodesSingleServicesSingleStateQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleServicesSingleState
 */
export const useGetNodesSingleServicesSingleState = <
  TData = Awaited<ReturnType<typeof getNodesSingleServicesSingleState>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  service: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleServicesSingleState>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleServicesSingleStateQueryOptions(
    node,
    service,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Start service.
 * @summary createNodesSingleServicesSingleStart
 */
export const createNodesSingleServicesSingleStart = (
  node: string,
  service: string,
  createNodesSingleServicesSingleStartRequest: CreateNodesSingleServicesSingleStartRequest,
) => {
  return apiInstance<CreateNodesSingleServicesSingleStartResponseResponse>({
    url: `/nodes/${node}/services/${service}/start`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleServicesSingleStartRequest,
  });
};

export const getCreateNodesSingleServicesSingleStartMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleStart>>,
    TError,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleStartRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleServicesSingleStart>>,
  TError,
  {
    node: string;
    service: string;
    data: CreateNodesSingleServicesSingleStartRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleStart>>,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleStartRequest;
    }
  > = (props) => {
    const { node, service, data } = props ?? {};

    return createNodesSingleServicesSingleStart(node, service, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleServicesSingleStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleServicesSingleStart>>
>;
export type CreateNodesSingleServicesSingleStartMutationBody =
  CreateNodesSingleServicesSingleStartRequest;
export type CreateNodesSingleServicesSingleStartMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleServicesSingleStart
 */
export const useCreateNodesSingleServicesSingleStart = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleStart>>,
    TError,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleStartRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleServicesSingleStartMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Stop service.
 * @summary createNodesSingleServicesSingleStop
 */
export const createNodesSingleServicesSingleStop = (
  node: string,
  service: string,
  createNodesSingleServicesSingleStopRequest: CreateNodesSingleServicesSingleStopRequest,
) => {
  return apiInstance<CreateNodesSingleServicesSingleStopResponseResponse>({
    url: `/nodes/${node}/services/${service}/stop`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleServicesSingleStopRequest,
  });
};

export const getCreateNodesSingleServicesSingleStopMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleStop>>,
    TError,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleStopRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleServicesSingleStop>>,
  TError,
  {
    node: string;
    service: string;
    data: CreateNodesSingleServicesSingleStopRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleStop>>,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleStopRequest;
    }
  > = (props) => {
    const { node, service, data } = props ?? {};

    return createNodesSingleServicesSingleStop(node, service, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleServicesSingleStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleServicesSingleStop>>
>;
export type CreateNodesSingleServicesSingleStopMutationBody =
  CreateNodesSingleServicesSingleStopRequest;
export type CreateNodesSingleServicesSingleStopMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleServicesSingleStop
 */
export const useCreateNodesSingleServicesSingleStop = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleStop>>,
    TError,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleStopRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleServicesSingleStopMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Hard restart service. Use reload if you want to reduce interruptions.
 * @summary createNodesSingleServicesSingleRestart
 */
export const createNodesSingleServicesSingleRestart = (
  node: string,
  service: string,
  createNodesSingleServicesSingleRestartRequest: CreateNodesSingleServicesSingleRestartRequest,
) => {
  return apiInstance<CreateNodesSingleServicesSingleRestartResponseResponse>({
    url: `/nodes/${node}/services/${service}/restart`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleServicesSingleRestartRequest,
  });
};

export const getCreateNodesSingleServicesSingleRestartMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleRestart>>,
    TError,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleRestartRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleServicesSingleRestart>>,
  TError,
  {
    node: string;
    service: string;
    data: CreateNodesSingleServicesSingleRestartRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleRestart>>,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleRestartRequest;
    }
  > = (props) => {
    const { node, service, data } = props ?? {};

    return createNodesSingleServicesSingleRestart(node, service, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleServicesSingleRestartMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleServicesSingleRestart>>
>;
export type CreateNodesSingleServicesSingleRestartMutationBody =
  CreateNodesSingleServicesSingleRestartRequest;
export type CreateNodesSingleServicesSingleRestartMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleServicesSingleRestart
 */
export const useCreateNodesSingleServicesSingleRestart = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleRestart>>,
    TError,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleRestartRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleServicesSingleRestartMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reload service. Falls back to restart if service cannot be reloaded.
 * @summary createNodesSingleServicesSingleReload
 */
export const createNodesSingleServicesSingleReload = (
  node: string,
  service: string,
  createNodesSingleServicesSingleReloadRequest: CreateNodesSingleServicesSingleReloadRequest,
) => {
  return apiInstance<CreateNodesSingleServicesSingleReloadResponseResponse>({
    url: `/nodes/${node}/services/${service}/reload`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleServicesSingleReloadRequest,
  });
};

export const getCreateNodesSingleServicesSingleReloadMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleReload>>,
    TError,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleReloadRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleServicesSingleReload>>,
  TError,
  {
    node: string;
    service: string;
    data: CreateNodesSingleServicesSingleReloadRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleReload>>,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleReloadRequest;
    }
  > = (props) => {
    const { node, service, data } = props ?? {};

    return createNodesSingleServicesSingleReload(node, service, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleServicesSingleReloadMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleServicesSingleReload>>
>;
export type CreateNodesSingleServicesSingleReloadMutationBody =
  CreateNodesSingleServicesSingleReloadRequest;
export type CreateNodesSingleServicesSingleReloadMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleServicesSingleReload
 */
export const useCreateNodesSingleServicesSingleReload = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleServicesSingleReload>>,
    TError,
    {
      node: string;
      service: string;
      data: CreateNodesSingleServicesSingleReloadRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleServicesSingleReloadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete subscription key of this node.
 * @summary deleteNodesSingleSubscription
 */
export const deleteNodesSingleSubscription = (node: string) => {
  return apiInstance<DeleteNodesSingleSubscriptionResponseResponse>({
    url: `/nodes/${node}/subscription`,
    method: "delete",
  });
};

export const getDeleteNodesSingleSubscriptionMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleSubscription>>,
    TError,
    { node: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleSubscription>>,
  TError,
  { node: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleSubscription>>,
    { node: string }
  > = (props) => {
    const { node } = props ?? {};

    return deleteNodesSingleSubscription(node);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleSubscription>>
>;

export type DeleteNodesSingleSubscriptionMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleSubscription
 */
export const useDeleteNodesSingleSubscription = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleSubscription>>,
    TError,
    { node: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read subscription info.
 * @summary getNodesSingleSubscription
 */
export const getNodesSingleSubscription = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleSubscriptionResponseResponse>({
    url: `/nodes/${node}/subscription`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleSubscriptionQueryKey = (node: string) =>
  [`/nodes/${node}/subscription`] as const;

export const getGetNodesSingleSubscriptionQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleSubscription>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleSubscription>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleSubscription>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleSubscriptionQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleSubscription>>
  > = ({ signal }) => getNodesSingleSubscription(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleSubscriptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleSubscription>>
>;
export type GetNodesSingleSubscriptionQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleSubscription
 */
export const useGetNodesSingleSubscription = <
  TData = Awaited<ReturnType<typeof getNodesSingleSubscription>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleSubscription>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleSubscriptionQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update subscription info.
 * @summary createNodesSingleSubscription
 */
export const createNodesSingleSubscription = (
  node: string,
  createNodesSingleSubscriptionRequest: CreateNodesSingleSubscriptionRequest,
) => {
  return apiInstance<CreateNodesSingleSubscriptionResponseResponse>({
    url: `/nodes/${node}/subscription`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleSubscriptionRequest,
  });
};

export const getCreateNodesSingleSubscriptionMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleSubscription>>,
    TError,
    { node: string; data: CreateNodesSingleSubscriptionRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleSubscription>>,
  TError,
  { node: string; data: CreateNodesSingleSubscriptionRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleSubscription>>,
    { node: string; data: CreateNodesSingleSubscriptionRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleSubscription(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleSubscription>>
>;
export type CreateNodesSingleSubscriptionMutationBody =
  CreateNodesSingleSubscriptionRequest;
export type CreateNodesSingleSubscriptionMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleSubscription
 */
export const useCreateNodesSingleSubscription = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleSubscription>>,
    TError,
    { node: string; data: CreateNodesSingleSubscriptionRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Set subscription key.
 * @summary updateNodesSingleSubscription
 */
export const updateNodesSingleSubscription = (
  node: string,
  updateNodesSingleSubscriptionRequest: UpdateNodesSingleSubscriptionRequest,
) => {
  return apiInstance<UpdateNodesSingleSubscriptionResponseResponse>({
    url: `/nodes/${node}/subscription`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleSubscriptionRequest,
  });
};

export const getUpdateNodesSingleSubscriptionMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleSubscription>>,
    TError,
    { node: string; data: UpdateNodesSingleSubscriptionRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleSubscription>>,
  TError,
  { node: string; data: UpdateNodesSingleSubscriptionRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleSubscription>>,
    { node: string; data: UpdateNodesSingleSubscriptionRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return updateNodesSingleSubscription(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleSubscription>>
>;
export type UpdateNodesSingleSubscriptionMutationBody =
  UpdateNodesSingleSubscriptionRequest;
export type UpdateNodesSingleSubscriptionMutationError = ErrorType<unknown>;

/**
 * @summary updateNodesSingleSubscription
 */
export const useUpdateNodesSingleSubscription = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleSubscription>>,
    TError,
    { node: string; data: UpdateNodesSingleSubscriptionRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Revert network configuration changes.
 * @summary deleteNodesSingleNetwork
 */
export const deleteNodesSingleNetwork = (node: string) => {
  return apiInstance<DeleteNodesSingleNetworkResponseResponse>({
    url: `/nodes/${node}/network`,
    method: "delete",
  });
};

export const getDeleteNodesSingleNetworkMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleNetwork>>,
    TError,
    { node: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleNetwork>>,
  TError,
  { node: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleNetwork>>,
    { node: string }
  > = (props) => {
    const { node } = props ?? {};

    return deleteNodesSingleNetwork(node);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleNetworkMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleNetwork>>
>;

export type DeleteNodesSingleNetworkMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleNetwork
 */
export const useDeleteNodesSingleNetwork = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleNetwork>>,
    TError,
    { node: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteNodesSingleNetworkMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List available networks
 * @summary getNodesSingleNetwork
 */
export const getNodesSingleNetwork = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleNetworkResponseResponse>({
    url: `/nodes/${node}/network`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleNetworkQueryKey = (node: string) =>
  [`/nodes/${node}/network`] as const;

export const getGetNodesSingleNetworkQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleNetwork>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleNetwork>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleNetwork>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleNetworkQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleNetwork>>
  > = ({ signal }) => getNodesSingleNetwork(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleNetworkQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleNetwork>>
>;
export type GetNodesSingleNetworkQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleNetwork
 */
export const useGetNodesSingleNetwork = <
  TData = Awaited<ReturnType<typeof getNodesSingleNetwork>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleNetwork>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleNetworkQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create network device configuration
 * @summary createNodesSingleNetwork
 */
export const createNodesSingleNetwork = (
  node: string,
  createNodesSingleNetworkRequest: CreateNodesSingleNetworkRequest,
) => {
  return apiInstance<CreateNodesSingleNetworkResponseResponse>({
    url: `/nodes/${node}/network`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleNetworkRequest,
  });
};

export const getCreateNodesSingleNetworkMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleNetwork>>,
    TError,
    { node: string; data: CreateNodesSingleNetworkRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleNetwork>>,
  TError,
  { node: string; data: CreateNodesSingleNetworkRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleNetwork>>,
    { node: string; data: CreateNodesSingleNetworkRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleNetwork(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleNetworkMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleNetwork>>
>;
export type CreateNodesSingleNetworkMutationBody =
  CreateNodesSingleNetworkRequest;
export type CreateNodesSingleNetworkMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleNetwork
 */
export const useCreateNodesSingleNetwork = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleNetwork>>,
    TError,
    { node: string; data: CreateNodesSingleNetworkRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleNetworkMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reload network configuration
 * @summary updateNodesSingleNetwork
 */
export const updateNodesSingleNetwork = (
  node: string,
  updateNodesSingleNetworkRequest: UpdateNodesSingleNetworkRequest,
) => {
  return apiInstance<UpdateNodesSingleNetworkResponseResponse>({
    url: `/nodes/${node}/network`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleNetworkRequest,
  });
};

export const getUpdateNodesSingleNetworkMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleNetwork>>,
    TError,
    { node: string; data: UpdateNodesSingleNetworkRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleNetwork>>,
  TError,
  { node: string; data: UpdateNodesSingleNetworkRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleNetwork>>,
    { node: string; data: UpdateNodesSingleNetworkRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return updateNodesSingleNetwork(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleNetworkMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleNetwork>>
>;
export type UpdateNodesSingleNetworkMutationBody =
  UpdateNodesSingleNetworkRequest;
export type UpdateNodesSingleNetworkMutationError = ErrorType<unknown>;

/**
 * @summary updateNodesSingleNetwork
 */
export const useUpdateNodesSingleNetwork = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleNetwork>>,
    TError,
    { node: string; data: UpdateNodesSingleNetworkRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateNodesSingleNetworkMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete network device configuration
 * @summary deleteNodesSingleNetworkSingle
 */
export const deleteNodesSingleNetworkSingle = (node: string, iface: string) => {
  return apiInstance<DeleteNodesSingleNetworkSingleResponseResponse>({
    url: `/nodes/${node}/network/${iface}`,
    method: "delete",
  });
};

export const getDeleteNodesSingleNetworkSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleNetworkSingle>>,
    TError,
    { node: string; iface: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleNetworkSingle>>,
  TError,
  { node: string; iface: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleNetworkSingle>>,
    { node: string; iface: string }
  > = (props) => {
    const { node, iface } = props ?? {};

    return deleteNodesSingleNetworkSingle(node, iface);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleNetworkSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleNetworkSingle>>
>;

export type DeleteNodesSingleNetworkSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodesSingleNetworkSingle
 */
export const useDeleteNodesSingleNetworkSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleNetworkSingle>>,
    TError,
    { node: string; iface: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleNetworkSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read network device configuration
 * @summary getNodesSingleNetworkSingle
 */
export const getNodesSingleNetworkSingle = (
  node: string,
  iface: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleNetworkSingleResponseResponse>({
    url: `/nodes/${node}/network/${iface}`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleNetworkSingleQueryKey = (
  node: string,
  iface: string,
) => [`/nodes/${node}/network/${iface}`] as const;

export const getGetNodesSingleNetworkSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleNetworkSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  iface: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleNetworkSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleNetworkSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleNetworkSingleQueryKey(node, iface);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleNetworkSingle>>
  > = ({ signal }) => getNodesSingleNetworkSingle(node, iface, signal);

  return { queryKey, queryFn, enabled: !!(node && iface), ...queryOptions };
};

export type GetNodesSingleNetworkSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleNetworkSingle>>
>;
export type GetNodesSingleNetworkSingleQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleNetworkSingle
 */
export const useGetNodesSingleNetworkSingle = <
  TData = Awaited<ReturnType<typeof getNodesSingleNetworkSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  iface: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleNetworkSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleNetworkSingleQueryOptions(
    node,
    iface,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update network device configuration
 * @summary updateNodesSingleNetworkSingle
 */
export const updateNodesSingleNetworkSingle = (
  node: string,
  iface: string,
  updateNodesSingleNetworkSingleRequest: UpdateNodesSingleNetworkSingleRequest,
) => {
  return apiInstance<UpdateNodesSingleNetworkSingleResponseResponse>({
    url: `/nodes/${node}/network/${iface}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleNetworkSingleRequest,
  });
};

export const getUpdateNodesSingleNetworkSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleNetworkSingle>>,
    TError,
    {
      node: string;
      iface: string;
      data: UpdateNodesSingleNetworkSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleNetworkSingle>>,
  TError,
  { node: string; iface: string; data: UpdateNodesSingleNetworkSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleNetworkSingle>>,
    { node: string; iface: string; data: UpdateNodesSingleNetworkSingleRequest }
  > = (props) => {
    const { node, iface, data } = props ?? {};

    return updateNodesSingleNetworkSingle(node, iface, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleNetworkSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleNetworkSingle>>
>;
export type UpdateNodesSingleNetworkSingleMutationBody =
  UpdateNodesSingleNetworkSingleRequest;
export type UpdateNodesSingleNetworkSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateNodesSingleNetworkSingle
 */
export const useUpdateNodesSingleNetworkSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleNetworkSingle>>,
    TError,
    {
      node: string;
      iface: string;
      data: UpdateNodesSingleNetworkSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleNetworkSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read task list for one node (finished tasks).
 * @summary getNodeTasks
 */
export const getNodeTasks = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodeTasksResponseResponse>({
    url: `/nodes/${node}/tasks`,
    method: "get",
    signal,
  });
};

export const getGetNodeTasksQueryKey = (node: string) =>
  [`/nodes/${node}/tasks`] as const;

export const getGetNodeTasksQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeTasks>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeTasks>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getNodeTasks>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeTasksQueryKey(node);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeTasks>>> = ({
    signal,
  }) => getNodeTasks(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodeTasksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeTasks>>
>;
export type GetNodeTasksQueryError = ErrorType<unknown>;

/**
 * @summary getNodeTasks
 */
export const useGetNodeTasks = <
  TData = Awaited<ReturnType<typeof getNodeTasks>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeTasks>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeTasksQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Stop a task.
 * @summary stopNodeTask
 */
export const stopNodeTask = (node: string, upid: string) => {
  return apiInstance<StopNodeTaskResponseResponse>({
    url: `/nodes/${node}/tasks/${upid}`,
    method: "delete",
  });
};

export const getStopNodeTaskMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopNodeTask>>,
    TError,
    { node: string; upid: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stopNodeTask>>,
  TError,
  { node: string; upid: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stopNodeTask>>,
    { node: string; upid: string }
  > = (props) => {
    const { node, upid } = props ?? {};

    return stopNodeTask(node, upid);
  };

  return { mutationFn, ...mutationOptions };
};

export type StopNodeTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof stopNodeTask>>
>;

export type StopNodeTaskMutationError = ErrorType<unknown>;

/**
 * @summary stopNodeTask
 */
export const useStopNodeTask = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopNodeTask>>,
    TError,
    { node: string; upid: string },
    TContext
  >;
}) => {
  const mutationOptions = getStopNodeTaskMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * getNodeTask
 * @summary getNodeTask
 */
export const getNodeTask = (
  node: string,
  upid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodeTaskResponseResponse>({
    url: `/nodes/${node}/tasks/${upid}`,
    method: "get",
    signal,
  });
};

export const getGetNodeTaskQueryKey = (node: string, upid: string) =>
  [`/nodes/${node}/tasks/${upid}`] as const;

export const getGetNodeTaskQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeTask>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  upid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeTask>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getNodeTask>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeTaskQueryKey(node, upid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeTask>>> = ({
    signal,
  }) => getNodeTask(node, upid, signal);

  return { queryKey, queryFn, enabled: !!(node && upid), ...queryOptions };
};

export type GetNodeTaskQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeTask>>
>;
export type GetNodeTaskQueryError = ErrorType<unknown>;

/**
 * @summary getNodeTask
 */
export const useGetNodeTask = <
  TData = Awaited<ReturnType<typeof getNodeTask>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  upid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeTask>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeTaskQueryOptions(node, upid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read task log.
 * @summary getNodeTaskLog
 */
export const getNodeTaskLog = (
  node: string,
  upid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodeTaskLogResponseResponse>({
    url: `/nodes/${node}/tasks/${upid}/log`,
    method: "get",
    signal,
  });
};

export const getGetNodeTaskLogQueryKey = (node: string, upid: string) =>
  [`/nodes/${node}/tasks/${upid}/log`] as const;

export const getGetNodeTaskLogQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeTaskLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  upid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeTaskLog>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeTaskLog>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodeTaskLogQueryKey(node, upid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeTaskLog>>> = ({
    signal,
  }) => getNodeTaskLog(node, upid, signal);

  return { queryKey, queryFn, enabled: !!(node && upid), ...queryOptions };
};

export type GetNodeTaskLogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeTaskLog>>
>;
export type GetNodeTaskLogQueryError = ErrorType<unknown>;

/**
 * @summary getNodeTaskLog
 */
export const useGetNodeTaskLog = <
  TData = Awaited<ReturnType<typeof getNodeTaskLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  upid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeTaskLog>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeTaskLogQueryOptions(node, upid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read task status.
 * @summary getNodeTaskStatus
 */
export const getNodeTaskStatus = (
  node: string,
  upid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodeTaskStatusResponseResponse>({
    url: `/nodes/${node}/tasks/${upid}/status`,
    method: "get",
    signal,
  });
};

export const getGetNodeTaskStatusQueryKey = (node: string, upid: string) =>
  [`/nodes/${node}/tasks/${upid}/status`] as const;

export const getGetNodeTaskStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeTaskStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  upid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeTaskStatus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeTaskStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodeTaskStatusQueryKey(node, upid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodeTaskStatus>>
  > = ({ signal }) => getNodeTaskStatus(node, upid, signal);

  return { queryKey, queryFn, enabled: !!(node && upid), ...queryOptions };
};

export type GetNodeTaskStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeTaskStatus>>
>;
export type GetNodeTaskStatusQueryError = ErrorType<unknown>;

/**
 * @summary getNodeTaskStatus
 */
export const useGetNodeTaskStatus = <
  TData = Awaited<ReturnType<typeof getNodeTaskStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  upid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeTaskStatus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeTaskStatusQueryOptions(node, upid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Index of available scan methods
 * @summary getNodesSingleScan
 */
export const getNodesSingleScan = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleScanResponseResponse>({
    url: `/nodes/${node}/scan`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleScanQueryKey = (node: string) =>
  [`/nodes/${node}/scan`] as const;

export const getGetNodesSingleScanQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleScan>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScan>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleScan>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleScanQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleScan>>
  > = ({ signal }) => getNodesSingleScan(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleScanQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleScan>>
>;
export type GetNodesSingleScanQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleScan
 */
export const useGetNodesSingleScan = <
  TData = Awaited<ReturnType<typeof getNodesSingleScan>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScan>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleScanQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Scan zfs pool list on local node.
 * @summary getNodesSingleScanZfs
 */
export const getNodesSingleScanZfs = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleScanZfsResponseResponse>({
    url: `/nodes/${node}/scan/zfs`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleScanZfsQueryKey = (node: string) =>
  [`/nodes/${node}/scan/zfs`] as const;

export const getGetNodesSingleScanZfsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanZfs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanZfs>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleScanZfs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleScanZfsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleScanZfs>>
  > = ({ signal }) => getNodesSingleScanZfs(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleScanZfsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleScanZfs>>
>;
export type GetNodesSingleScanZfsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleScanZfs
 */
export const useGetNodesSingleScanZfs = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanZfs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanZfs>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleScanZfsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Scan remote NFS server.
 * @summary getNodesSingleScanNfs
 */
export const getNodesSingleScanNfs = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleScanNfsResponseResponse>({
    url: `/nodes/${node}/scan/nfs`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleScanNfsQueryKey = (node: string) =>
  [`/nodes/${node}/scan/nfs`] as const;

export const getGetNodesSingleScanNfsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanNfs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanNfs>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleScanNfs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleScanNfsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleScanNfs>>
  > = ({ signal }) => getNodesSingleScanNfs(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleScanNfsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleScanNfs>>
>;
export type GetNodesSingleScanNfsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleScanNfs
 */
export const useGetNodesSingleScanNfs = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanNfs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanNfs>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleScanNfsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Scan remote CIFS server.
 * @summary getNodesSingleScanCifs
 */
export const getNodesSingleScanCifs = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleScanCifsResponseResponse>({
    url: `/nodes/${node}/scan/cifs`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleScanCifsQueryKey = (node: string) =>
  [`/nodes/${node}/scan/cifs`] as const;

export const getGetNodesSingleScanCifsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanCifs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanCifs>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleScanCifs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleScanCifsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleScanCifs>>
  > = ({ signal }) => getNodesSingleScanCifs(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleScanCifsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleScanCifs>>
>;
export type GetNodesSingleScanCifsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleScanCifs
 */
export const useGetNodesSingleScanCifs = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanCifs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanCifs>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleScanCifsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Scan remote GlusterFS server.
 * @summary getNodesSingleScanGlusterfs
 */
export const getNodesSingleScanGlusterfs = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleScanGlusterfsResponseResponse>({
    url: `/nodes/${node}/scan/glusterfs`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleScanGlusterfsQueryKey = (node: string) =>
  [`/nodes/${node}/scan/glusterfs`] as const;

export const getGetNodesSingleScanGlusterfsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanGlusterfs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanGlusterfs>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleScanGlusterfs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleScanGlusterfsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleScanGlusterfs>>
  > = ({ signal }) => getNodesSingleScanGlusterfs(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleScanGlusterfsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleScanGlusterfs>>
>;
export type GetNodesSingleScanGlusterfsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleScanGlusterfs
 */
export const useGetNodesSingleScanGlusterfs = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanGlusterfs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanGlusterfs>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleScanGlusterfsQueryOptions(
    node,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Scan remote iSCSI server.
 * @summary getNodesSingleScanIscsi
 */
export const getNodesSingleScanIscsi = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleScanIscsiResponseResponse>({
    url: `/nodes/${node}/scan/iscsi`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleScanIscsiQueryKey = (node: string) =>
  [`/nodes/${node}/scan/iscsi`] as const;

export const getGetNodesSingleScanIscsiQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanIscsi>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanIscsi>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleScanIscsi>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleScanIscsiQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleScanIscsi>>
  > = ({ signal }) => getNodesSingleScanIscsi(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleScanIscsiQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleScanIscsi>>
>;
export type GetNodesSingleScanIscsiQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleScanIscsi
 */
export const useGetNodesSingleScanIscsi = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanIscsi>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanIscsi>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleScanIscsiQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List local LVM volume groups.
 * @summary getNodesSingleScanLvm
 */
export const getNodesSingleScanLvm = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleScanLvmResponseResponse>({
    url: `/nodes/${node}/scan/lvm`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleScanLvmQueryKey = (node: string) =>
  [`/nodes/${node}/scan/lvm`] as const;

export const getGetNodesSingleScanLvmQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanLvm>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanLvm>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleScanLvm>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleScanLvmQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleScanLvm>>
  > = ({ signal }) => getNodesSingleScanLvm(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleScanLvmQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleScanLvm>>
>;
export type GetNodesSingleScanLvmQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleScanLvm
 */
export const useGetNodesSingleScanLvm = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanLvm>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanLvm>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleScanLvmQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List local LVM Thin Pools.
 * @summary getNodesSingleScanLvmthin
 */
export const getNodesSingleScanLvmthin = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleScanLvmthinResponseResponse>({
    url: `/nodes/${node}/scan/lvmthin`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleScanLvmthinQueryKey = (node: string) =>
  [`/nodes/${node}/scan/lvmthin`] as const;

export const getGetNodesSingleScanLvmthinQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanLvmthin>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanLvmthin>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleScanLvmthin>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleScanLvmthinQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleScanLvmthin>>
  > = ({ signal }) => getNodesSingleScanLvmthin(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleScanLvmthinQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleScanLvmthin>>
>;
export type GetNodesSingleScanLvmthinQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleScanLvmthin
 */
export const useGetNodesSingleScanLvmthin = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanLvmthin>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanLvmthin>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleScanLvmthinQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List local USB devices.
 * @summary getNodesSingleScanUsb
 */
export const getNodesSingleScanUsb = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleScanUsbResponseResponse>({
    url: `/nodes/${node}/scan/usb`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleScanUsbQueryKey = (node: string) =>
  [`/nodes/${node}/scan/usb`] as const;

export const getGetNodesSingleScanUsbQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanUsb>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanUsb>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleScanUsb>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleScanUsbQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleScanUsb>>
  > = ({ signal }) => getNodesSingleScanUsb(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleScanUsbQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleScanUsb>>
>;
export type GetNodesSingleScanUsbQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleScanUsb
 */
export const useGetNodesSingleScanUsb = <
  TData = Awaited<ReturnType<typeof getNodesSingleScanUsb>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleScanUsb>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleScanUsbQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Index of hardware types
 * @summary getNodesSingleHardware
 */
export const getNodesSingleHardware = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleHardwareResponseResponse>({
    url: `/nodes/${node}/hardware`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleHardwareQueryKey = (node: string) =>
  [`/nodes/${node}/hardware`] as const;

export const getGetNodesSingleHardwareQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleHardware>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHardware>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleHardware>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleHardwareQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleHardware>>
  > = ({ signal }) => getNodesSingleHardware(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleHardwareQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleHardware>>
>;
export type GetNodesSingleHardwareQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleHardware
 */
export const useGetNodesSingleHardware = <
  TData = Awaited<ReturnType<typeof getNodesSingleHardware>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHardware>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleHardwareQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List local PCI devices.
 * @summary getNodesSingleHardwarePci
 */
export const getNodesSingleHardwarePci = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleHardwarePciResponseResponse>({
    url: `/nodes/${node}/hardware/pci`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleHardwarePciQueryKey = (node: string) =>
  [`/nodes/${node}/hardware/pci`] as const;

export const getGetNodesSingleHardwarePciQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleHardwarePci>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHardwarePci>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleHardwarePci>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleHardwarePciQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleHardwarePci>>
  > = ({ signal }) => getNodesSingleHardwarePci(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleHardwarePciQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleHardwarePci>>
>;
export type GetNodesSingleHardwarePciQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleHardwarePci
 */
export const useGetNodesSingleHardwarePci = <
  TData = Awaited<ReturnType<typeof getNodesSingleHardwarePci>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHardwarePci>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleHardwarePciQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Index of available pci methods
 * @summary getNodesSingleHardwarePciSingle
 */
export const getNodesSingleHardwarePciSingle = (
  node: string,
  pciid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleHardwarePciSingleResponseResponse>({
    url: `/nodes/${node}/hardware/pci/${pciid}`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleHardwarePciSingleQueryKey = (
  node: string,
  pciid: string,
) => [`/nodes/${node}/hardware/pci/${pciid}`] as const;

export const getGetNodesSingleHardwarePciSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleHardwarePciSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  pciid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHardwarePciSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleHardwarePciSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleHardwarePciSingleQueryKey(node, pciid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleHardwarePciSingle>>
  > = ({ signal }) => getNodesSingleHardwarePciSingle(node, pciid, signal);

  return { queryKey, queryFn, enabled: !!(node && pciid), ...queryOptions };
};

export type GetNodesSingleHardwarePciSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleHardwarePciSingle>>
>;
export type GetNodesSingleHardwarePciSingleQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleHardwarePciSingle
 */
export const useGetNodesSingleHardwarePciSingle = <
  TData = Awaited<ReturnType<typeof getNodesSingleHardwarePciSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  pciid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHardwarePciSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleHardwarePciSingleQueryOptions(
    node,
    pciid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List mediated device types for given PCI device.
 * @summary getNodesSingleHardwarePciSingleMdev
 */
export const getNodesSingleHardwarePciSingleMdev = (
  node: string,
  pciid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleHardwarePciSingleMdevResponseResponse>({
    url: `/nodes/${node}/hardware/pci/${pciid}/mdev`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleHardwarePciSingleMdevQueryKey = (
  node: string,
  pciid: string,
) => [`/nodes/${node}/hardware/pci/${pciid}/mdev`] as const;

export const getGetNodesSingleHardwarePciSingleMdevQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleHardwarePciSingleMdev>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  pciid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHardwarePciSingleMdev>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleHardwarePciSingleMdev>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleHardwarePciSingleMdevQueryKey(node, pciid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleHardwarePciSingleMdev>>
  > = ({ signal }) => getNodesSingleHardwarePciSingleMdev(node, pciid, signal);

  return { queryKey, queryFn, enabled: !!(node && pciid), ...queryOptions };
};

export type GetNodesSingleHardwarePciSingleMdevQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleHardwarePciSingleMdev>>
>;
export type GetNodesSingleHardwarePciSingleMdevQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleHardwarePciSingleMdev
 */
export const useGetNodesSingleHardwarePciSingleMdev = <
  TData = Awaited<ReturnType<typeof getNodesSingleHardwarePciSingleMdev>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  pciid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHardwarePciSingleMdev>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleHardwarePciSingleMdevQueryOptions(
    node,
    pciid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get status for all datastores.
 * @summary getNodesSingleStorage
 */
export const getNodesSingleStorage = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleStorageResponseResponse>({
    url: `/nodes/${node}/storage`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleStorageQueryKey = (node: string) =>
  [`/nodes/${node}/storage`] as const;

export const getGetNodesSingleStorageQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorage>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorage>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleStorage>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleStorageQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleStorage>>
  > = ({ signal }) => getNodesSingleStorage(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleStorageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleStorage>>
>;
export type GetNodesSingleStorageQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleStorage
 */
export const useGetNodesSingleStorage = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorage>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorage>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleStorageQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * getNodesSingleStorageSingle
 * @summary getNodesSingleStorageSingle
 */
export const getNodesSingleStorageSingle = (
  node: string,
  storage: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleStorageSingleResponseResponse>({
    url: `/nodes/${node}/storage/${storage}`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleStorageSingleQueryKey = (
  node: string,
  storage: string,
) => [`/nodes/${node}/storage/${storage}`] as const;

export const getGetNodesSingleStorageSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleStorageSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleStorageSingleQueryKey(node, storage);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleStorageSingle>>
  > = ({ signal }) => getNodesSingleStorageSingle(node, storage, signal);

  return { queryKey, queryFn, enabled: !!(node && storage), ...queryOptions };
};

export type GetNodesSingleStorageSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleStorageSingle>>
>;
export type GetNodesSingleStorageSingleQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleStorageSingle
 */
export const useGetNodesSingleStorageSingle = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleStorageSingleQueryOptions(
    node,
    storage,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Prune backups. Only those using the standard naming scheme are considered.
 * @summary deleteNodesSingleStorageSinglePrunebackups
 */
export const deleteNodesSingleStorageSinglePrunebackups = (
  node: string,
  storage: string,
) => {
  return apiInstance<DeleteNodesSingleStorageSinglePrunebackupsResponseResponse>(
    { url: `/nodes/${node}/storage/${storage}/prunebackups`, method: "delete" },
  );
};

export const getDeleteNodesSingleStorageSinglePrunebackupsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleStorageSinglePrunebackups>>,
    TError,
    { node: string; storage: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleStorageSinglePrunebackups>>,
  TError,
  { node: string; storage: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleStorageSinglePrunebackups>>,
    { node: string; storage: string }
  > = (props) => {
    const { node, storage } = props ?? {};

    return deleteNodesSingleStorageSinglePrunebackups(node, storage);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleStorageSinglePrunebackupsMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteNodesSingleStorageSinglePrunebackups>>
  >;

export type DeleteNodesSingleStorageSinglePrunebackupsMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleStorageSinglePrunebackups
 */
export const useDeleteNodesSingleStorageSinglePrunebackups = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleStorageSinglePrunebackups>>,
    TError,
    { node: string; storage: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleStorageSinglePrunebackupsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get prune information for backups. NOTE: this is only a preview and might not be what a subsequent prune call does if backups are removed/added in the meantime.
 * @summary getNodesSingleStorageSinglePrunebackups
 */
export const getNodesSingleStorageSinglePrunebackups = (
  node: string,
  storage: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleStorageSinglePrunebackupsResponseResponse>({
    url: `/nodes/${node}/storage/${storage}/prunebackups`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleStorageSinglePrunebackupsQueryKey = (
  node: string,
  storage: string,
) => [`/nodes/${node}/storage/${storage}/prunebackups`] as const;

export const getGetNodesSingleStorageSinglePrunebackupsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSinglePrunebackups>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSinglePrunebackups>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleStorageSinglePrunebackups>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleStorageSinglePrunebackupsQueryKey(node, storage);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleStorageSinglePrunebackups>>
  > = ({ signal }) =>
    getNodesSingleStorageSinglePrunebackups(node, storage, signal);

  return { queryKey, queryFn, enabled: !!(node && storage), ...queryOptions };
};

export type GetNodesSingleStorageSinglePrunebackupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleStorageSinglePrunebackups>>
>;
export type GetNodesSingleStorageSinglePrunebackupsQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleStorageSinglePrunebackups
 */
export const useGetNodesSingleStorageSinglePrunebackups = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSinglePrunebackups>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSinglePrunebackups>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleStorageSinglePrunebackupsQueryOptions(
    node,
    storage,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List storage content.
 * @summary getNodesSingleStorageSingleContent
 */
export const getNodesSingleStorageSingleContent = (
  node: string,
  storage: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleStorageSingleContentResponseResponse>({
    url: `/nodes/${node}/storage/${storage}/content`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleStorageSingleContentQueryKey = (
  node: string,
  storage: string,
) => [`/nodes/${node}/storage/${storage}/content`] as const;

export const getGetNodesSingleStorageSingleContentQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleContent>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleContent>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleContent>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleStorageSingleContentQueryKey(node, storage);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleStorageSingleContent>>
  > = ({ signal }) => getNodesSingleStorageSingleContent(node, storage, signal);

  return { queryKey, queryFn, enabled: !!(node && storage), ...queryOptions };
};

export type GetNodesSingleStorageSingleContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleContent>>
>;
export type GetNodesSingleStorageSingleContentQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleStorageSingleContent
 */
export const useGetNodesSingleStorageSingleContent = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleContent>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleContent>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleStorageSingleContentQueryOptions(
    node,
    storage,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Allocate disk images.
 * @summary createNodesSingleStorageSingleContent
 */
export const createNodesSingleStorageSingleContent = (
  node: string,
  storage: string,
  createNodesSingleStorageSingleContentRequest: CreateNodesSingleStorageSingleContentRequest,
) => {
  return apiInstance<CreateNodesSingleStorageSingleContentResponseResponse>({
    url: `/nodes/${node}/storage/${storage}/content`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleStorageSingleContentRequest,
  });
};

export const getCreateNodesSingleStorageSingleContentMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleContent>>,
    TError,
    {
      node: string;
      storage: string;
      data: CreateNodesSingleStorageSingleContentRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleStorageSingleContent>>,
  TError,
  {
    node: string;
    storage: string;
    data: CreateNodesSingleStorageSingleContentRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleContent>>,
    {
      node: string;
      storage: string;
      data: CreateNodesSingleStorageSingleContentRequest;
    }
  > = (props) => {
    const { node, storage, data } = props ?? {};

    return createNodesSingleStorageSingleContent(node, storage, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleStorageSingleContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleStorageSingleContent>>
>;
export type CreateNodesSingleStorageSingleContentMutationBody =
  CreateNodesSingleStorageSingleContentRequest;
export type CreateNodesSingleStorageSingleContentMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleStorageSingleContent
 */
export const useCreateNodesSingleStorageSingleContent = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleContent>>,
    TError,
    {
      node: string;
      storage: string;
      data: CreateNodesSingleStorageSingleContentRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleStorageSingleContentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete volume
 * @summary deleteNodesSingleStorageSingleContentSingle
 */
export const deleteNodesSingleStorageSingleContentSingle = (
  node: string,
  storage: string,
  volume: string,
) => {
  return apiInstance<DeleteNodesSingleStorageSingleContentSingleResponseResponse>(
    {
      url: `/nodes/${node}/storage/${storage}/content/${volume}`,
      method: "delete",
    },
  );
};

export const getDeleteNodesSingleStorageSingleContentSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleStorageSingleContentSingle>>,
    TError,
    { node: string; storage: string; volume: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleStorageSingleContentSingle>>,
  TError,
  { node: string; storage: string; volume: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleStorageSingleContentSingle>>,
    { node: string; storage: string; volume: string }
  > = (props) => {
    const { node, storage, volume } = props ?? {};

    return deleteNodesSingleStorageSingleContentSingle(node, storage, volume);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleStorageSingleContentSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteNodesSingleStorageSingleContentSingle>>
  >;

export type DeleteNodesSingleStorageSingleContentSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleStorageSingleContentSingle
 */
export const useDeleteNodesSingleStorageSingleContentSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleStorageSingleContentSingle>>,
    TError,
    { node: string; storage: string; volume: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleStorageSingleContentSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get volume attributes
 * @summary getNodesSingleStorageSingleContentSingle
 */
export const getNodesSingleStorageSingleContentSingle = (
  node: string,
  storage: string,
  volume: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleStorageSingleContentSingleResponseResponse>({
    url: `/nodes/${node}/storage/${storage}/content/${volume}`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleStorageSingleContentSingleQueryKey = (
  node: string,
  storage: string,
  volume: string,
) => [`/nodes/${node}/storage/${storage}/content/${volume}`] as const;

export const getGetNodesSingleStorageSingleContentSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleContentSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  volume: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleContentSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleContentSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleStorageSingleContentSingleQueryKey(node, storage, volume);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleStorageSingleContentSingle>>
  > = ({ signal }) =>
    getNodesSingleStorageSingleContentSingle(node, storage, volume, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(node && storage && volume),
    ...queryOptions,
  };
};

export type GetNodesSingleStorageSingleContentSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleContentSingle>>
>;
export type GetNodesSingleStorageSingleContentSingleQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleStorageSingleContentSingle
 */
export const useGetNodesSingleStorageSingleContentSingle = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleContentSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  volume: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleContentSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleStorageSingleContentSingleQueryOptions(
    node,
    storage,
    volume,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Copy a volume. This is experimental code - do not use.
 * @summary createNodesSingleStorageSingleContentSingle
 */
export const createNodesSingleStorageSingleContentSingle = (
  node: string,
  storage: string,
  volume: string,
  createNodesSingleStorageSingleContentSingleRequest: CreateNodesSingleStorageSingleContentSingleRequest,
) => {
  return apiInstance<CreateNodesSingleStorageSingleContentSingleResponseResponse>(
    {
      url: `/nodes/${node}/storage/${storage}/content/${volume}`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleStorageSingleContentSingleRequest,
    },
  );
};

export const getCreateNodesSingleStorageSingleContentSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleContentSingle>>,
    TError,
    {
      node: string;
      storage: string;
      volume: string;
      data: CreateNodesSingleStorageSingleContentSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleStorageSingleContentSingle>>,
  TError,
  {
    node: string;
    storage: string;
    volume: string;
    data: CreateNodesSingleStorageSingleContentSingleRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleContentSingle>>,
    {
      node: string;
      storage: string;
      volume: string;
      data: CreateNodesSingleStorageSingleContentSingleRequest;
    }
  > = (props) => {
    const { node, storage, volume, data } = props ?? {};

    return createNodesSingleStorageSingleContentSingle(
      node,
      storage,
      volume,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleStorageSingleContentSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleContentSingle>>
  >;
export type CreateNodesSingleStorageSingleContentSingleMutationBody =
  CreateNodesSingleStorageSingleContentSingleRequest;
export type CreateNodesSingleStorageSingleContentSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleStorageSingleContentSingle
 */
export const useCreateNodesSingleStorageSingleContentSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleContentSingle>>,
    TError,
    {
      node: string;
      storage: string;
      volume: string;
      data: CreateNodesSingleStorageSingleContentSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleStorageSingleContentSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Update volume attributes
 * @summary updateNodesSingleStorageSingleContentSingle
 */
export const updateNodesSingleStorageSingleContentSingle = (
  node: string,
  storage: string,
  volume: string,
  updateNodesSingleStorageSingleContentSingleRequest: UpdateNodesSingleStorageSingleContentSingleRequest,
) => {
  return apiInstance<UpdateNodesSingleStorageSingleContentSingleResponseResponse>(
    {
      url: `/nodes/${node}/storage/${storage}/content/${volume}`,
      method: "put",
      headers: { "Content-Type": "application/json" },
      data: updateNodesSingleStorageSingleContentSingleRequest,
    },
  );
};

export const getUpdateNodesSingleStorageSingleContentSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleStorageSingleContentSingle>>,
    TError,
    {
      node: string;
      storage: string;
      volume: string;
      data: UpdateNodesSingleStorageSingleContentSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleStorageSingleContentSingle>>,
  TError,
  {
    node: string;
    storage: string;
    volume: string;
    data: UpdateNodesSingleStorageSingleContentSingleRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleStorageSingleContentSingle>>,
    {
      node: string;
      storage: string;
      volume: string;
      data: UpdateNodesSingleStorageSingleContentSingleRequest;
    }
  > = (props) => {
    const { node, storage, volume, data } = props ?? {};

    return updateNodesSingleStorageSingleContentSingle(
      node,
      storage,
      volume,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleStorageSingleContentSingleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateNodesSingleStorageSingleContentSingle>>
  >;
export type UpdateNodesSingleStorageSingleContentSingleMutationBody =
  UpdateNodesSingleStorageSingleContentSingleRequest;
export type UpdateNodesSingleStorageSingleContentSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary updateNodesSingleStorageSingleContentSingle
 */
export const useUpdateNodesSingleStorageSingleContentSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleStorageSingleContentSingle>>,
    TError,
    {
      node: string;
      storage: string;
      volume: string;
      data: UpdateNodesSingleStorageSingleContentSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleStorageSingleContentSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read storage status.
 * @summary getNodesSingleStorageSingleStatus
 */
export const getNodesSingleStorageSingleStatus = (
  node: string,
  storage: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleStorageSingleStatusResponseResponse>({
    url: `/nodes/${node}/storage/${storage}/status`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleStorageSingleStatusQueryKey = (
  node: string,
  storage: string,
) => [`/nodes/${node}/storage/${storage}/status`] as const;

export const getGetNodesSingleStorageSingleStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleStatus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleStorageSingleStatusQueryKey(node, storage);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleStorageSingleStatus>>
  > = ({ signal }) => getNodesSingleStorageSingleStatus(node, storage, signal);

  return { queryKey, queryFn, enabled: !!(node && storage), ...queryOptions };
};

export type GetNodesSingleStorageSingleStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleStatus>>
>;
export type GetNodesSingleStorageSingleStatusQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleStorageSingleStatus
 */
export const useGetNodesSingleStorageSingleStatus = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleStatus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleStorageSingleStatusQueryOptions(
    node,
    storage,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read storage RRD statistics (returns PNG).
 * @summary getNodesSingleStorageSingleRrd
 */
export const getNodesSingleStorageSingleRrd = (
  node: string,
  storage: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleStorageSingleRrdResponseResponse>({
    url: `/nodes/${node}/storage/${storage}/rrd`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleStorageSingleRrdQueryKey = (
  node: string,
  storage: string,
) => [`/nodes/${node}/storage/${storage}/rrd`] as const;

export const getGetNodesSingleStorageSingleRrdQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleRrd>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleRrd>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleRrd>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleStorageSingleRrdQueryKey(node, storage);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleStorageSingleRrd>>
  > = ({ signal }) => getNodesSingleStorageSingleRrd(node, storage, signal);

  return { queryKey, queryFn, enabled: !!(node && storage), ...queryOptions };
};

export type GetNodesSingleStorageSingleRrdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleRrd>>
>;
export type GetNodesSingleStorageSingleRrdQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleStorageSingleRrd
 */
export const useGetNodesSingleStorageSingleRrd = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleRrd>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleRrd>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleStorageSingleRrdQueryOptions(
    node,
    storage,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read storage RRD statistics.
 * @summary getNodesSingleStorageSingleRrddata
 */
export const getNodesSingleStorageSingleRrddata = (
  node: string,
  storage: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleStorageSingleRrddataResponseResponse>({
    url: `/nodes/${node}/storage/${storage}/rrddata`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleStorageSingleRrddataQueryKey = (
  node: string,
  storage: string,
) => [`/nodes/${node}/storage/${storage}/rrddata`] as const;

export const getGetNodesSingleStorageSingleRrddataQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleRrddata>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleRrddata>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleRrddata>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleStorageSingleRrddataQueryKey(node, storage);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleStorageSingleRrddata>>
  > = ({ signal }) => getNodesSingleStorageSingleRrddata(node, storage, signal);

  return { queryKey, queryFn, enabled: !!(node && storage), ...queryOptions };
};

export type GetNodesSingleStorageSingleRrddataQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleStorageSingleRrddata>>
>;
export type GetNodesSingleStorageSingleRrddataQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleStorageSingleRrddata
 */
export const useGetNodesSingleStorageSingleRrddata = <
  TData = Awaited<ReturnType<typeof getNodesSingleStorageSingleRrddata>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStorageSingleRrddata>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleStorageSingleRrddataQueryOptions(
    node,
    storage,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Upload templates and ISO images.
 * @summary createNodesSingleStorageSingleUpload
 */
export const createNodesSingleStorageSingleUpload = (
  node: string,
  storage: string,
  createNodesSingleStorageSingleUploadRequest: CreateNodesSingleStorageSingleUploadRequest,
) => {
  return apiInstance<CreateNodesSingleStorageSingleUploadResponseResponse>({
    url: `/nodes/${node}/storage/${storage}/upload`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleStorageSingleUploadRequest,
  });
};

export const getCreateNodesSingleStorageSingleUploadMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleUpload>>,
    TError,
    {
      node: string;
      storage: string;
      data: CreateNodesSingleStorageSingleUploadRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleStorageSingleUpload>>,
  TError,
  {
    node: string;
    storage: string;
    data: CreateNodesSingleStorageSingleUploadRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleUpload>>,
    {
      node: string;
      storage: string;
      data: CreateNodesSingleStorageSingleUploadRequest;
    }
  > = (props) => {
    const { node, storage, data } = props ?? {};

    return createNodesSingleStorageSingleUpload(node, storage, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleStorageSingleUploadMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleStorageSingleUpload>>
>;
export type CreateNodesSingleStorageSingleUploadMutationBody =
  CreateNodesSingleStorageSingleUploadRequest;
export type CreateNodesSingleStorageSingleUploadMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleStorageSingleUpload
 */
export const useCreateNodesSingleStorageSingleUpload = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStorageSingleUpload>>,
    TError,
    {
      node: string;
      storage: string;
      data: CreateNodesSingleStorageSingleUploadRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleStorageSingleUploadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Node index.
 * @summary getNodesSingleDisks
 */
export const getNodesSingleDisks = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleDisksResponseResponse>({
    url: `/nodes/${node}/disks`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleDisksQueryKey = (node: string) =>
  [`/nodes/${node}/disks`] as const;

export const getGetNodesSingleDisksQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisks>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisks>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleDisks>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleDisksQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleDisks>>
  > = ({ signal }) => getNodesSingleDisks(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleDisksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleDisks>>
>;
export type GetNodesSingleDisksQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleDisks
 */
export const useGetNodesSingleDisks = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisks>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisks>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleDisksQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List LVM Volume Groups
 * @summary getNodesSingleDisksLvm
 */
export const getNodesSingleDisksLvm = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleDisksLvmResponseResponse>({
    url: `/nodes/${node}/disks/lvm`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleDisksLvmQueryKey = (node: string) =>
  [`/nodes/${node}/disks/lvm`] as const;

export const getGetNodesSingleDisksLvmQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksLvm>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksLvm>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleDisksLvm>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleDisksLvmQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleDisksLvm>>
  > = ({ signal }) => getNodesSingleDisksLvm(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleDisksLvmQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleDisksLvm>>
>;
export type GetNodesSingleDisksLvmQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleDisksLvm
 */
export const useGetNodesSingleDisksLvm = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksLvm>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksLvm>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleDisksLvmQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create an LVM Volume Group
 * @summary createNodesSingleDisksLvm
 */
export const createNodesSingleDisksLvm = (
  node: string,
  createNodesSingleDisksLvmRequest: CreateNodesSingleDisksLvmRequest,
) => {
  return apiInstance<CreateNodesSingleDisksLvmResponseResponse>({
    url: `/nodes/${node}/disks/lvm`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleDisksLvmRequest,
  });
};

export const getCreateNodesSingleDisksLvmMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksLvm>>,
    TError,
    { node: string; data: CreateNodesSingleDisksLvmRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleDisksLvm>>,
  TError,
  { node: string; data: CreateNodesSingleDisksLvmRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleDisksLvm>>,
    { node: string; data: CreateNodesSingleDisksLvmRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleDisksLvm(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleDisksLvmMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleDisksLvm>>
>;
export type CreateNodesSingleDisksLvmMutationBody =
  CreateNodesSingleDisksLvmRequest;
export type CreateNodesSingleDisksLvmMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleDisksLvm
 */
export const useCreateNodesSingleDisksLvm = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksLvm>>,
    TError,
    { node: string; data: CreateNodesSingleDisksLvmRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleDisksLvmMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List LVM thinpools
 * @summary getNodesSingleDisksLvmthin
 */
export const getNodesSingleDisksLvmthin = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleDisksLvmthinResponseResponse>({
    url: `/nodes/${node}/disks/lvmthin`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleDisksLvmthinQueryKey = (node: string) =>
  [`/nodes/${node}/disks/lvmthin`] as const;

export const getGetNodesSingleDisksLvmthinQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksLvmthin>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksLvmthin>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleDisksLvmthin>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleDisksLvmthinQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleDisksLvmthin>>
  > = ({ signal }) => getNodesSingleDisksLvmthin(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleDisksLvmthinQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleDisksLvmthin>>
>;
export type GetNodesSingleDisksLvmthinQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleDisksLvmthin
 */
export const useGetNodesSingleDisksLvmthin = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksLvmthin>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksLvmthin>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleDisksLvmthinQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create an LVM thinpool
 * @summary createNodesSingleDisksLvmthin
 */
export const createNodesSingleDisksLvmthin = (
  node: string,
  createNodesSingleDisksLvmthinRequest: CreateNodesSingleDisksLvmthinRequest,
) => {
  return apiInstance<CreateNodesSingleDisksLvmthinResponseResponse>({
    url: `/nodes/${node}/disks/lvmthin`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleDisksLvmthinRequest,
  });
};

export const getCreateNodesSingleDisksLvmthinMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksLvmthin>>,
    TError,
    { node: string; data: CreateNodesSingleDisksLvmthinRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleDisksLvmthin>>,
  TError,
  { node: string; data: CreateNodesSingleDisksLvmthinRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleDisksLvmthin>>,
    { node: string; data: CreateNodesSingleDisksLvmthinRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleDisksLvmthin(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleDisksLvmthinMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleDisksLvmthin>>
>;
export type CreateNodesSingleDisksLvmthinMutationBody =
  CreateNodesSingleDisksLvmthinRequest;
export type CreateNodesSingleDisksLvmthinMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleDisksLvmthin
 */
export const useCreateNodesSingleDisksLvmthin = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksLvmthin>>,
    TError,
    { node: string; data: CreateNodesSingleDisksLvmthinRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleDisksLvmthinMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * PVE Managed Directory storages.
 * @summary getNodesSingleDisksDirectory
 */
export const getNodesSingleDisksDirectory = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleDisksDirectoryResponseResponse>({
    url: `/nodes/${node}/disks/directory`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleDisksDirectoryQueryKey = (node: string) =>
  [`/nodes/${node}/disks/directory`] as const;

export const getGetNodesSingleDisksDirectoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksDirectory>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksDirectory>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleDisksDirectory>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleDisksDirectoryQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleDisksDirectory>>
  > = ({ signal }) => getNodesSingleDisksDirectory(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleDisksDirectoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleDisksDirectory>>
>;
export type GetNodesSingleDisksDirectoryQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleDisksDirectory
 */
export const useGetNodesSingleDisksDirectory = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksDirectory>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksDirectory>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleDisksDirectoryQueryOptions(
    node,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a Filesystem on an unused disk. Will be mounted under '/mnt/pve/NAME'.
 * @summary createNodesSingleDisksDirectory
 */
export const createNodesSingleDisksDirectory = (
  node: string,
  createNodesSingleDisksDirectoryRequest: CreateNodesSingleDisksDirectoryRequest,
) => {
  return apiInstance<CreateNodesSingleDisksDirectoryResponseResponse>({
    url: `/nodes/${node}/disks/directory`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleDisksDirectoryRequest,
  });
};

export const getCreateNodesSingleDisksDirectoryMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksDirectory>>,
    TError,
    { node: string; data: CreateNodesSingleDisksDirectoryRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleDisksDirectory>>,
  TError,
  { node: string; data: CreateNodesSingleDisksDirectoryRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleDisksDirectory>>,
    { node: string; data: CreateNodesSingleDisksDirectoryRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleDisksDirectory(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleDisksDirectoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleDisksDirectory>>
>;
export type CreateNodesSingleDisksDirectoryMutationBody =
  CreateNodesSingleDisksDirectoryRequest;
export type CreateNodesSingleDisksDirectoryMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleDisksDirectory
 */
export const useCreateNodesSingleDisksDirectory = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksDirectory>>,
    TError,
    { node: string; data: CreateNodesSingleDisksDirectoryRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleDisksDirectoryMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * List Zpools.
 * @summary getNodesSingleDisksZfs
 */
export const getNodesSingleDisksZfs = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleDisksZfsResponseResponse>({
    url: `/nodes/${node}/disks/zfs`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleDisksZfsQueryKey = (node: string) =>
  [`/nodes/${node}/disks/zfs`] as const;

export const getGetNodesSingleDisksZfsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksZfs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksZfs>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleDisksZfs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleDisksZfsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleDisksZfs>>
  > = ({ signal }) => getNodesSingleDisksZfs(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleDisksZfsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleDisksZfs>>
>;
export type GetNodesSingleDisksZfsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleDisksZfs
 */
export const useGetNodesSingleDisksZfs = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksZfs>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksZfs>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleDisksZfsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a ZFS pool.
 * @summary createNodesSingleDisksZfs
 */
export const createNodesSingleDisksZfs = (
  node: string,
  createNodesSingleDisksZfsRequest: CreateNodesSingleDisksZfsRequest,
) => {
  return apiInstance<CreateNodesSingleDisksZfsResponseResponse>({
    url: `/nodes/${node}/disks/zfs`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleDisksZfsRequest,
  });
};

export const getCreateNodesSingleDisksZfsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksZfs>>,
    TError,
    { node: string; data: CreateNodesSingleDisksZfsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleDisksZfs>>,
  TError,
  { node: string; data: CreateNodesSingleDisksZfsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleDisksZfs>>,
    { node: string; data: CreateNodesSingleDisksZfsRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleDisksZfs(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleDisksZfsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleDisksZfs>>
>;
export type CreateNodesSingleDisksZfsMutationBody =
  CreateNodesSingleDisksZfsRequest;
export type CreateNodesSingleDisksZfsMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleDisksZfs
 */
export const useCreateNodesSingleDisksZfs = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksZfs>>,
    TError,
    { node: string; data: CreateNodesSingleDisksZfsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleDisksZfsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get details about a zpool.
 * @summary getNodesSingleDisksZfsSingle
 */
export const getNodesSingleDisksZfsSingle = (
  node: string,
  name: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleDisksZfsSingleResponseResponse>({
    url: `/nodes/${node}/disks/zfs/${name}`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleDisksZfsSingleQueryKey = (
  node: string,
  name: string,
) => [`/nodes/${node}/disks/zfs/${name}`] as const;

export const getGetNodesSingleDisksZfsSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksZfsSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksZfsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleDisksZfsSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleDisksZfsSingleQueryKey(node, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleDisksZfsSingle>>
  > = ({ signal }) => getNodesSingleDisksZfsSingle(node, name, signal);

  return { queryKey, queryFn, enabled: !!(node && name), ...queryOptions };
};

export type GetNodesSingleDisksZfsSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleDisksZfsSingle>>
>;
export type GetNodesSingleDisksZfsSingleQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleDisksZfsSingle
 */
export const useGetNodesSingleDisksZfsSingle = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksZfsSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksZfsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleDisksZfsSingleQueryOptions(
    node,
    name,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List local disks.
 * @summary getNodesSingleDisksList
 */
export const getNodesSingleDisksList = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleDisksListResponseResponse>({
    url: `/nodes/${node}/disks/list`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleDisksListQueryKey = (node: string) =>
  [`/nodes/${node}/disks/list`] as const;

export const getGetNodesSingleDisksListQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksList>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksList>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleDisksList>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleDisksListQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleDisksList>>
  > = ({ signal }) => getNodesSingleDisksList(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleDisksListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleDisksList>>
>;
export type GetNodesSingleDisksListQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleDisksList
 */
export const useGetNodesSingleDisksList = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksList>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksList>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleDisksListQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get SMART Health of a disk.
 * @summary getNodesSingleDisksSmart
 */
export const getNodesSingleDisksSmart = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleDisksSmartResponseResponse>({
    url: `/nodes/${node}/disks/smart`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleDisksSmartQueryKey = (node: string) =>
  [`/nodes/${node}/disks/smart`] as const;

export const getGetNodesSingleDisksSmartQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksSmart>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksSmart>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleDisksSmart>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleDisksSmartQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleDisksSmart>>
  > = ({ signal }) => getNodesSingleDisksSmart(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleDisksSmartQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleDisksSmart>>
>;
export type GetNodesSingleDisksSmartQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleDisksSmart
 */
export const useGetNodesSingleDisksSmart = <
  TData = Awaited<ReturnType<typeof getNodesSingleDisksSmart>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDisksSmart>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleDisksSmartQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Initialize Disk with GPT
 * @summary createNodesSingleDisksInitgpt
 */
export const createNodesSingleDisksInitgpt = (
  node: string,
  createNodesSingleDisksInitgptRequest: CreateNodesSingleDisksInitgptRequest,
) => {
  return apiInstance<CreateNodesSingleDisksInitgptResponseResponse>({
    url: `/nodes/${node}/disks/initgpt`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleDisksInitgptRequest,
  });
};

export const getCreateNodesSingleDisksInitgptMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksInitgpt>>,
    TError,
    { node: string; data: CreateNodesSingleDisksInitgptRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleDisksInitgpt>>,
  TError,
  { node: string; data: CreateNodesSingleDisksInitgptRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleDisksInitgpt>>,
    { node: string; data: CreateNodesSingleDisksInitgptRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleDisksInitgpt(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleDisksInitgptMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleDisksInitgpt>>
>;
export type CreateNodesSingleDisksInitgptMutationBody =
  CreateNodesSingleDisksInitgptRequest;
export type CreateNodesSingleDisksInitgptMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleDisksInitgpt
 */
export const useCreateNodesSingleDisksInitgpt = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleDisksInitgpt>>,
    TError,
    { node: string; data: CreateNodesSingleDisksInitgptRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleDisksInitgptMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index for apt (Advanced Package Tool).
 * @summary getNodesSingleApt
 */
export const getNodesSingleApt = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleAptResponseResponse>({
    url: `/nodes/${node}/apt`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleAptQueryKey = (node: string) =>
  [`/nodes/${node}/apt`] as const;

export const getGetNodesSingleAptQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleApt>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleApt>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleApt>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodesSingleAptQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleApt>>
  > = ({ signal }) => getNodesSingleApt(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleAptQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleApt>>
>;
export type GetNodesSingleAptQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleApt
 */
export const useGetNodesSingleApt = <
  TData = Awaited<ReturnType<typeof getNodesSingleApt>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleApt>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleAptQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List available updates.
 * @summary getNodesSingleAptUpdate
 */
export const getNodesSingleAptUpdate = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleAptUpdateResponseResponse>({
    url: `/nodes/${node}/apt/update`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleAptUpdateQueryKey = (node: string) =>
  [`/nodes/${node}/apt/update`] as const;

export const getGetNodesSingleAptUpdateQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleAptUpdate>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleAptUpdate>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleAptUpdate>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleAptUpdateQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleAptUpdate>>
  > = ({ signal }) => getNodesSingleAptUpdate(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleAptUpdateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleAptUpdate>>
>;
export type GetNodesSingleAptUpdateQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleAptUpdate
 */
export const useGetNodesSingleAptUpdate = <
  TData = Awaited<ReturnType<typeof getNodesSingleAptUpdate>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleAptUpdate>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleAptUpdateQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * This is used to resynchronize the package index files from their sources (apt-get update).
 * @summary createNodesSingleAptUpdate
 */
export const createNodesSingleAptUpdate = (
  node: string,
  createNodesSingleAptUpdateRequest: CreateNodesSingleAptUpdateRequest,
) => {
  return apiInstance<CreateNodesSingleAptUpdateResponseResponse>({
    url: `/nodes/${node}/apt/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleAptUpdateRequest,
  });
};

export const getCreateNodesSingleAptUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleAptUpdate>>,
    TError,
    { node: string; data: CreateNodesSingleAptUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleAptUpdate>>,
  TError,
  { node: string; data: CreateNodesSingleAptUpdateRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleAptUpdate>>,
    { node: string; data: CreateNodesSingleAptUpdateRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleAptUpdate(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleAptUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleAptUpdate>>
>;
export type CreateNodesSingleAptUpdateMutationBody =
  CreateNodesSingleAptUpdateRequest;
export type CreateNodesSingleAptUpdateMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleAptUpdate
 */
export const useCreateNodesSingleAptUpdate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleAptUpdate>>,
    TError,
    { node: string; data: CreateNodesSingleAptUpdateRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleAptUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get package changelogs.
 * @summary getNodesSingleAptChangelog
 */
export const getNodesSingleAptChangelog = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleAptChangelogResponseResponse>({
    url: `/nodes/${node}/apt/changelog`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleAptChangelogQueryKey = (node: string) =>
  [`/nodes/${node}/apt/changelog`] as const;

export const getGetNodesSingleAptChangelogQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleAptChangelog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleAptChangelog>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleAptChangelog>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleAptChangelogQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleAptChangelog>>
  > = ({ signal }) => getNodesSingleAptChangelog(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleAptChangelogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleAptChangelog>>
>;
export type GetNodesSingleAptChangelogQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleAptChangelog
 */
export const useGetNodesSingleAptChangelog = <
  TData = Awaited<ReturnType<typeof getNodesSingleAptChangelog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleAptChangelog>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleAptChangelogQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get package information for important Proxmox packages.
 * @summary getNodesSingleAptVersions
 */
export const getNodesSingleAptVersions = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleAptVersionsResponseResponse>({
    url: `/nodes/${node}/apt/versions`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleAptVersionsQueryKey = (node: string) =>
  [`/nodes/${node}/apt/versions`] as const;

export const getGetNodesSingleAptVersionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleAptVersions>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleAptVersions>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleAptVersions>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleAptVersionsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleAptVersions>>
  > = ({ signal }) => getNodesSingleAptVersions(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleAptVersionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleAptVersions>>
>;
export type GetNodesSingleAptVersionsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleAptVersions
 */
export const useGetNodesSingleAptVersions = <
  TData = Awaited<ReturnType<typeof getNodesSingleAptVersions>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleAptVersions>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleAptVersionsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Directory index.
 * @summary getNodeFirewall
 */
export const getNodeFirewall = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodeFirewallResponseResponse>({
    url: `/nodes/${node}/firewall`,
    method: "get",
    signal,
  });
};

export const getGetNodeFirewallQueryKey = (node: string) =>
  [`/nodes/${node}/firewall`] as const;

export const getGetNodeFirewallQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeFirewall>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeFirewall>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeFirewall>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeFirewallQueryKey(node);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeFirewall>>> = ({
    signal,
  }) => getNodeFirewall(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodeFirewallQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeFirewall>>
>;
export type GetNodeFirewallQueryError = ErrorType<unknown>;

/**
 * @summary getNodeFirewall
 */
export const useGetNodeFirewall = <
  TData = Awaited<ReturnType<typeof getNodeFirewall>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeFirewall>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeFirewallQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List rules.
 * @summary getNodeFirewallRules
 */
export const getNodeFirewallRules = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodeFirewallRulesResponseResponse>({
    url: `/nodes/${node}/firewall/rules`,
    method: "get",
    signal,
  });
};

export const getGetNodeFirewallRulesQueryKey = (node: string) =>
  [`/nodes/${node}/firewall/rules`] as const;

export const getGetNodeFirewallRulesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeFirewallRules>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeFirewallRules>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeFirewallRules>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodeFirewallRulesQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodeFirewallRules>>
  > = ({ signal }) => getNodeFirewallRules(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodeFirewallRulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeFirewallRules>>
>;
export type GetNodeFirewallRulesQueryError = ErrorType<unknown>;

/**
 * @summary getNodeFirewallRules
 */
export const useGetNodeFirewallRules = <
  TData = Awaited<ReturnType<typeof getNodeFirewallRules>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeFirewallRules>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeFirewallRulesQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new rule.
 * @summary createNodeFirewallRule
 */
export const createNodeFirewallRule = (
  node: string,
  createNodeFirewallRuleRequest: CreateNodeFirewallRuleRequest,
) => {
  return apiInstance<CreateNodeFirewallRuleResponseResponse>({
    url: `/nodes/${node}/firewall/rules`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodeFirewallRuleRequest,
  });
};

export const getCreateNodeFirewallRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodeFirewallRule>>,
    TError,
    { node: string; data: CreateNodeFirewallRuleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodeFirewallRule>>,
  TError,
  { node: string; data: CreateNodeFirewallRuleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodeFirewallRule>>,
    { node: string; data: CreateNodeFirewallRuleRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodeFirewallRule(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodeFirewallRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodeFirewallRule>>
>;
export type CreateNodeFirewallRuleMutationBody = CreateNodeFirewallRuleRequest;
export type CreateNodeFirewallRuleMutationError = ErrorType<unknown>;

/**
 * @summary createNodeFirewallRule
 */
export const useCreateNodeFirewallRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodeFirewallRule>>,
    TError,
    { node: string; data: CreateNodeFirewallRuleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodeFirewallRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete rule.
 * @summary deleteNodeFirewallRule
 */
export const deleteNodeFirewallRule = (node: string, pos: number) => {
  return apiInstance<DeleteNodeFirewallRuleResponseResponse>({
    url: `/nodes/${node}/firewall/rules/${pos}`,
    method: "delete",
  });
};

export const getDeleteNodeFirewallRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodeFirewallRule>>,
    TError,
    { node: string; pos: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodeFirewallRule>>,
  TError,
  { node: string; pos: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodeFirewallRule>>,
    { node: string; pos: number }
  > = (props) => {
    const { node, pos } = props ?? {};

    return deleteNodeFirewallRule(node, pos);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodeFirewallRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodeFirewallRule>>
>;

export type DeleteNodeFirewallRuleMutationError = ErrorType<unknown>;

/**
 * @summary deleteNodeFirewallRule
 */
export const useDeleteNodeFirewallRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodeFirewallRule>>,
    TError,
    { node: string; pos: number },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteNodeFirewallRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get single rule data.
 * @summary getNodeFirewallRule
 */
export const getNodeFirewallRule = (
  node: string,
  pos: number,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodeFirewallRuleResponseResponse>({
    url: `/nodes/${node}/firewall/rules/${pos}`,
    method: "get",
    signal,
  });
};

export const getGetNodeFirewallRuleQueryKey = (node: string, pos: number) =>
  [`/nodes/${node}/firewall/rules/${pos}`] as const;

export const getGetNodeFirewallRuleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeFirewallRule>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeFirewallRule>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeFirewallRule>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodeFirewallRuleQueryKey(node, pos);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodeFirewallRule>>
  > = ({ signal }) => getNodeFirewallRule(node, pos, signal);

  return { queryKey, queryFn, enabled: !!(node && pos), ...queryOptions };
};

export type GetNodeFirewallRuleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeFirewallRule>>
>;
export type GetNodeFirewallRuleQueryError = ErrorType<unknown>;

/**
 * @summary getNodeFirewallRule
 */
export const useGetNodeFirewallRule = <
  TData = Awaited<ReturnType<typeof getNodeFirewallRule>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  pos: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeFirewallRule>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeFirewallRuleQueryOptions(node, pos, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Modify rule data.
 * @summary updateNodeFirewallRule
 */
export const updateNodeFirewallRule = (
  node: string,
  pos: number,
  updateNodeFirewallRuleRequest: UpdateNodeFirewallRuleRequest,
) => {
  return apiInstance<UpdateNodeFirewallRuleResponseResponse>({
    url: `/nodes/${node}/firewall/rules/${pos}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodeFirewallRuleRequest,
  });
};

export const getUpdateNodeFirewallRuleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodeFirewallRule>>,
    TError,
    { node: string; pos: number; data: UpdateNodeFirewallRuleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodeFirewallRule>>,
  TError,
  { node: string; pos: number; data: UpdateNodeFirewallRuleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodeFirewallRule>>,
    { node: string; pos: number; data: UpdateNodeFirewallRuleRequest }
  > = (props) => {
    const { node, pos, data } = props ?? {};

    return updateNodeFirewallRule(node, pos, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodeFirewallRuleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodeFirewallRule>>
>;
export type UpdateNodeFirewallRuleMutationBody = UpdateNodeFirewallRuleRequest;
export type UpdateNodeFirewallRuleMutationError = ErrorType<unknown>;

/**
 * @summary updateNodeFirewallRule
 */
export const useUpdateNodeFirewallRule = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodeFirewallRule>>,
    TError,
    { node: string; pos: number; data: UpdateNodeFirewallRuleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateNodeFirewallRuleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get host firewall options.
 * @summary getNodeFirewallOptions
 */
export const getNodeFirewallOptions = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodeFirewallOptionsResponseResponse>({
    url: `/nodes/${node}/firewall/options`,
    method: "get",
    signal,
  });
};

export const getGetNodeFirewallOptionsQueryKey = (node: string) =>
  [`/nodes/${node}/firewall/options`] as const;

export const getGetNodeFirewallOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeFirewallOptions>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeFirewallOptions>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeFirewallOptions>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodeFirewallOptionsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodeFirewallOptions>>
  > = ({ signal }) => getNodeFirewallOptions(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodeFirewallOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeFirewallOptions>>
>;
export type GetNodeFirewallOptionsQueryError = ErrorType<unknown>;

/**
 * @summary getNodeFirewallOptions
 */
export const useGetNodeFirewallOptions = <
  TData = Awaited<ReturnType<typeof getNodeFirewallOptions>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeFirewallOptions>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeFirewallOptionsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set Firewall options.
 * @summary updateNodeFirewallOptions
 */
export const updateNodeFirewallOptions = (
  node: string,
  updateNodeFirewallOptionsRequest: UpdateNodeFirewallOptionsRequest,
) => {
  return apiInstance<UpdateNodeFirewallOptionsResponseResponse>({
    url: `/nodes/${node}/firewall/options`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodeFirewallOptionsRequest,
  });
};

export const getUpdateNodeFirewallOptionsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodeFirewallOptions>>,
    TError,
    { node: string; data: UpdateNodeFirewallOptionsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodeFirewallOptions>>,
  TError,
  { node: string; data: UpdateNodeFirewallOptionsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodeFirewallOptions>>,
    { node: string; data: UpdateNodeFirewallOptionsRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return updateNodeFirewallOptions(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodeFirewallOptionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodeFirewallOptions>>
>;
export type UpdateNodeFirewallOptionsMutationBody =
  UpdateNodeFirewallOptionsRequest;
export type UpdateNodeFirewallOptionsMutationError = ErrorType<unknown>;

/**
 * @summary updateNodeFirewallOptions
 */
export const useUpdateNodeFirewallOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodeFirewallOptions>>,
    TError,
    { node: string; data: UpdateNodeFirewallOptionsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateNodeFirewallOptionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read firewall log
 * @summary getNodesSingleFirewallLog
 */
export const getNodesSingleFirewallLog = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleFirewallLogResponseResponse>({
    url: `/nodes/${node}/firewall/log`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleFirewallLogQueryKey = (node: string) =>
  [`/nodes/${node}/firewall/log`] as const;

export const getGetNodesSingleFirewallLogQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleFirewallLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleFirewallLog>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleFirewallLog>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleFirewallLogQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleFirewallLog>>
  > = ({ signal }) => getNodesSingleFirewallLog(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleFirewallLogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleFirewallLog>>
>;
export type GetNodesSingleFirewallLogQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleFirewallLog
 */
export const useGetNodesSingleFirewallLog = <
  TData = Awaited<ReturnType<typeof getNodesSingleFirewallLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleFirewallLog>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleFirewallLogQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List status of all replication jobs on this node.
 * @summary getNodesSingleReplication
 */
export const getNodesSingleReplication = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleReplicationResponseResponse>({
    url: `/nodes/${node}/replication`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleReplicationQueryKey = (node: string) =>
  [`/nodes/${node}/replication`] as const;

export const getGetNodesSingleReplicationQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleReplication>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReplication>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleReplication>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleReplicationQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleReplication>>
  > = ({ signal }) => getNodesSingleReplication(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleReplicationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleReplication>>
>;
export type GetNodesSingleReplicationQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleReplication
 */
export const useGetNodesSingleReplication = <
  TData = Awaited<ReturnType<typeof getNodesSingleReplication>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReplication>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleReplicationQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Directory index.
 * @summary getNodesSingleReplicationSingle
 */
export const getNodesSingleReplicationSingle = (
  node: string,
  id: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleReplicationSingleResponseResponse>({
    url: `/nodes/${node}/replication/${id}`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleReplicationSingleQueryKey = (
  node: string,
  id: string,
) => [`/nodes/${node}/replication/${id}`] as const;

export const getGetNodesSingleReplicationSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleReplicationSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReplicationSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleReplicationSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleReplicationSingleQueryKey(node, id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleReplicationSingle>>
  > = ({ signal }) => getNodesSingleReplicationSingle(node, id, signal);

  return { queryKey, queryFn, enabled: !!(node && id), ...queryOptions };
};

export type GetNodesSingleReplicationSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleReplicationSingle>>
>;
export type GetNodesSingleReplicationSingleQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleReplicationSingle
 */
export const useGetNodesSingleReplicationSingle = <
  TData = Awaited<ReturnType<typeof getNodesSingleReplicationSingle>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReplicationSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleReplicationSingleQueryOptions(
    node,
    id,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get replication job status.
 * @summary getNodesSingleReplicationSingleStatus
 */
export const getNodesSingleReplicationSingleStatus = (
  node: string,
  id: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleReplicationSingleStatusResponseResponse>({
    url: `/nodes/${node}/replication/${id}/status`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleReplicationSingleStatusQueryKey = (
  node: string,
  id: string,
) => [`/nodes/${node}/replication/${id}/status`] as const;

export const getGetNodesSingleReplicationSingleStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleReplicationSingleStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReplicationSingleStatus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleReplicationSingleStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleReplicationSingleStatusQueryKey(node, id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleReplicationSingleStatus>>
  > = ({ signal }) => getNodesSingleReplicationSingleStatus(node, id, signal);

  return { queryKey, queryFn, enabled: !!(node && id), ...queryOptions };
};

export type GetNodesSingleReplicationSingleStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleReplicationSingleStatus>>
>;
export type GetNodesSingleReplicationSingleStatusQueryError =
  ErrorType<unknown>;

/**
 * @summary getNodesSingleReplicationSingleStatus
 */
export const useGetNodesSingleReplicationSingleStatus = <
  TData = Awaited<ReturnType<typeof getNodesSingleReplicationSingleStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReplicationSingleStatus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleReplicationSingleStatusQueryOptions(
    node,
    id,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read replication job log.
 * @summary getNodesSingleReplicationSingleLog
 */
export const getNodesSingleReplicationSingleLog = (
  node: string,
  id: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleReplicationSingleLogResponseResponse>({
    url: `/nodes/${node}/replication/${id}/log`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleReplicationSingleLogQueryKey = (
  node: string,
  id: string,
) => [`/nodes/${node}/replication/${id}/log`] as const;

export const getGetNodesSingleReplicationSingleLogQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleReplicationSingleLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReplicationSingleLog>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleReplicationSingleLog>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNodesSingleReplicationSingleLogQueryKey(node, id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleReplicationSingleLog>>
  > = ({ signal }) => getNodesSingleReplicationSingleLog(node, id, signal);

  return { queryKey, queryFn, enabled: !!(node && id), ...queryOptions };
};

export type GetNodesSingleReplicationSingleLogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleReplicationSingleLog>>
>;
export type GetNodesSingleReplicationSingleLogQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleReplicationSingleLog
 */
export const useGetNodesSingleReplicationSingleLog = <
  TData = Awaited<ReturnType<typeof getNodesSingleReplicationSingleLog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReplicationSingleLog>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleReplicationSingleLogQueryOptions(
    node,
    id,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Schedule replication job to start as soon as possible.
 * @summary createNodesSingleReplicationSingleSchedulenow
 */
export const createNodesSingleReplicationSingleSchedulenow = (
  node: string,
  id: string,
  createNodesSingleReplicationSingleSchedulenowRequest: CreateNodesSingleReplicationSingleSchedulenowRequest,
) => {
  return apiInstance<CreateNodesSingleReplicationSingleSchedulenowResponseResponse>(
    {
      url: `/nodes/${node}/replication/${id}/schedule_now`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleReplicationSingleSchedulenowRequest,
    },
  );
};

export const getCreateNodesSingleReplicationSingleSchedulenowMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleReplicationSingleSchedulenow>>,
    TError,
    {
      node: string;
      id: string;
      data: CreateNodesSingleReplicationSingleSchedulenowRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleReplicationSingleSchedulenow>>,
  TError,
  {
    node: string;
    id: string;
    data: CreateNodesSingleReplicationSingleSchedulenowRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleReplicationSingleSchedulenow>>,
    {
      node: string;
      id: string;
      data: CreateNodesSingleReplicationSingleSchedulenowRequest;
    }
  > = (props) => {
    const { node, id, data } = props ?? {};

    return createNodesSingleReplicationSingleSchedulenow(node, id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleReplicationSingleSchedulenowMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleReplicationSingleSchedulenow>>
  >;
export type CreateNodesSingleReplicationSingleSchedulenowMutationBody =
  CreateNodesSingleReplicationSingleSchedulenowRequest;
export type CreateNodesSingleReplicationSingleSchedulenowMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleReplicationSingleSchedulenow
 */
export const useCreateNodesSingleReplicationSingleSchedulenow = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleReplicationSingleSchedulenow>>,
    TError,
    {
      node: string;
      id: string;
      data: CreateNodesSingleReplicationSingleSchedulenowRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleReplicationSingleSchedulenowMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Node index.
 * @summary getNodesSingleCertificates
 */
export const getNodesSingleCertificates = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleCertificatesResponseResponse>({
    url: `/nodes/${node}/certificates`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCertificatesQueryKey = (node: string) =>
  [`/nodes/${node}/certificates`] as const;

export const getGetNodesSingleCertificatesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCertificates>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCertificates>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCertificates>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCertificatesQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCertificates>>
  > = ({ signal }) => getNodesSingleCertificates(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCertificatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCertificates>>
>;
export type GetNodesSingleCertificatesQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCertificates
 */
export const useGetNodesSingleCertificates = <
  TData = Awaited<ReturnType<typeof getNodesSingleCertificates>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCertificates>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCertificatesQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * ACME index.
 * @summary getNodesSingleCertificatesAcme
 */
export const getNodesSingleCertificatesAcme = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleCertificatesAcmeResponseResponse>({
    url: `/nodes/${node}/certificates/acme`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCertificatesAcmeQueryKey = (node: string) =>
  [`/nodes/${node}/certificates/acme`] as const;

export const getGetNodesSingleCertificatesAcmeQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCertificatesAcme>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCertificatesAcme>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCertificatesAcme>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCertificatesAcmeQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCertificatesAcme>>
  > = ({ signal }) => getNodesSingleCertificatesAcme(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCertificatesAcmeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCertificatesAcme>>
>;
export type GetNodesSingleCertificatesAcmeQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCertificatesAcme
 */
export const useGetNodesSingleCertificatesAcme = <
  TData = Awaited<ReturnType<typeof getNodesSingleCertificatesAcme>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCertificatesAcme>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCertificatesAcmeQueryOptions(
    node,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Revoke existing certificate from CA.
 * @summary deleteNodesSingleCertificatesAcmeCertificate
 */
export const deleteNodesSingleCertificatesAcmeCertificate = (node: string) => {
  return apiInstance<DeleteNodesSingleCertificatesAcmeCertificateResponseResponse>(
    { url: `/nodes/${node}/certificates/acme/certificate`, method: "delete" },
  );
};

export const getDeleteNodesSingleCertificatesAcmeCertificateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCertificatesAcmeCertificate>>,
    TError,
    { node: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleCertificatesAcmeCertificate>>,
  TError,
  { node: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleCertificatesAcmeCertificate>>,
    { node: string }
  > = (props) => {
    const { node } = props ?? {};

    return deleteNodesSingleCertificatesAcmeCertificate(node);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleCertificatesAcmeCertificateMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteNodesSingleCertificatesAcmeCertificate>>
  >;

export type DeleteNodesSingleCertificatesAcmeCertificateMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleCertificatesAcmeCertificate
 */
export const useDeleteNodesSingleCertificatesAcmeCertificate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCertificatesAcmeCertificate>>,
    TError,
    { node: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleCertificatesAcmeCertificateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Order a new certificate from ACME-compatible CA.
 * @summary createNodesSingleCertificatesAcmeCertificate
 */
export const createNodesSingleCertificatesAcmeCertificate = (
  node: string,
  createNodesSingleCertificatesAcmeCertificateRequest: CreateNodesSingleCertificatesAcmeCertificateRequest,
) => {
  return apiInstance<CreateNodesSingleCertificatesAcmeCertificateResponseResponse>(
    {
      url: `/nodes/${node}/certificates/acme/certificate`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: createNodesSingleCertificatesAcmeCertificateRequest,
    },
  );
};

export const getCreateNodesSingleCertificatesAcmeCertificateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCertificatesAcmeCertificate>>,
    TError,
    { node: string; data: CreateNodesSingleCertificatesAcmeCertificateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCertificatesAcmeCertificate>>,
  TError,
  { node: string; data: CreateNodesSingleCertificatesAcmeCertificateRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCertificatesAcmeCertificate>>,
    { node: string; data: CreateNodesSingleCertificatesAcmeCertificateRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleCertificatesAcmeCertificate(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCertificatesAcmeCertificateMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createNodesSingleCertificatesAcmeCertificate>>
  >;
export type CreateNodesSingleCertificatesAcmeCertificateMutationBody =
  CreateNodesSingleCertificatesAcmeCertificateRequest;
export type CreateNodesSingleCertificatesAcmeCertificateMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleCertificatesAcmeCertificate
 */
export const useCreateNodesSingleCertificatesAcmeCertificate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCertificatesAcmeCertificate>>,
    TError,
    { node: string; data: CreateNodesSingleCertificatesAcmeCertificateRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCertificatesAcmeCertificateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Renew existing certificate from CA.
 * @summary updateNodesSingleCertificatesAcmeCertificate
 */
export const updateNodesSingleCertificatesAcmeCertificate = (
  node: string,
  updateNodesSingleCertificatesAcmeCertificateRequest: UpdateNodesSingleCertificatesAcmeCertificateRequest,
) => {
  return apiInstance<UpdateNodesSingleCertificatesAcmeCertificateResponseResponse>(
    {
      url: `/nodes/${node}/certificates/acme/certificate`,
      method: "put",
      headers: { "Content-Type": "application/json" },
      data: updateNodesSingleCertificatesAcmeCertificateRequest,
    },
  );
};

export const getUpdateNodesSingleCertificatesAcmeCertificateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleCertificatesAcmeCertificate>>,
    TError,
    { node: string; data: UpdateNodesSingleCertificatesAcmeCertificateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleCertificatesAcmeCertificate>>,
  TError,
  { node: string; data: UpdateNodesSingleCertificatesAcmeCertificateRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleCertificatesAcmeCertificate>>,
    { node: string; data: UpdateNodesSingleCertificatesAcmeCertificateRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return updateNodesSingleCertificatesAcmeCertificate(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleCertificatesAcmeCertificateMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateNodesSingleCertificatesAcmeCertificate>>
  >;
export type UpdateNodesSingleCertificatesAcmeCertificateMutationBody =
  UpdateNodesSingleCertificatesAcmeCertificateRequest;
export type UpdateNodesSingleCertificatesAcmeCertificateMutationError =
  ErrorType<unknown>;

/**
 * @summary updateNodesSingleCertificatesAcmeCertificate
 */
export const useUpdateNodesSingleCertificatesAcmeCertificate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleCertificatesAcmeCertificate>>,
    TError,
    { node: string; data: UpdateNodesSingleCertificatesAcmeCertificateRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateNodesSingleCertificatesAcmeCertificateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get information about node's certificates.
 * @summary getNodesSingleCertificatesInfo
 */
export const getNodesSingleCertificatesInfo = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleCertificatesInfoResponseResponse>({
    url: `/nodes/${node}/certificates/info`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleCertificatesInfoQueryKey = (node: string) =>
  [`/nodes/${node}/certificates/info`] as const;

export const getGetNodesSingleCertificatesInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleCertificatesInfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCertificatesInfo>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleCertificatesInfo>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleCertificatesInfoQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleCertificatesInfo>>
  > = ({ signal }) => getNodesSingleCertificatesInfo(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleCertificatesInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleCertificatesInfo>>
>;
export type GetNodesSingleCertificatesInfoQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleCertificatesInfo
 */
export const useGetNodesSingleCertificatesInfo = <
  TData = Awaited<ReturnType<typeof getNodesSingleCertificatesInfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleCertificatesInfo>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleCertificatesInfoQueryOptions(
    node,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * DELETE custom certificate chain and key.
 * @summary deleteNodesSingleCertificatesCustom
 */
export const deleteNodesSingleCertificatesCustom = (node: string) => {
  return apiInstance<DeleteNodesSingleCertificatesCustomResponseResponse>({
    url: `/nodes/${node}/certificates/custom`,
    method: "delete",
  });
};

export const getDeleteNodesSingleCertificatesCustomMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCertificatesCustom>>,
    TError,
    { node: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNodesSingleCertificatesCustom>>,
  TError,
  { node: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNodesSingleCertificatesCustom>>,
    { node: string }
  > = (props) => {
    const { node } = props ?? {};

    return deleteNodesSingleCertificatesCustom(node);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNodesSingleCertificatesCustomMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNodesSingleCertificatesCustom>>
>;

export type DeleteNodesSingleCertificatesCustomMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteNodesSingleCertificatesCustom
 */
export const useDeleteNodesSingleCertificatesCustom = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodesSingleCertificatesCustom>>,
    TError,
    { node: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteNodesSingleCertificatesCustomMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Upload or update custom certificate chain and key.
 * @summary createNodesSingleCertificatesCustom
 */
export const createNodesSingleCertificatesCustom = (
  node: string,
  createNodesSingleCertificatesCustomRequest: CreateNodesSingleCertificatesCustomRequest,
) => {
  return apiInstance<CreateNodesSingleCertificatesCustomResponseResponse>({
    url: `/nodes/${node}/certificates/custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleCertificatesCustomRequest,
  });
};

export const getCreateNodesSingleCertificatesCustomMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCertificatesCustom>>,
    TError,
    { node: string; data: CreateNodesSingleCertificatesCustomRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleCertificatesCustom>>,
  TError,
  { node: string; data: CreateNodesSingleCertificatesCustomRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleCertificatesCustom>>,
    { node: string; data: CreateNodesSingleCertificatesCustomRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleCertificatesCustom(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleCertificatesCustomMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleCertificatesCustom>>
>;
export type CreateNodesSingleCertificatesCustomMutationBody =
  CreateNodesSingleCertificatesCustomRequest;
export type CreateNodesSingleCertificatesCustomMutationError =
  ErrorType<unknown>;

/**
 * @summary createNodesSingleCertificatesCustom
 */
export const useCreateNodesSingleCertificatesCustom = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleCertificatesCustom>>,
    TError,
    { node: string; data: CreateNodesSingleCertificatesCustomRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleCertificatesCustomMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get node configuration options.
 * @summary getNodesSingleConfig
 */
export const getNodesSingleConfig = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleConfigResponseResponse>({
    url: `/nodes/${node}/config`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleConfigQueryKey = (node: string) =>
  [`/nodes/${node}/config`] as const;

export const getGetNodesSingleConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleConfig>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleConfig>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleConfigQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleConfig>>
  > = ({ signal }) => getNodesSingleConfig(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleConfig>>
>;
export type GetNodesSingleConfigQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleConfig
 */
export const useGetNodesSingleConfig = <
  TData = Awaited<ReturnType<typeof getNodesSingleConfig>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleConfig>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleConfigQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set node configuration options.
 * @summary updateNodesSingleConfig
 */
export const updateNodesSingleConfig = (
  node: string,
  updateNodesSingleConfigRequest: UpdateNodesSingleConfigRequest,
) => {
  return apiInstance<UpdateNodesSingleConfigResponseResponse>({
    url: `/nodes/${node}/config`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleConfigRequest,
  });
};

export const getUpdateNodesSingleConfigMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleConfig>>,
    TError,
    { node: string; data: UpdateNodesSingleConfigRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleConfig>>,
  TError,
  { node: string; data: UpdateNodesSingleConfigRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleConfig>>,
    { node: string; data: UpdateNodesSingleConfigRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return updateNodesSingleConfig(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleConfig>>
>;
export type UpdateNodesSingleConfigMutationBody =
  UpdateNodesSingleConfigRequest;
export type UpdateNodesSingleConfigMutationError = ErrorType<unknown>;

/**
 * @summary updateNodesSingleConfig
 */
export const useUpdateNodesSingleConfig = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleConfig>>,
    TError,
    { node: string; data: UpdateNodesSingleConfigRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateNodesSingleConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * SDN index.
 * @summary getNodeSDN
 */
export const getNodeSDN = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodeSDNResponseResponse>({
    url: `/nodes/${node}/sdn`,
    method: "get",
    signal,
  });
};

export const getGetNodeSDNQueryKey = (node: string) =>
  [`/nodes/${node}/sdn`] as const;

export const getGetNodeSDNQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeSDN>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeSDN>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getNodeSDN>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeSDNQueryKey(node);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeSDN>>> = ({
    signal,
  }) => getNodeSDN(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodeSDNQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeSDN>>
>;
export type GetNodeSDNQueryError = ErrorType<unknown>;

/**
 * @summary getNodeSDN
 */
export const useGetNodeSDN = <
  TData = Awaited<ReturnType<typeof getNodeSDN>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeSDN>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeSDNQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get status for all zones.
 * @summary getNodeSDNZones
 */
export const getNodeSDNZones = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodeSDNZonesResponseResponse>({
    url: `/nodes/${node}/sdn/zones`,
    method: "get",
    signal,
  });
};

export const getGetNodeSDNZonesQueryKey = (node: string) =>
  [`/nodes/${node}/sdn/zones`] as const;

export const getGetNodeSDNZonesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeSDNZones>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeSDNZones>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeSDNZones>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeSDNZonesQueryKey(node);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeSDNZones>>> = ({
    signal,
  }) => getNodeSDNZones(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodeSDNZonesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeSDNZones>>
>;
export type GetNodeSDNZonesQueryError = ErrorType<unknown>;

/**
 * @summary getNodeSDNZones
 */
export const useGetNodeSDNZones = <
  TData = Awaited<ReturnType<typeof getNodeSDNZones>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeSDNZones>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeSDNZonesQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * getNodeSDNZone
 * @summary getNodeSDNZone
 */
export const getNodeSDNZone = (
  node: string,
  zone: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodeSDNZoneResponseResponse>({
    url: `/nodes/${node}/sdn/zones/${zone}`,
    method: "get",
    signal,
  });
};

export const getGetNodeSDNZoneQueryKey = (node: string, zone: string) =>
  [`/nodes/${node}/sdn/zones/${zone}`] as const;

export const getGetNodeSDNZoneQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeSDNZone>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  zone: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeSDNZone>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeSDNZone>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodeSDNZoneQueryKey(node, zone);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeSDNZone>>> = ({
    signal,
  }) => getNodeSDNZone(node, zone, signal);

  return { queryKey, queryFn, enabled: !!(node && zone), ...queryOptions };
};

export type GetNodeSDNZoneQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeSDNZone>>
>;
export type GetNodeSDNZoneQueryError = ErrorType<unknown>;

/**
 * @summary getNodeSDNZone
 */
export const useGetNodeSDNZone = <
  TData = Awaited<ReturnType<typeof getNodeSDNZone>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  zone: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeSDNZone>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeSDNZoneQueryOptions(node, zone, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List zone content.
 * @summary getNodeSDNZoneContent
 */
export const getNodeSDNZoneContent = (
  node: string,
  zone: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodeSDNZoneContentResponseResponse>({
    url: `/nodes/${node}/sdn/zones/${zone}/content`,
    method: "get",
    signal,
  });
};

export const getGetNodeSDNZoneContentQueryKey = (node: string, zone: string) =>
  [`/nodes/${node}/sdn/zones/${zone}/content`] as const;

export const getGetNodeSDNZoneContentQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeSDNZoneContent>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  zone: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeSDNZoneContent>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeSDNZoneContent>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodeSDNZoneContentQueryKey(node, zone);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodeSDNZoneContent>>
  > = ({ signal }) => getNodeSDNZoneContent(node, zone, signal);

  return { queryKey, queryFn, enabled: !!(node && zone), ...queryOptions };
};

export type GetNodeSDNZoneContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeSDNZoneContent>>
>;
export type GetNodeSDNZoneContentQueryError = ErrorType<unknown>;

/**
 * @summary getNodeSDNZoneContent
 */
export const useGetNodeSDNZoneContent = <
  TData = Awaited<ReturnType<typeof getNodeSDNZoneContent>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  zone: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeSDNZoneContent>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeSDNZoneContentQueryOptions(
    node,
    zone,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * API version details
 * @summary getNodesSingleVersion
 */
export const getNodesSingleVersion = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleVersionResponseResponse>({
    url: `/nodes/${node}/version`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleVersionQueryKey = (node: string) =>
  [`/nodes/${node}/version`] as const;

export const getGetNodesSingleVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleVersion>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleVersion>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleVersion>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleVersionQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleVersion>>
  > = ({ signal }) => getNodesSingleVersion(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleVersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleVersion>>
>;
export type GetNodesSingleVersionQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleVersion
 */
export const useGetNodesSingleVersion = <
  TData = Awaited<ReturnType<typeof getNodesSingleVersion>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleVersion>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleVersionQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read node status
 * @summary getNodesSingleStatus
 */
export const getNodesSingleStatus = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleStatusResponseResponse>({
    url: `/nodes/${node}/status`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleStatusQueryKey = (node: string) =>
  [`/nodes/${node}/status`] as const;

export const getGetNodesSingleStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStatus>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleStatusQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleStatus>>
  > = ({ signal }) => getNodesSingleStatus(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleStatus>>
>;
export type GetNodesSingleStatusQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleStatus
 */
export const useGetNodesSingleStatus = <
  TData = Awaited<ReturnType<typeof getNodesSingleStatus>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleStatus>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleStatusQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Reboot or shutdown a node.
 * @summary createNodesSingleStatus
 */
export const createNodesSingleStatus = (
  node: string,
  createNodesSingleStatusRequest: CreateNodesSingleStatusRequest,
) => {
  return apiInstance<CreateNodesSingleStatusResponseResponse>({
    url: `/nodes/${node}/status`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleStatusRequest,
  });
};

export const getCreateNodesSingleStatusMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStatus>>,
    TError,
    { node: string; data: CreateNodesSingleStatusRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleStatus>>,
  TError,
  { node: string; data: CreateNodesSingleStatusRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleStatus>>,
    { node: string; data: CreateNodesSingleStatusRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleStatus(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleStatus>>
>;
export type CreateNodesSingleStatusMutationBody =
  CreateNodesSingleStatusRequest;
export type CreateNodesSingleStatusMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleStatus
 */
export const useCreateNodesSingleStatus = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStatus>>,
    TError,
    { node: string; data: CreateNodesSingleStatusRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleStatusMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read tap/vm network device interface counters
 * @summary getNodesSingleNetstat
 */
export const getNodesSingleNetstat = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleNetstatResponseResponse>({
    url: `/nodes/${node}/netstat`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleNetstatQueryKey = (node: string) =>
  [`/nodes/${node}/netstat`] as const;

export const getGetNodesSingleNetstatQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleNetstat>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleNetstat>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleNetstat>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleNetstatQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleNetstat>>
  > = ({ signal }) => getNodesSingleNetstat(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleNetstatQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleNetstat>>
>;
export type GetNodesSingleNetstatQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleNetstat
 */
export const useGetNodesSingleNetstat = <
  TData = Awaited<ReturnType<typeof getNodesSingleNetstat>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleNetstat>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleNetstatQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute multiple commands in order.
 * @summary createNodesSingleExecute
 */
export const createNodesSingleExecute = (
  node: string,
  createNodesSingleExecuteRequest: CreateNodesSingleExecuteRequest,
) => {
  return apiInstance<CreateNodesSingleExecuteResponseResponse>({
    url: `/nodes/${node}/execute`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleExecuteRequest,
  });
};

export const getCreateNodesSingleExecuteMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleExecute>>,
    TError,
    { node: string; data: CreateNodesSingleExecuteRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleExecute>>,
  TError,
  { node: string; data: CreateNodesSingleExecuteRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleExecute>>,
    { node: string; data: CreateNodesSingleExecuteRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleExecute(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleExecuteMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleExecute>>
>;
export type CreateNodesSingleExecuteMutationBody =
  CreateNodesSingleExecuteRequest;
export type CreateNodesSingleExecuteMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleExecute
 */
export const useCreateNodesSingleExecute = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleExecute>>,
    TError,
    { node: string; data: CreateNodesSingleExecuteRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleExecuteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Try to wake a node via 'wake on LAN' network packet.
 * @summary createNodesSingleWakeonlan
 */
export const createNodesSingleWakeonlan = (
  node: string,
  createNodesSingleWakeonlanRequest: CreateNodesSingleWakeonlanRequest,
) => {
  return apiInstance<CreateNodesSingleWakeonlanResponseResponse>({
    url: `/nodes/${node}/wakeonlan`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleWakeonlanRequest,
  });
};

export const getCreateNodesSingleWakeonlanMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleWakeonlan>>,
    TError,
    { node: string; data: CreateNodesSingleWakeonlanRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleWakeonlan>>,
  TError,
  { node: string; data: CreateNodesSingleWakeonlanRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleWakeonlan>>,
    { node: string; data: CreateNodesSingleWakeonlanRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleWakeonlan(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleWakeonlanMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleWakeonlan>>
>;
export type CreateNodesSingleWakeonlanMutationBody =
  CreateNodesSingleWakeonlanRequest;
export type CreateNodesSingleWakeonlanMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleWakeonlan
 */
export const useCreateNodesSingleWakeonlan = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleWakeonlan>>,
    TError,
    { node: string; data: CreateNodesSingleWakeonlanRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleWakeonlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read node RRD statistics (returns PNG)
 * @summary getNodeRRD
 */
export const getNodeRRD = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodeRRDResponseResponse>({
    url: `/nodes/${node}/rrd`,
    method: "get",
    signal,
  });
};

export const getGetNodeRRDQueryKey = (node: string) =>
  [`/nodes/${node}/rrd`] as const;

export const getGetNodeRRDQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeRRD>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeRRD>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getNodeRRD>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeRRDQueryKey(node);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeRRD>>> = ({
    signal,
  }) => getNodeRRD(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodeRRDQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeRRD>>
>;
export type GetNodeRRDQueryError = ErrorType<unknown>;

/**
 * @summary getNodeRRD
 */
export const useGetNodeRRD = <
  TData = Awaited<ReturnType<typeof getNodeRRD>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeRRD>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeRRDQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read node RRD statistics
 * @summary getNodeRRDData
 */
export const getNodeRRDData = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodeRRDDataResponseResponse>({
    url: `/nodes/${node}/rrddata`,
    method: "get",
    signal,
  });
};

export const getGetNodeRRDDataQueryKey = (node: string) =>
  [`/nodes/${node}/rrddata`] as const;

export const getGetNodeRRDDataQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeRRDData>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeRRDData>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodeRRDData>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeRRDDataQueryKey(node);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeRRDData>>> = ({
    signal,
  }) => getNodeRRDData(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodeRRDDataQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeRRDData>>
>;
export type GetNodeRRDDataQueryError = ErrorType<unknown>;

/**
 * @summary getNodeRRDData
 */
export const useGetNodeRRDData = <
  TData = Awaited<ReturnType<typeof getNodeRRDData>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeRRDData>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeRRDDataQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read system log
 * @summary getNodesSingleSyslog
 */
export const getNodesSingleSyslog = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleSyslogResponseResponse>({
    url: `/nodes/${node}/syslog`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleSyslogQueryKey = (node: string) =>
  [`/nodes/${node}/syslog`] as const;

export const getGetNodesSingleSyslogQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleSyslog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleSyslog>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleSyslog>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleSyslogQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleSyslog>>
  > = ({ signal }) => getNodesSingleSyslog(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleSyslogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleSyslog>>
>;
export type GetNodesSingleSyslogQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleSyslog
 */
export const useGetNodesSingleSyslog = <
  TData = Awaited<ReturnType<typeof getNodesSingleSyslog>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleSyslog>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleSyslogQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Read Journal
 * @summary getNodesSingleJournal
 */
export const getNodesSingleJournal = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleJournalResponseResponse>({
    url: `/nodes/${node}/journal`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleJournalQueryKey = (node: string) =>
  [`/nodes/${node}/journal`] as const;

export const getGetNodesSingleJournalQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleJournal>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleJournal>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleJournal>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleJournalQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleJournal>>
  > = ({ signal }) => getNodesSingleJournal(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleJournalQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleJournal>>
>;
export type GetNodesSingleJournalQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleJournal
 */
export const useGetNodesSingleJournal = <
  TData = Awaited<ReturnType<typeof getNodesSingleJournal>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleJournal>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleJournalQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Creates a VNC Shell proxy.
 * @summary createNodesSingleVncshell
 */
export const createNodesSingleVncshell = (
  node: string,
  createNodesSingleVncshellRequest: CreateNodesSingleVncshellRequest,
) => {
  return apiInstance<CreateNodesSingleVncshellResponseResponse>({
    url: `/nodes/${node}/vncshell`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleVncshellRequest,
  });
};

export const getCreateNodesSingleVncshellMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleVncshell>>,
    TError,
    { node: string; data: CreateNodesSingleVncshellRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleVncshell>>,
  TError,
  { node: string; data: CreateNodesSingleVncshellRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleVncshell>>,
    { node: string; data: CreateNodesSingleVncshellRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleVncshell(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleVncshellMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleVncshell>>
>;
export type CreateNodesSingleVncshellMutationBody =
  CreateNodesSingleVncshellRequest;
export type CreateNodesSingleVncshellMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleVncshell
 */
export const useCreateNodesSingleVncshell = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleVncshell>>,
    TError,
    { node: string; data: CreateNodesSingleVncshellRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleVncshellMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Creates a VNC Shell proxy.
 * @summary createNodesSingleTermproxy
 */
export const createNodesSingleTermproxy = (
  node: string,
  createNodesSingleTermproxyRequest: CreateNodesSingleTermproxyRequest,
) => {
  return apiInstance<CreateNodesSingleTermproxyResponseResponse>({
    url: `/nodes/${node}/termproxy`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleTermproxyRequest,
  });
};

export const getCreateNodesSingleTermproxyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleTermproxy>>,
    TError,
    { node: string; data: CreateNodesSingleTermproxyRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleTermproxy>>,
  TError,
  { node: string; data: CreateNodesSingleTermproxyRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleTermproxy>>,
    { node: string; data: CreateNodesSingleTermproxyRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleTermproxy(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleTermproxyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleTermproxy>>
>;
export type CreateNodesSingleTermproxyMutationBody =
  CreateNodesSingleTermproxyRequest;
export type CreateNodesSingleTermproxyMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleTermproxy
 */
export const useCreateNodesSingleTermproxy = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleTermproxy>>,
    TError,
    { node: string; data: CreateNodesSingleTermproxyRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleTermproxyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Opens a weksocket for VNC traffic.
 * @summary getNodesSingleVncwebsocket
 */
export const getNodesSingleVncwebsocket = (
  node: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetNodesSingleVncwebsocketResponseResponse>({
    url: `/nodes/${node}/vncwebsocket`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleVncwebsocketQueryKey = (node: string) =>
  [`/nodes/${node}/vncwebsocket`] as const;

export const getGetNodesSingleVncwebsocketQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleVncwebsocket>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleVncwebsocket>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleVncwebsocket>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleVncwebsocketQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleVncwebsocket>>
  > = ({ signal }) => getNodesSingleVncwebsocket(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleVncwebsocketQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleVncwebsocket>>
>;
export type GetNodesSingleVncwebsocketQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleVncwebsocket
 */
export const useGetNodesSingleVncwebsocket = <
  TData = Awaited<ReturnType<typeof getNodesSingleVncwebsocket>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleVncwebsocket>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleVncwebsocketQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Creates a SPICE shell.
 * @summary createNodesSingleSpiceshell
 */
export const createNodesSingleSpiceshell = (
  node: string,
  createNodesSingleSpiceshellRequest: CreateNodesSingleSpiceshellRequest,
) => {
  return apiInstance<CreateNodesSingleSpiceshellResponseResponse>({
    url: `/nodes/${node}/spiceshell`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleSpiceshellRequest,
  });
};

export const getCreateNodesSingleSpiceshellMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleSpiceshell>>,
    TError,
    { node: string; data: CreateNodesSingleSpiceshellRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleSpiceshell>>,
  TError,
  { node: string; data: CreateNodesSingleSpiceshellRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleSpiceshell>>,
    { node: string; data: CreateNodesSingleSpiceshellRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleSpiceshell(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleSpiceshellMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleSpiceshell>>
>;
export type CreateNodesSingleSpiceshellMutationBody =
  CreateNodesSingleSpiceshellRequest;
export type CreateNodesSingleSpiceshellMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleSpiceshell
 */
export const useCreateNodesSingleSpiceshell = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleSpiceshell>>,
    TError,
    { node: string; data: CreateNodesSingleSpiceshellRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleSpiceshellMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read DNS settings.
 * @summary getNodesSingleDns
 */
export const getNodesSingleDns = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleDnsResponseResponse>({
    url: `/nodes/${node}/dns`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleDnsQueryKey = (node: string) =>
  [`/nodes/${node}/dns`] as const;

export const getGetNodesSingleDnsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleDns>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDns>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleDns>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodesSingleDnsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleDns>>
  > = ({ signal }) => getNodesSingleDns(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleDnsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleDns>>
>;
export type GetNodesSingleDnsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleDns
 */
export const useGetNodesSingleDns = <
  TData = Awaited<ReturnType<typeof getNodesSingleDns>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleDns>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleDnsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Write DNS settings.
 * @summary updateNodesSingleDns
 */
export const updateNodesSingleDns = (
  node: string,
  updateNodesSingleDnsRequest: UpdateNodesSingleDnsRequest,
) => {
  return apiInstance<UpdateNodesSingleDnsResponseResponse>({
    url: `/nodes/${node}/dns`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleDnsRequest,
  });
};

export const getUpdateNodesSingleDnsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleDns>>,
    TError,
    { node: string; data: UpdateNodesSingleDnsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleDns>>,
  TError,
  { node: string; data: UpdateNodesSingleDnsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleDns>>,
    { node: string; data: UpdateNodesSingleDnsRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return updateNodesSingleDns(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleDnsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleDns>>
>;
export type UpdateNodesSingleDnsMutationBody = UpdateNodesSingleDnsRequest;
export type UpdateNodesSingleDnsMutationError = ErrorType<unknown>;

/**
 * @summary updateNodesSingleDns
 */
export const useUpdateNodesSingleDns = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleDns>>,
    TError,
    { node: string; data: UpdateNodesSingleDnsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateNodesSingleDnsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read server time and time zone settings.
 * @summary getNodesSingleTime
 */
export const getNodesSingleTime = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleTimeResponseResponse>({
    url: `/nodes/${node}/time`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleTimeQueryKey = (node: string) =>
  [`/nodes/${node}/time`] as const;

export const getGetNodesSingleTimeQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleTime>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleTime>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleTime>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleTimeQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleTime>>
  > = ({ signal }) => getNodesSingleTime(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleTimeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleTime>>
>;
export type GetNodesSingleTimeQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleTime
 */
export const useGetNodesSingleTime = <
  TData = Awaited<ReturnType<typeof getNodesSingleTime>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleTime>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleTimeQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Set time zone.
 * @summary updateNodesSingleTime
 */
export const updateNodesSingleTime = (
  node: string,
  updateNodesSingleTimeRequest: UpdateNodesSingleTimeRequest,
) => {
  return apiInstance<UpdateNodesSingleTimeResponseResponse>({
    url: `/nodes/${node}/time`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateNodesSingleTimeRequest,
  });
};

export const getUpdateNodesSingleTimeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleTime>>,
    TError,
    { node: string; data: UpdateNodesSingleTimeRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNodesSingleTime>>,
  TError,
  { node: string; data: UpdateNodesSingleTimeRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNodesSingleTime>>,
    { node: string; data: UpdateNodesSingleTimeRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return updateNodesSingleTime(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNodesSingleTimeMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNodesSingleTime>>
>;
export type UpdateNodesSingleTimeMutationBody = UpdateNodesSingleTimeRequest;
export type UpdateNodesSingleTimeMutationError = ErrorType<unknown>;

/**
 * @summary updateNodesSingleTime
 */
export const useUpdateNodesSingleTime = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNodesSingleTime>>,
    TError,
    { node: string; data: UpdateNodesSingleTimeRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateNodesSingleTimeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get list of appliances.
 * @summary getNodesSingleAplinfo
 */
export const getNodesSingleAplinfo = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleAplinfoResponseResponse>({
    url: `/nodes/${node}/aplinfo`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleAplinfoQueryKey = (node: string) =>
  [`/nodes/${node}/aplinfo`] as const;

export const getGetNodesSingleAplinfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleAplinfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleAplinfo>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleAplinfo>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleAplinfoQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleAplinfo>>
  > = ({ signal }) => getNodesSingleAplinfo(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleAplinfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleAplinfo>>
>;
export type GetNodesSingleAplinfoQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleAplinfo
 */
export const useGetNodesSingleAplinfo = <
  TData = Awaited<ReturnType<typeof getNodesSingleAplinfo>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleAplinfo>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleAplinfoQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Download appliance templates.
 * @summary createNodesSingleAplinfo
 */
export const createNodesSingleAplinfo = (
  node: string,
  createNodesSingleAplinfoRequest: CreateNodesSingleAplinfoRequest,
) => {
  return apiInstance<CreateNodesSingleAplinfoResponseResponse>({
    url: `/nodes/${node}/aplinfo`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleAplinfoRequest,
  });
};

export const getCreateNodesSingleAplinfoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleAplinfo>>,
    TError,
    { node: string; data: CreateNodesSingleAplinfoRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleAplinfo>>,
  TError,
  { node: string; data: CreateNodesSingleAplinfoRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleAplinfo>>,
    { node: string; data: CreateNodesSingleAplinfoRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleAplinfo(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleAplinfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleAplinfo>>
>;
export type CreateNodesSingleAplinfoMutationBody =
  CreateNodesSingleAplinfoRequest;
export type CreateNodesSingleAplinfoMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleAplinfo
 */
export const useCreateNodesSingleAplinfo = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleAplinfo>>,
    TError,
    { node: string; data: CreateNodesSingleAplinfoRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleAplinfoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Gather various systems information about a node
 * @summary getNodesSingleReport
 */
export const getNodesSingleReport = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleReportResponseResponse>({
    url: `/nodes/${node}/report`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleReportQueryKey = (node: string) =>
  [`/nodes/${node}/report`] as const;

export const getGetNodesSingleReportQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleReport>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReport>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleReport>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleReportQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleReport>>
  > = ({ signal }) => getNodesSingleReport(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleReportQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleReport>>
>;
export type GetNodesSingleReportQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleReport
 */
export const useGetNodesSingleReport = <
  TData = Awaited<ReturnType<typeof getNodesSingleReport>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleReport>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleReportQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Start all VMs and containers located on this node (by default only those with onboot=1).
 * @summary createNodesSingleStartall
 */
export const createNodesSingleStartall = (
  node: string,
  createNodesSingleStartallRequest: CreateNodesSingleStartallRequest,
) => {
  return apiInstance<CreateNodesSingleStartallResponseResponse>({
    url: `/nodes/${node}/startall`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleStartallRequest,
  });
};

export const getCreateNodesSingleStartallMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStartall>>,
    TError,
    { node: string; data: CreateNodesSingleStartallRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleStartall>>,
  TError,
  { node: string; data: CreateNodesSingleStartallRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleStartall>>,
    { node: string; data: CreateNodesSingleStartallRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleStartall(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleStartallMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleStartall>>
>;
export type CreateNodesSingleStartallMutationBody =
  CreateNodesSingleStartallRequest;
export type CreateNodesSingleStartallMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleStartall
 */
export const useCreateNodesSingleStartall = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStartall>>,
    TError,
    { node: string; data: CreateNodesSingleStartallRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleStartallMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Stop all VMs and Containers.
 * @summary createNodesSingleStopall
 */
export const createNodesSingleStopall = (
  node: string,
  createNodesSingleStopallRequest: CreateNodesSingleStopallRequest,
) => {
  return apiInstance<CreateNodesSingleStopallResponseResponse>({
    url: `/nodes/${node}/stopall`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleStopallRequest,
  });
};

export const getCreateNodesSingleStopallMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStopall>>,
    TError,
    { node: string; data: CreateNodesSingleStopallRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleStopall>>,
  TError,
  { node: string; data: CreateNodesSingleStopallRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleStopall>>,
    { node: string; data: CreateNodesSingleStopallRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleStopall(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleStopallMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleStopall>>
>;
export type CreateNodesSingleStopallMutationBody =
  CreateNodesSingleStopallRequest;
export type CreateNodesSingleStopallMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleStopall
 */
export const useCreateNodesSingleStopall = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleStopall>>,
    TError,
    { node: string; data: CreateNodesSingleStopallRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleStopallMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Migrate all VMs and Containers.
 * @summary createNodesSingleMigrateall
 */
export const createNodesSingleMigrateall = (
  node: string,
  createNodesSingleMigrateallRequest: CreateNodesSingleMigrateallRequest,
) => {
  return apiInstance<CreateNodesSingleMigrateallResponseResponse>({
    url: `/nodes/${node}/migrateall`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleMigrateallRequest,
  });
};

export const getCreateNodesSingleMigrateallMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleMigrateall>>,
    TError,
    { node: string; data: CreateNodesSingleMigrateallRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleMigrateall>>,
  TError,
  { node: string; data: CreateNodesSingleMigrateallRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleMigrateall>>,
    { node: string; data: CreateNodesSingleMigrateallRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleMigrateall(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleMigrateallMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleMigrateall>>
>;
export type CreateNodesSingleMigrateallMutationBody =
  CreateNodesSingleMigrateallRequest;
export type CreateNodesSingleMigrateallMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleMigrateall
 */
export const useCreateNodesSingleMigrateall = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleMigrateall>>,
    TError,
    { node: string; data: CreateNodesSingleMigrateallRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateNodesSingleMigrateallMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get the content of /etc/hosts.
 * @summary getNodesSingleHosts
 */
export const getNodesSingleHosts = (node: string, signal?: AbortSignal) => {
  return apiInstance<GetNodesSingleHostsResponseResponse>({
    url: `/nodes/${node}/hosts`,
    method: "get",
    signal,
  });
};

export const getGetNodesSingleHostsQueryKey = (node: string) =>
  [`/nodes/${node}/hosts`] as const;

export const getGetNodesSingleHostsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesSingleHosts>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHosts>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getNodesSingleHosts>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNodesSingleHostsQueryKey(node);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNodesSingleHosts>>
  > = ({ signal }) => getNodesSingleHosts(node, signal);

  return { queryKey, queryFn, enabled: !!node, ...queryOptions };
};

export type GetNodesSingleHostsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodesSingleHosts>>
>;
export type GetNodesSingleHostsQueryError = ErrorType<unknown>;

/**
 * @summary getNodesSingleHosts
 */
export const useGetNodesSingleHosts = <
  TData = Awaited<ReturnType<typeof getNodesSingleHosts>>,
  TError = ErrorType<unknown>,
>(
  node: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodesSingleHosts>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesSingleHostsQueryOptions(node, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Write /etc/hosts.
 * @summary createNodesSingleHosts
 */
export const createNodesSingleHosts = (
  node: string,
  createNodesSingleHostsRequest: CreateNodesSingleHostsRequest,
) => {
  return apiInstance<CreateNodesSingleHostsResponseResponse>({
    url: `/nodes/${node}/hosts`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createNodesSingleHostsRequest,
  });
};

export const getCreateNodesSingleHostsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleHosts>>,
    TError,
    { node: string; data: CreateNodesSingleHostsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNodesSingleHosts>>,
  TError,
  { node: string; data: CreateNodesSingleHostsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNodesSingleHosts>>,
    { node: string; data: CreateNodesSingleHostsRequest }
  > = (props) => {
    const { node, data } = props ?? {};

    return createNodesSingleHosts(node, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNodesSingleHostsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNodesSingleHosts>>
>;
export type CreateNodesSingleHostsMutationBody = CreateNodesSingleHostsRequest;
export type CreateNodesSingleHostsMutationError = ErrorType<unknown>;

/**
 * @summary createNodesSingleHosts
 */
export const useCreateNodesSingleHosts = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNodesSingleHosts>>,
    TError,
    { node: string; data: CreateNodesSingleHostsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateNodesSingleHostsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Storage index.
 * @summary getStorage
 */
export const getStorage = (signal?: AbortSignal) => {
  return apiInstance<GetStorageResponseResponse>({
    url: `/storage`,
    method: "get",
    signal,
  });
};

export const getGetStorageQueryKey = () => [`/storage`] as const;

export const getGetStorageQueryOptions = <
  TData = Awaited<ReturnType<typeof getStorage>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getStorage>>,
    TError,
    TData
  >;
}): UseQueryOptions<Awaited<ReturnType<typeof getStorage>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStorageQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStorage>>> = ({
    signal,
  }) => getStorage(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetStorageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStorage>>
>;
export type GetStorageQueryError = ErrorType<unknown>;

/**
 * @summary getStorage
 */
export const useGetStorage = <
  TData = Awaited<ReturnType<typeof getStorage>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getStorage>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetStorageQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new storage.
 * @summary createStorage
 */
export const createStorage = (createStorageRequest: CreateStorageRequest) => {
  return apiInstance<CreateStorageResponseResponse>({
    url: `/storage`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createStorageRequest,
  });
};

export const getCreateStorageMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createStorage>>,
    TError,
    { data: CreateStorageRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createStorage>>,
  TError,
  { data: CreateStorageRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createStorage>>,
    { data: CreateStorageRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createStorage(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateStorageMutationResult = NonNullable<
  Awaited<ReturnType<typeof createStorage>>
>;
export type CreateStorageMutationBody = CreateStorageRequest;
export type CreateStorageMutationError = ErrorType<unknown>;

/**
 * @summary createStorage
 */
export const useCreateStorage = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createStorage>>,
    TError,
    { data: CreateStorageRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateStorageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete storage configuration.
 * @summary deleteStorageSingle
 */
export const deleteStorageSingle = (storage: string) => {
  return apiInstance<DeleteStorageSingleResponseResponse>({
    url: `/storage/${storage}`,
    method: "delete",
  });
};

export const getDeleteStorageSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteStorageSingle>>,
    TError,
    { storage: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteStorageSingle>>,
  TError,
  { storage: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteStorageSingle>>,
    { storage: string }
  > = (props) => {
    const { storage } = props ?? {};

    return deleteStorageSingle(storage);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteStorageSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteStorageSingle>>
>;

export type DeleteStorageSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteStorageSingle
 */
export const useDeleteStorageSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteStorageSingle>>,
    TError,
    { storage: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteStorageSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Read storage configuration.
 * @summary getStorageSingle
 */
export const getStorageSingle = (storage: string, signal?: AbortSignal) => {
  return apiInstance<GetStorageSingleResponseResponse>({
    url: `/storage/${storage}`,
    method: "get",
    signal,
  });
};

export const getGetStorageSingleQueryKey = (storage: string) =>
  [`/storage/${storage}`] as const;

export const getGetStorageSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getStorageSingle>>,
  TError = ErrorType<unknown>,
>(
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getStorageSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getStorageSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetStorageSingleQueryKey(storage);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStorageSingle>>
  > = ({ signal }) => getStorageSingle(storage, signal);

  return { queryKey, queryFn, enabled: !!storage, ...queryOptions };
};

export type GetStorageSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStorageSingle>>
>;
export type GetStorageSingleQueryError = ErrorType<unknown>;

/**
 * @summary getStorageSingle
 */
export const useGetStorageSingle = <
  TData = Awaited<ReturnType<typeof getStorageSingle>>,
  TError = ErrorType<unknown>,
>(
  storage: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getStorageSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetStorageSingleQueryOptions(storage, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update storage configuration.
 * @summary updateStorageSingle
 */
export const updateStorageSingle = (
  storage: string,
  updateStorageSingleRequest: UpdateStorageSingleRequest,
) => {
  return apiInstance<UpdateStorageSingleResponseResponse>({
    url: `/storage/${storage}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateStorageSingleRequest,
  });
};

export const getUpdateStorageSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStorageSingle>>,
    TError,
    { storage: string; data: UpdateStorageSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateStorageSingle>>,
  TError,
  { storage: string; data: UpdateStorageSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStorageSingle>>,
    { storage: string; data: UpdateStorageSingleRequest }
  > = (props) => {
    const { storage, data } = props ?? {};

    return updateStorageSingle(storage, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateStorageSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateStorageSingle>>
>;
export type UpdateStorageSingleMutationBody = UpdateStorageSingleRequest;
export type UpdateStorageSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateStorageSingle
 */
export const useUpdateStorageSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStorageSingle>>,
    TError,
    { storage: string; data: UpdateStorageSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateStorageSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Directory index.
 * @summary getAccess
 */
export const getAccess = (signal?: AbortSignal) => {
  return apiInstance<GetAccessResponseResponse>({
    url: `/access`,
    method: "get",
    signal,
  });
};

export const getGetAccessQueryKey = () => [`/access`] as const;

export const getGetAccessQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccess>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getAccess>>, TError, TData>;
}): UseQueryOptions<Awaited<ReturnType<typeof getAccess>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccessQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccess>>> = ({
    signal,
  }) => getAccess(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetAccessQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccess>>
>;
export type GetAccessQueryError = ErrorType<unknown>;

/**
 * @summary getAccess
 */
export const useGetAccess = <
  TData = Awaited<ReturnType<typeof getAccess>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getAccess>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * User index.
 * @summary getAccessUsers
 */
export const getAccessUsers = (signal?: AbortSignal) => {
  return apiInstance<GetAccessUsersResponseResponse>({
    url: `/access/users`,
    method: "get",
    signal,
  });
};

export const getGetAccessUsersQueryKey = () => [`/access/users`] as const;

export const getGetAccessUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessUsers>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessUsers>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccessUsersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessUsers>>> = ({
    signal,
  }) => getAccessUsers(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetAccessUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessUsers>>
>;
export type GetAccessUsersQueryError = ErrorType<unknown>;

/**
 * @summary getAccessUsers
 */
export const useGetAccessUsers = <
  TData = Awaited<ReturnType<typeof getAccessUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessUsers>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessUsersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new user.
 * @summary createAccessUsers
 */
export const createAccessUsers = (
  createAccessUsersRequest: CreateAccessUsersRequest,
) => {
  return apiInstance<CreateAccessUsersResponseResponse>({
    url: `/access/users`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createAccessUsersRequest,
  });
};

export const getCreateAccessUsersMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessUsers>>,
    TError,
    { data: CreateAccessUsersRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAccessUsers>>,
  TError,
  { data: CreateAccessUsersRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAccessUsers>>,
    { data: CreateAccessUsersRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createAccessUsers(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAccessUsersMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAccessUsers>>
>;
export type CreateAccessUsersMutationBody = CreateAccessUsersRequest;
export type CreateAccessUsersMutationError = ErrorType<unknown>;

/**
 * @summary createAccessUsers
 */
export const useCreateAccessUsers = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessUsers>>,
    TError,
    { data: CreateAccessUsersRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateAccessUsersMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete user.
 * @summary deleteAccessUsersSingle
 */
export const deleteAccessUsersSingle = (userid: string) => {
  return apiInstance<DeleteAccessUsersSingleResponseResponse>({
    url: `/access/users/${userid}`,
    method: "delete",
  });
};

export const getDeleteAccessUsersSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessUsersSingle>>,
    TError,
    { userid: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccessUsersSingle>>,
  TError,
  { userid: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccessUsersSingle>>,
    { userid: string }
  > = (props) => {
    const { userid } = props ?? {};

    return deleteAccessUsersSingle(userid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccessUsersSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccessUsersSingle>>
>;

export type DeleteAccessUsersSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteAccessUsersSingle
 */
export const useDeleteAccessUsersSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessUsersSingle>>,
    TError,
    { userid: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteAccessUsersSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get user configuration.
 * @summary getAccessUsersSingle
 */
export const getAccessUsersSingle = (userid: string, signal?: AbortSignal) => {
  return apiInstance<GetAccessUsersSingleResponseResponse>({
    url: `/access/users/${userid}`,
    method: "get",
    signal,
  });
};

export const getGetAccessUsersSingleQueryKey = (userid: string) =>
  [`/access/users/${userid}`] as const;

export const getGetAccessUsersSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessUsersSingle>>,
  TError = ErrorType<unknown>,
>(
  userid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessUsersSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessUsersSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccessUsersSingleQueryKey(userid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessUsersSingle>>
  > = ({ signal }) => getAccessUsersSingle(userid, signal);

  return { queryKey, queryFn, enabled: !!userid, ...queryOptions };
};

export type GetAccessUsersSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessUsersSingle>>
>;
export type GetAccessUsersSingleQueryError = ErrorType<unknown>;

/**
 * @summary getAccessUsersSingle
 */
export const useGetAccessUsersSingle = <
  TData = Awaited<ReturnType<typeof getAccessUsersSingle>>,
  TError = ErrorType<unknown>,
>(
  userid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessUsersSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessUsersSingleQueryOptions(userid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update user configuration.
 * @summary updateAccessUsersSingle
 */
export const updateAccessUsersSingle = (
  userid: string,
  updateAccessUsersSingleRequest: UpdateAccessUsersSingleRequest,
) => {
  return apiInstance<UpdateAccessUsersSingleResponseResponse>({
    url: `/access/users/${userid}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateAccessUsersSingleRequest,
  });
};

export const getUpdateAccessUsersSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessUsersSingle>>,
    TError,
    { userid: string; data: UpdateAccessUsersSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccessUsersSingle>>,
  TError,
  { userid: string; data: UpdateAccessUsersSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccessUsersSingle>>,
    { userid: string; data: UpdateAccessUsersSingleRequest }
  > = (props) => {
    const { userid, data } = props ?? {};

    return updateAccessUsersSingle(userid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccessUsersSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAccessUsersSingle>>
>;
export type UpdateAccessUsersSingleMutationBody =
  UpdateAccessUsersSingleRequest;
export type UpdateAccessUsersSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateAccessUsersSingle
 */
export const useUpdateAccessUsersSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessUsersSingle>>,
    TError,
    { userid: string; data: UpdateAccessUsersSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateAccessUsersSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get user TFA types (Personal and Realm).
 * @summary getAccessUsersSingleTfa
 */
export const getAccessUsersSingleTfa = (
  userid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetAccessUsersSingleTfaResponseResponse>({
    url: `/access/users/${userid}/tfa`,
    method: "get",
    signal,
  });
};

export const getGetAccessUsersSingleTfaQueryKey = (userid: string) =>
  [`/access/users/${userid}/tfa`] as const;

export const getGetAccessUsersSingleTfaQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessUsersSingleTfa>>,
  TError = ErrorType<unknown>,
>(
  userid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessUsersSingleTfa>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessUsersSingleTfa>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccessUsersSingleTfaQueryKey(userid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessUsersSingleTfa>>
  > = ({ signal }) => getAccessUsersSingleTfa(userid, signal);

  return { queryKey, queryFn, enabled: !!userid, ...queryOptions };
};

export type GetAccessUsersSingleTfaQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessUsersSingleTfa>>
>;
export type GetAccessUsersSingleTfaQueryError = ErrorType<unknown>;

/**
 * @summary getAccessUsersSingleTfa
 */
export const useGetAccessUsersSingleTfa = <
  TData = Awaited<ReturnType<typeof getAccessUsersSingleTfa>>,
  TError = ErrorType<unknown>,
>(
  userid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessUsersSingleTfa>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessUsersSingleTfaQueryOptions(userid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get user API tokens.
 * @summary getAccessUsersSingleToken
 */
export const getAccessUsersSingleToken = (
  userid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetAccessUsersSingleTokenResponseResponse>({
    url: `/access/users/${userid}/token`,
    method: "get",
    signal,
  });
};

export const getGetAccessUsersSingleTokenQueryKey = (userid: string) =>
  [`/access/users/${userid}/token`] as const;

export const getGetAccessUsersSingleTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessUsersSingleToken>>,
  TError = ErrorType<unknown>,
>(
  userid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessUsersSingleToken>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessUsersSingleToken>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccessUsersSingleTokenQueryKey(userid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessUsersSingleToken>>
  > = ({ signal }) => getAccessUsersSingleToken(userid, signal);

  return { queryKey, queryFn, enabled: !!userid, ...queryOptions };
};

export type GetAccessUsersSingleTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessUsersSingleToken>>
>;
export type GetAccessUsersSingleTokenQueryError = ErrorType<unknown>;

/**
 * @summary getAccessUsersSingleToken
 */
export const useGetAccessUsersSingleToken = <
  TData = Awaited<ReturnType<typeof getAccessUsersSingleToken>>,
  TError = ErrorType<unknown>,
>(
  userid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessUsersSingleToken>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessUsersSingleTokenQueryOptions(
    userid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Remove API token for a specific user.
 * @summary deleteAccessUsersSingleTokenSingle
 */
export const deleteAccessUsersSingleTokenSingle = (
  userid: string,
  tokenid: string,
) => {
  return apiInstance<DeleteAccessUsersSingleTokenSingleResponseResponse>({
    url: `/access/users/${userid}/token/${tokenid}`,
    method: "delete",
  });
};

export const getDeleteAccessUsersSingleTokenSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessUsersSingleTokenSingle>>,
    TError,
    { userid: string; tokenid: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccessUsersSingleTokenSingle>>,
  TError,
  { userid: string; tokenid: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccessUsersSingleTokenSingle>>,
    { userid: string; tokenid: string }
  > = (props) => {
    const { userid, tokenid } = props ?? {};

    return deleteAccessUsersSingleTokenSingle(userid, tokenid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccessUsersSingleTokenSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccessUsersSingleTokenSingle>>
>;

export type DeleteAccessUsersSingleTokenSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary deleteAccessUsersSingleTokenSingle
 */
export const useDeleteAccessUsersSingleTokenSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessUsersSingleTokenSingle>>,
    TError,
    { userid: string; tokenid: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getDeleteAccessUsersSingleTokenSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get specific API token information.
 * @summary getAccessUsersSingleTokenSingle
 */
export const getAccessUsersSingleTokenSingle = (
  userid: string,
  tokenid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetAccessUsersSingleTokenSingleResponseResponse>({
    url: `/access/users/${userid}/token/${tokenid}`,
    method: "get",
    signal,
  });
};

export const getGetAccessUsersSingleTokenSingleQueryKey = (
  userid: string,
  tokenid: string,
) => [`/access/users/${userid}/token/${tokenid}`] as const;

export const getGetAccessUsersSingleTokenSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessUsersSingleTokenSingle>>,
  TError = ErrorType<unknown>,
>(
  userid: string,
  tokenid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessUsersSingleTokenSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessUsersSingleTokenSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAccessUsersSingleTokenSingleQueryKey(userid, tokenid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessUsersSingleTokenSingle>>
  > = ({ signal }) => getAccessUsersSingleTokenSingle(userid, tokenid, signal);

  return { queryKey, queryFn, enabled: !!(userid && tokenid), ...queryOptions };
};

export type GetAccessUsersSingleTokenSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessUsersSingleTokenSingle>>
>;
export type GetAccessUsersSingleTokenSingleQueryError = ErrorType<unknown>;

/**
 * @summary getAccessUsersSingleTokenSingle
 */
export const useGetAccessUsersSingleTokenSingle = <
  TData = Awaited<ReturnType<typeof getAccessUsersSingleTokenSingle>>,
  TError = ErrorType<unknown>,
>(
  userid: string,
  tokenid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessUsersSingleTokenSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessUsersSingleTokenSingleQueryOptions(
    userid,
    tokenid,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Generate a new API token for a specific user. NOTE: returns API token value, which needs to be stored as it cannot be retrieved afterwards!
 * @summary createAccessUsersSingleTokenSingle
 */
export const createAccessUsersSingleTokenSingle = (
  userid: string,
  tokenid: string,
  createAccessUsersSingleTokenSingleRequest: CreateAccessUsersSingleTokenSingleRequest,
) => {
  return apiInstance<CreateAccessUsersSingleTokenSingleResponseResponse>({
    url: `/access/users/${userid}/token/${tokenid}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createAccessUsersSingleTokenSingleRequest,
  });
};

export const getCreateAccessUsersSingleTokenSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessUsersSingleTokenSingle>>,
    TError,
    {
      userid: string;
      tokenid: string;
      data: CreateAccessUsersSingleTokenSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAccessUsersSingleTokenSingle>>,
  TError,
  {
    userid: string;
    tokenid: string;
    data: CreateAccessUsersSingleTokenSingleRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAccessUsersSingleTokenSingle>>,
    {
      userid: string;
      tokenid: string;
      data: CreateAccessUsersSingleTokenSingleRequest;
    }
  > = (props) => {
    const { userid, tokenid, data } = props ?? {};

    return createAccessUsersSingleTokenSingle(userid, tokenid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAccessUsersSingleTokenSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAccessUsersSingleTokenSingle>>
>;
export type CreateAccessUsersSingleTokenSingleMutationBody =
  CreateAccessUsersSingleTokenSingleRequest;
export type CreateAccessUsersSingleTokenSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary createAccessUsersSingleTokenSingle
 */
export const useCreateAccessUsersSingleTokenSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessUsersSingleTokenSingle>>,
    TError,
    {
      userid: string;
      tokenid: string;
      data: CreateAccessUsersSingleTokenSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateAccessUsersSingleTokenSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Update API token for a specific user.
 * @summary updateAccessUsersSingleTokenSingle
 */
export const updateAccessUsersSingleTokenSingle = (
  userid: string,
  tokenid: string,
  updateAccessUsersSingleTokenSingleRequest: UpdateAccessUsersSingleTokenSingleRequest,
) => {
  return apiInstance<UpdateAccessUsersSingleTokenSingleResponseResponse>({
    url: `/access/users/${userid}/token/${tokenid}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateAccessUsersSingleTokenSingleRequest,
  });
};

export const getUpdateAccessUsersSingleTokenSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessUsersSingleTokenSingle>>,
    TError,
    {
      userid: string;
      tokenid: string;
      data: UpdateAccessUsersSingleTokenSingleRequest;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccessUsersSingleTokenSingle>>,
  TError,
  {
    userid: string;
    tokenid: string;
    data: UpdateAccessUsersSingleTokenSingleRequest;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccessUsersSingleTokenSingle>>,
    {
      userid: string;
      tokenid: string;
      data: UpdateAccessUsersSingleTokenSingleRequest;
    }
  > = (props) => {
    const { userid, tokenid, data } = props ?? {};

    return updateAccessUsersSingleTokenSingle(userid, tokenid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccessUsersSingleTokenSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAccessUsersSingleTokenSingle>>
>;
export type UpdateAccessUsersSingleTokenSingleMutationBody =
  UpdateAccessUsersSingleTokenSingleRequest;
export type UpdateAccessUsersSingleTokenSingleMutationError =
  ErrorType<unknown>;

/**
 * @summary updateAccessUsersSingleTokenSingle
 */
export const useUpdateAccessUsersSingleTokenSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessUsersSingleTokenSingle>>,
    TError,
    {
      userid: string;
      tokenid: string;
      data: UpdateAccessUsersSingleTokenSingleRequest;
    },
    TContext
  >;
}) => {
  const mutationOptions =
    getUpdateAccessUsersSingleTokenSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Group index.
 * @summary getAccessGroups
 */
export const getAccessGroups = (signal?: AbortSignal) => {
  return apiInstance<GetAccessGroupsResponseResponse>({
    url: `/access/groups`,
    method: "get",
    signal,
  });
};

export const getGetAccessGroupsQueryKey = () => [`/access/groups`] as const;

export const getGetAccessGroupsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessGroups>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessGroups>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessGroups>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccessGroupsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessGroups>>> = ({
    signal,
  }) => getAccessGroups(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetAccessGroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessGroups>>
>;
export type GetAccessGroupsQueryError = ErrorType<unknown>;

/**
 * @summary getAccessGroups
 */
export const useGetAccessGroups = <
  TData = Awaited<ReturnType<typeof getAccessGroups>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessGroups>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessGroupsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new group.
 * @summary createAccessGroups
 */
export const createAccessGroups = (
  createAccessGroupsRequest: CreateAccessGroupsRequest,
) => {
  return apiInstance<CreateAccessGroupsResponseResponse>({
    url: `/access/groups`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createAccessGroupsRequest,
  });
};

export const getCreateAccessGroupsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessGroups>>,
    TError,
    { data: CreateAccessGroupsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAccessGroups>>,
  TError,
  { data: CreateAccessGroupsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAccessGroups>>,
    { data: CreateAccessGroupsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createAccessGroups(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAccessGroupsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAccessGroups>>
>;
export type CreateAccessGroupsMutationBody = CreateAccessGroupsRequest;
export type CreateAccessGroupsMutationError = ErrorType<unknown>;

/**
 * @summary createAccessGroups
 */
export const useCreateAccessGroups = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessGroups>>,
    TError,
    { data: CreateAccessGroupsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateAccessGroupsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete group.
 * @summary deleteAccessGroupsSingle
 */
export const deleteAccessGroupsSingle = (groupid: string) => {
  return apiInstance<DeleteAccessGroupsSingleResponseResponse>({
    url: `/access/groups/${groupid}`,
    method: "delete",
  });
};

export const getDeleteAccessGroupsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessGroupsSingle>>,
    TError,
    { groupid: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccessGroupsSingle>>,
  TError,
  { groupid: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccessGroupsSingle>>,
    { groupid: string }
  > = (props) => {
    const { groupid } = props ?? {};

    return deleteAccessGroupsSingle(groupid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccessGroupsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccessGroupsSingle>>
>;

export type DeleteAccessGroupsSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteAccessGroupsSingle
 */
export const useDeleteAccessGroupsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessGroupsSingle>>,
    TError,
    { groupid: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteAccessGroupsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get group configuration.
 * @summary getAccessGroupsSingle
 */
export const getAccessGroupsSingle = (
  groupid: string,
  signal?: AbortSignal,
) => {
  return apiInstance<GetAccessGroupsSingleResponseResponse>({
    url: `/access/groups/${groupid}`,
    method: "get",
    signal,
  });
};

export const getGetAccessGroupsSingleQueryKey = (groupid: string) =>
  [`/access/groups/${groupid}`] as const;

export const getGetAccessGroupsSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessGroupsSingle>>,
  TError = ErrorType<unknown>,
>(
  groupid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessGroupsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessGroupsSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccessGroupsSingleQueryKey(groupid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessGroupsSingle>>
  > = ({ signal }) => getAccessGroupsSingle(groupid, signal);

  return { queryKey, queryFn, enabled: !!groupid, ...queryOptions };
};

export type GetAccessGroupsSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessGroupsSingle>>
>;
export type GetAccessGroupsSingleQueryError = ErrorType<unknown>;

/**
 * @summary getAccessGroupsSingle
 */
export const useGetAccessGroupsSingle = <
  TData = Awaited<ReturnType<typeof getAccessGroupsSingle>>,
  TError = ErrorType<unknown>,
>(
  groupid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessGroupsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessGroupsSingleQueryOptions(groupid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update group data.
 * @summary updateAccessGroupsSingle
 */
export const updateAccessGroupsSingle = (
  groupid: string,
  updateAccessGroupsSingleRequest: UpdateAccessGroupsSingleRequest,
) => {
  return apiInstance<UpdateAccessGroupsSingleResponseResponse>({
    url: `/access/groups/${groupid}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateAccessGroupsSingleRequest,
  });
};

export const getUpdateAccessGroupsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessGroupsSingle>>,
    TError,
    { groupid: string; data: UpdateAccessGroupsSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccessGroupsSingle>>,
  TError,
  { groupid: string; data: UpdateAccessGroupsSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccessGroupsSingle>>,
    { groupid: string; data: UpdateAccessGroupsSingleRequest }
  > = (props) => {
    const { groupid, data } = props ?? {};

    return updateAccessGroupsSingle(groupid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccessGroupsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAccessGroupsSingle>>
>;
export type UpdateAccessGroupsSingleMutationBody =
  UpdateAccessGroupsSingleRequest;
export type UpdateAccessGroupsSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateAccessGroupsSingle
 */
export const useUpdateAccessGroupsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessGroupsSingle>>,
    TError,
    { groupid: string; data: UpdateAccessGroupsSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateAccessGroupsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Role index.
 * @summary getAccessRoles
 */
export const getAccessRoles = (signal?: AbortSignal) => {
  return apiInstance<GetAccessRolesResponseResponse>({
    url: `/access/roles`,
    method: "get",
    signal,
  });
};

export const getGetAccessRolesQueryKey = () => [`/access/roles`] as const;

export const getGetAccessRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessRoles>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessRoles>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessRoles>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccessRolesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessRoles>>> = ({
    signal,
  }) => getAccessRoles(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetAccessRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessRoles>>
>;
export type GetAccessRolesQueryError = ErrorType<unknown>;

/**
 * @summary getAccessRoles
 */
export const useGetAccessRoles = <
  TData = Awaited<ReturnType<typeof getAccessRoles>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessRoles>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessRolesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new role.
 * @summary createAccessRoles
 */
export const createAccessRoles = (
  createAccessRolesRequest: CreateAccessRolesRequest,
) => {
  return apiInstance<CreateAccessRolesResponseResponse>({
    url: `/access/roles`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createAccessRolesRequest,
  });
};

export const getCreateAccessRolesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessRoles>>,
    TError,
    { data: CreateAccessRolesRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAccessRoles>>,
  TError,
  { data: CreateAccessRolesRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAccessRoles>>,
    { data: CreateAccessRolesRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createAccessRoles(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAccessRolesMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAccessRoles>>
>;
export type CreateAccessRolesMutationBody = CreateAccessRolesRequest;
export type CreateAccessRolesMutationError = ErrorType<unknown>;

/**
 * @summary createAccessRoles
 */
export const useCreateAccessRoles = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessRoles>>,
    TError,
    { data: CreateAccessRolesRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateAccessRolesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete role.
 * @summary deleteAccessRolesSingle
 */
export const deleteAccessRolesSingle = (roleid: string) => {
  return apiInstance<DeleteAccessRolesSingleResponseResponse>({
    url: `/access/roles/${roleid}`,
    method: "delete",
  });
};

export const getDeleteAccessRolesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessRolesSingle>>,
    TError,
    { roleid: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccessRolesSingle>>,
  TError,
  { roleid: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccessRolesSingle>>,
    { roleid: string }
  > = (props) => {
    const { roleid } = props ?? {};

    return deleteAccessRolesSingle(roleid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccessRolesSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccessRolesSingle>>
>;

export type DeleteAccessRolesSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteAccessRolesSingle
 */
export const useDeleteAccessRolesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessRolesSingle>>,
    TError,
    { roleid: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteAccessRolesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get role configuration.
 * @summary getAccessRolesSingle
 */
export const getAccessRolesSingle = (roleid: string, signal?: AbortSignal) => {
  return apiInstance<GetAccessRolesSingleResponseResponse>({
    url: `/access/roles/${roleid}`,
    method: "get",
    signal,
  });
};

export const getGetAccessRolesSingleQueryKey = (roleid: string) =>
  [`/access/roles/${roleid}`] as const;

export const getGetAccessRolesSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessRolesSingle>>,
  TError = ErrorType<unknown>,
>(
  roleid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessRolesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessRolesSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccessRolesSingleQueryKey(roleid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessRolesSingle>>
  > = ({ signal }) => getAccessRolesSingle(roleid, signal);

  return { queryKey, queryFn, enabled: !!roleid, ...queryOptions };
};

export type GetAccessRolesSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessRolesSingle>>
>;
export type GetAccessRolesSingleQueryError = ErrorType<unknown>;

/**
 * @summary getAccessRolesSingle
 */
export const useGetAccessRolesSingle = <
  TData = Awaited<ReturnType<typeof getAccessRolesSingle>>,
  TError = ErrorType<unknown>,
>(
  roleid: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessRolesSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessRolesSingleQueryOptions(roleid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update an existing role.
 * @summary updateAccessRolesSingle
 */
export const updateAccessRolesSingle = (
  roleid: string,
  updateAccessRolesSingleRequest: UpdateAccessRolesSingleRequest,
) => {
  return apiInstance<UpdateAccessRolesSingleResponseResponse>({
    url: `/access/roles/${roleid}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateAccessRolesSingleRequest,
  });
};

export const getUpdateAccessRolesSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessRolesSingle>>,
    TError,
    { roleid: string; data: UpdateAccessRolesSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccessRolesSingle>>,
  TError,
  { roleid: string; data: UpdateAccessRolesSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccessRolesSingle>>,
    { roleid: string; data: UpdateAccessRolesSingleRequest }
  > = (props) => {
    const { roleid, data } = props ?? {};

    return updateAccessRolesSingle(roleid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccessRolesSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAccessRolesSingle>>
>;
export type UpdateAccessRolesSingleMutationBody =
  UpdateAccessRolesSingleRequest;
export type UpdateAccessRolesSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateAccessRolesSingle
 */
export const useUpdateAccessRolesSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessRolesSingle>>,
    TError,
    { roleid: string; data: UpdateAccessRolesSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateAccessRolesSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get Access Control List (ACLs).
 * @summary getAccessAcl
 */
export const getAccessAcl = (signal?: AbortSignal) => {
  return apiInstance<GetAccessAclResponseResponse>({
    url: `/access/acl`,
    method: "get",
    signal,
  });
};

export const getGetAccessAclQueryKey = () => [`/access/acl`] as const;

export const getGetAccessAclQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessAcl>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessAcl>>,
    TError,
    TData
  >;
}): UseQueryOptions<Awaited<ReturnType<typeof getAccessAcl>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccessAclQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessAcl>>> = ({
    signal,
  }) => getAccessAcl(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetAccessAclQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessAcl>>
>;
export type GetAccessAclQueryError = ErrorType<unknown>;

/**
 * @summary getAccessAcl
 */
export const useGetAccessAcl = <
  TData = Awaited<ReturnType<typeof getAccessAcl>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessAcl>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessAclQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update Access Control List (add or remove permissions).
 * @summary updateAccessAcl
 */
export const updateAccessAcl = (
  updateAccessAclRequest: UpdateAccessAclRequest,
) => {
  return apiInstance<UpdateAccessAclResponseResponse>({
    url: `/access/acl`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateAccessAclRequest,
  });
};

export const getUpdateAccessAclMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessAcl>>,
    TError,
    { data: UpdateAccessAclRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccessAcl>>,
  TError,
  { data: UpdateAccessAclRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccessAcl>>,
    { data: UpdateAccessAclRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateAccessAcl(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccessAclMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAccessAcl>>
>;
export type UpdateAccessAclMutationBody = UpdateAccessAclRequest;
export type UpdateAccessAclMutationError = ErrorType<unknown>;

/**
 * @summary updateAccessAcl
 */
export const useUpdateAccessAcl = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessAcl>>,
    TError,
    { data: UpdateAccessAclRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateAccessAclMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Authentication domain index.
 * @summary getAccessDomains
 */
export const getAccessDomains = (signal?: AbortSignal) => {
  return apiInstance<GetAccessDomainsResponseResponse>({
    url: `/access/domains`,
    method: "get",
    signal,
  });
};

export const getGetAccessDomainsQueryKey = () => [`/access/domains`] as const;

export const getGetAccessDomainsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessDomains>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessDomains>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessDomains>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccessDomainsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessDomains>>
  > = ({ signal }) => getAccessDomains(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetAccessDomainsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessDomains>>
>;
export type GetAccessDomainsQueryError = ErrorType<unknown>;

/**
 * @summary getAccessDomains
 */
export const useGetAccessDomains = <
  TData = Awaited<ReturnType<typeof getAccessDomains>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessDomains>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessDomainsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Add an authentication server.
 * @summary createAccessDomains
 */
export const createAccessDomains = (
  createAccessDomainsRequest: CreateAccessDomainsRequest,
) => {
  return apiInstance<CreateAccessDomainsResponseResponse>({
    url: `/access/domains`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createAccessDomainsRequest,
  });
};

export const getCreateAccessDomainsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessDomains>>,
    TError,
    { data: CreateAccessDomainsRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAccessDomains>>,
  TError,
  { data: CreateAccessDomainsRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAccessDomains>>,
    { data: CreateAccessDomainsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createAccessDomains(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAccessDomainsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAccessDomains>>
>;
export type CreateAccessDomainsMutationBody = CreateAccessDomainsRequest;
export type CreateAccessDomainsMutationError = ErrorType<unknown>;

/**
 * @summary createAccessDomains
 */
export const useCreateAccessDomains = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessDomains>>,
    TError,
    { data: CreateAccessDomainsRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateAccessDomainsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete an authentication server.
 * @summary deleteAccessDomainsSingle
 */
export const deleteAccessDomainsSingle = (realm: string) => {
  return apiInstance<DeleteAccessDomainsSingleResponseResponse>({
    url: `/access/domains/${realm}`,
    method: "delete",
  });
};

export const getDeleteAccessDomainsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessDomainsSingle>>,
    TError,
    { realm: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccessDomainsSingle>>,
  TError,
  { realm: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccessDomainsSingle>>,
    { realm: string }
  > = (props) => {
    const { realm } = props ?? {};

    return deleteAccessDomainsSingle(realm);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccessDomainsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccessDomainsSingle>>
>;

export type DeleteAccessDomainsSingleMutationError = ErrorType<unknown>;

/**
 * @summary deleteAccessDomainsSingle
 */
export const useDeleteAccessDomainsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccessDomainsSingle>>,
    TError,
    { realm: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteAccessDomainsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get auth server configuration.
 * @summary getAccessDomainsSingle
 */
export const getAccessDomainsSingle = (realm: string, signal?: AbortSignal) => {
  return apiInstance<GetAccessDomainsSingleResponseResponse>({
    url: `/access/domains/${realm}`,
    method: "get",
    signal,
  });
};

export const getGetAccessDomainsSingleQueryKey = (realm: string) =>
  [`/access/domains/${realm}`] as const;

export const getGetAccessDomainsSingleQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessDomainsSingle>>,
  TError = ErrorType<unknown>,
>(
  realm: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessDomainsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessDomainsSingle>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccessDomainsSingleQueryKey(realm);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessDomainsSingle>>
  > = ({ signal }) => getAccessDomainsSingle(realm, signal);

  return { queryKey, queryFn, enabled: !!realm, ...queryOptions };
};

export type GetAccessDomainsSingleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessDomainsSingle>>
>;
export type GetAccessDomainsSingleQueryError = ErrorType<unknown>;

/**
 * @summary getAccessDomainsSingle
 */
export const useGetAccessDomainsSingle = <
  TData = Awaited<ReturnType<typeof getAccessDomainsSingle>>,
  TError = ErrorType<unknown>,
>(
  realm: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAccessDomainsSingle>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessDomainsSingleQueryOptions(realm, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update authentication server settings.
 * @summary updateAccessDomainsSingle
 */
export const updateAccessDomainsSingle = (
  realm: string,
  updateAccessDomainsSingleRequest: UpdateAccessDomainsSingleRequest,
) => {
  return apiInstance<UpdateAccessDomainsSingleResponseResponse>({
    url: `/access/domains/${realm}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateAccessDomainsSingleRequest,
  });
};

export const getUpdateAccessDomainsSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessDomainsSingle>>,
    TError,
    { realm: string; data: UpdateAccessDomainsSingleRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccessDomainsSingle>>,
  TError,
  { realm: string; data: UpdateAccessDomainsSingleRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccessDomainsSingle>>,
    { realm: string; data: UpdateAccessDomainsSingleRequest }
  > = (props) => {
    const { realm, data } = props ?? {};

    return updateAccessDomainsSingle(realm, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccessDomainsSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAccessDomainsSingle>>
>;
export type UpdateAccessDomainsSingleMutationBody =
  UpdateAccessDomainsSingleRequest;
export type UpdateAccessDomainsSingleMutationError = ErrorType<unknown>;

/**
 * @summary updateAccessDomainsSingle
 */
export const useUpdateAccessDomainsSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessDomainsSingle>>,
    TError,
    { realm: string; data: UpdateAccessDomainsSingleRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateAccessDomainsSingleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Syncs users and/or groups from the configured LDAP to user.cfg. NOTE: Synced groups will have the name 'name-$realm', so make sure those groups do not exist to prevent overwriting.
 * @summary createAccessDomainsSingleSync
 */
export const createAccessDomainsSingleSync = (
  realm: string,
  createAccessDomainsSingleSyncRequest: CreateAccessDomainsSingleSyncRequest,
) => {
  return apiInstance<CreateAccessDomainsSingleSyncResponseResponse>({
    url: `/access/domains/${realm}/sync`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createAccessDomainsSingleSyncRequest,
  });
};

export const getCreateAccessDomainsSingleSyncMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessDomainsSingleSync>>,
    TError,
    { realm: string; data: CreateAccessDomainsSingleSyncRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAccessDomainsSingleSync>>,
  TError,
  { realm: string; data: CreateAccessDomainsSingleSyncRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAccessDomainsSingleSync>>,
    { realm: string; data: CreateAccessDomainsSingleSyncRequest }
  > = (props) => {
    const { realm, data } = props ?? {};

    return createAccessDomainsSingleSync(realm, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAccessDomainsSingleSyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAccessDomainsSingleSync>>
>;
export type CreateAccessDomainsSingleSyncMutationBody =
  CreateAccessDomainsSingleSyncRequest;
export type CreateAccessDomainsSingleSyncMutationError = ErrorType<unknown>;

/**
 * @summary createAccessDomainsSingleSync
 */
export const useCreateAccessDomainsSingleSync = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessDomainsSingleSync>>,
    TError,
    { realm: string; data: CreateAccessDomainsSingleSyncRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getCreateAccessDomainsSingleSyncMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Dummy. Useful for formatters which want to provide a login page.
 * @summary getAccessTicket
 */
export const getAccessTicket = (signal?: AbortSignal) => {
  return apiInstance<GetAccessTicketResponseResponse>({
    url: `/access/ticket`,
    method: "get",
    signal,
  });
};

export const getGetAccessTicketQueryKey = () => [`/access/ticket`] as const;

export const getGetAccessTicketQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessTicket>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessTicket>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessTicket>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccessTicketQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessTicket>>> = ({
    signal,
  }) => getAccessTicket(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetAccessTicketQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessTicket>>
>;
export type GetAccessTicketQueryError = ErrorType<unknown>;

/**
 * @summary getAccessTicket
 */
export const useGetAccessTicket = <
  TData = Awaited<ReturnType<typeof getAccessTicket>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessTicket>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessTicketQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create or verify authentication ticket.
 * @summary createAccessTicket
 */
export const createAccessTicket = (
  createAccessTicketRequest: CreateAccessTicketRequest,
) => {
  return apiInstance<CreateAccessTicketResponseResponse>({
    url: `/access/ticket`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createAccessTicketRequest,
  });
};

export const getCreateAccessTicketMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessTicket>>,
    TError,
    { data: CreateAccessTicketRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAccessTicket>>,
  TError,
  { data: CreateAccessTicketRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAccessTicket>>,
    { data: CreateAccessTicketRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createAccessTicket(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAccessTicketMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAccessTicket>>
>;
export type CreateAccessTicketMutationBody = CreateAccessTicketRequest;
export type CreateAccessTicketMutationError = ErrorType<unknown>;

/**
 * @summary createAccessTicket
 */
export const useCreateAccessTicket = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessTicket>>,
    TError,
    { data: CreateAccessTicketRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateAccessTicketMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Change user password.
 * @summary updateAccessPassword
 */
export const updateAccessPassword = (
  updateAccessPasswordRequest: UpdateAccessPasswordRequest,
) => {
  return apiInstance<UpdateAccessPasswordResponseResponse>({
    url: `/access/password`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateAccessPasswordRequest,
  });
};

export const getUpdateAccessPasswordMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessPassword>>,
    TError,
    { data: UpdateAccessPasswordRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccessPassword>>,
  TError,
  { data: UpdateAccessPasswordRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccessPassword>>,
    { data: UpdateAccessPasswordRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateAccessPassword(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccessPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAccessPassword>>
>;
export type UpdateAccessPasswordMutationBody = UpdateAccessPasswordRequest;
export type UpdateAccessPasswordMutationError = ErrorType<unknown>;

/**
 * @summary updateAccessPassword
 */
export const useUpdateAccessPassword = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessPassword>>,
    TError,
    { data: UpdateAccessPasswordRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateAccessPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Finish a u2f challenge.
 * @summary createAccessTfa
 */
export const createAccessTfa = (
  createAccessTfaRequest: CreateAccessTfaRequest,
) => {
  return apiInstance<CreateAccessTfaResponseResponse>({
    url: `/access/tfa`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createAccessTfaRequest,
  });
};

export const getCreateAccessTfaMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessTfa>>,
    TError,
    { data: CreateAccessTfaRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAccessTfa>>,
  TError,
  { data: CreateAccessTfaRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAccessTfa>>,
    { data: CreateAccessTfaRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createAccessTfa(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAccessTfaMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAccessTfa>>
>;
export type CreateAccessTfaMutationBody = CreateAccessTfaRequest;
export type CreateAccessTfaMutationError = ErrorType<unknown>;

/**
 * @summary createAccessTfa
 */
export const useCreateAccessTfa = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccessTfa>>,
    TError,
    { data: CreateAccessTfaRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreateAccessTfaMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Change user u2f authentication.
 * @summary updateAccessTfa
 */
export const updateAccessTfa = (
  updateAccessTfaRequest: UpdateAccessTfaRequest,
) => {
  return apiInstance<UpdateAccessTfaResponseResponse>({
    url: `/access/tfa`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateAccessTfaRequest,
  });
};

export const getUpdateAccessTfaMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessTfa>>,
    TError,
    { data: UpdateAccessTfaRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccessTfa>>,
  TError,
  { data: UpdateAccessTfaRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccessTfa>>,
    { data: UpdateAccessTfaRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateAccessTfa(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccessTfaMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAccessTfa>>
>;
export type UpdateAccessTfaMutationBody = UpdateAccessTfaRequest;
export type UpdateAccessTfaMutationError = ErrorType<unknown>;

/**
 * @summary updateAccessTfa
 */
export const useUpdateAccessTfa = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccessTfa>>,
    TError,
    { data: UpdateAccessTfaRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdateAccessTfaMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve effective permissions of given user/token.
 * @summary getAccessPermissions
 */
export const getAccessPermissions = (signal?: AbortSignal) => {
  return apiInstance<GetAccessPermissionsResponseResponse>({
    url: `/access/permissions`,
    method: "get",
    signal,
  });
};

export const getGetAccessPermissionsQueryKey = () =>
  [`/access/permissions`] as const;

export const getGetAccessPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessPermissions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessPermissions>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getAccessPermissions>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccessPermissionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessPermissions>>
  > = ({ signal }) => getAccessPermissions(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetAccessPermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessPermissions>>
>;
export type GetAccessPermissionsQueryError = ErrorType<unknown>;

/**
 * @summary getAccessPermissions
 */
export const useGetAccessPermissions = <
  TData = Awaited<ReturnType<typeof getAccessPermissions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getAccessPermissions>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessPermissionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Pool index.
 * @summary getPools
 */
export const getPools = (signal?: AbortSignal) => {
  return apiInstance<GetPoolsResponseResponse>({
    url: `/pools`,
    method: "get",
    signal,
  });
};

export const getGetPoolsQueryKey = () => [`/pools`] as const;

export const getGetPoolsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPools>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getPools>>, TError, TData>;
}): UseQueryOptions<Awaited<ReturnType<typeof getPools>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPoolsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPools>>> = ({
    signal,
  }) => getPools(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetPoolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPools>>
>;
export type GetPoolsQueryError = ErrorType<unknown>;

/**
 * @summary getPools
 */
export const useGetPools = <
  TData = Awaited<ReturnType<typeof getPools>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getPools>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetPoolsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create new pool.
 * @summary createPool
 */
export const createPool = (createPoolRequest: CreatePoolRequest) => {
  return apiInstance<CreatePoolResponseResponse>({
    url: `/pools`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createPoolRequest,
  });
};

export const getCreatePoolMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPool>>,
    TError,
    { data: CreatePoolRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPool>>,
  TError,
  { data: CreatePoolRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPool>>,
    { data: CreatePoolRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createPool(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePoolMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPool>>
>;
export type CreatePoolMutationBody = CreatePoolRequest;
export type CreatePoolMutationError = ErrorType<unknown>;

/**
 * @summary createPool
 */
export const useCreatePool = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPool>>,
    TError,
    { data: CreatePoolRequest },
    TContext
  >;
}) => {
  const mutationOptions = getCreatePoolMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete pool.
 * @summary deletePool
 */
export const deletePool = (poolid: string) => {
  return apiInstance<DeletePoolResponseResponse>({
    url: `/pools/${poolid}`,
    method: "delete",
  });
};

export const getDeletePoolMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePool>>,
    TError,
    { poolid: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePool>>,
  TError,
  { poolid: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePool>>,
    { poolid: string }
  > = (props) => {
    const { poolid } = props ?? {};

    return deletePool(poolid);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePoolMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePool>>
>;

export type DeletePoolMutationError = ErrorType<unknown>;

/**
 * @summary deletePool
 */
export const useDeletePool = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePool>>,
    TError,
    { poolid: string },
    TContext
  >;
}) => {
  const mutationOptions = getDeletePoolMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get pool configuration.
 * @summary getPool
 */
export const getPool = (poolid: string, signal?: AbortSignal) => {
  return apiInstance<GetPoolResponseResponse>({
    url: `/pools/${poolid}`,
    method: "get",
    signal,
  });
};

export const getGetPoolQueryKey = (poolid: string) =>
  [`/pools/${poolid}`] as const;

export const getGetPoolQueryOptions = <
  TData = Awaited<ReturnType<typeof getPool>>,
  TError = ErrorType<unknown>,
>(
  poolid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPool>>, TError, TData>;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getPool>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPoolQueryKey(poolid);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPool>>> = ({
    signal,
  }) => getPool(poolid, signal);

  return { queryKey, queryFn, enabled: !!poolid, ...queryOptions };
};

export type GetPoolQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPool>>
>;
export type GetPoolQueryError = ErrorType<unknown>;

/**
 * @summary getPool
 */
export const useGetPool = <
  TData = Awaited<ReturnType<typeof getPool>>,
  TError = ErrorType<unknown>,
>(
  poolid: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPool>>, TError, TData>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetPoolQueryOptions(poolid, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update pool data.
 * @summary updatePool
 */
export const updatePool = (
  poolid: string,
  updatePoolRequest: UpdatePoolRequest,
) => {
  return apiInstance<UpdatePoolResponseResponse>({
    url: `/pools/${poolid}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updatePoolRequest,
  });
};

export const getUpdatePoolMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePool>>,
    TError,
    { poolid: string; data: UpdatePoolRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePool>>,
  TError,
  { poolid: string; data: UpdatePoolRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePool>>,
    { poolid: string; data: UpdatePoolRequest }
  > = (props) => {
    const { poolid, data } = props ?? {};

    return updatePool(poolid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePoolMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePool>>
>;
export type UpdatePoolMutationBody = UpdatePoolRequest;
export type UpdatePoolMutationError = ErrorType<unknown>;

/**
 * @summary updatePool
 */
export const useUpdatePool = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePool>>,
    TError,
    { poolid: string; data: UpdatePoolRequest },
    TContext
  >;
}) => {
  const mutationOptions = getUpdatePoolMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * API version details. The result also includes the global datacenter confguration.
 * @summary getVersion
 */
export const getVersion = (signal?: AbortSignal) => {
  return apiInstance<GetVersionResponseResponse>({
    url: `/version`,
    method: "get",
    signal,
  });
};

export const getGetVersionQueryKey = () => [`/version`] as const;

export const getGetVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof getVersion>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getVersion>>,
    TError,
    TData
  >;
}): UseQueryOptions<Awaited<ReturnType<typeof getVersion>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersion>>> = ({
    signal,
  }) => getVersion(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type GetVersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVersion>>
>;
export type GetVersionQueryError = ErrorType<unknown>;

/**
 * @summary getVersion
 */
export const useGetVersion = <
  TData = Awaited<ReturnType<typeof getVersion>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getVersion>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetVersionQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};
