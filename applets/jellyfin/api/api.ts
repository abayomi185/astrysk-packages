/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * Jellyfin API
 * OpenAPI spec version: 10.8.8
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import type {
  ActivityLogEntryQueryResult,
  AddListingProviderParams,
  AddMediaPathParams,
  AddToCollectionParams,
  AddToPlaylistParams,
  AddVirtualFolderDto,
  AddVirtualFolderParams,
  AdminNotificationDto,
  AlbumInfoRemoteSearchQuery,
  AllThemeMediaResult,
  ApplySearchCriteriaParams,
  ArtistInfoRemoteSearchQuery,
  AuthenticateUserByName,
  AuthenticateUserParams,
  AuthenticationInfoQueryResult,
  AuthenticationResult,
  AuthorizeParams,
  BaseItemDto,
  BaseItemDtoQueryResult,
  BasePluginConfiguration,
  BookInfoRemoteSearchQuery,
  BoxSetInfoRemoteSearchQuery,
  BrandingOptions,
  BufferRequestDto,
  ChannelFeatures,
  ChannelMappingOptionsDto,
  ClientCapabilitiesDto,
  ClientLogDocumentResponseDto,
  CloseLiveStreamParams,
  CollectionCreationResult,
  ConfigImageTypes,
  ConfigurationPageInfo,
  ConnectParams,
  CountryInfo,
  CreateCollectionParams,
  CreateKeyParams,
  CreatePlaylistDto,
  CreatePlaylistParams,
  CreateUserByName,
  CultureDto,
  DefaultDirectoryBrowserInfoDto,
  DeleteDeviceParams,
  DeleteItemImageParams,
  DeleteItemsParams,
  DeleteListingProviderParams,
  DeleteTunerHostParams,
  DeleteUserImageParams,
  DeviceInfo,
  DeviceInfoQueryResult,
  DeviceOptions,
  DeviceOptionsDto,
  DeviceProfile,
  DeviceProfileInfo,
  DiscoverTunersParams,
  DiscvoverTunersParams,
  DisplayContentParams,
  DisplayPreferencesDto,
  DownloadRemoteImageParams,
  EndPointInfo,
  ExternalIdInfo,
  FileSystemEntryInfo,
  FontFile,
  ForgotPasswordDto,
  ForgotPasswordPinDto,
  ForgotPasswordResult,
  GeneralCommand,
  GeneralCommandType,
  GetAdditionalPartParams,
  GetAlbumArtistsParams,
  GetAncestorsParams,
  GetArtistByNameParams,
  GetArtistImageParams,
  GetArtistsParams,
  GetAudioStreamByContainerParams,
  GetAudioStreamParams,
  GetBitrateTestBytesParams,
  GetChannelItemsParams,
  GetChannelMappingOptionsParams,
  GetChannelParams,
  GetChannelsParams,
  GetConfigurationPagesParams,
  GetDashboardConfigurationPageParams,
  GetDefaultTimerParams,
  GetDeviceInfoParams,
  GetDeviceOptionsParams,
  GetDevicesParams,
  GetDirectoryContentsParams,
  GetDisplayPreferencesParams,
  GetEpisodesParams,
  GetGenreImageByIndexParams,
  GetGenreImageParams,
  GetGenreParams,
  GetGenresParams,
  GetHlsAudioSegmentParams,
  GetHlsVideoSegmentParams,
  GetInstantMixFromAlbumParams,
  GetInstantMixFromArtists2Params,
  GetInstantMixFromArtistsParams,
  GetInstantMixFromItemParams,
  GetInstantMixFromMusicGenreByIdParams,
  GetInstantMixFromMusicGenreByNameParams,
  GetInstantMixFromPlaylistParams,
  GetInstantMixFromSongParams,
  GetItemCountsParams,
  GetItemImage2Params,
  GetItemImageByIndexParams,
  GetItemImageParams,
  GetItemsByUserIdParams,
  GetItemsParams,
  GetLatestChannelItemsParams,
  GetLatestMediaParams,
  GetLibraryOptionsInfoParams,
  GetLineupsParams,
  GetLiveHlsStreamParams,
  GetLiveTvChannelsParams,
  GetLiveTvProgramsParams,
  GetLogEntriesParams,
  GetLogFileParams,
  GetMasterHlsAudioPlaylistParams,
  GetMasterHlsVideoPlaylistParams,
  GetMediaFoldersParams,
  GetMovieRecommendationsParams,
  GetMusicGenreImageByIndexParams,
  GetMusicGenreImageParams,
  GetMusicGenreParams,
  GetMusicGenresParams,
  GetNextUpParams,
  GetPackageInfoParams,
  GetParams,
  GetParentPathParams,
  GetPersonImageByIndexParams,
  GetPersonImageParams,
  GetPersonParams,
  GetPersonsParams,
  GetPlaybackInfoParams,
  GetPlaylistItemsParams,
  GetPostedPlaybackInfoParams,
  GetProgramParams,
  GetProgramsDto,
  GetQueryFiltersLegacyParams,
  GetQueryFiltersParams,
  GetRecommendedProgramsParams,
  GetRecordingFoldersParams,
  GetRecordingGroupsParams,
  GetRecordingParams,
  GetRecordingsParams,
  GetRecordingsSeriesParams,
  GetRemoteImagesParams,
  GetResumeItemsParams,
  GetSeasonsParams,
  GetSeriesTimersParams,
  GetSessionsParams,
  GetSimilarAlbumsParams,
  GetSimilarArtistsParams,
  GetSimilarItemsParams,
  GetSimilarMoviesParams,
  GetSimilarShowsParams,
  GetSimilarTrailersParams,
  GetSplashscreenParams,
  GetStudioImageByIndexParams,
  GetStudioImageParams,
  GetStudioParams,
  GetStudiosParams,
  GetSubtitleParams,
  GetSubtitlePlaylistParams,
  GetSubtitleWithTicksParams,
  GetSuggestionsParams,
  GetTasksParams,
  GetThemeMediaParams,
  GetThemeSongsParams,
  GetThemeVideosParams,
  GetTimersParams,
  GetTrailersParams,
  GetUniversalAudioStreamParams,
  GetUpcomingEpisodesParams,
  GetUserImageByIndexParams,
  GetUserImageParams,
  GetUserViewsParams,
  GetUsersParams,
  GetVariantHlsAudioPlaylistParams,
  GetVariantHlsVideoPlaylistParams,
  GetVideoStreamByContainerParams,
  GetVideoStreamParams,
  GetYearParams,
  GetYearsParams,
  GroupInfoDto,
  GuideInfo,
  HeadArtistImageParams,
  HeadAudioStreamByContainerParams,
  HeadAudioStreamParams,
  HeadGenreImageByIndexParams,
  HeadGenreImageParams,
  HeadItemImage2Params,
  HeadItemImageByIndexParams,
  HeadItemImageParams,
  HeadMasterHlsAudioPlaylistParams,
  HeadMasterHlsVideoPlaylistParams,
  HeadMusicGenreImageByIndexParams,
  HeadMusicGenreImageParams,
  HeadPersonImageByIndexParams,
  HeadPersonImageParams,
  HeadStudioImageByIndexParams,
  HeadStudioImageParams,
  HeadUniversalAudioStreamParams,
  HeadUserImageByIndexParams,
  HeadUserImageParams,
  HeadVideoStreamByContainerParams,
  HeadVideoStreamParams,
  IgnoreWaitRequestDto,
  ImageByNameInfo,
  ImageFormat,
  ImageInfo,
  ImageProviderInfo,
  ImageType,
  InstallPackageParams,
  ItemCounts,
  JoinGroupRequestDto,
  LibraryOptionsResultDto,
  ListingsProviderInfo,
  LiveStreamResponse,
  LiveTvInfo,
  LocalizationOption,
  LogFile,
  MarkPlayedItemParams,
  MediaEncoderPathDto,
  MediaPathDto,
  MediaUpdateInfoDto,
  MergeVersionsParams,
  MessageCommand,
  MetadataEditorInfo,
  MetadataOptions,
  MovePlaylistItemRequestDto,
  MovieInfoRemoteSearchQuery,
  MusicVideoInfoRemoteSearchQuery,
  NameIdPair,
  NewGroupRequestDto,
  NextItemRequestDto,
  NotificationResultDto,
  NotificationTypeInfo,
  NotificationsSummaryDto,
  OnPlaybackProgressParams,
  OnPlaybackStartParams,
  OnPlaybackStoppedParams,
  OpenLiveStreamDto,
  OpenLiveStreamParams,
  PackageInfo,
  ParentalRating,
  PersonLookupInfoRemoteSearchQuery,
  PinRedeemResult,
  PingPlaybackSessionParams,
  PingRequestDto,
  PlayParams,
  PlayRequestDto,
  PlaybackInfoDto,
  PlaybackInfoResponse,
  PlaybackProgressInfo,
  PlaybackStartInfo,
  PlaybackStopInfo,
  PlaylistCreationResult,
  PlaystateCommand,
  PluginInfo,
  PostAddedMoviesParams,
  PostAddedSeriesParams,
  PostCapabilitiesParams,
  PostFullCapabilitiesParams,
  PostUpdatedMoviesParams,
  PostUpdatedSeriesParams,
  PostUserImageParams,
  PreviousItemRequestDto,
  ProblemDetails,
  PublicSystemInfo,
  QueryFilters,
  QueryFiltersLegacy,
  QueueRequestDto,
  QuickConnectDto,
  QuickConnectResult,
  ReadyRequestDto,
  RecommendationDto,
  RefreshItemParams,
  RemoteImageResult,
  RemoteSearchResult,
  RemoteSubtitleInfo,
  RemoveFromCollectionParams,
  RemoveFromPlaylistParams,
  RemoveFromPlaylistRequestDto,
  RemoveMediaPathParams,
  RemoveVirtualFolderParams,
  RenameVirtualFolderParams,
  ReportViewingParams,
  RepositoryInfo,
  SearchHintResult,
  SearchRemoteSubtitlesParams,
  SeekRequestDto,
  SendPlaystateCommandParams,
  SeriesInfoRemoteSearchQuery,
  SeriesTimerInfoDto,
  SeriesTimerInfoDtoQueryResult,
  ServerConfiguration,
  SessionInfo,
  SetChannelMappingDto,
  SetPlaylistItemRequestDto,
  SetRepeatModeRequestDto,
  SetShuffleModeRequestDto,
  SpecialViewOptionDto,
  StartupConfigurationDto,
  StartupRemoteAccessDto,
  StartupUserDto,
  StopEncodingProcessParams,
  SystemInfo,
  TaskInfo,
  TaskTriggerInfo,
  ThemeMediaResult,
  TimerInfoDto,
  TimerInfoDtoQueryResult,
  TrailerInfoRemoteSearchQuery,
  TunerChannelMapping,
  TunerHostInfo,
  UpdateDeviceOptionsParams,
  UpdateDisplayPreferencesParams,
  UpdateItemContentTypeParams,
  UpdateItemImageIndexParams,
  UpdateLibraryOptionsDto,
  UpdateMediaPathRequestDto,
  UpdateUserEasyPassword,
  UpdateUserItemRatingParams,
  UpdateUserPassword,
  UploadSubtitleDto,
  UserConfiguration,
  UserDto,
  UserItemDataDto,
  UserPolicy,
  UtcTimeResponse,
  ValidatePathDto,
  VirtualFolderInfo,
  WakeOnLanInfo,
} from "./model";
import { apiInstance } from "../../../api/apiInstance";
import type { ErrorType } from "../../../api/apiInstance";

/**
 * @summary Gets activity log entries.
 */
export const getLogEntries = (
  params?: GetLogEntriesParams,
  signal?: AbortSignal
) => {
  return apiInstance<ActivityLogEntryQueryResult>({
    url: `/System/ActivityLog/Entries`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLogEntriesQueryKey = (params?: GetLogEntriesParams) => {
  return [`/System/ActivityLog/Entries`, ...(params ? [params] : [])] as const;
};

export const getGetLogEntriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getLogEntries>>,
  TError = ErrorType<void>
>(
  params?: GetLogEntriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogEntries>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLogEntriesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLogEntries>>> = ({
    signal,
  }) => getLogEntries(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLogEntries>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLogEntriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLogEntries>>
>;
export type GetLogEntriesQueryError = ErrorType<void>;

export function useGetLogEntries<
  TData = Awaited<ReturnType<typeof getLogEntries>>,
  TError = ErrorType<void>
>(
  params: undefined | GetLogEntriesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogEntries>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogEntries>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLogEntries<
  TData = Awaited<ReturnType<typeof getLogEntries>>,
  TError = ErrorType<void>
>(
  params?: GetLogEntriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogEntries>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogEntries>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLogEntries<
  TData = Awaited<ReturnType<typeof getLogEntries>>,
  TError = ErrorType<void>
>(
  params?: GetLogEntriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogEntries>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets activity log entries.
 */

export function useGetLogEntries<
  TData = Awaited<ReturnType<typeof getLogEntries>>,
  TError = ErrorType<void>
>(
  params?: GetLogEntriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogEntries>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLogEntriesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all keys.
 */
export const getKeys = (signal?: AbortSignal) => {
  return apiInstance<AuthenticationInfoQueryResult>({
    url: `/Auth/Keys`,
    method: "GET",
    signal,
  });
};

export const getGetKeysQueryKey = () => {
  return [`/Auth/Keys`] as const;
};

export const getGetKeysQueryOptions = <
  TData = Awaited<ReturnType<typeof getKeys>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getKeys>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetKeysQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getKeys>>> = ({
    signal,
  }) => getKeys(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getKeys>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetKeysQueryResult = NonNullable<
  Awaited<ReturnType<typeof getKeys>>
>;
export type GetKeysQueryError = ErrorType<void>;

export function useGetKeys<
  TData = Awaited<ReturnType<typeof getKeys>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getKeys>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getKeys>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetKeys<
  TData = Awaited<ReturnType<typeof getKeys>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getKeys>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getKeys>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetKeys<
  TData = Awaited<ReturnType<typeof getKeys>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getKeys>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get all keys.
 */

export function useGetKeys<
  TData = Awaited<ReturnType<typeof getKeys>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getKeys>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetKeysQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new api key.
 */
export const createKey = (params: CreateKeyParams) => {
  return apiInstance<void>({ url: `/Auth/Keys`, method: "POST", params });
};

export const getCreateKeyMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createKey>>,
    TError,
    { params: CreateKeyParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createKey>>,
  TError,
  { params: CreateKeyParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createKey>>,
    { params: CreateKeyParams }
  > = (props) => {
    const { params } = props ?? {};

    return createKey(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createKey>>
>;

export type CreateKeyMutationError = ErrorType<void>;

/**
 * @summary Create a new api key.
 */
export const useCreateKey = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createKey>>,
    TError,
    { params: CreateKeyParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createKey>>,
  TError,
  { params: CreateKeyParams },
  TContext
> => {
  const mutationOptions = getCreateKeyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Remove an api key.
 */
export const revokeKey = (key: string) => {
  return apiInstance<void>({ url: `/Auth/Keys/${key}`, method: "DELETE" });
};

export const getRevokeKeyMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revokeKey>>,
    TError,
    { key: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof revokeKey>>,
  TError,
  { key: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof revokeKey>>,
    { key: string }
  > = (props) => {
    const { key } = props ?? {};

    return revokeKey(key);
  };

  return { mutationFn, ...mutationOptions };
};

export type RevokeKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof revokeKey>>
>;

export type RevokeKeyMutationError = ErrorType<void>;

/**
 * @summary Remove an api key.
 */
export const useRevokeKey = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revokeKey>>,
    TError,
    { key: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof revokeKey>>,
  TError,
  { key: string },
  TContext
> => {
  const mutationOptions = getRevokeKeyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets all artists from a given item, folder, or the entire library.
 */
export const getArtists = (params?: GetArtistsParams, signal?: AbortSignal) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Artists`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetArtistsQueryKey = (params?: GetArtistsParams) => {
  return [`/Artists`, ...(params ? [params] : [])] as const;
};

export const getGetArtistsQueryOptions = <
  TData = Awaited<ReturnType<typeof getArtists>>,
  TError = ErrorType<void>
>(
  params?: GetArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtists>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetArtistsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getArtists>>> = ({
    signal,
  }) => getArtists(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getArtists>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetArtistsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getArtists>>
>;
export type GetArtistsQueryError = ErrorType<void>;

export function useGetArtists<
  TData = Awaited<ReturnType<typeof getArtists>>,
  TError = ErrorType<void>
>(
  params: undefined | GetArtistsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtists>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtists>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetArtists<
  TData = Awaited<ReturnType<typeof getArtists>>,
  TError = ErrorType<void>
>(
  params?: GetArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtists>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtists>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetArtists<
  TData = Awaited<ReturnType<typeof getArtists>>,
  TError = ErrorType<void>
>(
  params?: GetArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtists>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all artists from a given item, folder, or the entire library.
 */

export function useGetArtists<
  TData = Awaited<ReturnType<typeof getArtists>>,
  TError = ErrorType<void>
>(
  params?: GetArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtists>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetArtistsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an artist by name.
 */
export const getArtistByName = (
  name: string,
  params?: GetArtistByNameParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/Artists/${name}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetArtistByNameQueryKey = (
  name: string,
  params?: GetArtistByNameParams
) => {
  return [`/Artists/${name}`, ...(params ? [params] : [])] as const;
};

export const getGetArtistByNameQueryOptions = <
  TData = Awaited<ReturnType<typeof getArtistByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetArtistByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getArtistByName>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetArtistByNameQueryKey(name, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getArtistByName>>> = ({
    signal,
  }) => getArtistByName(name, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getArtistByName>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetArtistByNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getArtistByName>>
>;
export type GetArtistByNameQueryError = ErrorType<void>;

export function useGetArtistByName<
  TData = Awaited<ReturnType<typeof getArtistByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params: undefined | GetArtistByNameParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getArtistByName>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtistByName>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetArtistByName<
  TData = Awaited<ReturnType<typeof getArtistByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetArtistByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getArtistByName>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtistByName>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetArtistByName<
  TData = Awaited<ReturnType<typeof getArtistByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetArtistByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getArtistByName>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets an artist by name.
 */

export function useGetArtistByName<
  TData = Awaited<ReturnType<typeof getArtistByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetArtistByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getArtistByName>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetArtistByNameQueryOptions(name, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets all album artists from a given item, folder, or the entire library.
 */
export const getAlbumArtists = (
  params?: GetAlbumArtistsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Artists/AlbumArtists`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetAlbumArtistsQueryKey = (params?: GetAlbumArtistsParams) => {
  return [`/Artists/AlbumArtists`, ...(params ? [params] : [])] as const;
};

export const getGetAlbumArtistsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAlbumArtists>>,
  TError = ErrorType<void>
>(
  params?: GetAlbumArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlbumArtists>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlbumArtistsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlbumArtists>>> = ({
    signal,
  }) => getAlbumArtists(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAlbumArtists>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAlbumArtistsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlbumArtists>>
>;
export type GetAlbumArtistsQueryError = ErrorType<void>;

export function useGetAlbumArtists<
  TData = Awaited<ReturnType<typeof getAlbumArtists>>,
  TError = ErrorType<void>
>(
  params: undefined | GetAlbumArtistsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlbumArtists>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlbumArtists>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAlbumArtists<
  TData = Awaited<ReturnType<typeof getAlbumArtists>>,
  TError = ErrorType<void>
>(
  params?: GetAlbumArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlbumArtists>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlbumArtists>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAlbumArtists<
  TData = Awaited<ReturnType<typeof getAlbumArtists>>,
  TError = ErrorType<void>
>(
  params?: GetAlbumArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlbumArtists>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all album artists from a given item, folder, or the entire library.
 */

export function useGetAlbumArtists<
  TData = Awaited<ReturnType<typeof getAlbumArtists>>,
  TError = ErrorType<void>
>(
  params?: GetAlbumArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlbumArtists>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAlbumArtistsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an audio stream.
 */
export const getAudioStream = (
  itemId: string,
  params?: GetAudioStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/stream`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetAudioStreamQueryKey = (
  itemId: string,
  params?: GetAudioStreamParams
) => {
  return [`/Audio/${itemId}/stream`, ...(params ? [params] : [])] as const;
};

export const getGetAudioStreamQueryOptions = <
  TData = Awaited<ReturnType<typeof getAudioStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params?: GetAudioStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAudioStream>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAudioStreamQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAudioStream>>> = ({
    signal,
  }) => getAudioStream(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAudioStream>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAudioStreamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAudioStream>>
>;
export type GetAudioStreamQueryError = ErrorType<unknown>;

export function useGetAudioStream<
  TData = Awaited<ReturnType<typeof getAudioStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params: undefined | GetAudioStreamParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAudioStream>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAudioStream>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAudioStream<
  TData = Awaited<ReturnType<typeof getAudioStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params?: GetAudioStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAudioStream>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAudioStream>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAudioStream<
  TData = Awaited<ReturnType<typeof getAudioStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params?: GetAudioStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAudioStream>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets an audio stream.
 */

export function useGetAudioStream<
  TData = Awaited<ReturnType<typeof getAudioStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params?: GetAudioStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAudioStream>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAudioStreamQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an audio stream.
 */
export const headAudioStream = (
  itemId: string,
  params?: HeadAudioStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/stream`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadAudioStreamMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headAudioStream>>,
    TError,
    { itemId: string; params?: HeadAudioStreamParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headAudioStream>>,
  TError,
  { itemId: string; params?: HeadAudioStreamParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headAudioStream>>,
    { itemId: string; params?: HeadAudioStreamParams }
  > = (props) => {
    const { itemId, params } = props ?? {};

    return headAudioStream(itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadAudioStreamMutationResult = NonNullable<
  Awaited<ReturnType<typeof headAudioStream>>
>;

export type HeadAudioStreamMutationError = ErrorType<unknown>;

/**
 * @summary Gets an audio stream.
 */
export const useHeadAudioStream = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headAudioStream>>,
    TError,
    { itemId: string; params?: HeadAudioStreamParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headAudioStream>>,
  TError,
  { itemId: string; params?: HeadAudioStreamParams },
  TContext
> => {
  const mutationOptions = getHeadAudioStreamMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets an audio stream.
 */
export const getAudioStreamByContainer = (
  itemId: string,
  container: string,
  params?: GetAudioStreamByContainerParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/stream.${container}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetAudioStreamByContainerQueryKey = (
  itemId: string,
  container: string,
  params?: GetAudioStreamByContainerParams
) => {
  return [
    `/Audio/${itemId}/stream.${container}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAudioStreamByContainerQueryOptions = <
  TData = Awaited<ReturnType<typeof getAudioStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params?: GetAudioStreamByContainerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAudioStreamByContainer>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAudioStreamByContainerQueryKey(itemId, container, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAudioStreamByContainer>>
  > = ({ signal }) =>
    getAudioStreamByContainer(itemId, container, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && container),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAudioStreamByContainer>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAudioStreamByContainerQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAudioStreamByContainer>>
>;
export type GetAudioStreamByContainerQueryError = ErrorType<unknown>;

export function useGetAudioStreamByContainer<
  TData = Awaited<ReturnType<typeof getAudioStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params: undefined | GetAudioStreamByContainerParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAudioStreamByContainer>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAudioStreamByContainer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAudioStreamByContainer<
  TData = Awaited<ReturnType<typeof getAudioStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params?: GetAudioStreamByContainerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAudioStreamByContainer>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAudioStreamByContainer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAudioStreamByContainer<
  TData = Awaited<ReturnType<typeof getAudioStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params?: GetAudioStreamByContainerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAudioStreamByContainer>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets an audio stream.
 */

export function useGetAudioStreamByContainer<
  TData = Awaited<ReturnType<typeof getAudioStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params?: GetAudioStreamByContainerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAudioStreamByContainer>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAudioStreamByContainerQueryOptions(
    itemId,
    container,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an audio stream.
 */
export const headAudioStreamByContainer = (
  itemId: string,
  container: string,
  params?: HeadAudioStreamByContainerParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/stream.${container}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadAudioStreamByContainerMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headAudioStreamByContainer>>,
    TError,
    {
      itemId: string;
      container: string;
      params?: HeadAudioStreamByContainerParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headAudioStreamByContainer>>,
  TError,
  {
    itemId: string;
    container: string;
    params?: HeadAudioStreamByContainerParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headAudioStreamByContainer>>,
    {
      itemId: string;
      container: string;
      params?: HeadAudioStreamByContainerParams;
    }
  > = (props) => {
    const { itemId, container, params } = props ?? {};

    return headAudioStreamByContainer(itemId, container, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadAudioStreamByContainerMutationResult = NonNullable<
  Awaited<ReturnType<typeof headAudioStreamByContainer>>
>;

export type HeadAudioStreamByContainerMutationError = ErrorType<unknown>;

/**
 * @summary Gets an audio stream.
 */
export const useHeadAudioStreamByContainer = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headAudioStreamByContainer>>,
    TError,
    {
      itemId: string;
      container: string;
      params?: HeadAudioStreamByContainerParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headAudioStreamByContainer>>,
  TError,
  {
    itemId: string;
    container: string;
    params?: HeadAudioStreamByContainerParams;
  },
  TContext
> => {
  const mutationOptions = getHeadAudioStreamByContainerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets branding configuration.
 */
export const getBrandingOptions = (signal?: AbortSignal) => {
  return apiInstance<BrandingOptions>({
    url: `/Branding/Configuration`,
    method: "GET",
    signal,
  });
};

export const getGetBrandingOptionsQueryKey = () => {
  return [`/Branding/Configuration`] as const;
};

export const getGetBrandingOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getBrandingOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getBrandingOptions>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBrandingOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBrandingOptions>>
  > = ({ signal }) => getBrandingOptions(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBrandingOptions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetBrandingOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBrandingOptions>>
>;
export type GetBrandingOptionsQueryError = ErrorType<unknown>;

export function useGetBrandingOptions<
  TData = Awaited<ReturnType<typeof getBrandingOptions>>,
  TError = ErrorType<unknown>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getBrandingOptions>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getBrandingOptions>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetBrandingOptions<
  TData = Awaited<ReturnType<typeof getBrandingOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getBrandingOptions>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getBrandingOptions>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetBrandingOptions<
  TData = Awaited<ReturnType<typeof getBrandingOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getBrandingOptions>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets branding configuration.
 */

export function useGetBrandingOptions<
  TData = Awaited<ReturnType<typeof getBrandingOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getBrandingOptions>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetBrandingOptionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets branding css.
 */
export const getBrandingCss = (signal?: AbortSignal) => {
  return apiInstance<string | void>({
    url: `/Branding/Css`,
    method: "GET",
    signal,
  });
};

export const getGetBrandingCssQueryKey = () => {
  return [`/Branding/Css`] as const;
};

export const getGetBrandingCssQueryOptions = <
  TData = Awaited<ReturnType<typeof getBrandingCss>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBrandingCssQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBrandingCss>>> = ({
    signal,
  }) => getBrandingCss(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBrandingCss>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetBrandingCssQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBrandingCss>>
>;
export type GetBrandingCssQueryError = ErrorType<unknown>;

export function useGetBrandingCss<
  TData = Awaited<ReturnType<typeof getBrandingCss>>,
  TError = ErrorType<unknown>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getBrandingCss>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetBrandingCss<
  TData = Awaited<ReturnType<typeof getBrandingCss>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getBrandingCss>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetBrandingCss<
  TData = Awaited<ReturnType<typeof getBrandingCss>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets branding css.
 */

export function useGetBrandingCss<
  TData = Awaited<ReturnType<typeof getBrandingCss>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetBrandingCssQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets branding css.
 */
export const getBrandingCss2 = (signal?: AbortSignal) => {
  return apiInstance<string | void>({
    url: `/Branding/Css.css`,
    method: "GET",
    signal,
  });
};

export const getGetBrandingCss2QueryKey = () => {
  return [`/Branding/Css.css`] as const;
};

export const getGetBrandingCss2QueryOptions = <
  TData = Awaited<ReturnType<typeof getBrandingCss2>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss2>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBrandingCss2QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBrandingCss2>>> = ({
    signal,
  }) => getBrandingCss2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBrandingCss2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetBrandingCss2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getBrandingCss2>>
>;
export type GetBrandingCss2QueryError = ErrorType<unknown>;

export function useGetBrandingCss2<
  TData = Awaited<ReturnType<typeof getBrandingCss2>>,
  TError = ErrorType<unknown>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss2>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getBrandingCss2>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetBrandingCss2<
  TData = Awaited<ReturnType<typeof getBrandingCss2>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss2>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getBrandingCss2>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetBrandingCss2<
  TData = Awaited<ReturnType<typeof getBrandingCss2>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss2>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets branding css.
 */

export function useGetBrandingCss2<
  TData = Awaited<ReturnType<typeof getBrandingCss2>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss2>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetBrandingCss2QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets available channels.
 */
export const getChannels = (
  params?: GetChannelsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Channels`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetChannelsQueryKey = (params?: GetChannelsParams) => {
  return [`/Channels`, ...(params ? [params] : [])] as const;
};

export const getGetChannelsQueryOptions = <
  TData = Awaited<ReturnType<typeof getChannels>>,
  TError = ErrorType<void>
>(
  params?: GetChannelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChannelsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannels>>> = ({
    signal,
  }) => getChannels(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getChannels>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetChannelsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getChannels>>
>;
export type GetChannelsQueryError = ErrorType<void>;

export function useGetChannels<
  TData = Awaited<ReturnType<typeof getChannels>>,
  TError = ErrorType<void>
>(
  params: undefined | GetChannelsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannels>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannels<
  TData = Awaited<ReturnType<typeof getChannels>>,
  TError = ErrorType<void>
>(
  params?: GetChannelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannels>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannels<
  TData = Awaited<ReturnType<typeof getChannels>>,
  TError = ErrorType<void>
>(
  params?: GetChannelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available channels.
 */

export function useGetChannels<
  TData = Awaited<ReturnType<typeof getChannels>>,
  TError = ErrorType<void>
>(
  params?: GetChannelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetChannelsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get channel features.
 */
export const getChannelFeatures = (channelId: string, signal?: AbortSignal) => {
  return apiInstance<ChannelFeatures>({
    url: `/Channels/${channelId}/Features`,
    method: "GET",
    signal,
  });
};

export const getGetChannelFeaturesQueryKey = (channelId: string) => {
  return [`/Channels/${channelId}/Features`] as const;
};

export const getGetChannelFeaturesQueryOptions = <
  TData = Awaited<ReturnType<typeof getChannelFeatures>>,
  TError = ErrorType<void>
>(
  channelId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelFeatures>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetChannelFeaturesQueryKey(channelId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getChannelFeatures>>
  > = ({ signal }) => getChannelFeatures(channelId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!channelId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getChannelFeatures>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetChannelFeaturesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getChannelFeatures>>
>;
export type GetChannelFeaturesQueryError = ErrorType<void>;

export function useGetChannelFeatures<
  TData = Awaited<ReturnType<typeof getChannelFeatures>>,
  TError = ErrorType<void>
>(
  channelId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelFeatures>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelFeatures>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannelFeatures<
  TData = Awaited<ReturnType<typeof getChannelFeatures>>,
  TError = ErrorType<void>
>(
  channelId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelFeatures>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelFeatures>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannelFeatures<
  TData = Awaited<ReturnType<typeof getChannelFeatures>>,
  TError = ErrorType<void>
>(
  channelId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelFeatures>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get channel features.
 */

export function useGetChannelFeatures<
  TData = Awaited<ReturnType<typeof getChannelFeatures>>,
  TError = ErrorType<void>
>(
  channelId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelFeatures>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetChannelFeaturesQueryOptions(channelId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get channel items.
 */
export const getChannelItems = (
  channelId: string,
  params?: GetChannelItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Channels/${channelId}/Items`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetChannelItemsQueryKey = (
  channelId: string,
  params?: GetChannelItemsParams
) => {
  return [`/Channels/${channelId}/Items`, ...(params ? [params] : [])] as const;
};

export const getGetChannelItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getChannelItems>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params?: GetChannelItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelItems>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetChannelItemsQueryKey(channelId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelItems>>> = ({
    signal,
  }) => getChannelItems(channelId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!channelId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getChannelItems>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetChannelItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getChannelItems>>
>;
export type GetChannelItemsQueryError = ErrorType<void>;

export function useGetChannelItems<
  TData = Awaited<ReturnType<typeof getChannelItems>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params: undefined | GetChannelItemsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelItems>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannelItems<
  TData = Awaited<ReturnType<typeof getChannelItems>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params?: GetChannelItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelItems>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannelItems<
  TData = Awaited<ReturnType<typeof getChannelItems>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params?: GetChannelItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelItems>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get channel items.
 */

export function useGetChannelItems<
  TData = Awaited<ReturnType<typeof getChannelItems>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params?: GetChannelItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelItems>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetChannelItemsQueryOptions(
    channelId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all channel features.
 */
export const getAllChannelFeatures = (signal?: AbortSignal) => {
  return apiInstance<ChannelFeatures[]>({
    url: `/Channels/Features`,
    method: "GET",
    signal,
  });
};

export const getGetAllChannelFeaturesQueryKey = () => {
  return [`/Channels/Features`] as const;
};

export const getGetAllChannelFeaturesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllChannelFeatures>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllChannelFeatures>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllChannelFeaturesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllChannelFeatures>>
  > = ({ signal }) => getAllChannelFeatures(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllChannelFeatures>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllChannelFeaturesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllChannelFeatures>>
>;
export type GetAllChannelFeaturesQueryError = ErrorType<void>;

export function useGetAllChannelFeatures<
  TData = Awaited<ReturnType<typeof getAllChannelFeatures>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllChannelFeatures>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getAllChannelFeatures>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAllChannelFeatures<
  TData = Awaited<ReturnType<typeof getAllChannelFeatures>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllChannelFeatures>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getAllChannelFeatures>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAllChannelFeatures<
  TData = Awaited<ReturnType<typeof getAllChannelFeatures>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllChannelFeatures>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get all channel features.
 */

export function useGetAllChannelFeatures<
  TData = Awaited<ReturnType<typeof getAllChannelFeatures>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllChannelFeatures>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAllChannelFeaturesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets latest channel items.
 */
export const getLatestChannelItems = (
  params?: GetLatestChannelItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Channels/Items/Latest`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLatestChannelItemsQueryKey = (
  params?: GetLatestChannelItemsParams
) => {
  return [`/Channels/Items/Latest`, ...(params ? [params] : [])] as const;
};

export const getGetLatestChannelItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLatestChannelItems>>,
  TError = ErrorType<void>
>(
  params?: GetLatestChannelItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestChannelItems>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLatestChannelItemsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLatestChannelItems>>
  > = ({ signal }) => getLatestChannelItems(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLatestChannelItems>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLatestChannelItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLatestChannelItems>>
>;
export type GetLatestChannelItemsQueryError = ErrorType<void>;

export function useGetLatestChannelItems<
  TData = Awaited<ReturnType<typeof getLatestChannelItems>>,
  TError = ErrorType<void>
>(
  params: undefined | GetLatestChannelItemsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestChannelItems>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestChannelItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLatestChannelItems<
  TData = Awaited<ReturnType<typeof getLatestChannelItems>>,
  TError = ErrorType<void>
>(
  params?: GetLatestChannelItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestChannelItems>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestChannelItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLatestChannelItems<
  TData = Awaited<ReturnType<typeof getLatestChannelItems>>,
  TError = ErrorType<void>
>(
  params?: GetLatestChannelItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestChannelItems>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets latest channel items.
 */

export function useGetLatestChannelItems<
  TData = Awaited<ReturnType<typeof getLatestChannelItems>>,
  TError = ErrorType<void>
>(
  params?: GetLatestChannelItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestChannelItems>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLatestChannelItemsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Upload a document.
 */
export const logFile = (logFileBody: Blob) => {
  return apiInstance<ClientLogDocumentResponseDto>({
    url: `/ClientLog/Document`,
    method: "POST",
    headers: { "Content-Type": "text/plain" },
    data: logFileBody,
  });
};

export const getLogFileMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logFile>>,
    TError,
    { data: Blob },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof logFile>>,
  TError,
  { data: Blob },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logFile>>,
    { data: Blob }
  > = (props) => {
    const { data } = props ?? {};

    return logFile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type LogFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof logFile>>
>;
export type LogFileMutationBody = Blob;
export type LogFileMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Upload a document.
 */
export const useLogFile = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logFile>>,
    TError,
    { data: Blob },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof logFile>>,
  TError,
  { data: Blob },
  TContext
> => {
  const mutationOptions = getLogFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Creates a new collection.
 */
export const createCollection = (params?: CreateCollectionParams) => {
  return apiInstance<CollectionCreationResult>({
    url: `/Collections`,
    method: "POST",
    params,
  });
};

export const getCreateCollectionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCollection>>,
    TError,
    { params?: CreateCollectionParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCollection>>,
  TError,
  { params?: CreateCollectionParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCollection>>,
    { params?: CreateCollectionParams }
  > = (props) => {
    const { params } = props ?? {};

    return createCollection(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateCollectionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCollection>>
>;

export type CreateCollectionMutationError = ErrorType<void>;

/**
 * @summary Creates a new collection.
 */
export const useCreateCollection = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCollection>>,
    TError,
    { params?: CreateCollectionParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createCollection>>,
  TError,
  { params?: CreateCollectionParams },
  TContext
> => {
  const mutationOptions = getCreateCollectionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Adds items to a collection.
 */
export const addToCollection = (
  collectionId: string,
  params: AddToCollectionParams
) => {
  return apiInstance<void>({
    url: `/Collections/${collectionId}/Items`,
    method: "POST",
    params,
  });
};

export const getAddToCollectionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addToCollection>>,
    TError,
    { collectionId: string; params: AddToCollectionParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addToCollection>>,
  TError,
  { collectionId: string; params: AddToCollectionParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addToCollection>>,
    { collectionId: string; params: AddToCollectionParams }
  > = (props) => {
    const { collectionId, params } = props ?? {};

    return addToCollection(collectionId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddToCollectionMutationResult = NonNullable<
  Awaited<ReturnType<typeof addToCollection>>
>;

export type AddToCollectionMutationError = ErrorType<void>;

/**
 * @summary Adds items to a collection.
 */
export const useAddToCollection = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addToCollection>>,
    TError,
    { collectionId: string; params: AddToCollectionParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof addToCollection>>,
  TError,
  { collectionId: string; params: AddToCollectionParams },
  TContext
> => {
  const mutationOptions = getAddToCollectionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Removes items from a collection.
 */
export const removeFromCollection = (
  collectionId: string,
  params: RemoveFromCollectionParams
) => {
  return apiInstance<void>({
    url: `/Collections/${collectionId}/Items`,
    method: "DELETE",
    params,
  });
};

export const getRemoveFromCollectionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeFromCollection>>,
    TError,
    { collectionId: string; params: RemoveFromCollectionParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeFromCollection>>,
  TError,
  { collectionId: string; params: RemoveFromCollectionParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeFromCollection>>,
    { collectionId: string; params: RemoveFromCollectionParams }
  > = (props) => {
    const { collectionId, params } = props ?? {};

    return removeFromCollection(collectionId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveFromCollectionMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeFromCollection>>
>;

export type RemoveFromCollectionMutationError = ErrorType<void>;

/**
 * @summary Removes items from a collection.
 */
export const useRemoveFromCollection = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeFromCollection>>,
    TError,
    { collectionId: string; params: RemoveFromCollectionParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof removeFromCollection>>,
  TError,
  { collectionId: string; params: RemoveFromCollectionParams },
  TContext
> => {
  const mutationOptions = getRemoveFromCollectionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets application configuration.
 */
export const getConfiguration = (signal?: AbortSignal) => {
  return apiInstance<ServerConfiguration>({
    url: `/System/Configuration`,
    method: "GET",
    signal,
  });
};

export const getGetConfigurationQueryKey = () => {
  return [`/System/Configuration`] as const;
};

export const getGetConfigurationQueryOptions = <
  TData = Awaited<ReturnType<typeof getConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getConfiguration>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConfigurationQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getConfiguration>>
  > = ({ signal }) => getConfiguration(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConfiguration>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetConfigurationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getConfiguration>>
>;
export type GetConfigurationQueryError = ErrorType<void>;

export function useGetConfiguration<
  TData = Awaited<ReturnType<typeof getConfiguration>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getConfiguration>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getConfiguration>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConfiguration<
  TData = Awaited<ReturnType<typeof getConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getConfiguration>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getConfiguration>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConfiguration<
  TData = Awaited<ReturnType<typeof getConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getConfiguration>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets application configuration.
 */

export function useGetConfiguration<
  TData = Awaited<ReturnType<typeof getConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getConfiguration>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetConfigurationQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates application configuration.
 */
export const updateConfiguration = (
  serverConfiguration: ServerConfiguration
) => {
  return apiInstance<void>({
    url: `/System/Configuration`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: serverConfiguration,
  });
};

export const getUpdateConfigurationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateConfiguration>>,
    TError,
    { data: ServerConfiguration },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateConfiguration>>,
  TError,
  { data: ServerConfiguration },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateConfiguration>>,
    { data: ServerConfiguration }
  > = (props) => {
    const { data } = props ?? {};

    return updateConfiguration(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateConfigurationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateConfiguration>>
>;
export type UpdateConfigurationMutationBody = ServerConfiguration;
export type UpdateConfigurationMutationError = ErrorType<void>;

/**
 * @summary Updates application configuration.
 */
export const useUpdateConfiguration = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateConfiguration>>,
    TError,
    { data: ServerConfiguration },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateConfiguration>>,
  TError,
  { data: ServerConfiguration },
  TContext
> => {
  const mutationOptions = getUpdateConfigurationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a named configuration.
 */
export const getNamedConfiguration = (key: string, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/System/Configuration/${key}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetNamedConfigurationQueryKey = (key: string) => {
  return [`/System/Configuration/${key}`] as const;
};

export const getGetNamedConfigurationQueryOptions = <
  TData = Awaited<ReturnType<typeof getNamedConfiguration>>,
  TError = ErrorType<void>
>(
  key: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNamedConfiguration>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNamedConfigurationQueryKey(key);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNamedConfiguration>>
  > = ({ signal }) => getNamedConfiguration(key, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!key,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getNamedConfiguration>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNamedConfigurationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNamedConfiguration>>
>;
export type GetNamedConfigurationQueryError = ErrorType<void>;

export function useGetNamedConfiguration<
  TData = Awaited<ReturnType<typeof getNamedConfiguration>>,
  TError = ErrorType<void>
>(
  key: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNamedConfiguration>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNamedConfiguration>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNamedConfiguration<
  TData = Awaited<ReturnType<typeof getNamedConfiguration>>,
  TError = ErrorType<void>
>(
  key: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNamedConfiguration>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNamedConfiguration>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNamedConfiguration<
  TData = Awaited<ReturnType<typeof getNamedConfiguration>>,
  TError = ErrorType<void>
>(
  key: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNamedConfiguration>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a named configuration.
 */

export function useGetNamedConfiguration<
  TData = Awaited<ReturnType<typeof getNamedConfiguration>>,
  TError = ErrorType<void>
>(
  key: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNamedConfiguration>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetNamedConfigurationQueryOptions(key, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates named configuration.
 */
export const updateNamedConfiguration = (
  key: string,
  updateNamedConfigurationBody: unknown
) => {
  return apiInstance<void>({
    url: `/System/Configuration/${key}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: updateNamedConfigurationBody,
  });
};

export const getUpdateNamedConfigurationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNamedConfiguration>>,
    TError,
    { key: string; data: unknown },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateNamedConfiguration>>,
  TError,
  { key: string; data: unknown },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateNamedConfiguration>>,
    { key: string; data: unknown }
  > = (props) => {
    const { key, data } = props ?? {};

    return updateNamedConfiguration(key, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateNamedConfigurationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateNamedConfiguration>>
>;
export type UpdateNamedConfigurationMutationBody = unknown;
export type UpdateNamedConfigurationMutationError = ErrorType<void>;

/**
 * @summary Updates named configuration.
 */
export const useUpdateNamedConfiguration = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateNamedConfiguration>>,
    TError,
    { key: string; data: unknown },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateNamedConfiguration>>,
  TError,
  { key: string; data: unknown },
  TContext
> => {
  const mutationOptions = getUpdateNamedConfigurationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a default MetadataOptions object.
 */
export const getDefaultMetadataOptions = (signal?: AbortSignal) => {
  return apiInstance<MetadataOptions>({
    url: `/System/Configuration/MetadataOptions/Default`,
    method: "GET",
    signal,
  });
};

export const getGetDefaultMetadataOptionsQueryKey = () => {
  return [`/System/Configuration/MetadataOptions/Default`] as const;
};

export const getGetDefaultMetadataOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDefaultMetadataOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDefaultMetadataOptions>>
  > = ({ signal }) => getDefaultMetadataOptions(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDefaultMetadataOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDefaultMetadataOptions>>
>;
export type GetDefaultMetadataOptionsQueryError = ErrorType<void>;

export function useGetDefaultMetadataOptions<
  TData = Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultMetadataOptions<
  TData = Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultMetadataOptions<
  TData = Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a default MetadataOptions object.
 */

export function useGetDefaultMetadataOptions<
  TData = Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultMetadataOptions>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDefaultMetadataOptionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates the path to the media encoder.
 */
export const updateMediaEncoderPath = (
  mediaEncoderPathDto: MediaEncoderPathDto
) => {
  return apiInstance<void>({
    url: `/System/MediaEncoder/Path`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: mediaEncoderPathDto,
  });
};

export const getUpdateMediaEncoderPathMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMediaEncoderPath>>,
    TError,
    { data: MediaEncoderPathDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMediaEncoderPath>>,
  TError,
  { data: MediaEncoderPathDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMediaEncoderPath>>,
    { data: MediaEncoderPathDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateMediaEncoderPath(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMediaEncoderPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMediaEncoderPath>>
>;
export type UpdateMediaEncoderPathMutationBody = MediaEncoderPathDto;
export type UpdateMediaEncoderPathMutationError = ErrorType<void>;

/**
 * @summary Updates the path to the media encoder.
 */
export const useUpdateMediaEncoderPath = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMediaEncoderPath>>,
    TError,
    { data: MediaEncoderPathDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateMediaEncoderPath>>,
  TError,
  { data: MediaEncoderPathDto },
  TContext
> => {
  const mutationOptions = getUpdateMediaEncoderPathMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a dashboard configuration page.
 */
export const getDashboardConfigurationPage = (
  params?: GetDashboardConfigurationPageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/web/ConfigurationPage`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetDashboardConfigurationPageQueryKey = (
  params?: GetDashboardConfigurationPageParams
) => {
  return [`/web/ConfigurationPage`, ...(params ? [params] : [])] as const;
};

export const getGetDashboardConfigurationPageQueryOptions = <
  TData = Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
  TError = ErrorType<ProblemDetails>
>(
  params?: GetDashboardConfigurationPageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDashboardConfigurationPageQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDashboardConfigurationPage>>
  > = ({ signal }) => getDashboardConfigurationPage(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDashboardConfigurationPageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDashboardConfigurationPage>>
>;
export type GetDashboardConfigurationPageQueryError = ErrorType<ProblemDetails>;

export function useGetDashboardConfigurationPage<
  TData = Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
  TError = ErrorType<ProblemDetails>
>(
  params: undefined | GetDashboardConfigurationPageParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDashboardConfigurationPage<
  TData = Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
  TError = ErrorType<ProblemDetails>
>(
  params?: GetDashboardConfigurationPageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDashboardConfigurationPage<
  TData = Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
  TError = ErrorType<ProblemDetails>
>(
  params?: GetDashboardConfigurationPageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a dashboard configuration page.
 */

export function useGetDashboardConfigurationPage<
  TData = Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
  TError = ErrorType<ProblemDetails>
>(
  params?: GetDashboardConfigurationPageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardConfigurationPage>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDashboardConfigurationPageQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the configuration pages.
 */
export const getConfigurationPages = (
  params?: GetConfigurationPagesParams,
  signal?: AbortSignal
) => {
  return apiInstance<ConfigurationPageInfo[]>({
    url: `/web/ConfigurationPages`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetConfigurationPagesQueryKey = (
  params?: GetConfigurationPagesParams
) => {
  return [`/web/ConfigurationPages`, ...(params ? [params] : [])] as const;
};

export const getGetConfigurationPagesQueryOptions = <
  TData = Awaited<ReturnType<typeof getConfigurationPages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params?: GetConfigurationPagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConfigurationPages>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetConfigurationPagesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getConfigurationPages>>
  > = ({ signal }) => getConfigurationPages(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConfigurationPages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetConfigurationPagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getConfigurationPages>>
>;
export type GetConfigurationPagesQueryError = ErrorType<void | ProblemDetails>;

export function useGetConfigurationPages<
  TData = Awaited<ReturnType<typeof getConfigurationPages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: undefined | GetConfigurationPagesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConfigurationPages>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigurationPages>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConfigurationPages<
  TData = Awaited<ReturnType<typeof getConfigurationPages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params?: GetConfigurationPagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConfigurationPages>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigurationPages>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConfigurationPages<
  TData = Awaited<ReturnType<typeof getConfigurationPages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params?: GetConfigurationPagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConfigurationPages>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the configuration pages.
 */

export function useGetConfigurationPages<
  TData = Awaited<ReturnType<typeof getConfigurationPages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params?: GetConfigurationPagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConfigurationPages>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetConfigurationPagesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Devices.
 */
export const getDevices = (params?: GetDevicesParams, signal?: AbortSignal) => {
  return apiInstance<DeviceInfoQueryResult>({
    url: `/Devices`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDevicesQueryKey = (params?: GetDevicesParams) => {
  return [`/Devices`, ...(params ? [params] : [])] as const;
};

export const getGetDevicesQueryOptions = <
  TData = Awaited<ReturnType<typeof getDevices>>,
  TError = ErrorType<void>
>(
  params?: GetDevicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDevices>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDevicesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDevices>>> = ({
    signal,
  }) => getDevices(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDevices>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDevicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDevices>>
>;
export type GetDevicesQueryError = ErrorType<void>;

export function useGetDevices<
  TData = Awaited<ReturnType<typeof getDevices>>,
  TError = ErrorType<void>
>(
  params: undefined | GetDevicesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDevices>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDevices>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDevices<
  TData = Awaited<ReturnType<typeof getDevices>>,
  TError = ErrorType<void>
>(
  params?: GetDevicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDevices>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDevices>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDevices<
  TData = Awaited<ReturnType<typeof getDevices>>,
  TError = ErrorType<void>
>(
  params?: GetDevicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDevices>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get Devices.
 */

export function useGetDevices<
  TData = Awaited<ReturnType<typeof getDevices>>,
  TError = ErrorType<void>
>(
  params?: GetDevicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDevices>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDevicesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Deletes a device.
 */
export const deleteDevice = (params: DeleteDeviceParams) => {
  return apiInstance<void>({ url: `/Devices`, method: "DELETE", params });
};

export const getDeleteDeviceMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDevice>>,
    TError,
    { params: DeleteDeviceParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteDevice>>,
  TError,
  { params: DeleteDeviceParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDevice>>,
    { params: DeleteDeviceParams }
  > = (props) => {
    const { params } = props ?? {};

    return deleteDevice(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteDeviceMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDevice>>
>;

export type DeleteDeviceMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Deletes a device.
 */
export const useDeleteDevice = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDevice>>,
    TError,
    { params: DeleteDeviceParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteDevice>>,
  TError,
  { params: DeleteDeviceParams },
  TContext
> => {
  const mutationOptions = getDeleteDeviceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get info for a device.
 */
export const getDeviceInfo = (
  params: GetDeviceInfoParams,
  signal?: AbortSignal
) => {
  return apiInstance<DeviceInfo>({
    url: `/Devices/Info`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDeviceInfoQueryKey = (params: GetDeviceInfoParams) => {
  return [`/Devices/Info`, ...(params ? [params] : [])] as const;
};

export const getGetDeviceInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getDeviceInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDeviceInfo>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDeviceInfoQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeviceInfo>>> = ({
    signal,
  }) => getDeviceInfo(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeviceInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDeviceInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDeviceInfo>>
>;
export type GetDeviceInfoQueryError = ErrorType<void | ProblemDetails>;

export function useGetDeviceInfo<
  TData = Awaited<ReturnType<typeof getDeviceInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceInfoParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDeviceInfo>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeviceInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDeviceInfo<
  TData = Awaited<ReturnType<typeof getDeviceInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDeviceInfo>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeviceInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDeviceInfo<
  TData = Awaited<ReturnType<typeof getDeviceInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDeviceInfo>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get info for a device.
 */

export function useGetDeviceInfo<
  TData = Awaited<ReturnType<typeof getDeviceInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDeviceInfo>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDeviceInfoQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get options for a device.
 */
export const getDeviceOptions = (
  params: GetDeviceOptionsParams,
  signal?: AbortSignal
) => {
  return apiInstance<DeviceOptions>({
    url: `/Devices/Options`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDeviceOptionsQueryKey = (params: GetDeviceOptionsParams) => {
  return [`/Devices/Options`, ...(params ? [params] : [])] as const;
};

export const getGetDeviceOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDeviceOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceOptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceOptions>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDeviceOptionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDeviceOptions>>
  > = ({ signal }) => getDeviceOptions(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeviceOptions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDeviceOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDeviceOptions>>
>;
export type GetDeviceOptionsQueryError = ErrorType<void | ProblemDetails>;

export function useGetDeviceOptions<
  TData = Awaited<ReturnType<typeof getDeviceOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceOptionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeviceOptions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDeviceOptions<
  TData = Awaited<ReturnType<typeof getDeviceOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceOptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeviceOptions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDeviceOptions<
  TData = Awaited<ReturnType<typeof getDeviceOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceOptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceOptions>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get options for a device.
 */

export function useGetDeviceOptions<
  TData = Awaited<ReturnType<typeof getDeviceOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  params: GetDeviceOptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceOptions>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDeviceOptionsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update device options.
 */
export const updateDeviceOptions = (
  deviceOptionsDto: DeviceOptionsDto,
  params: UpdateDeviceOptionsParams
) => {
  return apiInstance<void>({
    url: `/Devices/Options`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: deviceOptionsDto,
    params,
  });
};

export const getUpdateDeviceOptionsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeviceOptions>>,
    TError,
    { data: DeviceOptionsDto; params: UpdateDeviceOptionsParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDeviceOptions>>,
  TError,
  { data: DeviceOptionsDto; params: UpdateDeviceOptionsParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeviceOptions>>,
    { data: DeviceOptionsDto; params: UpdateDeviceOptionsParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return updateDeviceOptions(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDeviceOptionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDeviceOptions>>
>;
export type UpdateDeviceOptionsMutationBody = DeviceOptionsDto;
export type UpdateDeviceOptionsMutationError = ErrorType<void>;

/**
 * @summary Update device options.
 */
export const useUpdateDeviceOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeviceOptions>>,
    TError,
    { data: DeviceOptionsDto; params: UpdateDeviceOptionsParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateDeviceOptions>>,
  TError,
  { data: DeviceOptionsDto; params: UpdateDeviceOptionsParams },
  TContext
> => {
  const mutationOptions = getUpdateDeviceOptionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Display Preferences.
 */
export const getDisplayPreferences = (
  displayPreferencesId: string,
  params: GetDisplayPreferencesParams,
  signal?: AbortSignal
) => {
  return apiInstance<DisplayPreferencesDto>({
    url: `/DisplayPreferences/${displayPreferencesId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDisplayPreferencesQueryKey = (
  displayPreferencesId: string,
  params: GetDisplayPreferencesParams
) => {
  return [
    `/DisplayPreferences/${displayPreferencesId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetDisplayPreferencesQueryOptions = <
  TData = Awaited<ReturnType<typeof getDisplayPreferences>>,
  TError = ErrorType<void>
>(
  displayPreferencesId: string,
  params: GetDisplayPreferencesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDisplayPreferences>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetDisplayPreferencesQueryKey(displayPreferencesId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDisplayPreferences>>
  > = ({ signal }) =>
    getDisplayPreferences(displayPreferencesId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!displayPreferencesId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDisplayPreferences>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDisplayPreferencesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDisplayPreferences>>
>;
export type GetDisplayPreferencesQueryError = ErrorType<void>;

export function useGetDisplayPreferences<
  TData = Awaited<ReturnType<typeof getDisplayPreferences>>,
  TError = ErrorType<void>
>(
  displayPreferencesId: string,
  params: GetDisplayPreferencesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDisplayPreferences>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDisplayPreferences>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDisplayPreferences<
  TData = Awaited<ReturnType<typeof getDisplayPreferences>>,
  TError = ErrorType<void>
>(
  displayPreferencesId: string,
  params: GetDisplayPreferencesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDisplayPreferences>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDisplayPreferences>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDisplayPreferences<
  TData = Awaited<ReturnType<typeof getDisplayPreferences>>,
  TError = ErrorType<void>
>(
  displayPreferencesId: string,
  params: GetDisplayPreferencesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDisplayPreferences>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get Display Preferences.
 */

export function useGetDisplayPreferences<
  TData = Awaited<ReturnType<typeof getDisplayPreferences>>,
  TError = ErrorType<void>
>(
  displayPreferencesId: string,
  params: GetDisplayPreferencesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDisplayPreferences>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDisplayPreferencesQueryOptions(
    displayPreferencesId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update Display Preferences.
 */
export const updateDisplayPreferences = (
  displayPreferencesId: string,
  displayPreferencesDto: DisplayPreferencesDto,
  params: UpdateDisplayPreferencesParams
) => {
  return apiInstance<void>({
    url: `/DisplayPreferences/${displayPreferencesId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: displayPreferencesDto,
    params,
  });
};

export const getUpdateDisplayPreferencesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDisplayPreferences>>,
    TError,
    {
      displayPreferencesId: string;
      data: DisplayPreferencesDto;
      params: UpdateDisplayPreferencesParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDisplayPreferences>>,
  TError,
  {
    displayPreferencesId: string;
    data: DisplayPreferencesDto;
    params: UpdateDisplayPreferencesParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDisplayPreferences>>,
    {
      displayPreferencesId: string;
      data: DisplayPreferencesDto;
      params: UpdateDisplayPreferencesParams;
    }
  > = (props) => {
    const { displayPreferencesId, data, params } = props ?? {};

    return updateDisplayPreferences(displayPreferencesId, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDisplayPreferencesMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDisplayPreferences>>
>;
export type UpdateDisplayPreferencesMutationBody = DisplayPreferencesDto;
export type UpdateDisplayPreferencesMutationError = ErrorType<void>;

/**
 * @summary Update Display Preferences.
 */
export const useUpdateDisplayPreferences = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDisplayPreferences>>,
    TError,
    {
      displayPreferencesId: string;
      data: DisplayPreferencesDto;
      params: UpdateDisplayPreferencesParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateDisplayPreferences>>,
  TError,
  {
    displayPreferencesId: string;
    data: DisplayPreferencesDto;
    params: UpdateDisplayPreferencesParams;
  },
  TContext
> => {
  const mutationOptions = getUpdateDisplayPreferencesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get profile infos.
 */
export const getProfileInfos = (signal?: AbortSignal) => {
  return apiInstance<DeviceProfileInfo[]>({
    url: `/Dlna/ProfileInfos`,
    method: "GET",
    signal,
  });
};

export const getGetProfileInfosQueryKey = () => {
  return [`/Dlna/ProfileInfos`] as const;
};

export const getGetProfileInfosQueryOptions = <
  TData = Awaited<ReturnType<typeof getProfileInfos>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfileInfos>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProfileInfosQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfileInfos>>> = ({
    signal,
  }) => getProfileInfos(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfileInfos>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetProfileInfosQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProfileInfos>>
>;
export type GetProfileInfosQueryError = ErrorType<void>;

export function useGetProfileInfos<
  TData = Awaited<ReturnType<typeof getProfileInfos>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfileInfos>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getProfileInfos>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetProfileInfos<
  TData = Awaited<ReturnType<typeof getProfileInfos>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfileInfos>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getProfileInfos>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetProfileInfos<
  TData = Awaited<ReturnType<typeof getProfileInfos>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfileInfos>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get profile infos.
 */

export function useGetProfileInfos<
  TData = Awaited<ReturnType<typeof getProfileInfos>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfileInfos>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetProfileInfosQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates a profile.
 */
export const createProfile = (deviceProfile: DeviceProfile) => {
  return apiInstance<void>({
    url: `/Dlna/Profiles`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: deviceProfile,
  });
};

export const getCreateProfileMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProfile>>,
    TError,
    { data: DeviceProfile },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProfile>>,
  TError,
  { data: DeviceProfile },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProfile>>,
    { data: DeviceProfile }
  > = (props) => {
    const { data } = props ?? {};

    return createProfile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProfileMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProfile>>
>;
export type CreateProfileMutationBody = DeviceProfile;
export type CreateProfileMutationError = ErrorType<void>;

/**
 * @summary Creates a profile.
 */
export const useCreateProfile = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProfile>>,
    TError,
    { data: DeviceProfile },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createProfile>>,
  TError,
  { data: DeviceProfile },
  TContext
> => {
  const mutationOptions = getCreateProfileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a single profile.
 */
export const getProfile = (profileId: string, signal?: AbortSignal) => {
  return apiInstance<DeviceProfile>({
    url: `/Dlna/Profiles/${profileId}`,
    method: "GET",
    signal,
  });
};

export const getGetProfileQueryKey = (profileId: string) => {
  return [`/Dlna/Profiles/${profileId}`] as const;
};

export const getGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  profileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProfileQueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({
    signal,
  }) => getProfile(profileId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!profileId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfile>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProfile>>
>;
export type GetProfileQueryError = ErrorType<void | ProblemDetails>;

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  profileId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  profileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  profileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a single profile.
 */

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  profileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetProfileQueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Deletes a profile.
 */
export const deleteProfile = (profileId: string) => {
  return apiInstance<void>({
    url: `/Dlna/Profiles/${profileId}`,
    method: "DELETE",
  });
};

export const getDeleteProfileMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProfile>>,
    TError,
    { profileId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProfile>>,
  TError,
  { profileId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProfile>>,
    { profileId: string }
  > = (props) => {
    const { profileId } = props ?? {};

    return deleteProfile(profileId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProfileMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProfile>>
>;

export type DeleteProfileMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Deletes a profile.
 */
export const useDeleteProfile = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProfile>>,
    TError,
    { profileId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteProfile>>,
  TError,
  { profileId: string },
  TContext
> => {
  const mutationOptions = getDeleteProfileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a profile.
 */
export const updateProfile = (
  profileId: string,
  deviceProfile: DeviceProfile
) => {
  return apiInstance<void>({
    url: `/Dlna/Profiles/${profileId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: deviceProfile,
  });
};

export const getUpdateProfileMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProfile>>,
    TError,
    { profileId: string; data: DeviceProfile },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProfile>>,
  TError,
  { profileId: string; data: DeviceProfile },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProfile>>,
    { profileId: string; data: DeviceProfile }
  > = (props) => {
    const { profileId, data } = props ?? {};

    return updateProfile(profileId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProfileMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProfile>>
>;
export type UpdateProfileMutationBody = DeviceProfile;
export type UpdateProfileMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Updates a profile.
 */
export const useUpdateProfile = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProfile>>,
    TError,
    { profileId: string; data: DeviceProfile },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateProfile>>,
  TError,
  { profileId: string; data: DeviceProfile },
  TContext
> => {
  const mutationOptions = getUpdateProfileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the default profile.
 */
export const getDefaultProfile = (signal?: AbortSignal) => {
  return apiInstance<DeviceProfile>({
    url: `/Dlna/Profiles/Default`,
    method: "GET",
    signal,
  });
};

export const getGetDefaultProfileQueryKey = () => {
  return [`/Dlna/Profiles/Default`] as const;
};

export const getGetDefaultProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getDefaultProfile>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultProfile>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultProfileQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDefaultProfile>>
  > = ({ signal }) => getDefaultProfile(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDefaultProfile>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDefaultProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDefaultProfile>>
>;
export type GetDefaultProfileQueryError = ErrorType<void>;

export function useGetDefaultProfile<
  TData = Awaited<ReturnType<typeof getDefaultProfile>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultProfile>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDefaultProfile>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultProfile<
  TData = Awaited<ReturnType<typeof getDefaultProfile>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultProfile>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDefaultProfile>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultProfile<
  TData = Awaited<ReturnType<typeof getDefaultProfile>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultProfile>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the default profile.
 */

export function useGetDefaultProfile<
  TData = Awaited<ReturnType<typeof getDefaultProfile>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultProfile>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDefaultProfileQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getConnectionManager = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/ConnectionManager`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetConnectionManagerQueryKey = (serverId: string) => {
  return [`/Dlna/${serverId}/ConnectionManager`] as const;
};

export const getGetConnectionManagerQueryOptions = <
  TData = Awaited<ReturnType<typeof getConnectionManager>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetConnectionManagerQueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getConnectionManager>>
  > = ({ signal }) => getConnectionManager(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getConnectionManager>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetConnectionManagerQueryResult = NonNullable<
  Awaited<ReturnType<typeof getConnectionManager>>
>;
export type GetConnectionManagerQueryError = ErrorType<void>;

export function useGetConnectionManager<
  TData = Awaited<ReturnType<typeof getConnectionManager>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectionManager>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConnectionManager<
  TData = Awaited<ReturnType<typeof getConnectionManager>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectionManager>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConnectionManager<
  TData = Awaited<ReturnType<typeof getConnectionManager>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets Dlna media receiver registrar xml.
 */

export function useGetConnectionManager<
  TData = Awaited<ReturnType<typeof getConnectionManager>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetConnectionManagerQueryOptions(serverId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getConnectionManager2 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/ConnectionManager/ConnectionManager`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetConnectionManager2QueryKey = (serverId: string) => {
  return [`/Dlna/${serverId}/ConnectionManager/ConnectionManager`] as const;
};

export const getGetConnectionManager2QueryOptions = <
  TData = Awaited<ReturnType<typeof getConnectionManager2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager2>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetConnectionManager2QueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getConnectionManager2>>
  > = ({ signal }) => getConnectionManager2(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getConnectionManager2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetConnectionManager2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getConnectionManager2>>
>;
export type GetConnectionManager2QueryError = ErrorType<void>;

export function useGetConnectionManager2<
  TData = Awaited<ReturnType<typeof getConnectionManager2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectionManager2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConnectionManager2<
  TData = Awaited<ReturnType<typeof getConnectionManager2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectionManager2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConnectionManager2<
  TData = Awaited<ReturnType<typeof getConnectionManager2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets Dlna media receiver registrar xml.
 */

export function useGetConnectionManager2<
  TData = Awaited<ReturnType<typeof getConnectionManager2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetConnectionManager2QueryOptions(serverId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getConnectionManager3 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/ConnectionManager/ConnectionManager.xml`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetConnectionManager3QueryKey = (serverId: string) => {
  return [`/Dlna/${serverId}/ConnectionManager/ConnectionManager.xml`] as const;
};

export const getGetConnectionManager3QueryOptions = <
  TData = Awaited<ReturnType<typeof getConnectionManager3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager3>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetConnectionManager3QueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getConnectionManager3>>
  > = ({ signal }) => getConnectionManager3(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getConnectionManager3>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetConnectionManager3QueryResult = NonNullable<
  Awaited<ReturnType<typeof getConnectionManager3>>
>;
export type GetConnectionManager3QueryError = ErrorType<void>;

export function useGetConnectionManager3<
  TData = Awaited<ReturnType<typeof getConnectionManager3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager3>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectionManager3>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConnectionManager3<
  TData = Awaited<ReturnType<typeof getConnectionManager3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager3>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConnectionManager3>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetConnectionManager3<
  TData = Awaited<ReturnType<typeof getConnectionManager3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager3>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets Dlna media receiver registrar xml.
 */

export function useGetConnectionManager3<
  TData = Awaited<ReturnType<typeof getConnectionManager3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConnectionManager3>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetConnectionManager3QueryOptions(serverId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Process a connection manager control request.
 */
export const processConnectionManagerControlRequest = (serverId: string) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/ConnectionManager/Control`,
    method: "POST",
    responseType: "blob",
  });
};

export const getProcessConnectionManagerControlRequestMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof processConnectionManagerControlRequest>>,
    TError,
    { serverId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof processConnectionManagerControlRequest>>,
  TError,
  { serverId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof processConnectionManagerControlRequest>>,
    { serverId: string }
  > = (props) => {
    const { serverId } = props ?? {};

    return processConnectionManagerControlRequest(serverId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProcessConnectionManagerControlRequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof processConnectionManagerControlRequest>>
>;

export type ProcessConnectionManagerControlRequestMutationError =
  ErrorType<void>;

/**
 * @summary Process a connection manager control request.
 */
export const useProcessConnectionManagerControlRequest = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof processConnectionManagerControlRequest>>,
    TError,
    { serverId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof processConnectionManagerControlRequest>>,
  TError,
  { serverId: string },
  TContext
> => {
  const mutationOptions =
    getProcessConnectionManagerControlRequestMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets Dlna content directory xml.
 */
export const getContentDirectory = (serverId: string, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/ContentDirectory`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetContentDirectoryQueryKey = (serverId: string) => {
  return [`/Dlna/${serverId}/ContentDirectory`] as const;
};

export const getGetContentDirectoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getContentDirectory>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetContentDirectoryQueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getContentDirectory>>
  > = ({ signal }) => getContentDirectory(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getContentDirectory>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetContentDirectoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getContentDirectory>>
>;
export type GetContentDirectoryQueryError = ErrorType<void>;

export function useGetContentDirectory<
  TData = Awaited<ReturnType<typeof getContentDirectory>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContentDirectory>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetContentDirectory<
  TData = Awaited<ReturnType<typeof getContentDirectory>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContentDirectory>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetContentDirectory<
  TData = Awaited<ReturnType<typeof getContentDirectory>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets Dlna content directory xml.
 */

export function useGetContentDirectory<
  TData = Awaited<ReturnType<typeof getContentDirectory>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetContentDirectoryQueryOptions(serverId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets Dlna content directory xml.
 */
export const getContentDirectory2 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/ContentDirectory/ContentDirectory`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetContentDirectory2QueryKey = (serverId: string) => {
  return [`/Dlna/${serverId}/ContentDirectory/ContentDirectory`] as const;
};

export const getGetContentDirectory2QueryOptions = <
  TData = Awaited<ReturnType<typeof getContentDirectory2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory2>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetContentDirectory2QueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getContentDirectory2>>
  > = ({ signal }) => getContentDirectory2(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getContentDirectory2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetContentDirectory2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getContentDirectory2>>
>;
export type GetContentDirectory2QueryError = ErrorType<void>;

export function useGetContentDirectory2<
  TData = Awaited<ReturnType<typeof getContentDirectory2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContentDirectory2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetContentDirectory2<
  TData = Awaited<ReturnType<typeof getContentDirectory2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContentDirectory2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetContentDirectory2<
  TData = Awaited<ReturnType<typeof getContentDirectory2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets Dlna content directory xml.
 */

export function useGetContentDirectory2<
  TData = Awaited<ReturnType<typeof getContentDirectory2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetContentDirectory2QueryOptions(serverId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets Dlna content directory xml.
 */
export const getContentDirectory3 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/ContentDirectory/ContentDirectory.xml`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetContentDirectory3QueryKey = (serverId: string) => {
  return [`/Dlna/${serverId}/ContentDirectory/ContentDirectory.xml`] as const;
};

export const getGetContentDirectory3QueryOptions = <
  TData = Awaited<ReturnType<typeof getContentDirectory3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory3>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetContentDirectory3QueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getContentDirectory3>>
  > = ({ signal }) => getContentDirectory3(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getContentDirectory3>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetContentDirectory3QueryResult = NonNullable<
  Awaited<ReturnType<typeof getContentDirectory3>>
>;
export type GetContentDirectory3QueryError = ErrorType<void>;

export function useGetContentDirectory3<
  TData = Awaited<ReturnType<typeof getContentDirectory3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory3>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContentDirectory3>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetContentDirectory3<
  TData = Awaited<ReturnType<typeof getContentDirectory3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory3>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContentDirectory3>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetContentDirectory3<
  TData = Awaited<ReturnType<typeof getContentDirectory3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory3>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets Dlna content directory xml.
 */

export function useGetContentDirectory3<
  TData = Awaited<ReturnType<typeof getContentDirectory3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getContentDirectory3>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetContentDirectory3QueryOptions(serverId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Process a content directory control request.
 */
export const processContentDirectoryControlRequest = (serverId: string) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/ContentDirectory/Control`,
    method: "POST",
    responseType: "blob",
  });
};

export const getProcessContentDirectoryControlRequestMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof processContentDirectoryControlRequest>>,
    TError,
    { serverId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof processContentDirectoryControlRequest>>,
  TError,
  { serverId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof processContentDirectoryControlRequest>>,
    { serverId: string }
  > = (props) => {
    const { serverId } = props ?? {};

    return processContentDirectoryControlRequest(serverId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProcessContentDirectoryControlRequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof processContentDirectoryControlRequest>>
>;

export type ProcessContentDirectoryControlRequestMutationError =
  ErrorType<void>;

/**
 * @summary Process a content directory control request.
 */
export const useProcessContentDirectoryControlRequest = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof processContentDirectoryControlRequest>>,
    TError,
    { serverId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof processContentDirectoryControlRequest>>,
  TError,
  { serverId: string },
  TContext
> => {
  const mutationOptions =
    getProcessContentDirectoryControlRequestMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Description Xml.
 */
export const getDescriptionXml = (serverId: string, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/description`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetDescriptionXmlQueryKey = (serverId: string) => {
  return [`/Dlna/${serverId}/description`] as const;
};

export const getGetDescriptionXmlQueryOptions = <
  TData = Awaited<ReturnType<typeof getDescriptionXml>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDescriptionXmlQueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDescriptionXml>>
  > = ({ signal }) => getDescriptionXml(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDescriptionXml>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDescriptionXmlQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDescriptionXml>>
>;
export type GetDescriptionXmlQueryError = ErrorType<void>;

export function useGetDescriptionXml<
  TData = Awaited<ReturnType<typeof getDescriptionXml>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDescriptionXml>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDescriptionXml<
  TData = Awaited<ReturnType<typeof getDescriptionXml>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDescriptionXml>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDescriptionXml<
  TData = Awaited<ReturnType<typeof getDescriptionXml>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get Description Xml.
 */

export function useGetDescriptionXml<
  TData = Awaited<ReturnType<typeof getDescriptionXml>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDescriptionXmlQueryOptions(serverId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Description Xml.
 */
export const getDescriptionXml2 = (serverId: string, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/description.xml`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetDescriptionXml2QueryKey = (serverId: string) => {
  return [`/Dlna/${serverId}/description.xml`] as const;
};

export const getGetDescriptionXml2QueryOptions = <
  TData = Awaited<ReturnType<typeof getDescriptionXml2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml2>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDescriptionXml2QueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDescriptionXml2>>
  > = ({ signal }) => getDescriptionXml2(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDescriptionXml2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDescriptionXml2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getDescriptionXml2>>
>;
export type GetDescriptionXml2QueryError = ErrorType<void>;

export function useGetDescriptionXml2<
  TData = Awaited<ReturnType<typeof getDescriptionXml2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDescriptionXml2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDescriptionXml2<
  TData = Awaited<ReturnType<typeof getDescriptionXml2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDescriptionXml2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDescriptionXml2<
  TData = Awaited<ReturnType<typeof getDescriptionXml2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get Description Xml.
 */

export function useGetDescriptionXml2<
  TData = Awaited<ReturnType<typeof getDescriptionXml2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDescriptionXml2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDescriptionXml2QueryOptions(serverId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a server icon.
 */
export const getIconId = (
  serverId: string,
  fileName: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/icons/${fileName}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetIconIdQueryKey = (serverId: string, fileName: string) => {
  return [`/Dlna/${serverId}/icons/${fileName}`] as const;
};

export const getGetIconIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getIconId>>,
  TError = ErrorType<void | ProblemDetails>
>(
  serverId: string,
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIconId>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetIconIdQueryKey(serverId, fileName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIconId>>> = ({
    signal,
  }) => getIconId(serverId, fileName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(serverId && fileName),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getIconId>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetIconIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIconId>>
>;
export type GetIconIdQueryError = ErrorType<void | ProblemDetails>;

export function useGetIconId<
  TData = Awaited<ReturnType<typeof getIconId>>,
  TError = ErrorType<void | ProblemDetails>
>(
  serverId: string,
  fileName: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIconId>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIconId>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetIconId<
  TData = Awaited<ReturnType<typeof getIconId>>,
  TError = ErrorType<void | ProblemDetails>
>(
  serverId: string,
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIconId>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIconId>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetIconId<
  TData = Awaited<ReturnType<typeof getIconId>>,
  TError = ErrorType<void | ProblemDetails>
>(
  serverId: string,
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIconId>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a server icon.
 */

export function useGetIconId<
  TData = Awaited<ReturnType<typeof getIconId>>,
  TError = ErrorType<void | ProblemDetails>
>(
  serverId: string,
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIconId>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetIconIdQueryOptions(serverId, fileName, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getMediaReceiverRegistrar = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/MediaReceiverRegistrar`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetMediaReceiverRegistrarQueryKey = (serverId: string) => {
  return [`/Dlna/${serverId}/MediaReceiverRegistrar`] as const;
};

export const getGetMediaReceiverRegistrarQueryOptions = <
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMediaReceiverRegistrarQueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMediaReceiverRegistrar>>
  > = ({ signal }) => getMediaReceiverRegistrar(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMediaReceiverRegistrarQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMediaReceiverRegistrar>>
>;
export type GetMediaReceiverRegistrarQueryError = ErrorType<void>;

export function useGetMediaReceiverRegistrar<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaReceiverRegistrar<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaReceiverRegistrar<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets Dlna media receiver registrar xml.
 */

export function useGetMediaReceiverRegistrar<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMediaReceiverRegistrarQueryOptions(
    serverId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Process a media receiver registrar control request.
 */
export const processMediaReceiverRegistrarControlRequest = (
  serverId: string
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/MediaReceiverRegistrar/Control`,
    method: "POST",
    responseType: "blob",
  });
};

export const getProcessMediaReceiverRegistrarControlRequestMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>,
    TError,
    { serverId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>,
  TError,
  { serverId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>,
    { serverId: string }
  > = (props) => {
    const { serverId } = props ?? {};

    return processMediaReceiverRegistrarControlRequest(serverId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProcessMediaReceiverRegistrarControlRequestMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>
  >;

export type ProcessMediaReceiverRegistrarControlRequestMutationError =
  ErrorType<void>;

/**
 * @summary Process a media receiver registrar control request.
 */
export const useProcessMediaReceiverRegistrarControlRequest = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>,
    TError,
    { serverId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>,
  TError,
  { serverId: string },
  TContext
> => {
  const mutationOptions =
    getProcessMediaReceiverRegistrarControlRequestMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getMediaReceiverRegistrar2 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetMediaReceiverRegistrar2QueryKey = (serverId: string) => {
  return [
    `/Dlna/${serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar`,
  ] as const;
};

export const getGetMediaReceiverRegistrar2QueryOptions = <
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMediaReceiverRegistrar2QueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>
  > = ({ signal }) => getMediaReceiverRegistrar2(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMediaReceiverRegistrar2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>
>;
export type GetMediaReceiverRegistrar2QueryError = ErrorType<void>;

export function useGetMediaReceiverRegistrar2<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaReceiverRegistrar2<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaReceiverRegistrar2<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets Dlna media receiver registrar xml.
 */

export function useGetMediaReceiverRegistrar2<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMediaReceiverRegistrar2QueryOptions(
    serverId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getMediaReceiverRegistrar3 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Dlna/${serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar.xml`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetMediaReceiverRegistrar3QueryKey = (serverId: string) => {
  return [
    `/Dlna/${serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar.xml`,
  ] as const;
};

export const getGetMediaReceiverRegistrar3QueryOptions = <
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMediaReceiverRegistrar3QueryKey(serverId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>
  > = ({ signal }) => getMediaReceiverRegistrar3(serverId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!serverId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMediaReceiverRegistrar3QueryResult = NonNullable<
  Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>
>;
export type GetMediaReceiverRegistrar3QueryError = ErrorType<void>;

export function useGetMediaReceiverRegistrar3<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaReceiverRegistrar3<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaReceiverRegistrar3<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets Dlna media receiver registrar xml.
 */

export function useGetMediaReceiverRegistrar3<
  TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
  TError = ErrorType<void>
>(
  serverId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMediaReceiverRegistrar3QueryOptions(
    serverId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a server icon.
 */
export const getIcon = (fileName: string, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/Dlna/icons/${fileName}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetIconQueryKey = (fileName: string) => {
  return [`/Dlna/icons/${fileName}`] as const;
};

export const getGetIconQueryOptions = <
  TData = Awaited<ReturnType<typeof getIcon>>,
  TError = ErrorType<void | ProblemDetails>
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIcon>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIconQueryKey(fileName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIcon>>> = ({
    signal,
  }) => getIcon(fileName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!fileName,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getIcon>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetIconQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIcon>>
>;
export type GetIconQueryError = ErrorType<void | ProblemDetails>;

export function useGetIcon<
  TData = Awaited<ReturnType<typeof getIcon>>,
  TError = ErrorType<void | ProblemDetails>
>(
  fileName: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIcon>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIcon>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetIcon<
  TData = Awaited<ReturnType<typeof getIcon>>,
  TError = ErrorType<void | ProblemDetails>
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIcon>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIcon>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetIcon<
  TData = Awaited<ReturnType<typeof getIcon>>,
  TError = ErrorType<void | ProblemDetails>
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIcon>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a server icon.
 */

export function useGetIcon<
  TData = Awaited<ReturnType<typeof getIcon>>,
  TError = ErrorType<void | ProblemDetails>
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIcon>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetIconQueryOptions(fileName, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a video stream using HTTP live streaming.
 */
export const getHlsAudioSegment = (
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/hls1/${playlistId}/${segmentId}.${container}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetHlsAudioSegmentQueryKey = (
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams
) => {
  return [
    `/Audio/${itemId}/hls1/${playlistId}/${segmentId}.${container}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetHlsAudioSegmentQueryOptions = <
  TData = Awaited<ReturnType<typeof getHlsAudioSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegment>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetHlsAudioSegmentQueryKey(
      itemId,
      playlistId,
      segmentId,
      container,
      params
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHlsAudioSegment>>
  > = ({ signal }) =>
    getHlsAudioSegment(
      itemId,
      playlistId,
      segmentId,
      container,
      params,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && playlistId && segmentId && container),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getHlsAudioSegment>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetHlsAudioSegmentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHlsAudioSegment>>
>;
export type GetHlsAudioSegmentQueryError = ErrorType<void>;

export function useGetHlsAudioSegment<
  TData = Awaited<ReturnType<typeof getHlsAudioSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegment>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsAudioSegment>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsAudioSegment<
  TData = Awaited<ReturnType<typeof getHlsAudioSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegment>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsAudioSegment>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsAudioSegment<
  TData = Awaited<ReturnType<typeof getHlsAudioSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegment>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a video stream using HTTP live streaming.
 */

export function useGetHlsAudioSegment<
  TData = Awaited<ReturnType<typeof getHlsAudioSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegment>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetHlsAudioSegmentQueryOptions(
    itemId,
    playlistId,
    segmentId,
    container,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an audio stream using HTTP live streaming.
 */
export const getVariantHlsAudioPlaylist = (
  itemId: string,
  params?: GetVariantHlsAudioPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/main.m3u8`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetVariantHlsAudioPlaylistQueryKey = (
  itemId: string,
  params?: GetVariantHlsAudioPlaylistParams
) => {
  return [`/Audio/${itemId}/main.m3u8`, ...(params ? [params] : [])] as const;
};

export const getGetVariantHlsAudioPlaylistQueryOptions = <
  TData = Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetVariantHlsAudioPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetVariantHlsAudioPlaylistQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>
  > = ({ signal }) => getVariantHlsAudioPlaylist(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetVariantHlsAudioPlaylistQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>
>;
export type GetVariantHlsAudioPlaylistQueryError = ErrorType<void>;

export function useGetVariantHlsAudioPlaylist<
  TData = Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetVariantHlsAudioPlaylistParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVariantHlsAudioPlaylist<
  TData = Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetVariantHlsAudioPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVariantHlsAudioPlaylist<
  TData = Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetVariantHlsAudioPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets an audio stream using HTTP live streaming.
 */

export function useGetVariantHlsAudioPlaylist<
  TData = Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetVariantHlsAudioPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetVariantHlsAudioPlaylistQueryOptions(
    itemId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an audio hls playlist stream.
 */
export const getMasterHlsAudioPlaylist = (
  itemId: string,
  params: GetMasterHlsAudioPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/master.m3u8`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetMasterHlsAudioPlaylistQueryKey = (
  itemId: string,
  params: GetMasterHlsAudioPlaylistParams
) => {
  return [`/Audio/${itemId}/master.m3u8`, ...(params ? [params] : [])] as const;
};

export const getGetMasterHlsAudioPlaylistQueryOptions = <
  TData = Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsAudioPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetMasterHlsAudioPlaylistQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>
  > = ({ signal }) => getMasterHlsAudioPlaylist(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMasterHlsAudioPlaylistQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>
>;
export type GetMasterHlsAudioPlaylistQueryError = ErrorType<void>;

export function useGetMasterHlsAudioPlaylist<
  TData = Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsAudioPlaylistParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMasterHlsAudioPlaylist<
  TData = Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsAudioPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMasterHlsAudioPlaylist<
  TData = Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsAudioPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets an audio hls playlist stream.
 */

export function useGetMasterHlsAudioPlaylist<
  TData = Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsAudioPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMasterHlsAudioPlaylistQueryOptions(
    itemId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an audio hls playlist stream.
 */
export const headMasterHlsAudioPlaylist = (
  itemId: string,
  params: HeadMasterHlsAudioPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/master.m3u8`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadMasterHlsAudioPlaylistMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>,
    TError,
    { itemId: string; params: HeadMasterHlsAudioPlaylistParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>,
  TError,
  { itemId: string; params: HeadMasterHlsAudioPlaylistParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>,
    { itemId: string; params: HeadMasterHlsAudioPlaylistParams }
  > = (props) => {
    const { itemId, params } = props ?? {};

    return headMasterHlsAudioPlaylist(itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadMasterHlsAudioPlaylistMutationResult = NonNullable<
  Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>
>;

export type HeadMasterHlsAudioPlaylistMutationError = ErrorType<void>;

/**
 * @summary Gets an audio hls playlist stream.
 */
export const useHeadMasterHlsAudioPlaylist = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>,
    TError,
    { itemId: string; params: HeadMasterHlsAudioPlaylistParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>,
  TError,
  { itemId: string; params: HeadMasterHlsAudioPlaylistParams },
  TContext
> => {
  const mutationOptions = getHeadMasterHlsAudioPlaylistMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a video stream using HTTP live streaming.
 */
export const getHlsVideoSegment = (
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/hls1/${playlistId}/${segmentId}.${container}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetHlsVideoSegmentQueryKey = (
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams
) => {
  return [
    `/Videos/${itemId}/hls1/${playlistId}/${segmentId}.${container}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetHlsVideoSegmentQueryOptions = <
  TData = Awaited<ReturnType<typeof getHlsVideoSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegment>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetHlsVideoSegmentQueryKey(
      itemId,
      playlistId,
      segmentId,
      container,
      params
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHlsVideoSegment>>
  > = ({ signal }) =>
    getHlsVideoSegment(
      itemId,
      playlistId,
      segmentId,
      container,
      params,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && playlistId && segmentId && container),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getHlsVideoSegment>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetHlsVideoSegmentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHlsVideoSegment>>
>;
export type GetHlsVideoSegmentQueryError = ErrorType<void>;

export function useGetHlsVideoSegment<
  TData = Awaited<ReturnType<typeof getHlsVideoSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegment>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsVideoSegment>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsVideoSegment<
  TData = Awaited<ReturnType<typeof getHlsVideoSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegment>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsVideoSegment>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsVideoSegment<
  TData = Awaited<ReturnType<typeof getHlsVideoSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegment>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a video stream using HTTP live streaming.
 */

export function useGetHlsVideoSegment<
  TData = Awaited<ReturnType<typeof getHlsVideoSegment>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegment>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetHlsVideoSegmentQueryOptions(
    itemId,
    playlistId,
    segmentId,
    container,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a hls live stream.
 */
export const getLiveHlsStream = (
  itemId: string,
  params?: GetLiveHlsStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/live.m3u8`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetLiveHlsStreamQueryKey = (
  itemId: string,
  params?: GetLiveHlsStreamParams
) => {
  return [`/Videos/${itemId}/live.m3u8`, ...(params ? [params] : [])] as const;
};

export const getGetLiveHlsStreamQueryOptions = <
  TData = Awaited<ReturnType<typeof getLiveHlsStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetLiveHlsStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveHlsStream>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLiveHlsStreamQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLiveHlsStream>>
  > = ({ signal }) => getLiveHlsStream(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLiveHlsStream>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLiveHlsStreamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLiveHlsStream>>
>;
export type GetLiveHlsStreamQueryError = ErrorType<void>;

export function useGetLiveHlsStream<
  TData = Awaited<ReturnType<typeof getLiveHlsStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetLiveHlsStreamParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveHlsStream>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveHlsStream>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveHlsStream<
  TData = Awaited<ReturnType<typeof getLiveHlsStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetLiveHlsStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveHlsStream>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveHlsStream>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveHlsStream<
  TData = Awaited<ReturnType<typeof getLiveHlsStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetLiveHlsStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveHlsStream>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a hls live stream.
 */

export function useGetLiveHlsStream<
  TData = Awaited<ReturnType<typeof getLiveHlsStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetLiveHlsStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveHlsStream>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLiveHlsStreamQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a video stream using HTTP live streaming.
 */
export const getVariantHlsVideoPlaylist = (
  itemId: string,
  params?: GetVariantHlsVideoPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/main.m3u8`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetVariantHlsVideoPlaylistQueryKey = (
  itemId: string,
  params?: GetVariantHlsVideoPlaylistParams
) => {
  return [`/Videos/${itemId}/main.m3u8`, ...(params ? [params] : [])] as const;
};

export const getGetVariantHlsVideoPlaylistQueryOptions = <
  TData = Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetVariantHlsVideoPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetVariantHlsVideoPlaylistQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>
  > = ({ signal }) => getVariantHlsVideoPlaylist(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetVariantHlsVideoPlaylistQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>
>;
export type GetVariantHlsVideoPlaylistQueryError = ErrorType<void>;

export function useGetVariantHlsVideoPlaylist<
  TData = Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetVariantHlsVideoPlaylistParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVariantHlsVideoPlaylist<
  TData = Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetVariantHlsVideoPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVariantHlsVideoPlaylist<
  TData = Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetVariantHlsVideoPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a video stream using HTTP live streaming.
 */

export function useGetVariantHlsVideoPlaylist<
  TData = Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetVariantHlsVideoPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetVariantHlsVideoPlaylistQueryOptions(
    itemId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a video hls playlist stream.
 */
export const getMasterHlsVideoPlaylist = (
  itemId: string,
  params: GetMasterHlsVideoPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/master.m3u8`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetMasterHlsVideoPlaylistQueryKey = (
  itemId: string,
  params: GetMasterHlsVideoPlaylistParams
) => {
  return [
    `/Videos/${itemId}/master.m3u8`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetMasterHlsVideoPlaylistQueryOptions = <
  TData = Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsVideoPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetMasterHlsVideoPlaylistQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>
  > = ({ signal }) => getMasterHlsVideoPlaylist(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMasterHlsVideoPlaylistQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>
>;
export type GetMasterHlsVideoPlaylistQueryError = ErrorType<void>;

export function useGetMasterHlsVideoPlaylist<
  TData = Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsVideoPlaylistParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMasterHlsVideoPlaylist<
  TData = Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsVideoPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMasterHlsVideoPlaylist<
  TData = Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsVideoPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a video hls playlist stream.
 */

export function useGetMasterHlsVideoPlaylist<
  TData = Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetMasterHlsVideoPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMasterHlsVideoPlaylistQueryOptions(
    itemId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a video hls playlist stream.
 */
export const headMasterHlsVideoPlaylist = (
  itemId: string,
  params: HeadMasterHlsVideoPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/master.m3u8`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadMasterHlsVideoPlaylistMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>,
    TError,
    { itemId: string; params: HeadMasterHlsVideoPlaylistParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>,
  TError,
  { itemId: string; params: HeadMasterHlsVideoPlaylistParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>,
    { itemId: string; params: HeadMasterHlsVideoPlaylistParams }
  > = (props) => {
    const { itemId, params } = props ?? {};

    return headMasterHlsVideoPlaylist(itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadMasterHlsVideoPlaylistMutationResult = NonNullable<
  Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>
>;

export type HeadMasterHlsVideoPlaylistMutationError = ErrorType<void>;

/**
 * @summary Gets a video hls playlist stream.
 */
export const useHeadMasterHlsVideoPlaylist = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>,
    TError,
    { itemId: string; params: HeadMasterHlsVideoPlaylistParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>,
  TError,
  { itemId: string; params: HeadMasterHlsVideoPlaylistParams },
  TContext
> => {
  const mutationOptions = getHeadMasterHlsVideoPlaylistMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Default directory browser.
 */
export const getDefaultDirectoryBrowser = (signal?: AbortSignal) => {
  return apiInstance<DefaultDirectoryBrowserInfoDto>({
    url: `/Environment/DefaultDirectoryBrowser`,
    method: "GET",
    signal,
  });
};

export const getGetDefaultDirectoryBrowserQueryKey = () => {
  return [`/Environment/DefaultDirectoryBrowser`] as const;
};

export const getGetDefaultDirectoryBrowserQueryOptions = <
  TData = Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDefaultDirectoryBrowserQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>
  > = ({ signal }) => getDefaultDirectoryBrowser(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDefaultDirectoryBrowserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>
>;
export type GetDefaultDirectoryBrowserQueryError = ErrorType<void>;

export function useGetDefaultDirectoryBrowser<
  TData = Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultDirectoryBrowser<
  TData = Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultDirectoryBrowser<
  TData = Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get Default directory browser.
 */

export function useGetDefaultDirectoryBrowser<
  TData = Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDefaultDirectoryBrowserQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the contents of a given directory in the file system.
 */
export const getDirectoryContents = (
  params: GetDirectoryContentsParams,
  signal?: AbortSignal
) => {
  return apiInstance<FileSystemEntryInfo[]>({
    url: `/Environment/DirectoryContents`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDirectoryContentsQueryKey = (
  params: GetDirectoryContentsParams
) => {
  return [
    `/Environment/DirectoryContents`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetDirectoryContentsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDirectoryContents>>,
  TError = ErrorType<void>
>(
  params: GetDirectoryContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDirectoryContents>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDirectoryContentsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDirectoryContents>>
  > = ({ signal }) => getDirectoryContents(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDirectoryContents>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDirectoryContentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDirectoryContents>>
>;
export type GetDirectoryContentsQueryError = ErrorType<void>;

export function useGetDirectoryContents<
  TData = Awaited<ReturnType<typeof getDirectoryContents>>,
  TError = ErrorType<void>
>(
  params: GetDirectoryContentsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDirectoryContents>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDirectoryContents>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDirectoryContents<
  TData = Awaited<ReturnType<typeof getDirectoryContents>>,
  TError = ErrorType<void>
>(
  params: GetDirectoryContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDirectoryContents>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDirectoryContents>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDirectoryContents<
  TData = Awaited<ReturnType<typeof getDirectoryContents>>,
  TError = ErrorType<void>
>(
  params: GetDirectoryContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDirectoryContents>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the contents of a given directory in the file system.
 */

export function useGetDirectoryContents<
  TData = Awaited<ReturnType<typeof getDirectoryContents>>,
  TError = ErrorType<void>
>(
  params: GetDirectoryContentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDirectoryContents>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDirectoryContentsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets available drives from the server's file system.
 */
export const getDrives = (signal?: AbortSignal) => {
  return apiInstance<FileSystemEntryInfo[]>({
    url: `/Environment/Drives`,
    method: "GET",
    signal,
  });
};

export const getGetDrivesQueryKey = () => {
  return [`/Environment/Drives`] as const;
};

export const getGetDrivesQueryOptions = <
  TData = Awaited<ReturnType<typeof getDrives>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getDrives>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDrivesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDrives>>> = ({
    signal,
  }) => getDrives(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDrives>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDrivesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDrives>>
>;
export type GetDrivesQueryError = ErrorType<void>;

export function useGetDrives<
  TData = Awaited<ReturnType<typeof getDrives>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getDrives>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDrives>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDrives<
  TData = Awaited<ReturnType<typeof getDrives>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getDrives>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDrives>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDrives<
  TData = Awaited<ReturnType<typeof getDrives>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getDrives>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available drives from the server's file system.
 */

export function useGetDrives<
  TData = Awaited<ReturnType<typeof getDrives>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getDrives>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDrivesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @deprecated
 * @summary Gets network paths.
 */
export const getNetworkShares = (signal?: AbortSignal) => {
  return apiInstance<FileSystemEntryInfo[]>({
    url: `/Environment/NetworkShares`,
    method: "GET",
    signal,
  });
};

export const getGetNetworkSharesQueryKey = () => {
  return [`/Environment/NetworkShares`] as const;
};

export const getGetNetworkSharesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNetworkShares>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNetworkShares>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNetworkSharesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNetworkShares>>
  > = ({ signal }) => getNetworkShares(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNetworkShares>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNetworkSharesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNetworkShares>>
>;
export type GetNetworkSharesQueryError = ErrorType<void>;

export function useGetNetworkShares<
  TData = Awaited<ReturnType<typeof getNetworkShares>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNetworkShares>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNetworkShares>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNetworkShares<
  TData = Awaited<ReturnType<typeof getNetworkShares>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNetworkShares>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNetworkShares>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNetworkShares<
  TData = Awaited<ReturnType<typeof getNetworkShares>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNetworkShares>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @deprecated
 * @summary Gets network paths.
 */

export function useGetNetworkShares<
  TData = Awaited<ReturnType<typeof getNetworkShares>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNetworkShares>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetNetworkSharesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the parent path of a given path.
 */
export const getParentPath = (
  params: GetParentPathParams,
  signal?: AbortSignal
) => {
  return apiInstance<string>({
    url: `/Environment/ParentPath`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetParentPathQueryKey = (params: GetParentPathParams) => {
  return [`/Environment/ParentPath`, ...(params ? [params] : [])] as const;
};

export const getGetParentPathQueryOptions = <
  TData = Awaited<ReturnType<typeof getParentPath>>,
  TError = ErrorType<void>
>(
  params: GetParentPathParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getParentPath>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetParentPathQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getParentPath>>> = ({
    signal,
  }) => getParentPath(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getParentPath>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetParentPathQueryResult = NonNullable<
  Awaited<ReturnType<typeof getParentPath>>
>;
export type GetParentPathQueryError = ErrorType<void>;

export function useGetParentPath<
  TData = Awaited<ReturnType<typeof getParentPath>>,
  TError = ErrorType<void>
>(
  params: GetParentPathParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getParentPath>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getParentPath>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetParentPath<
  TData = Awaited<ReturnType<typeof getParentPath>>,
  TError = ErrorType<void>
>(
  params: GetParentPathParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getParentPath>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getParentPath>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetParentPath<
  TData = Awaited<ReturnType<typeof getParentPath>>,
  TError = ErrorType<void>
>(
  params: GetParentPathParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getParentPath>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the parent path of a given path.
 */

export function useGetParentPath<
  TData = Awaited<ReturnType<typeof getParentPath>>,
  TError = ErrorType<void>
>(
  params: GetParentPathParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getParentPath>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetParentPathQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Validates path.
 */
export const validatePath = (validatePathDto: ValidatePathDto) => {
  return apiInstance<void>({
    url: `/Environment/ValidatePath`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: validatePathDto,
  });
};

export const getValidatePathMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validatePath>>,
    TError,
    { data: ValidatePathDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof validatePath>>,
  TError,
  { data: ValidatePathDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validatePath>>,
    { data: ValidatePathDto }
  > = (props) => {
    const { data } = props ?? {};

    return validatePath(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ValidatePathMutationResult = NonNullable<
  Awaited<ReturnType<typeof validatePath>>
>;
export type ValidatePathMutationBody = ValidatePathDto;
export type ValidatePathMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Validates path.
 */
export const useValidatePath = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validatePath>>,
    TError,
    { data: ValidatePathDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof validatePath>>,
  TError,
  { data: ValidatePathDto },
  TContext
> => {
  const mutationOptions = getValidatePathMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets legacy query filters.
 */
export const getQueryFiltersLegacy = (
  params?: GetQueryFiltersLegacyParams,
  signal?: AbortSignal
) => {
  return apiInstance<QueryFiltersLegacy>({
    url: `/Items/Filters`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetQueryFiltersLegacyQueryKey = (
  params?: GetQueryFiltersLegacyParams
) => {
  return [`/Items/Filters`, ...(params ? [params] : [])] as const;
};

export const getGetQueryFiltersLegacyQueryOptions = <
  TData = Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
  TError = ErrorType<void>
>(
  params?: GetQueryFiltersLegacyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQueryFiltersLegacyQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQueryFiltersLegacy>>
  > = ({ signal }) => getQueryFiltersLegacy(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetQueryFiltersLegacyQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQueryFiltersLegacy>>
>;
export type GetQueryFiltersLegacyQueryError = ErrorType<void>;

export function useGetQueryFiltersLegacy<
  TData = Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
  TError = ErrorType<void>
>(
  params: undefined | GetQueryFiltersLegacyParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetQueryFiltersLegacy<
  TData = Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
  TError = ErrorType<void>
>(
  params?: GetQueryFiltersLegacyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetQueryFiltersLegacy<
  TData = Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
  TError = ErrorType<void>
>(
  params?: GetQueryFiltersLegacyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets legacy query filters.
 */

export function useGetQueryFiltersLegacy<
  TData = Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
  TError = ErrorType<void>
>(
  params?: GetQueryFiltersLegacyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFiltersLegacy>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetQueryFiltersLegacyQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets query filters.
 */
export const getQueryFilters = (
  params?: GetQueryFiltersParams,
  signal?: AbortSignal
) => {
  return apiInstance<QueryFilters>({
    url: `/Items/Filters2`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetQueryFiltersQueryKey = (params?: GetQueryFiltersParams) => {
  return [`/Items/Filters2`, ...(params ? [params] : [])] as const;
};

export const getGetQueryFiltersQueryOptions = <
  TData = Awaited<ReturnType<typeof getQueryFilters>>,
  TError = ErrorType<void>
>(
  params?: GetQueryFiltersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFilters>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryFiltersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getQueryFilters>>> = ({
    signal,
  }) => getQueryFilters(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getQueryFilters>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetQueryFiltersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQueryFilters>>
>;
export type GetQueryFiltersQueryError = ErrorType<void>;

export function useGetQueryFilters<
  TData = Awaited<ReturnType<typeof getQueryFilters>>,
  TError = ErrorType<void>
>(
  params: undefined | GetQueryFiltersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFilters>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQueryFilters>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetQueryFilters<
  TData = Awaited<ReturnType<typeof getQueryFilters>>,
  TError = ErrorType<void>
>(
  params?: GetQueryFiltersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFilters>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQueryFilters>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetQueryFilters<
  TData = Awaited<ReturnType<typeof getQueryFilters>>,
  TError = ErrorType<void>
>(
  params?: GetQueryFiltersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFilters>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets query filters.
 */

export function useGetQueryFilters<
  TData = Awaited<ReturnType<typeof getQueryFilters>>,
  TError = ErrorType<void>
>(
  params?: GetQueryFiltersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQueryFilters>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetQueryFiltersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets all genres from a given item, folder, or the entire library.
 */
export const getGenres = (params?: GetGenresParams, signal?: AbortSignal) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Genres`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetGenresQueryKey = (params?: GetGenresParams) => {
  return [`/Genres`, ...(params ? [params] : [])] as const;
};

export const getGetGenresQueryOptions = <
  TData = Awaited<ReturnType<typeof getGenres>>,
  TError = ErrorType<void>
>(
  params?: GetGenresParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenres>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGenresQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenres>>> = ({
    signal,
  }) => getGenres(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGenres>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetGenresQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenres>>
>;
export type GetGenresQueryError = ErrorType<void>;

export function useGetGenres<
  TData = Awaited<ReturnType<typeof getGenres>>,
  TError = ErrorType<void>
>(
  params: undefined | GetGenresParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenres>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenres>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGenres<
  TData = Awaited<ReturnType<typeof getGenres>>,
  TError = ErrorType<void>
>(
  params?: GetGenresParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenres>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenres>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGenres<
  TData = Awaited<ReturnType<typeof getGenres>>,
  TError = ErrorType<void>
>(
  params?: GetGenresParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenres>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all genres from a given item, folder, or the entire library.
 */

export function useGetGenres<
  TData = Awaited<ReturnType<typeof getGenres>>,
  TError = ErrorType<void>
>(
  params?: GetGenresParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenres>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetGenresQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a genre, by name.
 */
export const getGenre = (
  genreName: string,
  params?: GetGenreParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/Genres/${genreName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetGenreQueryKey = (
  genreName: string,
  params?: GetGenreParams
) => {
  return [`/Genres/${genreName}`, ...(params ? [params] : [])] as const;
};

export const getGetGenreQueryOptions = <
  TData = Awaited<ReturnType<typeof getGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params?: GetGenreParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenre>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGenreQueryKey(genreName, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenre>>> = ({
    signal,
  }) => getGenre(genreName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!genreName,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getGenre>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetGenreQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenre>>
>;
export type GetGenreQueryError = ErrorType<void>;

export function useGetGenre<
  TData = Awaited<ReturnType<typeof getGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params: undefined | GetGenreParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenre>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenre>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGenre<
  TData = Awaited<ReturnType<typeof getGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params?: GetGenreParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenre>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenre>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGenre<
  TData = Awaited<ReturnType<typeof getGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params?: GetGenreParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenre>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a genre, by name.
 */

export function useGetGenre<
  TData = Awaited<ReturnType<typeof getGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params?: GetGenreParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenre>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetGenreQueryOptions(genreName, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the specified audio segment for an audio item.
 */
export const getHlsAudioSegmentLegacyAac = (
  itemId: string,
  segmentId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/hls/${segmentId}/stream.aac`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetHlsAudioSegmentLegacyAacQueryKey = (
  itemId: string,
  segmentId: string
) => {
  return [`/Audio/${itemId}/hls/${segmentId}/stream.aac`] as const;
};

export const getGetHlsAudioSegmentLegacyAacQueryOptions = <
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetHlsAudioSegmentLegacyAacQueryKey(itemId, segmentId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>
  > = ({ signal }) => getHlsAudioSegmentLegacyAac(itemId, segmentId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && segmentId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetHlsAudioSegmentLegacyAacQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>
>;
export type GetHlsAudioSegmentLegacyAacQueryError = ErrorType<unknown>;

export function useGetHlsAudioSegmentLegacyAac<
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsAudioSegmentLegacyAac<
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsAudioSegmentLegacyAac<
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the specified audio segment for an audio item.
 */

export function useGetHlsAudioSegmentLegacyAac<
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetHlsAudioSegmentLegacyAacQueryOptions(
    itemId,
    segmentId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the specified audio segment for an audio item.
 */
export const getHlsAudioSegmentLegacyMp3 = (
  itemId: string,
  segmentId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/hls/${segmentId}/stream.mp3`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetHlsAudioSegmentLegacyMp3QueryKey = (
  itemId: string,
  segmentId: string
) => {
  return [`/Audio/${itemId}/hls/${segmentId}/stream.mp3`] as const;
};

export const getGetHlsAudioSegmentLegacyMp3QueryOptions = <
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetHlsAudioSegmentLegacyMp3QueryKey(itemId, segmentId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>
  > = ({ signal }) => getHlsAudioSegmentLegacyMp3(itemId, segmentId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && segmentId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetHlsAudioSegmentLegacyMp3QueryResult = NonNullable<
  Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>
>;
export type GetHlsAudioSegmentLegacyMp3QueryError = ErrorType<unknown>;

export function useGetHlsAudioSegmentLegacyMp3<
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsAudioSegmentLegacyMp3<
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsAudioSegmentLegacyMp3<
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the specified audio segment for an audio item.
 */

export function useGetHlsAudioSegmentLegacyMp3<
  TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  segmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetHlsAudioSegmentLegacyMp3QueryOptions(
    itemId,
    segmentId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a hls video segment.
 */
export const getHlsVideoSegmentLegacy = (
  itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/hls/${playlistId}/${segmentId}.${segmentContainer}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetHlsVideoSegmentLegacyQueryKey = (
  itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string
) => {
  return [
    `/Videos/${itemId}/hls/${playlistId}/${segmentId}.${segmentContainer}`,
  ] as const;
};

export const getGetHlsVideoSegmentLegacyQueryOptions = <
  TData = Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetHlsVideoSegmentLegacyQueryKey(
      itemId,
      playlistId,
      segmentId,
      segmentContainer
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>
  > = ({ signal }) =>
    getHlsVideoSegmentLegacy(
      itemId,
      playlistId,
      segmentId,
      segmentContainer,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && playlistId && segmentId && segmentContainer),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetHlsVideoSegmentLegacyQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>
>;
export type GetHlsVideoSegmentLegacyQueryError = ErrorType<ProblemDetails>;

export function useGetHlsVideoSegmentLegacy<
  TData = Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsVideoSegmentLegacy<
  TData = Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsVideoSegmentLegacy<
  TData = Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a hls video segment.
 */

export function useGetHlsVideoSegmentLegacy<
  TData = Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetHlsVideoSegmentLegacyQueryOptions(
    itemId,
    playlistId,
    segmentId,
    segmentContainer,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a hls video playlist.
 */
export const getHlsPlaylistLegacy = (
  itemId: string,
  playlistId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/hls/${playlistId}/stream.m3u8`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetHlsPlaylistLegacyQueryKey = (
  itemId: string,
  playlistId: string
) => {
  return [`/Videos/${itemId}/hls/${playlistId}/stream.m3u8`] as const;
};

export const getGetHlsPlaylistLegacyQueryOptions = <
  TData = Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetHlsPlaylistLegacyQueryKey(itemId, playlistId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHlsPlaylistLegacy>>
  > = ({ signal }) => getHlsPlaylistLegacy(itemId, playlistId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && playlistId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetHlsPlaylistLegacyQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHlsPlaylistLegacy>>
>;
export type GetHlsPlaylistLegacyQueryError = ErrorType<void>;

export function useGetHlsPlaylistLegacy<
  TData = Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsPlaylistLegacy<
  TData = Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetHlsPlaylistLegacy<
  TData = Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a hls video playlist.
 */

export function useGetHlsPlaylistLegacy<
  TData = Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
  TError = ErrorType<void>
>(
  itemId: string,
  playlistId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHlsPlaylistLegacy>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetHlsPlaylistLegacyQueryOptions(
    itemId,
    playlistId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Stops an active encoding.
 */
export const stopEncodingProcess = (params: StopEncodingProcessParams) => {
  return apiInstance<void>({
    url: `/Videos/ActiveEncodings`,
    method: "DELETE",
    params,
  });
};

export const getStopEncodingProcessMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopEncodingProcess>>,
    TError,
    { params: StopEncodingProcessParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stopEncodingProcess>>,
  TError,
  { params: StopEncodingProcessParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stopEncodingProcess>>,
    { params: StopEncodingProcessParams }
  > = (props) => {
    const { params } = props ?? {};

    return stopEncodingProcess(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type StopEncodingProcessMutationResult = NonNullable<
  Awaited<ReturnType<typeof stopEncodingProcess>>
>;

export type StopEncodingProcessMutationError = ErrorType<void>;

/**
 * @summary Stops an active encoding.
 */
export const useStopEncodingProcess = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopEncodingProcess>>,
    TError,
    { params: StopEncodingProcessParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof stopEncodingProcess>>,
  TError,
  { params: StopEncodingProcessParams },
  TContext
> => {
  const mutationOptions = getStopEncodingProcessMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get artist image by name.
 */
export const getArtistImage = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetArtistImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Artists/${name}/Images/${imageType}/${imageIndex}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetArtistImageQueryKey = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetArtistImageParams
) => {
  return [
    `/Artists/${name}/Images/${imageType}/${imageIndex}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetArtistImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getArtistImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetArtistImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtistImage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetArtistImageQueryKey(name, imageType, imageIndex, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getArtistImage>>> = ({
    signal,
  }) => getArtistImage(name, imageType, imageIndex, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && imageType && imageIndex),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getArtistImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetArtistImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getArtistImage>>
>;
export type GetArtistImageQueryError = ErrorType<ProblemDetails>;

export function useGetArtistImage<
  TData = Awaited<ReturnType<typeof getArtistImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params: undefined | GetArtistImageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtistImage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtistImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetArtistImage<
  TData = Awaited<ReturnType<typeof getArtistImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetArtistImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtistImage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtistImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetArtistImage<
  TData = Awaited<ReturnType<typeof getArtistImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetArtistImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtistImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get artist image by name.
 */

export function useGetArtistImage<
  TData = Awaited<ReturnType<typeof getArtistImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetArtistImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getArtistImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetArtistImageQueryOptions(
    name,
    imageType,
    imageIndex,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get artist image by name.
 */
export const headArtistImage = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadArtistImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Artists/${name}/Images/${imageType}/${imageIndex}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadArtistImageMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headArtistImage>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadArtistImageParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headArtistImage>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadArtistImageParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headArtistImage>>,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadArtistImageParams;
    }
  > = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headArtistImage(name, imageType, imageIndex, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadArtistImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof headArtistImage>>
>;

export type HeadArtistImageMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get artist image by name.
 */
export const useHeadArtistImage = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headArtistImage>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadArtistImageParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headArtistImage>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadArtistImageParams;
  },
  TContext
> => {
  const mutationOptions = getHeadArtistImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Generates or gets the splashscreen.
 */
export const getSplashscreen = (
  params?: GetSplashscreenParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Branding/Splashscreen`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetSplashscreenQueryKey = (params?: GetSplashscreenParams) => {
  return [`/Branding/Splashscreen`, ...(params ? [params] : [])] as const;
};

export const getGetSplashscreenQueryOptions = <
  TData = Awaited<ReturnType<typeof getSplashscreen>>,
  TError = ErrorType<unknown>
>(
  params?: GetSplashscreenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSplashscreen>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSplashscreenQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSplashscreen>>> = ({
    signal,
  }) => getSplashscreen(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSplashscreen>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSplashscreenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSplashscreen>>
>;
export type GetSplashscreenQueryError = ErrorType<unknown>;

export function useGetSplashscreen<
  TData = Awaited<ReturnType<typeof getSplashscreen>>,
  TError = ErrorType<unknown>
>(
  params: undefined | GetSplashscreenParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSplashscreen>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSplashscreen>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSplashscreen<
  TData = Awaited<ReturnType<typeof getSplashscreen>>,
  TError = ErrorType<unknown>
>(
  params?: GetSplashscreenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSplashscreen>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSplashscreen>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSplashscreen<
  TData = Awaited<ReturnType<typeof getSplashscreen>>,
  TError = ErrorType<unknown>
>(
  params?: GetSplashscreenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSplashscreen>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Generates or gets the splashscreen.
 */

export function useGetSplashscreen<
  TData = Awaited<ReturnType<typeof getSplashscreen>>,
  TError = ErrorType<unknown>
>(
  params?: GetSplashscreenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSplashscreen>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSplashscreenQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Uploads a custom splashscreen.
The body is expected to the image contents base64 encoded.
 */
export const uploadCustomSplashscreen = (
  uploadCustomSplashscreenBody: Blob
) => {
  return apiInstance<void>({
    url: `/Branding/Splashscreen`,
    method: "POST",
    headers: { "Content-Type": "image/*" },
    data: uploadCustomSplashscreenBody,
  });
};

export const getUploadCustomSplashscreenMutationOptions = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadCustomSplashscreen>>,
    TError,
    { data: Blob },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadCustomSplashscreen>>,
  TError,
  { data: Blob },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadCustomSplashscreen>>,
    { data: Blob }
  > = (props) => {
    const { data } = props ?? {};

    return uploadCustomSplashscreen(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadCustomSplashscreenMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadCustomSplashscreen>>
>;
export type UploadCustomSplashscreenMutationBody = Blob;
export type UploadCustomSplashscreenMutationError =
  ErrorType<ProblemDetails | void>;

/**
 * @summary Uploads a custom splashscreen.
The body is expected to the image contents base64 encoded.
 */
export const useUploadCustomSplashscreen = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadCustomSplashscreen>>,
    TError,
    { data: Blob },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof uploadCustomSplashscreen>>,
  TError,
  { data: Blob },
  TContext
> => {
  const mutationOptions = getUploadCustomSplashscreenMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete a custom splashscreen.
 */
export const deleteCustomSplashscreen = () => {
  return apiInstance<void>({ url: `/Branding/Splashscreen`, method: "DELETE" });
};

export const getDeleteCustomSplashscreenMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCustomSplashscreen>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCustomSplashscreen>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCustomSplashscreen>>,
    void
  > = () => {
    return deleteCustomSplashscreen();
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteCustomSplashscreenMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCustomSplashscreen>>
>;

export type DeleteCustomSplashscreenMutationError = ErrorType<void>;

/**
 * @summary Delete a custom splashscreen.
 */
export const useDeleteCustomSplashscreen = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCustomSplashscreen>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteCustomSplashscreen>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getDeleteCustomSplashscreenMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get genre image by name.
 */
export const getGenreImage = (
  name: string,
  imageType: ImageType,
  params?: GetGenreImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Genres/${name}/Images/${imageType}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetGenreImageQueryKey = (
  name: string,
  imageType: ImageType,
  params?: GetGenreImageParams
) => {
  return [
    `/Genres/${name}/Images/${imageType}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetGenreImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetGenreImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreImage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGenreImageQueryKey(name, imageType, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenreImage>>> = ({
    signal,
  }) => getGenreImage(name, imageType, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && imageType),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGenreImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetGenreImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenreImage>>
>;
export type GetGenreImageQueryError = ErrorType<ProblemDetails>;

export function useGetGenreImage<
  TData = Awaited<ReturnType<typeof getGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params: undefined | GetGenreImageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreImage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGenreImage<
  TData = Awaited<ReturnType<typeof getGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetGenreImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreImage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGenreImage<
  TData = Awaited<ReturnType<typeof getGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetGenreImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get genre image by name.
 */

export function useGetGenreImage<
  TData = Awaited<ReturnType<typeof getGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetGenreImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenreImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetGenreImageQueryOptions(
    name,
    imageType,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get genre image by name.
 */
export const headGenreImage = (
  name: string,
  imageType: ImageType,
  params?: HeadGenreImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Genres/${name}/Images/${imageType}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadGenreImageMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headGenreImage>>,
    TError,
    { name: string; imageType: ImageType; params?: HeadGenreImageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headGenreImage>>,
  TError,
  { name: string; imageType: ImageType; params?: HeadGenreImageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headGenreImage>>,
    { name: string; imageType: ImageType; params?: HeadGenreImageParams }
  > = (props) => {
    const { name, imageType, params } = props ?? {};

    return headGenreImage(name, imageType, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadGenreImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof headGenreImage>>
>;

export type HeadGenreImageMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get genre image by name.
 */
export const useHeadGenreImage = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headGenreImage>>,
    TError,
    { name: string; imageType: ImageType; params?: HeadGenreImageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headGenreImage>>,
  TError,
  { name: string; imageType: ImageType; params?: HeadGenreImageParams },
  TContext
> => {
  const mutationOptions = getHeadGenreImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get genre image by name.
 */
export const getGenreImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetGenreImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Genres/${name}/Images/${imageType}/${imageIndex}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetGenreImageByIndexQueryKey = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetGenreImageByIndexParams
) => {
  return [
    `/Genres/${name}/Images/${imageType}/${imageIndex}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetGenreImageByIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof getGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetGenreImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenreImageByIndex>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetGenreImageByIndexQueryKey(name, imageType, imageIndex, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGenreImageByIndex>>
  > = ({ signal }) =>
    getGenreImageByIndex(name, imageType, imageIndex, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && imageType && imageIndex),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGenreImageByIndex>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetGenreImageByIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenreImageByIndex>>
>;
export type GetGenreImageByIndexQueryError = ErrorType<ProblemDetails>;

export function useGetGenreImageByIndex<
  TData = Awaited<ReturnType<typeof getGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params: undefined | GetGenreImageByIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenreImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGenreImageByIndex<
  TData = Awaited<ReturnType<typeof getGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetGenreImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenreImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenreImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGenreImageByIndex<
  TData = Awaited<ReturnType<typeof getGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetGenreImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenreImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get genre image by name.
 */

export function useGetGenreImageByIndex<
  TData = Awaited<ReturnType<typeof getGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetGenreImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenreImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetGenreImageByIndexQueryOptions(
    name,
    imageType,
    imageIndex,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get genre image by name.
 */
export const headGenreImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadGenreImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Genres/${name}/Images/${imageType}/${imageIndex}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadGenreImageByIndexMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headGenreImageByIndex>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadGenreImageByIndexParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headGenreImageByIndex>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadGenreImageByIndexParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headGenreImageByIndex>>,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadGenreImageByIndexParams;
    }
  > = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headGenreImageByIndex(name, imageType, imageIndex, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadGenreImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof headGenreImageByIndex>>
>;

export type HeadGenreImageByIndexMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get genre image by name.
 */
export const useHeadGenreImageByIndex = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headGenreImageByIndex>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadGenreImageByIndexParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headGenreImageByIndex>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadGenreImageByIndexParams;
  },
  TContext
> => {
  const mutationOptions = getHeadGenreImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get item image infos.
 */
export const getItemImageInfos = (itemId: string, signal?: AbortSignal) => {
  return apiInstance<ImageInfo[]>({
    url: `/Items/${itemId}/Images`,
    method: "GET",
    signal,
  });
};

export const getGetItemImageInfosQueryKey = (itemId: string) => {
  return [`/Items/${itemId}/Images`] as const;
};

export const getGetItemImageInfosQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemImageInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageInfos>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetItemImageInfosQueryKey(itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getItemImageInfos>>
  > = ({ signal }) => getItemImageInfos(itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemImageInfos>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetItemImageInfosQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemImageInfos>>
>;
export type GetItemImageInfosQueryError = ErrorType<void | ProblemDetails>;

export function useGetItemImageInfos<
  TData = Awaited<ReturnType<typeof getItemImageInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageInfos>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemImageInfos>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemImageInfos<
  TData = Awaited<ReturnType<typeof getItemImageInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageInfos>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemImageInfos>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemImageInfos<
  TData = Awaited<ReturnType<typeof getItemImageInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageInfos>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get item image infos.
 */

export function useGetItemImageInfos<
  TData = Awaited<ReturnType<typeof getItemImageInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageInfos>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetItemImageInfosQueryOptions(itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Delete an item's image.
 */
export const deleteItemImage = (
  itemId: string,
  imageType: ImageType,
  params?: DeleteItemImageParams
) => {
  return apiInstance<void>({
    url: `/Items/${itemId}/Images/${imageType}`,
    method: "DELETE",
    params,
  });
};

export const getDeleteItemImageMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteItemImage>>,
    TError,
    { itemId: string; imageType: ImageType; params?: DeleteItemImageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteItemImage>>,
  TError,
  { itemId: string; imageType: ImageType; params?: DeleteItemImageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteItemImage>>,
    { itemId: string; imageType: ImageType; params?: DeleteItemImageParams }
  > = (props) => {
    const { itemId, imageType, params } = props ?? {};

    return deleteItemImage(itemId, imageType, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteItemImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteItemImage>>
>;

export type DeleteItemImageMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Delete an item's image.
 */
export const useDeleteItemImage = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteItemImage>>,
    TError,
    { itemId: string; imageType: ImageType; params?: DeleteItemImageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteItemImage>>,
  TError,
  { itemId: string; imageType: ImageType; params?: DeleteItemImageParams },
  TContext
> => {
  const mutationOptions = getDeleteItemImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Set item image.
 */
export const setItemImage = (
  itemId: string,
  imageType: ImageType,
  setItemImageBody: Blob
) => {
  return apiInstance<void>({
    url: `/Items/${itemId}/Images/${imageType}`,
    method: "POST",
    headers: { "Content-Type": "image/*" },
    data: setItemImageBody,
  });
};

export const getSetItemImageMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setItemImage>>,
    TError,
    { itemId: string; imageType: ImageType; data: Blob },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setItemImage>>,
  TError,
  { itemId: string; imageType: ImageType; data: Blob },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setItemImage>>,
    { itemId: string; imageType: ImageType; data: Blob }
  > = (props) => {
    const { itemId, imageType, data } = props ?? {};

    return setItemImage(itemId, imageType, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetItemImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof setItemImage>>
>;
export type SetItemImageMutationBody = Blob;
export type SetItemImageMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Set item image.
 */
export const useSetItemImage = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setItemImage>>,
    TError,
    { itemId: string; imageType: ImageType; data: Blob },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof setItemImage>>,
  TError,
  { itemId: string; imageType: ImageType; data: Blob },
  TContext
> => {
  const mutationOptions = getSetItemImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the item's image.
 */
export const getItemImage = (
  itemId: string,
  imageType: ImageType,
  params?: GetItemImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Items/${itemId}/Images/${imageType}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetItemImageQueryKey = (
  itemId: string,
  imageType: ImageType,
  params?: GetItemImageParams
) => {
  return [
    `/Items/${itemId}/Images/${imageType}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetItemImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemImage>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  params?: GetItemImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetItemImageQueryKey(itemId, imageType, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemImage>>> = ({
    signal,
  }) => getItemImage(itemId, imageType, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && imageType),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetItemImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemImage>>
>;
export type GetItemImageQueryError = ErrorType<ProblemDetails>;

export function useGetItemImage<
  TData = Awaited<ReturnType<typeof getItemImage>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  params: undefined | GetItemImageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemImage<
  TData = Awaited<ReturnType<typeof getItemImage>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  params?: GetItemImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemImage<
  TData = Awaited<ReturnType<typeof getItemImage>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  params?: GetItemImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the item's image.
 */

export function useGetItemImage<
  TData = Awaited<ReturnType<typeof getItemImage>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  params?: GetItemImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetItemImageQueryOptions(
    itemId,
    imageType,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the item's image.
 */
export const headItemImage = (
  itemId: string,
  imageType: ImageType,
  params?: HeadItemImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Items/${itemId}/Images/${imageType}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadItemImageMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headItemImage>>,
    TError,
    { itemId: string; imageType: ImageType; params?: HeadItemImageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headItemImage>>,
  TError,
  { itemId: string; imageType: ImageType; params?: HeadItemImageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headItemImage>>,
    { itemId: string; imageType: ImageType; params?: HeadItemImageParams }
  > = (props) => {
    const { itemId, imageType, params } = props ?? {};

    return headItemImage(itemId, imageType, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadItemImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof headItemImage>>
>;

export type HeadItemImageMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Gets the item's image.
 */
export const useHeadItemImage = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headItemImage>>,
    TError,
    { itemId: string; imageType: ImageType; params?: HeadItemImageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headItemImage>>,
  TError,
  { itemId: string; imageType: ImageType; params?: HeadItemImageParams },
  TContext
> => {
  const mutationOptions = getHeadItemImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete an item's image.
 */
export const deleteItemImageByIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number
) => {
  return apiInstance<void>({
    url: `/Items/${itemId}/Images/${imageType}/${imageIndex}`,
    method: "DELETE",
  });
};

export const getDeleteItemImageByIndexMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteItemImageByIndex>>,
    TError,
    { itemId: string; imageType: ImageType; imageIndex: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteItemImageByIndex>>,
  TError,
  { itemId: string; imageType: ImageType; imageIndex: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteItemImageByIndex>>,
    { itemId: string; imageType: ImageType; imageIndex: number }
  > = (props) => {
    const { itemId, imageType, imageIndex } = props ?? {};

    return deleteItemImageByIndex(itemId, imageType, imageIndex);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteItemImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteItemImageByIndex>>
>;

export type DeleteItemImageByIndexMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Delete an item's image.
 */
export const useDeleteItemImageByIndex = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteItemImageByIndex>>,
    TError,
    { itemId: string; imageType: ImageType; imageIndex: number },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteItemImageByIndex>>,
  TError,
  { itemId: string; imageType: ImageType; imageIndex: number },
  TContext
> => {
  const mutationOptions = getDeleteItemImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Set item image.
 */
export const setItemImageByIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  setItemImageByIndexBody: Blob
) => {
  return apiInstance<void>({
    url: `/Items/${itemId}/Images/${imageType}/${imageIndex}`,
    method: "POST",
    headers: { "Content-Type": "image/*" },
    data: setItemImageByIndexBody,
  });
};

export const getSetItemImageByIndexMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setItemImageByIndex>>,
    TError,
    { itemId: string; imageType: ImageType; imageIndex: number; data: Blob },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setItemImageByIndex>>,
  TError,
  { itemId: string; imageType: ImageType; imageIndex: number; data: Blob },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setItemImageByIndex>>,
    { itemId: string; imageType: ImageType; imageIndex: number; data: Blob }
  > = (props) => {
    const { itemId, imageType, imageIndex, data } = props ?? {};

    return setItemImageByIndex(itemId, imageType, imageIndex, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetItemImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof setItemImageByIndex>>
>;
export type SetItemImageByIndexMutationBody = Blob;
export type SetItemImageByIndexMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Set item image.
 */
export const useSetItemImageByIndex = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setItemImageByIndex>>,
    TError,
    { itemId: string; imageType: ImageType; imageIndex: number; data: Blob },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof setItemImageByIndex>>,
  TError,
  { itemId: string; imageType: ImageType; imageIndex: number; data: Blob },
  TContext
> => {
  const mutationOptions = getSetItemImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the item's image.
 */
export const getItemImageByIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetItemImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Items/${itemId}/Images/${imageType}/${imageIndex}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetItemImageByIndexQueryKey = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetItemImageByIndexParams
) => {
  return [
    `/Items/${itemId}/Images/${imageType}/${imageIndex}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetItemImageByIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetItemImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageByIndex>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetItemImageByIndexQueryKey(itemId, imageType, imageIndex, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getItemImageByIndex>>
  > = ({ signal }) =>
    getItemImageByIndex(itemId, imageType, imageIndex, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && imageType && imageIndex),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemImageByIndex>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetItemImageByIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemImageByIndex>>
>;
export type GetItemImageByIndexQueryError = ErrorType<ProblemDetails>;

export function useGetItemImageByIndex<
  TData = Awaited<ReturnType<typeof getItemImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params: undefined | GetItemImageByIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemImageByIndex<
  TData = Awaited<ReturnType<typeof getItemImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetItemImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemImageByIndex<
  TData = Awaited<ReturnType<typeof getItemImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetItemImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the item's image.
 */

export function useGetItemImageByIndex<
  TData = Awaited<ReturnType<typeof getItemImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetItemImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetItemImageByIndexQueryOptions(
    itemId,
    imageType,
    imageIndex,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the item's image.
 */
export const headItemImageByIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadItemImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Items/${itemId}/Images/${imageType}/${imageIndex}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadItemImageByIndexMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headItemImageByIndex>>,
    TError,
    {
      itemId: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadItemImageByIndexParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headItemImageByIndex>>,
  TError,
  {
    itemId: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadItemImageByIndexParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headItemImageByIndex>>,
    {
      itemId: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadItemImageByIndexParams;
    }
  > = (props) => {
    const { itemId, imageType, imageIndex, params } = props ?? {};

    return headItemImageByIndex(itemId, imageType, imageIndex, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadItemImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof headItemImageByIndex>>
>;

export type HeadItemImageByIndexMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Gets the item's image.
 */
export const useHeadItemImageByIndex = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headItemImageByIndex>>,
    TError,
    {
      itemId: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadItemImageByIndexParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headItemImageByIndex>>,
  TError,
  {
    itemId: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadItemImageByIndexParams;
  },
  TContext
> => {
  const mutationOptions = getHeadItemImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the item's image.
 */
export const getItemImage2 = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: GetItemImage2Params,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Items/${itemId}/Images/${imageType}/${imageIndex}/${tag}/${format}/${maxWidth}/${maxHeight}/${percentPlayed}/${unplayedCount}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetItemImage2QueryKey = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: GetItemImage2Params
) => {
  return [
    `/Items/${itemId}/Images/${imageType}/${imageIndex}/${tag}/${format}/${maxWidth}/${maxHeight}/${percentPlayed}/${unplayedCount}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetItemImage2QueryOptions = <
  TData = Awaited<ReturnType<typeof getItemImage2>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: GetItemImage2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage2>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetItemImage2QueryKey(
      itemId,
      imageType,
      imageIndex,
      tag,
      format,
      maxWidth,
      maxHeight,
      percentPlayed,
      unplayedCount,
      params
    );

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemImage2>>> = ({
    signal,
  }) =>
    getItemImage2(
      itemId,
      imageType,
      imageIndex,
      tag,
      format,
      maxWidth,
      maxHeight,
      percentPlayed,
      unplayedCount,
      params,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(
      itemId &&
      imageType &&
      imageIndex &&
      tag &&
      format &&
      maxWidth &&
      maxHeight &&
      percentPlayed &&
      unplayedCount
    ),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemImage2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetItemImage2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemImage2>>
>;
export type GetItemImage2QueryError = ErrorType<ProblemDetails>;

export function useGetItemImage2<
  TData = Awaited<ReturnType<typeof getItemImage2>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params: undefined | GetItemImage2Params,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage2>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemImage2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemImage2<
  TData = Awaited<ReturnType<typeof getItemImage2>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: GetItemImage2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage2>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemImage2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemImage2<
  TData = Awaited<ReturnType<typeof getItemImage2>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: GetItemImage2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage2>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the item's image.
 */

export function useGetItemImage2<
  TData = Awaited<ReturnType<typeof getItemImage2>>,
  TError = ErrorType<ProblemDetails>
>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: GetItemImage2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemImage2>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetItemImage2QueryOptions(
    itemId,
    imageType,
    imageIndex,
    tag,
    format,
    maxWidth,
    maxHeight,
    percentPlayed,
    unplayedCount,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the item's image.
 */
export const headItemImage2 = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: HeadItemImage2Params,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Items/${itemId}/Images/${imageType}/${imageIndex}/${tag}/${format}/${maxWidth}/${maxHeight}/${percentPlayed}/${unplayedCount}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadItemImage2MutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headItemImage2>>,
    TError,
    {
      itemId: string;
      imageType: ImageType;
      imageIndex: number;
      tag: string;
      format: ImageFormat;
      maxWidth: number;
      maxHeight: number;
      percentPlayed: number;
      unplayedCount: number;
      params?: HeadItemImage2Params;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headItemImage2>>,
  TError,
  {
    itemId: string;
    imageType: ImageType;
    imageIndex: number;
    tag: string;
    format: ImageFormat;
    maxWidth: number;
    maxHeight: number;
    percentPlayed: number;
    unplayedCount: number;
    params?: HeadItemImage2Params;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headItemImage2>>,
    {
      itemId: string;
      imageType: ImageType;
      imageIndex: number;
      tag: string;
      format: ImageFormat;
      maxWidth: number;
      maxHeight: number;
      percentPlayed: number;
      unplayedCount: number;
      params?: HeadItemImage2Params;
    }
  > = (props) => {
    const {
      itemId,
      imageType,
      imageIndex,
      tag,
      format,
      maxWidth,
      maxHeight,
      percentPlayed,
      unplayedCount,
      params,
    } = props ?? {};

    return headItemImage2(
      itemId,
      imageType,
      imageIndex,
      tag,
      format,
      maxWidth,
      maxHeight,
      percentPlayed,
      unplayedCount,
      params
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadItemImage2MutationResult = NonNullable<
  Awaited<ReturnType<typeof headItemImage2>>
>;

export type HeadItemImage2MutationError = ErrorType<ProblemDetails>;

/**
 * @summary Gets the item's image.
 */
export const useHeadItemImage2 = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headItemImage2>>,
    TError,
    {
      itemId: string;
      imageType: ImageType;
      imageIndex: number;
      tag: string;
      format: ImageFormat;
      maxWidth: number;
      maxHeight: number;
      percentPlayed: number;
      unplayedCount: number;
      params?: HeadItemImage2Params;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headItemImage2>>,
  TError,
  {
    itemId: string;
    imageType: ImageType;
    imageIndex: number;
    tag: string;
    format: ImageFormat;
    maxWidth: number;
    maxHeight: number;
    percentPlayed: number;
    unplayedCount: number;
    params?: HeadItemImage2Params;
  },
  TContext
> => {
  const mutationOptions = getHeadItemImage2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates the index for an item image.
 */
export const updateItemImageIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params: UpdateItemImageIndexParams
) => {
  return apiInstance<void>({
    url: `/Items/${itemId}/Images/${imageType}/${imageIndex}/Index`,
    method: "POST",
    params,
  });
};

export const getUpdateItemImageIndexMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateItemImageIndex>>,
    TError,
    {
      itemId: string;
      imageType: ImageType;
      imageIndex: number;
      params: UpdateItemImageIndexParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateItemImageIndex>>,
  TError,
  {
    itemId: string;
    imageType: ImageType;
    imageIndex: number;
    params: UpdateItemImageIndexParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateItemImageIndex>>,
    {
      itemId: string;
      imageType: ImageType;
      imageIndex: number;
      params: UpdateItemImageIndexParams;
    }
  > = (props) => {
    const { itemId, imageType, imageIndex, params } = props ?? {};

    return updateItemImageIndex(itemId, imageType, imageIndex, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateItemImageIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateItemImageIndex>>
>;

export type UpdateItemImageIndexMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Updates the index for an item image.
 */
export const useUpdateItemImageIndex = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateItemImageIndex>>,
    TError,
    {
      itemId: string;
      imageType: ImageType;
      imageIndex: number;
      params: UpdateItemImageIndexParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateItemImageIndex>>,
  TError,
  {
    itemId: string;
    imageType: ImageType;
    imageIndex: number;
    params: UpdateItemImageIndexParams;
  },
  TContext
> => {
  const mutationOptions = getUpdateItemImageIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get music genre image by name.
 */
export const getMusicGenreImage = (
  name: string,
  imageType: ImageType,
  params?: GetMusicGenreImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/MusicGenres/${name}/Images/${imageType}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetMusicGenreImageQueryKey = (
  name: string,
  imageType: ImageType,
  params?: GetMusicGenreImageParams
) => {
  return [
    `/MusicGenres/${name}/Images/${imageType}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetMusicGenreImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getMusicGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetMusicGenreImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImage>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetMusicGenreImageQueryKey(name, imageType, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMusicGenreImage>>
  > = ({ signal }) => getMusicGenreImage(name, imageType, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && imageType),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMusicGenreImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMusicGenreImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMusicGenreImage>>
>;
export type GetMusicGenreImageQueryError = ErrorType<ProblemDetails>;

export function useGetMusicGenreImage<
  TData = Awaited<ReturnType<typeof getMusicGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params: undefined | GetMusicGenreImageParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImage>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMusicGenreImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMusicGenreImage<
  TData = Awaited<ReturnType<typeof getMusicGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetMusicGenreImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImage>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMusicGenreImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMusicGenreImage<
  TData = Awaited<ReturnType<typeof getMusicGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetMusicGenreImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImage>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get music genre image by name.
 */

export function useGetMusicGenreImage<
  TData = Awaited<ReturnType<typeof getMusicGenreImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetMusicGenreImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImage>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMusicGenreImageQueryOptions(
    name,
    imageType,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get music genre image by name.
 */
export const headMusicGenreImage = (
  name: string,
  imageType: ImageType,
  params?: HeadMusicGenreImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/MusicGenres/${name}/Images/${imageType}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadMusicGenreImageMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headMusicGenreImage>>,
    TError,
    { name: string; imageType: ImageType; params?: HeadMusicGenreImageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headMusicGenreImage>>,
  TError,
  { name: string; imageType: ImageType; params?: HeadMusicGenreImageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headMusicGenreImage>>,
    { name: string; imageType: ImageType; params?: HeadMusicGenreImageParams }
  > = (props) => {
    const { name, imageType, params } = props ?? {};

    return headMusicGenreImage(name, imageType, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadMusicGenreImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof headMusicGenreImage>>
>;

export type HeadMusicGenreImageMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get music genre image by name.
 */
export const useHeadMusicGenreImage = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headMusicGenreImage>>,
    TError,
    { name: string; imageType: ImageType; params?: HeadMusicGenreImageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headMusicGenreImage>>,
  TError,
  { name: string; imageType: ImageType; params?: HeadMusicGenreImageParams },
  TContext
> => {
  const mutationOptions = getHeadMusicGenreImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get music genre image by name.
 */
export const getMusicGenreImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetMusicGenreImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/MusicGenres/${name}/Images/${imageType}/${imageIndex}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetMusicGenreImageByIndexQueryKey = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetMusicGenreImageByIndexParams
) => {
  return [
    `/MusicGenres/${name}/Images/${imageType}/${imageIndex}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetMusicGenreImageByIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetMusicGenreImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetMusicGenreImageByIndexQueryKey(name, imageType, imageIndex, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMusicGenreImageByIndex>>
  > = ({ signal }) =>
    getMusicGenreImageByIndex(name, imageType, imageIndex, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && imageType && imageIndex),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMusicGenreImageByIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMusicGenreImageByIndex>>
>;
export type GetMusicGenreImageByIndexQueryError = ErrorType<ProblemDetails>;

export function useGetMusicGenreImageByIndex<
  TData = Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params: undefined | GetMusicGenreImageByIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMusicGenreImageByIndex<
  TData = Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetMusicGenreImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMusicGenreImageByIndex<
  TData = Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetMusicGenreImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get music genre image by name.
 */

export function useGetMusicGenreImageByIndex<
  TData = Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetMusicGenreImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMusicGenreImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMusicGenreImageByIndexQueryOptions(
    name,
    imageType,
    imageIndex,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get music genre image by name.
 */
export const headMusicGenreImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadMusicGenreImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/MusicGenres/${name}/Images/${imageType}/${imageIndex}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadMusicGenreImageByIndexMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headMusicGenreImageByIndex>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadMusicGenreImageByIndexParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headMusicGenreImageByIndex>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadMusicGenreImageByIndexParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headMusicGenreImageByIndex>>,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadMusicGenreImageByIndexParams;
    }
  > = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headMusicGenreImageByIndex(name, imageType, imageIndex, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadMusicGenreImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof headMusicGenreImageByIndex>>
>;

export type HeadMusicGenreImageByIndexMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get music genre image by name.
 */
export const useHeadMusicGenreImageByIndex = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headMusicGenreImageByIndex>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadMusicGenreImageByIndexParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headMusicGenreImageByIndex>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadMusicGenreImageByIndexParams;
  },
  TContext
> => {
  const mutationOptions = getHeadMusicGenreImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get person image by name.
 */
export const getPersonImage = (
  name: string,
  imageType: ImageType,
  params?: GetPersonImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Persons/${name}/Images/${imageType}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetPersonImageQueryKey = (
  name: string,
  imageType: ImageType,
  params?: GetPersonImageParams
) => {
  return [
    `/Persons/${name}/Images/${imageType}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetPersonImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getPersonImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetPersonImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersonImage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPersonImageQueryKey(name, imageType, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonImage>>> = ({
    signal,
  }) => getPersonImage(name, imageType, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && imageType),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPersonImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPersonImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPersonImage>>
>;
export type GetPersonImageQueryError = ErrorType<ProblemDetails>;

export function useGetPersonImage<
  TData = Awaited<ReturnType<typeof getPersonImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params: undefined | GetPersonImageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersonImage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersonImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPersonImage<
  TData = Awaited<ReturnType<typeof getPersonImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetPersonImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersonImage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersonImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPersonImage<
  TData = Awaited<ReturnType<typeof getPersonImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetPersonImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersonImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get person image by name.
 */

export function useGetPersonImage<
  TData = Awaited<ReturnType<typeof getPersonImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetPersonImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersonImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPersonImageQueryOptions(
    name,
    imageType,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get person image by name.
 */
export const headPersonImage = (
  name: string,
  imageType: ImageType,
  params?: HeadPersonImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Persons/${name}/Images/${imageType}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadPersonImageMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headPersonImage>>,
    TError,
    { name: string; imageType: ImageType; params?: HeadPersonImageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headPersonImage>>,
  TError,
  { name: string; imageType: ImageType; params?: HeadPersonImageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headPersonImage>>,
    { name: string; imageType: ImageType; params?: HeadPersonImageParams }
  > = (props) => {
    const { name, imageType, params } = props ?? {};

    return headPersonImage(name, imageType, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadPersonImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof headPersonImage>>
>;

export type HeadPersonImageMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get person image by name.
 */
export const useHeadPersonImage = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headPersonImage>>,
    TError,
    { name: string; imageType: ImageType; params?: HeadPersonImageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headPersonImage>>,
  TError,
  { name: string; imageType: ImageType; params?: HeadPersonImageParams },
  TContext
> => {
  const mutationOptions = getHeadPersonImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get person image by name.
 */
export const getPersonImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetPersonImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Persons/${name}/Images/${imageType}/${imageIndex}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetPersonImageByIndexQueryKey = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetPersonImageByIndexParams
) => {
  return [
    `/Persons/${name}/Images/${imageType}/${imageIndex}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetPersonImageByIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof getPersonImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetPersonImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonImageByIndex>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPersonImageByIndexQueryKey(name, imageType, imageIndex, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPersonImageByIndex>>
  > = ({ signal }) =>
    getPersonImageByIndex(name, imageType, imageIndex, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && imageType && imageIndex),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPersonImageByIndex>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPersonImageByIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPersonImageByIndex>>
>;
export type GetPersonImageByIndexQueryError = ErrorType<ProblemDetails>;

export function useGetPersonImageByIndex<
  TData = Awaited<ReturnType<typeof getPersonImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params: undefined | GetPersonImageByIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersonImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPersonImageByIndex<
  TData = Awaited<ReturnType<typeof getPersonImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetPersonImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersonImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPersonImageByIndex<
  TData = Awaited<ReturnType<typeof getPersonImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetPersonImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get person image by name.
 */

export function useGetPersonImageByIndex<
  TData = Awaited<ReturnType<typeof getPersonImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetPersonImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPersonImageByIndexQueryOptions(
    name,
    imageType,
    imageIndex,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get person image by name.
 */
export const headPersonImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadPersonImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Persons/${name}/Images/${imageType}/${imageIndex}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadPersonImageByIndexMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headPersonImageByIndex>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadPersonImageByIndexParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headPersonImageByIndex>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadPersonImageByIndexParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headPersonImageByIndex>>,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadPersonImageByIndexParams;
    }
  > = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headPersonImageByIndex(name, imageType, imageIndex, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadPersonImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof headPersonImageByIndex>>
>;

export type HeadPersonImageByIndexMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get person image by name.
 */
export const useHeadPersonImageByIndex = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headPersonImageByIndex>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadPersonImageByIndexParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headPersonImageByIndex>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadPersonImageByIndexParams;
  },
  TContext
> => {
  const mutationOptions = getHeadPersonImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get studio image by name.
 */
export const getStudioImage = (
  name: string,
  imageType: ImageType,
  params?: GetStudioImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Studios/${name}/Images/${imageType}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetStudioImageQueryKey = (
  name: string,
  imageType: ImageType,
  params?: GetStudioImageParams
) => {
  return [
    `/Studios/${name}/Images/${imageType}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetStudioImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudioImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetStudioImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudioImage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetStudioImageQueryKey(name, imageType, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudioImage>>> = ({
    signal,
  }) => getStudioImage(name, imageType, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && imageType),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudioImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetStudioImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStudioImage>>
>;
export type GetStudioImageQueryError = ErrorType<ProblemDetails>;

export function useGetStudioImage<
  TData = Awaited<ReturnType<typeof getStudioImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params: undefined | GetStudioImageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudioImage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudioImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStudioImage<
  TData = Awaited<ReturnType<typeof getStudioImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetStudioImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudioImage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudioImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStudioImage<
  TData = Awaited<ReturnType<typeof getStudioImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetStudioImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudioImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get studio image by name.
 */

export function useGetStudioImage<
  TData = Awaited<ReturnType<typeof getStudioImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  params?: GetStudioImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudioImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetStudioImageQueryOptions(
    name,
    imageType,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get studio image by name.
 */
export const headStudioImage = (
  name: string,
  imageType: ImageType,
  params?: HeadStudioImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Studios/${name}/Images/${imageType}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadStudioImageMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headStudioImage>>,
    TError,
    { name: string; imageType: ImageType; params?: HeadStudioImageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headStudioImage>>,
  TError,
  { name: string; imageType: ImageType; params?: HeadStudioImageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headStudioImage>>,
    { name: string; imageType: ImageType; params?: HeadStudioImageParams }
  > = (props) => {
    const { name, imageType, params } = props ?? {};

    return headStudioImage(name, imageType, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadStudioImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof headStudioImage>>
>;

export type HeadStudioImageMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get studio image by name.
 */
export const useHeadStudioImage = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headStudioImage>>,
    TError,
    { name: string; imageType: ImageType; params?: HeadStudioImageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headStudioImage>>,
  TError,
  { name: string; imageType: ImageType; params?: HeadStudioImageParams },
  TContext
> => {
  const mutationOptions = getHeadStudioImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get studio image by name.
 */
export const getStudioImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetStudioImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Studios/${name}/Images/${imageType}/${imageIndex}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetStudioImageByIndexQueryKey = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetStudioImageByIndexParams
) => {
  return [
    `/Studios/${name}/Images/${imageType}/${imageIndex}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetStudioImageByIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudioImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetStudioImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStudioImageByIndex>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetStudioImageByIndexQueryKey(name, imageType, imageIndex, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStudioImageByIndex>>
  > = ({ signal }) =>
    getStudioImageByIndex(name, imageType, imageIndex, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && imageType && imageIndex),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudioImageByIndex>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetStudioImageByIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStudioImageByIndex>>
>;
export type GetStudioImageByIndexQueryError = ErrorType<ProblemDetails>;

export function useGetStudioImageByIndex<
  TData = Awaited<ReturnType<typeof getStudioImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params: undefined | GetStudioImageByIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStudioImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudioImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStudioImageByIndex<
  TData = Awaited<ReturnType<typeof getStudioImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetStudioImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStudioImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudioImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStudioImageByIndex<
  TData = Awaited<ReturnType<typeof getStudioImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetStudioImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStudioImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get studio image by name.
 */

export function useGetStudioImageByIndex<
  TData = Awaited<ReturnType<typeof getStudioImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetStudioImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStudioImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetStudioImageByIndexQueryOptions(
    name,
    imageType,
    imageIndex,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get studio image by name.
 */
export const headStudioImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadStudioImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Studios/${name}/Images/${imageType}/${imageIndex}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadStudioImageByIndexMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headStudioImageByIndex>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadStudioImageByIndexParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headStudioImageByIndex>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadStudioImageByIndexParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headStudioImageByIndex>>,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadStudioImageByIndexParams;
    }
  > = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headStudioImageByIndex(name, imageType, imageIndex, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadStudioImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof headStudioImageByIndex>>
>;

export type HeadStudioImageByIndexMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get studio image by name.
 */
export const useHeadStudioImageByIndex = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headStudioImageByIndex>>,
    TError,
    {
      name: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadStudioImageByIndexParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headStudioImageByIndex>>,
  TError,
  {
    name: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadStudioImageByIndexParams;
  },
  TContext
> => {
  const mutationOptions = getHeadStudioImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Sets the user image.
 */
export const postUserImage = (
  userId: string,
  imageType: ImageType,
  postUserImageBody: Blob,
  params?: PostUserImageParams
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/Images/${imageType}`,
    method: "POST",
    headers: { "Content-Type": "image/*" },
    data: postUserImageBody,
    params,
  });
};

export const getPostUserImageMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserImage>>,
    TError,
    {
      userId: string;
      imageType: ImageType;
      data: Blob;
      params?: PostUserImageParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUserImage>>,
  TError,
  {
    userId: string;
    imageType: ImageType;
    data: Blob;
    params?: PostUserImageParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUserImage>>,
    {
      userId: string;
      imageType: ImageType;
      data: Blob;
      params?: PostUserImageParams;
    }
  > = (props) => {
    const { userId, imageType, data, params } = props ?? {};

    return postUserImage(userId, imageType, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUserImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof postUserImage>>
>;
export type PostUserImageMutationBody = Blob;
export type PostUserImageMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Sets the user image.
 */
export const usePostUserImage = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserImage>>,
    TError,
    {
      userId: string;
      imageType: ImageType;
      data: Blob;
      params?: PostUserImageParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postUserImage>>,
  TError,
  {
    userId: string;
    imageType: ImageType;
    data: Blob;
    params?: PostUserImageParams;
  },
  TContext
> => {
  const mutationOptions = getPostUserImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete the user's image.
 */
export const deleteUserImage = (
  userId: string,
  imageType: ImageType,
  params?: DeleteUserImageParams
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/Images/${imageType}`,
    method: "DELETE",
    params,
  });
};

export const getDeleteUserImageMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUserImage>>,
    TError,
    { userId: string; imageType: ImageType; params?: DeleteUserImageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUserImage>>,
  TError,
  { userId: string; imageType: ImageType; params?: DeleteUserImageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUserImage>>,
    { userId: string; imageType: ImageType; params?: DeleteUserImageParams }
  > = (props) => {
    const { userId, imageType, params } = props ?? {};

    return deleteUserImage(userId, imageType, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUserImage>>
>;

export type DeleteUserImageMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Delete the user's image.
 */
export const useDeleteUserImage = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUserImage>>,
    TError,
    { userId: string; imageType: ImageType; params?: DeleteUserImageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteUserImage>>,
  TError,
  { userId: string; imageType: ImageType; params?: DeleteUserImageParams },
  TContext
> => {
  const mutationOptions = getDeleteUserImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get user profile image.
 */
export const getUserImage = (
  userId: string,
  imageType: ImageType,
  params?: GetUserImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Users/${userId}/Images/${imageType}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetUserImageQueryKey = (
  userId: string,
  imageType: ImageType,
  params?: GetUserImageParams
) => {
  return [
    `/Users/${userId}/Images/${imageType}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetUserImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserImage>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  params?: GetUserImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserImage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetUserImageQueryKey(userId, imageType, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserImage>>> = ({
    signal,
  }) => getUserImage(userId, imageType, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && imageType),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserImage>>
>;
export type GetUserImageQueryError = ErrorType<ProblemDetails>;

export function useGetUserImage<
  TData = Awaited<ReturnType<typeof getUserImage>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  params: undefined | GetUserImageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserImage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUserImage<
  TData = Awaited<ReturnType<typeof getUserImage>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  params?: GetUserImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserImage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUserImage<
  TData = Awaited<ReturnType<typeof getUserImage>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  params?: GetUserImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get user profile image.
 */

export function useGetUserImage<
  TData = Awaited<ReturnType<typeof getUserImage>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  params?: GetUserImageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserImageQueryOptions(
    userId,
    imageType,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get user profile image.
 */
export const headUserImage = (
  userId: string,
  imageType: ImageType,
  params?: HeadUserImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Users/${userId}/Images/${imageType}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadUserImageMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headUserImage>>,
    TError,
    { userId: string; imageType: ImageType; params?: HeadUserImageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headUserImage>>,
  TError,
  { userId: string; imageType: ImageType; params?: HeadUserImageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headUserImage>>,
    { userId: string; imageType: ImageType; params?: HeadUserImageParams }
  > = (props) => {
    const { userId, imageType, params } = props ?? {};

    return headUserImage(userId, imageType, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadUserImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof headUserImage>>
>;

export type HeadUserImageMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get user profile image.
 */
export const useHeadUserImage = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headUserImage>>,
    TError,
    { userId: string; imageType: ImageType; params?: HeadUserImageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headUserImage>>,
  TError,
  { userId: string; imageType: ImageType; params?: HeadUserImageParams },
  TContext
> => {
  const mutationOptions = getHeadUserImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get user profile image.
 */
export const getUserImageByIndex = (
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetUserImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Users/${userId}/Images/${imageType}/${imageIndex}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetUserImageByIndexQueryKey = (
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetUserImageByIndexParams
) => {
  return [
    `/Users/${userId}/Images/${imageType}/${imageIndex}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetUserImageByIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetUserImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserImageByIndex>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetUserImageByIndexQueryKey(userId, imageType, imageIndex, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserImageByIndex>>
  > = ({ signal }) =>
    getUserImageByIndex(userId, imageType, imageIndex, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && imageType && imageIndex),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserImageByIndex>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserImageByIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserImageByIndex>>
>;
export type GetUserImageByIndexQueryError = ErrorType<ProblemDetails>;

export function useGetUserImageByIndex<
  TData = Awaited<ReturnType<typeof getUserImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params: undefined | GetUserImageByIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUserImageByIndex<
  TData = Awaited<ReturnType<typeof getUserImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetUserImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserImageByIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserImageByIndex>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUserImageByIndex<
  TData = Awaited<ReturnType<typeof getUserImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetUserImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get user profile image.
 */

export function useGetUserImageByIndex<
  TData = Awaited<ReturnType<typeof getUserImageByIndex>>,
  TError = ErrorType<ProblemDetails>
>(
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetUserImageByIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserImageByIndex>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserImageByIndexQueryOptions(
    userId,
    imageType,
    imageIndex,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get user profile image.
 */
export const headUserImageByIndex = (
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadUserImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Users/${userId}/Images/${imageType}/${imageIndex}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadUserImageByIndexMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headUserImageByIndex>>,
    TError,
    {
      userId: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadUserImageByIndexParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headUserImageByIndex>>,
  TError,
  {
    userId: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadUserImageByIndexParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headUserImageByIndex>>,
    {
      userId: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadUserImageByIndexParams;
    }
  > = (props) => {
    const { userId, imageType, imageIndex, params } = props ?? {};

    return headUserImageByIndex(userId, imageType, imageIndex, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadUserImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof headUserImageByIndex>>
>;

export type HeadUserImageByIndexMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Get user profile image.
 */
export const useHeadUserImageByIndex = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headUserImageByIndex>>,
    TError,
    {
      userId: string;
      imageType: ImageType;
      imageIndex: number;
      params?: HeadUserImageByIndexParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headUserImageByIndex>>,
  TError,
  {
    userId: string;
    imageType: ImageType;
    imageIndex: number;
    params?: HeadUserImageByIndexParams;
  },
  TContext
> => {
  const mutationOptions = getHeadUserImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Sets the user image.
 */
export const postUserImageByIndex = (
  userId: string,
  imageType: ImageType,
  index: number,
  postUserImageByIndexBody: Blob
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/Images/${imageType}/${index}`,
    method: "POST",
    headers: { "Content-Type": "image/*" },
    data: postUserImageByIndexBody,
  });
};

export const getPostUserImageByIndexMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserImageByIndex>>,
    TError,
    { userId: string; imageType: ImageType; index: number; data: Blob },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUserImageByIndex>>,
  TError,
  { userId: string; imageType: ImageType; index: number; data: Blob },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUserImageByIndex>>,
    { userId: string; imageType: ImageType; index: number; data: Blob }
  > = (props) => {
    const { userId, imageType, index, data } = props ?? {};

    return postUserImageByIndex(userId, imageType, index, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUserImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof postUserImageByIndex>>
>;
export type PostUserImageByIndexMutationBody = Blob;
export type PostUserImageByIndexMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Sets the user image.
 */
export const usePostUserImageByIndex = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserImageByIndex>>,
    TError,
    { userId: string; imageType: ImageType; index: number; data: Blob },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postUserImageByIndex>>,
  TError,
  { userId: string; imageType: ImageType; index: number; data: Blob },
  TContext
> => {
  const mutationOptions = getPostUserImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete the user's image.
 */
export const deleteUserImageByIndex = (
  userId: string,
  imageType: ImageType,
  index: number
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/Images/${imageType}/${index}`,
    method: "DELETE",
  });
};

export const getDeleteUserImageByIndexMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUserImageByIndex>>,
    TError,
    { userId: string; imageType: ImageType; index: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUserImageByIndex>>,
  TError,
  { userId: string; imageType: ImageType; index: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUserImageByIndex>>,
    { userId: string; imageType: ImageType; index: number }
  > = (props) => {
    const { userId, imageType, index } = props ?? {};

    return deleteUserImageByIndex(userId, imageType, index);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserImageByIndexMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUserImageByIndex>>
>;

export type DeleteUserImageByIndexMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Delete the user's image.
 */
export const useDeleteUserImageByIndex = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUserImageByIndex>>,
    TError,
    { userId: string; imageType: ImageType; index: number },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteUserImageByIndex>>,
  TError,
  { userId: string; imageType: ImageType; index: number },
  TContext
> => {
  const mutationOptions = getDeleteUserImageByIndexMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get all general images.
 */
export const getGeneralImages = (signal?: AbortSignal) => {
  return apiInstance<ImageByNameInfo[]>({
    url: `/Images/General`,
    method: "GET",
    signal,
  });
};

export const getGetGeneralImagesQueryKey = () => {
  return [`/Images/General`] as const;
};

export const getGetGeneralImagesQueryOptions = <
  TData = Awaited<ReturnType<typeof getGeneralImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGeneralImages>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGeneralImagesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGeneralImages>>
  > = ({ signal }) => getGeneralImages(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGeneralImages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetGeneralImagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGeneralImages>>
>;
export type GetGeneralImagesQueryError = ErrorType<void>;

export function useGetGeneralImages<
  TData = Awaited<ReturnType<typeof getGeneralImages>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGeneralImages>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getGeneralImages>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGeneralImages<
  TData = Awaited<ReturnType<typeof getGeneralImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGeneralImages>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getGeneralImages>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGeneralImages<
  TData = Awaited<ReturnType<typeof getGeneralImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGeneralImages>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get all general images.
 */

export function useGetGeneralImages<
  TData = Awaited<ReturnType<typeof getGeneralImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGeneralImages>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetGeneralImagesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get General Image.
 */
export const getGeneralImage = (
  name: string,
  type: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Images/General/${name}/${type}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetGeneralImageQueryKey = (name: string, type: string) => {
  return [`/Images/General/${name}/${type}`] as const;
};

export const getGetGeneralImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getGeneralImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  type: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeneralImage>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGeneralImageQueryKey(name, type);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGeneralImage>>> = ({
    signal,
  }) => getGeneralImage(name, type, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(name && type),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGeneralImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetGeneralImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGeneralImage>>
>;
export type GetGeneralImageQueryError = ErrorType<ProblemDetails>;

export function useGetGeneralImage<
  TData = Awaited<ReturnType<typeof getGeneralImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  type: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeneralImage>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGeneralImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGeneralImage<
  TData = Awaited<ReturnType<typeof getGeneralImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  type: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeneralImage>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGeneralImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGeneralImage<
  TData = Awaited<ReturnType<typeof getGeneralImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  type: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeneralImage>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get General Image.
 */

export function useGetGeneralImage<
  TData = Awaited<ReturnType<typeof getGeneralImage>>,
  TError = ErrorType<ProblemDetails>
>(
  name: string,
  type: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeneralImage>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetGeneralImageQueryOptions(name, type, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all media info images.
 */
export const getMediaInfoImages = (signal?: AbortSignal) => {
  return apiInstance<ImageByNameInfo[]>({
    url: `/Images/MediaInfo`,
    method: "GET",
    signal,
  });
};

export const getGetMediaInfoImagesQueryKey = () => {
  return [`/Images/MediaInfo`] as const;
};

export const getGetMediaInfoImagesQueryOptions = <
  TData = Awaited<ReturnType<typeof getMediaInfoImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMediaInfoImages>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaInfoImagesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMediaInfoImages>>
  > = ({ signal }) => getMediaInfoImages(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMediaInfoImages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMediaInfoImagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMediaInfoImages>>
>;
export type GetMediaInfoImagesQueryError = ErrorType<void>;

export function useGetMediaInfoImages<
  TData = Awaited<ReturnType<typeof getMediaInfoImages>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMediaInfoImages>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getMediaInfoImages>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaInfoImages<
  TData = Awaited<ReturnType<typeof getMediaInfoImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMediaInfoImages>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getMediaInfoImages>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaInfoImages<
  TData = Awaited<ReturnType<typeof getMediaInfoImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMediaInfoImages>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get all media info images.
 */

export function useGetMediaInfoImages<
  TData = Awaited<ReturnType<typeof getMediaInfoImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMediaInfoImages>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMediaInfoImagesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get media info image.
 */
export const getMediaInfoImage = (
  theme: string,
  name: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Images/MediaInfo/${theme}/${name}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetMediaInfoImageQueryKey = (theme: string, name: string) => {
  return [`/Images/MediaInfo/${theme}/${name}`] as const;
};

export const getGetMediaInfoImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getMediaInfoImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaInfoImage>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMediaInfoImageQueryKey(theme, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMediaInfoImage>>
  > = ({ signal }) => getMediaInfoImage(theme, name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(theme && name),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMediaInfoImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMediaInfoImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMediaInfoImage>>
>;
export type GetMediaInfoImageQueryError = ErrorType<ProblemDetails>;

export function useGetMediaInfoImage<
  TData = Awaited<ReturnType<typeof getMediaInfoImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaInfoImage>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaInfoImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaInfoImage<
  TData = Awaited<ReturnType<typeof getMediaInfoImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaInfoImage>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaInfoImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaInfoImage<
  TData = Awaited<ReturnType<typeof getMediaInfoImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaInfoImage>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get media info image.
 */

export function useGetMediaInfoImage<
  TData = Awaited<ReturnType<typeof getMediaInfoImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaInfoImage>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMediaInfoImageQueryOptions(theme, name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all general images.
 */
export const getRatingImages = (signal?: AbortSignal) => {
  return apiInstance<ImageByNameInfo[]>({
    url: `/Images/Ratings`,
    method: "GET",
    signal,
  });
};

export const getGetRatingImagesQueryKey = () => {
  return [`/Images/Ratings`] as const;
};

export const getGetRatingImagesQueryOptions = <
  TData = Awaited<ReturnType<typeof getRatingImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRatingImages>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRatingImagesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRatingImages>>> = ({
    signal,
  }) => getRatingImages(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRatingImages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRatingImagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRatingImages>>
>;
export type GetRatingImagesQueryError = ErrorType<void>;

export function useGetRatingImages<
  TData = Awaited<ReturnType<typeof getRatingImages>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRatingImages>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getRatingImages>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRatingImages<
  TData = Awaited<ReturnType<typeof getRatingImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRatingImages>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getRatingImages>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRatingImages<
  TData = Awaited<ReturnType<typeof getRatingImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRatingImages>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get all general images.
 */

export function useGetRatingImages<
  TData = Awaited<ReturnType<typeof getRatingImages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRatingImages>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRatingImagesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get rating image.
 */
export const getRatingImage = (
  theme: string,
  name: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Images/Ratings/${theme}/${name}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetRatingImageQueryKey = (theme: string, name: string) => {
  return [`/Images/Ratings/${theme}/${name}`] as const;
};

export const getGetRatingImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getRatingImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRatingImage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRatingImageQueryKey(theme, name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRatingImage>>> = ({
    signal,
  }) => getRatingImage(theme, name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(theme && name),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRatingImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRatingImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRatingImage>>
>;
export type GetRatingImageQueryError = ErrorType<ProblemDetails>;

export function useGetRatingImage<
  TData = Awaited<ReturnType<typeof getRatingImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRatingImage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRatingImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRatingImage<
  TData = Awaited<ReturnType<typeof getRatingImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRatingImage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRatingImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRatingImage<
  TData = Awaited<ReturnType<typeof getRatingImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRatingImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get rating image.
 */

export function useGetRatingImage<
  TData = Awaited<ReturnType<typeof getRatingImage>>,
  TError = ErrorType<ProblemDetails>
>(
  theme: string,
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRatingImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRatingImageQueryOptions(theme, name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates an instant playlist based on a given album.
 */
export const getInstantMixFromAlbum = (
  id: string,
  params?: GetInstantMixFromAlbumParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Albums/${id}/InstantMix`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetInstantMixFromAlbumQueryKey = (
  id: string,
  params?: GetInstantMixFromAlbumParams
) => {
  return [`/Albums/${id}/InstantMix`, ...(params ? [params] : [])] as const;
};

export const getGetInstantMixFromAlbumQueryOptions = <
  TData = Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromAlbumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetInstantMixFromAlbumQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstantMixFromAlbum>>
  > = ({ signal }) => getInstantMixFromAlbum(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInstantMixFromAlbumQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstantMixFromAlbum>>
>;
export type GetInstantMixFromAlbumQueryError = ErrorType<void>;

export function useGetInstantMixFromAlbum<
  TData = Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
  TError = ErrorType<void>
>(
  id: string,
  params: undefined | GetInstantMixFromAlbumParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromAlbum<
  TData = Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromAlbumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromAlbum<
  TData = Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromAlbumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Creates an instant playlist based on a given album.
 */

export function useGetInstantMixFromAlbum<
  TData = Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromAlbumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromAlbum>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetInstantMixFromAlbumQueryOptions(
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates an instant playlist based on a given artist.
 */
export const getInstantMixFromArtists = (
  id: string,
  params?: GetInstantMixFromArtistsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Artists/${id}/InstantMix`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetInstantMixFromArtistsQueryKey = (
  id: string,
  params?: GetInstantMixFromArtistsParams
) => {
  return [`/Artists/${id}/InstantMix`, ...(params ? [params] : [])] as const;
};

export const getGetInstantMixFromArtistsQueryOptions = <
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetInstantMixFromArtistsQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstantMixFromArtists>>
  > = ({ signal }) => getInstantMixFromArtists(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstantMixFromArtists>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInstantMixFromArtistsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstantMixFromArtists>>
>;
export type GetInstantMixFromArtistsQueryError = ErrorType<void>;

export function useGetInstantMixFromArtists<
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists>>,
  TError = ErrorType<void>
>(
  id: string,
  params: undefined | GetInstantMixFromArtistsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromArtists>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromArtists<
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromArtists>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromArtists<
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Creates an instant playlist based on a given artist.
 */

export function useGetInstantMixFromArtists<
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetInstantMixFromArtistsQueryOptions(
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @deprecated
 * @summary Creates an instant playlist based on a given artist.
 */
export const getInstantMixFromArtists2 = (
  params: GetInstantMixFromArtists2Params,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Artists/InstantMix`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetInstantMixFromArtists2QueryKey = (
  params: GetInstantMixFromArtists2Params
) => {
  return [`/Artists/InstantMix`, ...(params ? [params] : [])] as const;
};

export const getGetInstantMixFromArtists2QueryOptions = <
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromArtists2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetInstantMixFromArtists2QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstantMixFromArtists2>>
  > = ({ signal }) => getInstantMixFromArtists2(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInstantMixFromArtists2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstantMixFromArtists2>>
>;
export type GetInstantMixFromArtists2QueryError = ErrorType<void>;

export function useGetInstantMixFromArtists2<
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromArtists2Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromArtists2<
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromArtists2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromArtists2<
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromArtists2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @deprecated
 * @summary Creates an instant playlist based on a given artist.
 */

export function useGetInstantMixFromArtists2<
  TData = Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromArtists2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromArtists2>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetInstantMixFromArtists2QueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates an instant playlist based on a given item.
 */
export const getInstantMixFromItem = (
  id: string,
  params?: GetInstantMixFromItemParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Items/${id}/InstantMix`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetInstantMixFromItemQueryKey = (
  id: string,
  params?: GetInstantMixFromItemParams
) => {
  return [`/Items/${id}/InstantMix`, ...(params ? [params] : [])] as const;
};

export const getGetInstantMixFromItemQueryOptions = <
  TData = Awaited<ReturnType<typeof getInstantMixFromItem>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromItem>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetInstantMixFromItemQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstantMixFromItem>>
  > = ({ signal }) => getInstantMixFromItem(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstantMixFromItem>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInstantMixFromItemQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstantMixFromItem>>
>;
export type GetInstantMixFromItemQueryError = ErrorType<void>;

export function useGetInstantMixFromItem<
  TData = Awaited<ReturnType<typeof getInstantMixFromItem>>,
  TError = ErrorType<void>
>(
  id: string,
  params: undefined | GetInstantMixFromItemParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromItem>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromItem>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromItem<
  TData = Awaited<ReturnType<typeof getInstantMixFromItem>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromItem>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromItem>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromItem<
  TData = Awaited<ReturnType<typeof getInstantMixFromItem>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromItem>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Creates an instant playlist based on a given item.
 */

export function useGetInstantMixFromItem<
  TData = Awaited<ReturnType<typeof getInstantMixFromItem>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromItem>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetInstantMixFromItemQueryOptions(
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates an instant playlist based on a given genre.
 */
export const getInstantMixFromMusicGenreByName = (
  name: string,
  params?: GetInstantMixFromMusicGenreByNameParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/MusicGenres/${name}/InstantMix`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetInstantMixFromMusicGenreByNameQueryKey = (
  name: string,
  params?: GetInstantMixFromMusicGenreByNameParams
) => {
  return [
    `/MusicGenres/${name}/InstantMix`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetInstantMixFromMusicGenreByNameQueryOptions = <
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetInstantMixFromMusicGenreByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetInstantMixFromMusicGenreByNameQueryKey(name, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>
  > = ({ signal }) => getInstantMixFromMusicGenreByName(name, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInstantMixFromMusicGenreByNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>
>;
export type GetInstantMixFromMusicGenreByNameQueryError = ErrorType<void>;

export function useGetInstantMixFromMusicGenreByName<
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params: undefined | GetInstantMixFromMusicGenreByNameParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromMusicGenreByName<
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetInstantMixFromMusicGenreByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromMusicGenreByName<
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetInstantMixFromMusicGenreByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Creates an instant playlist based on a given genre.
 */

export function useGetInstantMixFromMusicGenreByName<
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetInstantMixFromMusicGenreByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetInstantMixFromMusicGenreByNameQueryOptions(
    name,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates an instant playlist based on a given genre.
 */
export const getInstantMixFromMusicGenreById = (
  params: GetInstantMixFromMusicGenreByIdParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/MusicGenres/InstantMix`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetInstantMixFromMusicGenreByIdQueryKey = (
  params: GetInstantMixFromMusicGenreByIdParams
) => {
  return [`/MusicGenres/InstantMix`, ...(params ? [params] : [])] as const;
};

export const getGetInstantMixFromMusicGenreByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromMusicGenreByIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetInstantMixFromMusicGenreByIdQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>
  > = ({ signal }) => getInstantMixFromMusicGenreById(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInstantMixFromMusicGenreByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>
>;
export type GetInstantMixFromMusicGenreByIdQueryError = ErrorType<void>;

export function useGetInstantMixFromMusicGenreById<
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromMusicGenreByIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromMusicGenreById<
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromMusicGenreByIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromMusicGenreById<
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromMusicGenreByIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Creates an instant playlist based on a given genre.
 */

export function useGetInstantMixFromMusicGenreById<
  TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
  TError = ErrorType<void>
>(
  params: GetInstantMixFromMusicGenreByIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetInstantMixFromMusicGenreByIdQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates an instant playlist based on a given playlist.
 */
export const getInstantMixFromPlaylist = (
  id: string,
  params?: GetInstantMixFromPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Playlists/${id}/InstantMix`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetInstantMixFromPlaylistQueryKey = (
  id: string,
  params?: GetInstantMixFromPlaylistParams
) => {
  return [`/Playlists/${id}/InstantMix`, ...(params ? [params] : [])] as const;
};

export const getGetInstantMixFromPlaylistQueryOptions = <
  TData = Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetInstantMixFromPlaylistQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstantMixFromPlaylist>>
  > = ({ signal }) => getInstantMixFromPlaylist(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInstantMixFromPlaylistQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstantMixFromPlaylist>>
>;
export type GetInstantMixFromPlaylistQueryError = ErrorType<void>;

export function useGetInstantMixFromPlaylist<
  TData = Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
  TError = ErrorType<void>
>(
  id: string,
  params: undefined | GetInstantMixFromPlaylistParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromPlaylist<
  TData = Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromPlaylist<
  TData = Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Creates an instant playlist based on a given playlist.
 */

export function useGetInstantMixFromPlaylist<
  TData = Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromPlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromPlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetInstantMixFromPlaylistQueryOptions(
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates an instant playlist based on a given song.
 */
export const getInstantMixFromSong = (
  id: string,
  params?: GetInstantMixFromSongParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Songs/${id}/InstantMix`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetInstantMixFromSongQueryKey = (
  id: string,
  params?: GetInstantMixFromSongParams
) => {
  return [`/Songs/${id}/InstantMix`, ...(params ? [params] : [])] as const;
};

export const getGetInstantMixFromSongQueryOptions = <
  TData = Awaited<ReturnType<typeof getInstantMixFromSong>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromSongParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromSong>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetInstantMixFromSongQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstantMixFromSong>>
  > = ({ signal }) => getInstantMixFromSong(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstantMixFromSong>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInstantMixFromSongQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstantMixFromSong>>
>;
export type GetInstantMixFromSongQueryError = ErrorType<void>;

export function useGetInstantMixFromSong<
  TData = Awaited<ReturnType<typeof getInstantMixFromSong>>,
  TError = ErrorType<void>
>(
  id: string,
  params: undefined | GetInstantMixFromSongParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromSong>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromSong>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromSong<
  TData = Awaited<ReturnType<typeof getInstantMixFromSong>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromSongParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromSong>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstantMixFromSong>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetInstantMixFromSong<
  TData = Awaited<ReturnType<typeof getInstantMixFromSong>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromSongParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromSong>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Creates an instant playlist based on a given song.
 */

export function useGetInstantMixFromSong<
  TData = Awaited<ReturnType<typeof getInstantMixFromSong>>,
  TError = ErrorType<void>
>(
  id: string,
  params?: GetInstantMixFromSongParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstantMixFromSong>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetInstantMixFromSongQueryOptions(
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get the item's external id info.
 */
export const getExternalIdInfos = (itemId: string, signal?: AbortSignal) => {
  return apiInstance<ExternalIdInfo[]>({
    url: `/Items/${itemId}/ExternalIdInfos`,
    method: "GET",
    signal,
  });
};

export const getGetExternalIdInfosQueryKey = (itemId: string) => {
  return [`/Items/${itemId}/ExternalIdInfos`] as const;
};

export const getGetExternalIdInfosQueryOptions = <
  TData = Awaited<ReturnType<typeof getExternalIdInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalIdInfos>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExternalIdInfosQueryKey(itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExternalIdInfos>>
  > = ({ signal }) => getExternalIdInfos(itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExternalIdInfos>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetExternalIdInfosQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExternalIdInfos>>
>;
export type GetExternalIdInfosQueryError = ErrorType<void | ProblemDetails>;

export function useGetExternalIdInfos<
  TData = Awaited<ReturnType<typeof getExternalIdInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalIdInfos>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalIdInfos>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetExternalIdInfos<
  TData = Awaited<ReturnType<typeof getExternalIdInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalIdInfos>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalIdInfos>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetExternalIdInfos<
  TData = Awaited<ReturnType<typeof getExternalIdInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalIdInfos>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get the item's external id info.
 */

export function useGetExternalIdInfos<
  TData = Awaited<ReturnType<typeof getExternalIdInfos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalIdInfos>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetExternalIdInfosQueryOptions(itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Applies search criteria to an item and refreshes metadata.
 */
export const applySearchCriteria = (
  itemId: string,
  remoteSearchResult: RemoteSearchResult,
  params?: ApplySearchCriteriaParams
) => {
  return apiInstance<void>({
    url: `/Items/RemoteSearch/Apply/${itemId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: remoteSearchResult,
    params,
  });
};

export const getApplySearchCriteriaMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof applySearchCriteria>>,
    TError,
    {
      itemId: string;
      data: RemoteSearchResult;
      params?: ApplySearchCriteriaParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof applySearchCriteria>>,
  TError,
  {
    itemId: string;
    data: RemoteSearchResult;
    params?: ApplySearchCriteriaParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof applySearchCriteria>>,
    {
      itemId: string;
      data: RemoteSearchResult;
      params?: ApplySearchCriteriaParams;
    }
  > = (props) => {
    const { itemId, data, params } = props ?? {};

    return applySearchCriteria(itemId, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApplySearchCriteriaMutationResult = NonNullable<
  Awaited<ReturnType<typeof applySearchCriteria>>
>;
export type ApplySearchCriteriaMutationBody = RemoteSearchResult;
export type ApplySearchCriteriaMutationError = ErrorType<void>;

/**
 * @summary Applies search criteria to an item and refreshes metadata.
 */
export const useApplySearchCriteria = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof applySearchCriteria>>,
    TError,
    {
      itemId: string;
      data: RemoteSearchResult;
      params?: ApplySearchCriteriaParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof applySearchCriteria>>,
  TError,
  {
    itemId: string;
    data: RemoteSearchResult;
    params?: ApplySearchCriteriaParams;
  },
  TContext
> => {
  const mutationOptions = getApplySearchCriteriaMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get book remote search.
 */
export const getBookRemoteSearchResults = (
  bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery
) => {
  return apiInstance<RemoteSearchResult[]>({
    url: `/Items/RemoteSearch/Book`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: bookInfoRemoteSearchQuery,
  });
};

export const getGetBookRemoteSearchResultsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getBookRemoteSearchResults>>,
    TError,
    { data: BookInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getBookRemoteSearchResults>>,
  TError,
  { data: BookInfoRemoteSearchQuery },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getBookRemoteSearchResults>>,
    { data: BookInfoRemoteSearchQuery }
  > = (props) => {
    const { data } = props ?? {};

    return getBookRemoteSearchResults(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetBookRemoteSearchResultsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getBookRemoteSearchResults>>
>;
export type GetBookRemoteSearchResultsMutationBody = BookInfoRemoteSearchQuery;
export type GetBookRemoteSearchResultsMutationError = ErrorType<void>;

/**
 * @summary Get book remote search.
 */
export const useGetBookRemoteSearchResults = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getBookRemoteSearchResults>>,
    TError,
    { data: BookInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getBookRemoteSearchResults>>,
  TError,
  { data: BookInfoRemoteSearchQuery },
  TContext
> => {
  const mutationOptions = getGetBookRemoteSearchResultsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get box set remote search.
 */
export const getBoxSetRemoteSearchResults = (
  boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery
) => {
  return apiInstance<RemoteSearchResult[]>({
    url: `/Items/RemoteSearch/BoxSet`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: boxSetInfoRemoteSearchQuery,
  });
};

export const getGetBoxSetRemoteSearchResultsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>,
    TError,
    { data: BoxSetInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>,
  TError,
  { data: BoxSetInfoRemoteSearchQuery },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>,
    { data: BoxSetInfoRemoteSearchQuery }
  > = (props) => {
    const { data } = props ?? {};

    return getBoxSetRemoteSearchResults(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetBoxSetRemoteSearchResultsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>
>;
export type GetBoxSetRemoteSearchResultsMutationBody =
  BoxSetInfoRemoteSearchQuery;
export type GetBoxSetRemoteSearchResultsMutationError = ErrorType<void>;

/**
 * @summary Get box set remote search.
 */
export const useGetBoxSetRemoteSearchResults = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>,
    TError,
    { data: BoxSetInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>,
  TError,
  { data: BoxSetInfoRemoteSearchQuery },
  TContext
> => {
  const mutationOptions =
    getGetBoxSetRemoteSearchResultsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get movie remote search.
 */
export const getMovieRemoteSearchResults = (
  movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery
) => {
  return apiInstance<RemoteSearchResult[]>({
    url: `/Items/RemoteSearch/Movie`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: movieInfoRemoteSearchQuery,
  });
};

export const getGetMovieRemoteSearchResultsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getMovieRemoteSearchResults>>,
    TError,
    { data: MovieInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getMovieRemoteSearchResults>>,
  TError,
  { data: MovieInfoRemoteSearchQuery },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getMovieRemoteSearchResults>>,
    { data: MovieInfoRemoteSearchQuery }
  > = (props) => {
    const { data } = props ?? {};

    return getMovieRemoteSearchResults(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetMovieRemoteSearchResultsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getMovieRemoteSearchResults>>
>;
export type GetMovieRemoteSearchResultsMutationBody =
  MovieInfoRemoteSearchQuery;
export type GetMovieRemoteSearchResultsMutationError = ErrorType<void>;

/**
 * @summary Get movie remote search.
 */
export const useGetMovieRemoteSearchResults = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getMovieRemoteSearchResults>>,
    TError,
    { data: MovieInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getMovieRemoteSearchResults>>,
  TError,
  { data: MovieInfoRemoteSearchQuery },
  TContext
> => {
  const mutationOptions =
    getGetMovieRemoteSearchResultsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get music album remote search.
 */
export const getMusicAlbumRemoteSearchResults = (
  albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery
) => {
  return apiInstance<RemoteSearchResult[]>({
    url: `/Items/RemoteSearch/MusicAlbum`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: albumInfoRemoteSearchQuery,
  });
};

export const getGetMusicAlbumRemoteSearchResultsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>,
    TError,
    { data: AlbumInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>,
  TError,
  { data: AlbumInfoRemoteSearchQuery },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>,
    { data: AlbumInfoRemoteSearchQuery }
  > = (props) => {
    const { data } = props ?? {};

    return getMusicAlbumRemoteSearchResults(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetMusicAlbumRemoteSearchResultsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>
>;
export type GetMusicAlbumRemoteSearchResultsMutationBody =
  AlbumInfoRemoteSearchQuery;
export type GetMusicAlbumRemoteSearchResultsMutationError = ErrorType<void>;

/**
 * @summary Get music album remote search.
 */
export const useGetMusicAlbumRemoteSearchResults = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>,
    TError,
    { data: AlbumInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>,
  TError,
  { data: AlbumInfoRemoteSearchQuery },
  TContext
> => {
  const mutationOptions =
    getGetMusicAlbumRemoteSearchResultsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get music artist remote search.
 */
export const getMusicArtistRemoteSearchResults = (
  artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery
) => {
  return apiInstance<RemoteSearchResult[]>({
    url: `/Items/RemoteSearch/MusicArtist`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: artistInfoRemoteSearchQuery,
  });
};

export const getGetMusicArtistRemoteSearchResultsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>,
    TError,
    { data: ArtistInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>,
  TError,
  { data: ArtistInfoRemoteSearchQuery },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>,
    { data: ArtistInfoRemoteSearchQuery }
  > = (props) => {
    const { data } = props ?? {};

    return getMusicArtistRemoteSearchResults(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetMusicArtistRemoteSearchResultsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>
>;
export type GetMusicArtistRemoteSearchResultsMutationBody =
  ArtistInfoRemoteSearchQuery;
export type GetMusicArtistRemoteSearchResultsMutationError = ErrorType<void>;

/**
 * @summary Get music artist remote search.
 */
export const useGetMusicArtistRemoteSearchResults = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>,
    TError,
    { data: ArtistInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>,
  TError,
  { data: ArtistInfoRemoteSearchQuery },
  TContext
> => {
  const mutationOptions =
    getGetMusicArtistRemoteSearchResultsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get music video remote search.
 */
export const getMusicVideoRemoteSearchResults = (
  musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery
) => {
  return apiInstance<RemoteSearchResult[]>({
    url: `/Items/RemoteSearch/MusicVideo`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: musicVideoInfoRemoteSearchQuery,
  });
};

export const getGetMusicVideoRemoteSearchResultsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>,
    TError,
    { data: MusicVideoInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>,
  TError,
  { data: MusicVideoInfoRemoteSearchQuery },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>,
    { data: MusicVideoInfoRemoteSearchQuery }
  > = (props) => {
    const { data } = props ?? {};

    return getMusicVideoRemoteSearchResults(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetMusicVideoRemoteSearchResultsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>
>;
export type GetMusicVideoRemoteSearchResultsMutationBody =
  MusicVideoInfoRemoteSearchQuery;
export type GetMusicVideoRemoteSearchResultsMutationError = ErrorType<void>;

/**
 * @summary Get music video remote search.
 */
export const useGetMusicVideoRemoteSearchResults = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>,
    TError,
    { data: MusicVideoInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>,
  TError,
  { data: MusicVideoInfoRemoteSearchQuery },
  TContext
> => {
  const mutationOptions =
    getGetMusicVideoRemoteSearchResultsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get person remote search.
 */
export const getPersonRemoteSearchResults = (
  personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery
) => {
  return apiInstance<RemoteSearchResult[]>({
    url: `/Items/RemoteSearch/Person`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: personLookupInfoRemoteSearchQuery,
  });
};

export const getGetPersonRemoteSearchResultsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPersonRemoteSearchResults>>,
    TError,
    { data: PersonLookupInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getPersonRemoteSearchResults>>,
  TError,
  { data: PersonLookupInfoRemoteSearchQuery },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getPersonRemoteSearchResults>>,
    { data: PersonLookupInfoRemoteSearchQuery }
  > = (props) => {
    const { data } = props ?? {};

    return getPersonRemoteSearchResults(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetPersonRemoteSearchResultsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getPersonRemoteSearchResults>>
>;
export type GetPersonRemoteSearchResultsMutationBody =
  PersonLookupInfoRemoteSearchQuery;
export type GetPersonRemoteSearchResultsMutationError = ErrorType<void>;

/**
 * @summary Get person remote search.
 */
export const useGetPersonRemoteSearchResults = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPersonRemoteSearchResults>>,
    TError,
    { data: PersonLookupInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getPersonRemoteSearchResults>>,
  TError,
  { data: PersonLookupInfoRemoteSearchQuery },
  TContext
> => {
  const mutationOptions =
    getGetPersonRemoteSearchResultsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get series remote search.
 */
export const getSeriesRemoteSearchResults = (
  seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery
) => {
  return apiInstance<RemoteSearchResult[]>({
    url: `/Items/RemoteSearch/Series`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: seriesInfoRemoteSearchQuery,
  });
};

export const getGetSeriesRemoteSearchResultsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>,
    TError,
    { data: SeriesInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>,
  TError,
  { data: SeriesInfoRemoteSearchQuery },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>,
    { data: SeriesInfoRemoteSearchQuery }
  > = (props) => {
    const { data } = props ?? {};

    return getSeriesRemoteSearchResults(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetSeriesRemoteSearchResultsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>
>;
export type GetSeriesRemoteSearchResultsMutationBody =
  SeriesInfoRemoteSearchQuery;
export type GetSeriesRemoteSearchResultsMutationError = ErrorType<void>;

/**
 * @summary Get series remote search.
 */
export const useGetSeriesRemoteSearchResults = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>,
    TError,
    { data: SeriesInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>,
  TError,
  { data: SeriesInfoRemoteSearchQuery },
  TContext
> => {
  const mutationOptions =
    getGetSeriesRemoteSearchResultsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get trailer remote search.
 */
export const getTrailerRemoteSearchResults = (
  trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery
) => {
  return apiInstance<RemoteSearchResult[]>({
    url: `/Items/RemoteSearch/Trailer`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: trailerInfoRemoteSearchQuery,
  });
};

export const getGetTrailerRemoteSearchResultsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>,
    TError,
    { data: TrailerInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>,
  TError,
  { data: TrailerInfoRemoteSearchQuery },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>,
    { data: TrailerInfoRemoteSearchQuery }
  > = (props) => {
    const { data } = props ?? {};

    return getTrailerRemoteSearchResults(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetTrailerRemoteSearchResultsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>
>;
export type GetTrailerRemoteSearchResultsMutationBody =
  TrailerInfoRemoteSearchQuery;
export type GetTrailerRemoteSearchResultsMutationError = ErrorType<void>;

/**
 * @summary Get trailer remote search.
 */
export const useGetTrailerRemoteSearchResults = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>,
    TError,
    { data: TrailerInfoRemoteSearchQuery },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>,
  TError,
  { data: TrailerInfoRemoteSearchQuery },
  TContext
> => {
  const mutationOptions =
    getGetTrailerRemoteSearchResultsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Refreshes metadata for an item.
 */
export const refreshItem = (itemId: string, params?: RefreshItemParams) => {
  return apiInstance<void>({
    url: `/Items/${itemId}/Refresh`,
    method: "POST",
    params,
  });
};

export const getRefreshItemMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshItem>>,
    TError,
    { itemId: string; params?: RefreshItemParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshItem>>,
  TError,
  { itemId: string; params?: RefreshItemParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshItem>>,
    { itemId: string; params?: RefreshItemParams }
  > = (props) => {
    const { itemId, params } = props ?? {};

    return refreshItem(itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshItem>>
>;

export type RefreshItemMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Refreshes metadata for an item.
 */
export const useRefreshItem = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshItem>>,
    TError,
    { itemId: string; params?: RefreshItemParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof refreshItem>>,
  TError,
  { itemId: string; params?: RefreshItemParams },
  TContext
> => {
  const mutationOptions = getRefreshItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets items based on a query.
 */
export const getItems = (params?: GetItemsParams, signal?: AbortSignal) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Items`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetItemsQueryKey = (params?: GetItemsParams) => {
  return [`/Items`, ...(params ? [params] : [])] as const;
};

export const getGetItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getItems>>,
  TError = ErrorType<void>
>(
  params?: GetItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItems>>> = ({
    signal,
  }) => getItems(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItems>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItems>>
>;
export type GetItemsQueryError = ErrorType<void>;

export function useGetItems<
  TData = Awaited<ReturnType<typeof getItems>>,
  TError = ErrorType<void>
>(
  params: undefined | GetItemsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItems<
  TData = Awaited<ReturnType<typeof getItems>>,
  TError = ErrorType<void>
>(
  params?: GetItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItems<
  TData = Awaited<ReturnType<typeof getItems>>,
  TError = ErrorType<void>
>(
  params?: GetItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets items based on a query.
 */

export function useGetItems<
  TData = Awaited<ReturnType<typeof getItems>>,
  TError = ErrorType<void>
>(
  params?: GetItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetItemsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Deletes items from the library and filesystem.
 */
export const deleteItems = (params?: DeleteItemsParams) => {
  return apiInstance<void>({ url: `/Items`, method: "DELETE", params });
};

export const getDeleteItemsMutationOptions = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteItems>>,
    TError,
    { params?: DeleteItemsParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteItems>>,
  TError,
  { params?: DeleteItemsParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteItems>>,
    { params?: DeleteItemsParams }
  > = (props) => {
    const { params } = props ?? {};

    return deleteItems(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteItemsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteItems>>
>;

export type DeleteItemsMutationError = ErrorType<ProblemDetails | void>;

/**
 * @summary Deletes items from the library and filesystem.
 */
export const useDeleteItems = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteItems>>,
    TError,
    { params?: DeleteItemsParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteItems>>,
  TError,
  { params?: DeleteItemsParams },
  TContext
> => {
  const mutationOptions = getDeleteItemsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets items based on a query.
 */
export const getItemsByUserId = (
  userId: string,
  params?: GetItemsByUserIdParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Users/${userId}/Items`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetItemsByUserIdQueryKey = (
  userId: string,
  params?: GetItemsByUserIdParams
) => {
  return [`/Users/${userId}/Items`, ...(params ? [params] : [])] as const;
};

export const getGetItemsByUserIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemsByUserId>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetItemsByUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemsByUserId>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetItemsByUserIdQueryKey(userId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getItemsByUserId>>
  > = ({ signal }) => getItemsByUserId(userId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemsByUserId>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetItemsByUserIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemsByUserId>>
>;
export type GetItemsByUserIdQueryError = ErrorType<void>;

export function useGetItemsByUserId<
  TData = Awaited<ReturnType<typeof getItemsByUserId>>,
  TError = ErrorType<void>
>(
  userId: string,
  params: undefined | GetItemsByUserIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemsByUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByUserId>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemsByUserId<
  TData = Awaited<ReturnType<typeof getItemsByUserId>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetItemsByUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemsByUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemsByUserId>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemsByUserId<
  TData = Awaited<ReturnType<typeof getItemsByUserId>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetItemsByUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemsByUserId>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets items based on a query.
 */

export function useGetItemsByUserId<
  TData = Awaited<ReturnType<typeof getItemsByUserId>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetItemsByUserIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getItemsByUserId>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetItemsByUserIdQueryOptions(userId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets items based on a query.
 */
export const getResumeItems = (
  userId: string,
  params?: GetResumeItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Users/${userId}/Items/Resume`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetResumeItemsQueryKey = (
  userId: string,
  params?: GetResumeItemsParams
) => {
  return [
    `/Users/${userId}/Items/Resume`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetResumeItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getResumeItems>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetResumeItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getResumeItems>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetResumeItemsQueryKey(userId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getResumeItems>>> = ({
    signal,
  }) => getResumeItems(userId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getResumeItems>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetResumeItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getResumeItems>>
>;
export type GetResumeItemsQueryError = ErrorType<void>;

export function useGetResumeItems<
  TData = Awaited<ReturnType<typeof getResumeItems>>,
  TError = ErrorType<void>
>(
  userId: string,
  params: undefined | GetResumeItemsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getResumeItems>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResumeItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetResumeItems<
  TData = Awaited<ReturnType<typeof getResumeItems>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetResumeItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getResumeItems>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResumeItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetResumeItems<
  TData = Awaited<ReturnType<typeof getResumeItems>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetResumeItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getResumeItems>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets items based on a query.
 */

export function useGetResumeItems<
  TData = Awaited<ReturnType<typeof getResumeItems>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetResumeItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getResumeItems>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetResumeItemsQueryOptions(userId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates an item.
 */
export const updateItem = (itemId: string, baseItemDto: BaseItemDto) => {
  return apiInstance<void>({
    url: `/Items/${itemId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: baseItemDto,
  });
};

export const getUpdateItemMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateItem>>,
    TError,
    { itemId: string; data: BaseItemDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateItem>>,
  TError,
  { itemId: string; data: BaseItemDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateItem>>,
    { itemId: string; data: BaseItemDto }
  > = (props) => {
    const { itemId, data } = props ?? {};

    return updateItem(itemId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateItem>>
>;
export type UpdateItemMutationBody = BaseItemDto;
export type UpdateItemMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Updates an item.
 */
export const useUpdateItem = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateItem>>,
    TError,
    { itemId: string; data: BaseItemDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateItem>>,
  TError,
  { itemId: string; data: BaseItemDto },
  TContext
> => {
  const mutationOptions = getUpdateItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Deletes an item from the library and filesystem.
 */
export const deleteItem = (itemId: string) => {
  return apiInstance<void>({ url: `/Items/${itemId}`, method: "DELETE" });
};

export const getDeleteItemMutationOptions = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteItem>>,
    TError,
    { itemId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteItem>>,
  TError,
  { itemId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteItem>>,
    { itemId: string }
  > = (props) => {
    const { itemId } = props ?? {};

    return deleteItem(itemId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteItem>>
>;

export type DeleteItemMutationError = ErrorType<ProblemDetails | void>;

/**
 * @summary Deletes an item from the library and filesystem.
 */
export const useDeleteItem = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteItem>>,
    TError,
    { itemId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteItem>>,
  TError,
  { itemId: string },
  TContext
> => {
  const mutationOptions = getDeleteItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates an item's content type.
 */
export const updateItemContentType = (
  itemId: string,
  params?: UpdateItemContentTypeParams
) => {
  return apiInstance<void>({
    url: `/Items/${itemId}/ContentType`,
    method: "POST",
    params,
  });
};

export const getUpdateItemContentTypeMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateItemContentType>>,
    TError,
    { itemId: string; params?: UpdateItemContentTypeParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateItemContentType>>,
  TError,
  { itemId: string; params?: UpdateItemContentTypeParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateItemContentType>>,
    { itemId: string; params?: UpdateItemContentTypeParams }
  > = (props) => {
    const { itemId, params } = props ?? {};

    return updateItemContentType(itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateItemContentTypeMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateItemContentType>>
>;

export type UpdateItemContentTypeMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Updates an item's content type.
 */
export const useUpdateItemContentType = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateItemContentType>>,
    TError,
    { itemId: string; params?: UpdateItemContentTypeParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateItemContentType>>,
  TError,
  { itemId: string; params?: UpdateItemContentTypeParams },
  TContext
> => {
  const mutationOptions = getUpdateItemContentTypeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets metadata editor info for an item.
 */
export const getMetadataEditorInfo = (itemId: string, signal?: AbortSignal) => {
  return apiInstance<MetadataEditorInfo>({
    url: `/Items/${itemId}/MetadataEditor`,
    method: "GET",
    signal,
  });
};

export const getGetMetadataEditorInfoQueryKey = (itemId: string) => {
  return [`/Items/${itemId}/MetadataEditor`] as const;
};

export const getGetMetadataEditorInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getMetadataEditorInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMetadataEditorInfo>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMetadataEditorInfoQueryKey(itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMetadataEditorInfo>>
  > = ({ signal }) => getMetadataEditorInfo(itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMetadataEditorInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMetadataEditorInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMetadataEditorInfo>>
>;
export type GetMetadataEditorInfoQueryError = ErrorType<void | ProblemDetails>;

export function useGetMetadataEditorInfo<
  TData = Awaited<ReturnType<typeof getMetadataEditorInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMetadataEditorInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadataEditorInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMetadataEditorInfo<
  TData = Awaited<ReturnType<typeof getMetadataEditorInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMetadataEditorInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadataEditorInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMetadataEditorInfo<
  TData = Awaited<ReturnType<typeof getMetadataEditorInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMetadataEditorInfo>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets metadata editor info for an item.
 */

export function useGetMetadataEditorInfo<
  TData = Awaited<ReturnType<typeof getMetadataEditorInfo>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMetadataEditorInfo>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMetadataEditorInfoQueryOptions(itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets similar items.
 */
export const getSimilarAlbums = (
  itemId: string,
  params?: GetSimilarAlbumsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Albums/${itemId}/Similar`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSimilarAlbumsQueryKey = (
  itemId: string,
  params?: GetSimilarAlbumsParams
) => {
  return [`/Albums/${itemId}/Similar`, ...(params ? [params] : [])] as const;
};

export const getGetSimilarAlbumsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSimilarAlbums>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarAlbumsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarAlbums>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSimilarAlbumsQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSimilarAlbums>>
  > = ({ signal }) => getSimilarAlbums(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSimilarAlbums>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSimilarAlbumsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSimilarAlbums>>
>;
export type GetSimilarAlbumsQueryError = ErrorType<void>;

export function useGetSimilarAlbums<
  TData = Awaited<ReturnType<typeof getSimilarAlbums>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetSimilarAlbumsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarAlbums>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarAlbums>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarAlbums<
  TData = Awaited<ReturnType<typeof getSimilarAlbums>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarAlbumsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarAlbums>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarAlbums>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarAlbums<
  TData = Awaited<ReturnType<typeof getSimilarAlbums>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarAlbumsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarAlbums>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets similar items.
 */

export function useGetSimilarAlbums<
  TData = Awaited<ReturnType<typeof getSimilarAlbums>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarAlbumsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarAlbums>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSimilarAlbumsQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets similar items.
 */
export const getSimilarArtists = (
  itemId: string,
  params?: GetSimilarArtistsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Artists/${itemId}/Similar`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSimilarArtistsQueryKey = (
  itemId: string,
  params?: GetSimilarArtistsParams
) => {
  return [`/Artists/${itemId}/Similar`, ...(params ? [params] : [])] as const;
};

export const getGetSimilarArtistsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSimilarArtists>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarArtists>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSimilarArtistsQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSimilarArtists>>
  > = ({ signal }) => getSimilarArtists(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSimilarArtists>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSimilarArtistsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSimilarArtists>>
>;
export type GetSimilarArtistsQueryError = ErrorType<void>;

export function useGetSimilarArtists<
  TData = Awaited<ReturnType<typeof getSimilarArtists>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetSimilarArtistsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarArtists>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarArtists>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarArtists<
  TData = Awaited<ReturnType<typeof getSimilarArtists>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarArtists>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarArtists>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarArtists<
  TData = Awaited<ReturnType<typeof getSimilarArtists>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarArtists>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets similar items.
 */

export function useGetSimilarArtists<
  TData = Awaited<ReturnType<typeof getSimilarArtists>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarArtists>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSimilarArtistsQueryOptions(
    itemId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets all parents of an item.
 */
export const getAncestors = (
  itemId: string,
  params?: GetAncestorsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto[]>({
    url: `/Items/${itemId}/Ancestors`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetAncestorsQueryKey = (
  itemId: string,
  params?: GetAncestorsParams
) => {
  return [`/Items/${itemId}/Ancestors`, ...(params ? [params] : [])] as const;
};

export const getGetAncestorsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAncestors>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetAncestorsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAncestors>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAncestorsQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAncestors>>> = ({
    signal,
  }) => getAncestors(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAncestors>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAncestorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAncestors>>
>;
export type GetAncestorsQueryError = ErrorType<void | ProblemDetails>;

export function useGetAncestors<
  TData = Awaited<ReturnType<typeof getAncestors>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params: undefined | GetAncestorsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAncestors>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAncestors>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAncestors<
  TData = Awaited<ReturnType<typeof getAncestors>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetAncestorsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAncestors>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAncestors>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAncestors<
  TData = Awaited<ReturnType<typeof getAncestors>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetAncestorsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAncestors>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all parents of an item.
 */

export function useGetAncestors<
  TData = Awaited<ReturnType<typeof getAncestors>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetAncestorsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAncestors>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAncestorsQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @deprecated
 * @summary Gets critic review for an item.
 */
export const getCriticReviews = (itemId: string, signal?: AbortSignal) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Items/${itemId}/CriticReviews`,
    method: "GET",
    signal,
  });
};

export const getGetCriticReviewsQueryKey = (itemId: string) => {
  return [`/Items/${itemId}/CriticReviews`] as const;
};

export const getGetCriticReviewsQueryOptions = <
  TData = Awaited<ReturnType<typeof getCriticReviews>>,
  TError = ErrorType<void>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCriticReviews>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCriticReviewsQueryKey(itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCriticReviews>>
  > = ({ signal }) => getCriticReviews(itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCriticReviews>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCriticReviewsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCriticReviews>>
>;
export type GetCriticReviewsQueryError = ErrorType<void>;

export function useGetCriticReviews<
  TData = Awaited<ReturnType<typeof getCriticReviews>>,
  TError = ErrorType<void>
>(
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCriticReviews>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCriticReviews>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetCriticReviews<
  TData = Awaited<ReturnType<typeof getCriticReviews>>,
  TError = ErrorType<void>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCriticReviews>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCriticReviews>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetCriticReviews<
  TData = Awaited<ReturnType<typeof getCriticReviews>>,
  TError = ErrorType<void>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCriticReviews>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @deprecated
 * @summary Gets critic review for an item.
 */

export function useGetCriticReviews<
  TData = Awaited<ReturnType<typeof getCriticReviews>>,
  TError = ErrorType<void>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCriticReviews>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetCriticReviewsQueryOptions(itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Downloads item media.
 */
export const getDownload = (itemId: string, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/Items/${itemId}/Download`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetDownloadQueryKey = (itemId: string) => {
  return [`/Items/${itemId}/Download`] as const;
};

export const getGetDownloadQueryOptions = <
  TData = Awaited<ReturnType<typeof getDownload>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDownload>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDownloadQueryKey(itemId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDownload>>> = ({
    signal,
  }) => getDownload(itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDownload>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDownloadQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDownload>>
>;
export type GetDownloadQueryError = ErrorType<void | ProblemDetails>;

export function useGetDownload<
  TData = Awaited<ReturnType<typeof getDownload>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDownload>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDownload>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDownload<
  TData = Awaited<ReturnType<typeof getDownload>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDownload>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDownload>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDownload<
  TData = Awaited<ReturnType<typeof getDownload>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDownload>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Downloads item media.
 */

export function useGetDownload<
  TData = Awaited<ReturnType<typeof getDownload>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDownload>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDownloadQueryOptions(itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get the original file of an item.
 */
export const getFile = (itemId: string, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/Items/${itemId}/File`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetFileQueryKey = (itemId: string) => {
  return [`/Items/${itemId}/File`] as const;
};

export const getGetFileQueryOptions = <
  TData = Awaited<ReturnType<typeof getFile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFileQueryKey(itemId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFile>>> = ({
    signal,
  }) => getFile(itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFile>>
>;
export type GetFileQueryError = ErrorType<void | ProblemDetails>;

export function useGetFile<
  TData = Awaited<ReturnType<typeof getFile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFile<
  TData = Awaited<ReturnType<typeof getFile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFile<
  TData = Awaited<ReturnType<typeof getFile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get the original file of an item.
 */

export function useGetFile<
  TData = Awaited<ReturnType<typeof getFile>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetFileQueryOptions(itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets similar items.
 */
export const getSimilarItems = (
  itemId: string,
  params?: GetSimilarItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Items/${itemId}/Similar`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSimilarItemsQueryKey = (
  itemId: string,
  params?: GetSimilarItemsParams
) => {
  return [`/Items/${itemId}/Similar`, ...(params ? [params] : [])] as const;
};

export const getGetSimilarItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSimilarItems>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarItems>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSimilarItemsQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSimilarItems>>> = ({
    signal,
  }) => getSimilarItems(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSimilarItems>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSimilarItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSimilarItems>>
>;
export type GetSimilarItemsQueryError = ErrorType<void>;

export function useGetSimilarItems<
  TData = Awaited<ReturnType<typeof getSimilarItems>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetSimilarItemsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarItems>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarItems<
  TData = Awaited<ReturnType<typeof getSimilarItems>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarItems>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarItems<
  TData = Awaited<ReturnType<typeof getSimilarItems>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarItems>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets similar items.
 */

export function useGetSimilarItems<
  TData = Awaited<ReturnType<typeof getSimilarItems>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarItems>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSimilarItemsQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get theme songs and videos for an item.
 */
export const getThemeMedia = (
  itemId: string,
  params?: GetThemeMediaParams,
  signal?: AbortSignal
) => {
  return apiInstance<AllThemeMediaResult>({
    url: `/Items/${itemId}/ThemeMedia`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetThemeMediaQueryKey = (
  itemId: string,
  params?: GetThemeMediaParams
) => {
  return [`/Items/${itemId}/ThemeMedia`, ...(params ? [params] : [])] as const;
};

export const getGetThemeMediaQueryOptions = <
  TData = Awaited<ReturnType<typeof getThemeMedia>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetThemeMediaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeMedia>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetThemeMediaQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getThemeMedia>>> = ({
    signal,
  }) => getThemeMedia(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getThemeMedia>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetThemeMediaQueryResult = NonNullable<
  Awaited<ReturnType<typeof getThemeMedia>>
>;
export type GetThemeMediaQueryError = ErrorType<void>;

export function useGetThemeMedia<
  TData = Awaited<ReturnType<typeof getThemeMedia>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetThemeMediaParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeMedia>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThemeMedia>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetThemeMedia<
  TData = Awaited<ReturnType<typeof getThemeMedia>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetThemeMediaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeMedia>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThemeMedia>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetThemeMedia<
  TData = Awaited<ReturnType<typeof getThemeMedia>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetThemeMediaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeMedia>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get theme songs and videos for an item.
 */

export function useGetThemeMedia<
  TData = Awaited<ReturnType<typeof getThemeMedia>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetThemeMediaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeMedia>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetThemeMediaQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get theme songs for an item.
 */
export const getThemeSongs = (
  itemId: string,
  params?: GetThemeSongsParams,
  signal?: AbortSignal
) => {
  return apiInstance<ThemeMediaResult>({
    url: `/Items/${itemId}/ThemeSongs`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetThemeSongsQueryKey = (
  itemId: string,
  params?: GetThemeSongsParams
) => {
  return [`/Items/${itemId}/ThemeSongs`, ...(params ? [params] : [])] as const;
};

export const getGetThemeSongsQueryOptions = <
  TData = Awaited<ReturnType<typeof getThemeSongs>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetThemeSongsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeSongs>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetThemeSongsQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getThemeSongs>>> = ({
    signal,
  }) => getThemeSongs(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getThemeSongs>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetThemeSongsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getThemeSongs>>
>;
export type GetThemeSongsQueryError = ErrorType<void | ProblemDetails>;

export function useGetThemeSongs<
  TData = Awaited<ReturnType<typeof getThemeSongs>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params: undefined | GetThemeSongsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeSongs>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThemeSongs>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetThemeSongs<
  TData = Awaited<ReturnType<typeof getThemeSongs>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetThemeSongsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeSongs>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThemeSongs>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetThemeSongs<
  TData = Awaited<ReturnType<typeof getThemeSongs>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetThemeSongsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeSongs>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get theme songs for an item.
 */

export function useGetThemeSongs<
  TData = Awaited<ReturnType<typeof getThemeSongs>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetThemeSongsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeSongs>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetThemeSongsQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get theme videos for an item.
 */
export const getThemeVideos = (
  itemId: string,
  params?: GetThemeVideosParams,
  signal?: AbortSignal
) => {
  return apiInstance<ThemeMediaResult>({
    url: `/Items/${itemId}/ThemeVideos`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetThemeVideosQueryKey = (
  itemId: string,
  params?: GetThemeVideosParams
) => {
  return [`/Items/${itemId}/ThemeVideos`, ...(params ? [params] : [])] as const;
};

export const getGetThemeVideosQueryOptions = <
  TData = Awaited<ReturnType<typeof getThemeVideos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetThemeVideosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeVideos>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetThemeVideosQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getThemeVideos>>> = ({
    signal,
  }) => getThemeVideos(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getThemeVideos>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetThemeVideosQueryResult = NonNullable<
  Awaited<ReturnType<typeof getThemeVideos>>
>;
export type GetThemeVideosQueryError = ErrorType<void | ProblemDetails>;

export function useGetThemeVideos<
  TData = Awaited<ReturnType<typeof getThemeVideos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params: undefined | GetThemeVideosParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeVideos>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThemeVideos>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetThemeVideos<
  TData = Awaited<ReturnType<typeof getThemeVideos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetThemeVideosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeVideos>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThemeVideos>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetThemeVideos<
  TData = Awaited<ReturnType<typeof getThemeVideos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetThemeVideosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeVideos>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get theme videos for an item.
 */

export function useGetThemeVideos<
  TData = Awaited<ReturnType<typeof getThemeVideos>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetThemeVideosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getThemeVideos>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetThemeVideosQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get item counts.
 */
export const getItemCounts = (
  params?: GetItemCountsParams,
  signal?: AbortSignal
) => {
  return apiInstance<ItemCounts>({
    url: `/Items/Counts`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetItemCountsQueryKey = (params?: GetItemCountsParams) => {
  return [`/Items/Counts`, ...(params ? [params] : [])] as const;
};

export const getGetItemCountsQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemCounts>>,
  TError = ErrorType<void>
>(
  params?: GetItemCountsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemCounts>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemCountsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemCounts>>> = ({
    signal,
  }) => getItemCounts(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemCounts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetItemCountsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemCounts>>
>;
export type GetItemCountsQueryError = ErrorType<void>;

export function useGetItemCounts<
  TData = Awaited<ReturnType<typeof getItemCounts>>,
  TError = ErrorType<void>
>(
  params: undefined | GetItemCountsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemCounts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemCounts>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemCounts<
  TData = Awaited<ReturnType<typeof getItemCounts>>,
  TError = ErrorType<void>
>(
  params?: GetItemCountsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemCounts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemCounts>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItemCounts<
  TData = Awaited<ReturnType<typeof getItemCounts>>,
  TError = ErrorType<void>
>(
  params?: GetItemCountsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemCounts>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get item counts.
 */

export function useGetItemCounts<
  TData = Awaited<ReturnType<typeof getItemCounts>>,
  TError = ErrorType<void>
>(
  params?: GetItemCountsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItemCounts>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetItemCountsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the library options info.
 */
export const getLibraryOptionsInfo = (
  params?: GetLibraryOptionsInfoParams,
  signal?: AbortSignal
) => {
  return apiInstance<LibraryOptionsResultDto>({
    url: `/Libraries/AvailableOptions`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLibraryOptionsInfoQueryKey = (
  params?: GetLibraryOptionsInfoParams
) => {
  return [`/Libraries/AvailableOptions`, ...(params ? [params] : [])] as const;
};

export const getGetLibraryOptionsInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
  TError = ErrorType<void>
>(
  params?: GetLibraryOptionsInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLibraryOptionsInfoQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLibraryOptionsInfo>>
  > = ({ signal }) => getLibraryOptionsInfo(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLibraryOptionsInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibraryOptionsInfo>>
>;
export type GetLibraryOptionsInfoQueryError = ErrorType<void>;

export function useGetLibraryOptionsInfo<
  TData = Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
  TError = ErrorType<void>
>(
  params: undefined | GetLibraryOptionsInfoParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLibraryOptionsInfo<
  TData = Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
  TError = ErrorType<void>
>(
  params?: GetLibraryOptionsInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLibraryOptionsInfo<
  TData = Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
  TError = ErrorType<void>
>(
  params?: GetLibraryOptionsInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the library options info.
 */

export function useGetLibraryOptionsInfo<
  TData = Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
  TError = ErrorType<void>
>(
  params?: GetLibraryOptionsInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLibraryOptionsInfo>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLibraryOptionsInfoQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Reports that new movies have been added by an external source.
 */
export const postUpdatedMedia = (mediaUpdateInfoDto: MediaUpdateInfoDto) => {
  return apiInstance<void>({
    url: `/Library/Media/Updated`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: mediaUpdateInfoDto,
  });
};

export const getPostUpdatedMediaMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUpdatedMedia>>,
    TError,
    { data: MediaUpdateInfoDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUpdatedMedia>>,
  TError,
  { data: MediaUpdateInfoDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUpdatedMedia>>,
    { data: MediaUpdateInfoDto }
  > = (props) => {
    const { data } = props ?? {};

    return postUpdatedMedia(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUpdatedMediaMutationResult = NonNullable<
  Awaited<ReturnType<typeof postUpdatedMedia>>
>;
export type PostUpdatedMediaMutationBody = MediaUpdateInfoDto;
export type PostUpdatedMediaMutationError = ErrorType<void>;

/**
 * @summary Reports that new movies have been added by an external source.
 */
export const usePostUpdatedMedia = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUpdatedMedia>>,
    TError,
    { data: MediaUpdateInfoDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postUpdatedMedia>>,
  TError,
  { data: MediaUpdateInfoDto },
  TContext
> => {
  const mutationOptions = getPostUpdatedMediaMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets all user media folders.
 */
export const getMediaFolders = (
  params?: GetMediaFoldersParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Library/MediaFolders`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetMediaFoldersQueryKey = (params?: GetMediaFoldersParams) => {
  return [`/Library/MediaFolders`, ...(params ? [params] : [])] as const;
};

export const getGetMediaFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getMediaFolders>>,
  TError = ErrorType<void>
>(
  params?: GetMediaFoldersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaFolders>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMediaFolders>>> = ({
    signal,
  }) => getMediaFolders(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMediaFolders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMediaFoldersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMediaFolders>>
>;
export type GetMediaFoldersQueryError = ErrorType<void>;

export function useGetMediaFolders<
  TData = Awaited<ReturnType<typeof getMediaFolders>>,
  TError = ErrorType<void>
>(
  params: undefined | GetMediaFoldersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaFolders>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaFolders>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaFolders<
  TData = Awaited<ReturnType<typeof getMediaFolders>>,
  TError = ErrorType<void>
>(
  params?: GetMediaFoldersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaFolders>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMediaFolders>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMediaFolders<
  TData = Awaited<ReturnType<typeof getMediaFolders>>,
  TError = ErrorType<void>
>(
  params?: GetMediaFoldersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaFolders>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all user media folders.
 */

export function useGetMediaFolders<
  TData = Awaited<ReturnType<typeof getMediaFolders>>,
  TError = ErrorType<void>
>(
  params?: GetMediaFoldersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMediaFolders>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMediaFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Reports that new movies have been added by an external source.
 */
export const postAddedMovies = (params?: PostAddedMoviesParams) => {
  return apiInstance<void>({
    url: `/Library/Movies/Added`,
    method: "POST",
    params,
  });
};

export const getPostAddedMoviesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAddedMovies>>,
    TError,
    { params?: PostAddedMoviesParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAddedMovies>>,
  TError,
  { params?: PostAddedMoviesParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAddedMovies>>,
    { params?: PostAddedMoviesParams }
  > = (props) => {
    const { params } = props ?? {};

    return postAddedMovies(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAddedMoviesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAddedMovies>>
>;

export type PostAddedMoviesMutationError = ErrorType<void>;

/**
 * @summary Reports that new movies have been added by an external source.
 */
export const usePostAddedMovies = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAddedMovies>>,
    TError,
    { params?: PostAddedMoviesParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postAddedMovies>>,
  TError,
  { params?: PostAddedMoviesParams },
  TContext
> => {
  const mutationOptions = getPostAddedMoviesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports that new movies have been added by an external source.
 */
export const postUpdatedMovies = (params?: PostUpdatedMoviesParams) => {
  return apiInstance<void>({
    url: `/Library/Movies/Updated`,
    method: "POST",
    params,
  });
};

export const getPostUpdatedMoviesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUpdatedMovies>>,
    TError,
    { params?: PostUpdatedMoviesParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUpdatedMovies>>,
  TError,
  { params?: PostUpdatedMoviesParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUpdatedMovies>>,
    { params?: PostUpdatedMoviesParams }
  > = (props) => {
    const { params } = props ?? {};

    return postUpdatedMovies(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUpdatedMoviesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postUpdatedMovies>>
>;

export type PostUpdatedMoviesMutationError = ErrorType<void>;

/**
 * @summary Reports that new movies have been added by an external source.
 */
export const usePostUpdatedMovies = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUpdatedMovies>>,
    TError,
    { params?: PostUpdatedMoviesParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postUpdatedMovies>>,
  TError,
  { params?: PostUpdatedMoviesParams },
  TContext
> => {
  const mutationOptions = getPostUpdatedMoviesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a list of physical paths from virtual folders.
 */
export const getPhysicalPaths = (signal?: AbortSignal) => {
  return apiInstance<string[]>({
    url: `/Library/PhysicalPaths`,
    method: "GET",
    signal,
  });
};

export const getGetPhysicalPathsQueryKey = () => {
  return [`/Library/PhysicalPaths`] as const;
};

export const getGetPhysicalPathsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPhysicalPaths>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPhysicalPaths>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhysicalPathsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPhysicalPaths>>
  > = ({ signal }) => getPhysicalPaths(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPhysicalPaths>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPhysicalPathsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPhysicalPaths>>
>;
export type GetPhysicalPathsQueryError = ErrorType<void>;

export function useGetPhysicalPaths<
  TData = Awaited<ReturnType<typeof getPhysicalPaths>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPhysicalPaths>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPhysicalPaths>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPhysicalPaths<
  TData = Awaited<ReturnType<typeof getPhysicalPaths>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPhysicalPaths>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPhysicalPaths>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPhysicalPaths<
  TData = Awaited<ReturnType<typeof getPhysicalPaths>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPhysicalPaths>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a list of physical paths from virtual folders.
 */

export function useGetPhysicalPaths<
  TData = Awaited<ReturnType<typeof getPhysicalPaths>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPhysicalPaths>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPhysicalPathsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Starts a library scan.
 */
export const refreshLibrary = () => {
  return apiInstance<void>({ url: `/Library/Refresh`, method: "POST" });
};

export const getRefreshLibraryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshLibrary>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshLibrary>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshLibrary>>,
    void
  > = () => {
    return refreshLibrary();
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshLibraryMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshLibrary>>
>;

export type RefreshLibraryMutationError = ErrorType<void>;

/**
 * @summary Starts a library scan.
 */
export const useRefreshLibrary = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshLibrary>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof refreshLibrary>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getRefreshLibraryMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports that new episodes of a series have been added by an external source.
 */
export const postAddedSeries = (params?: PostAddedSeriesParams) => {
  return apiInstance<void>({
    url: `/Library/Series/Added`,
    method: "POST",
    params,
  });
};

export const getPostAddedSeriesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAddedSeries>>,
    TError,
    { params?: PostAddedSeriesParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAddedSeries>>,
  TError,
  { params?: PostAddedSeriesParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAddedSeries>>,
    { params?: PostAddedSeriesParams }
  > = (props) => {
    const { params } = props ?? {};

    return postAddedSeries(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAddedSeriesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAddedSeries>>
>;

export type PostAddedSeriesMutationError = ErrorType<void>;

/**
 * @summary Reports that new episodes of a series have been added by an external source.
 */
export const usePostAddedSeries = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAddedSeries>>,
    TError,
    { params?: PostAddedSeriesParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postAddedSeries>>,
  TError,
  { params?: PostAddedSeriesParams },
  TContext
> => {
  const mutationOptions = getPostAddedSeriesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports that new episodes of a series have been added by an external source.
 */
export const postUpdatedSeries = (params?: PostUpdatedSeriesParams) => {
  return apiInstance<void>({
    url: `/Library/Series/Updated`,
    method: "POST",
    params,
  });
};

export const getPostUpdatedSeriesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUpdatedSeries>>,
    TError,
    { params?: PostUpdatedSeriesParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUpdatedSeries>>,
  TError,
  { params?: PostUpdatedSeriesParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUpdatedSeries>>,
    { params?: PostUpdatedSeriesParams }
  > = (props) => {
    const { params } = props ?? {};

    return postUpdatedSeries(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUpdatedSeriesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postUpdatedSeries>>
>;

export type PostUpdatedSeriesMutationError = ErrorType<void>;

/**
 * @summary Reports that new episodes of a series have been added by an external source.
 */
export const usePostUpdatedSeries = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUpdatedSeries>>,
    TError,
    { params?: PostUpdatedSeriesParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postUpdatedSeries>>,
  TError,
  { params?: PostUpdatedSeriesParams },
  TContext
> => {
  const mutationOptions = getPostUpdatedSeriesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets similar items.
 */
export const getSimilarMovies = (
  itemId: string,
  params?: GetSimilarMoviesParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Movies/${itemId}/Similar`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSimilarMoviesQueryKey = (
  itemId: string,
  params?: GetSimilarMoviesParams
) => {
  return [`/Movies/${itemId}/Similar`, ...(params ? [params] : [])] as const;
};

export const getGetSimilarMoviesQueryOptions = <
  TData = Awaited<ReturnType<typeof getSimilarMovies>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarMoviesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarMovies>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSimilarMoviesQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSimilarMovies>>
  > = ({ signal }) => getSimilarMovies(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSimilarMovies>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSimilarMoviesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSimilarMovies>>
>;
export type GetSimilarMoviesQueryError = ErrorType<void>;

export function useGetSimilarMovies<
  TData = Awaited<ReturnType<typeof getSimilarMovies>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetSimilarMoviesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarMovies>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarMovies>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarMovies<
  TData = Awaited<ReturnType<typeof getSimilarMovies>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarMoviesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarMovies>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarMovies>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarMovies<
  TData = Awaited<ReturnType<typeof getSimilarMovies>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarMoviesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarMovies>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets similar items.
 */

export function useGetSimilarMovies<
  TData = Awaited<ReturnType<typeof getSimilarMovies>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarMoviesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarMovies>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSimilarMoviesQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets similar items.
 */
export const getSimilarShows = (
  itemId: string,
  params?: GetSimilarShowsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Shows/${itemId}/Similar`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSimilarShowsQueryKey = (
  itemId: string,
  params?: GetSimilarShowsParams
) => {
  return [`/Shows/${itemId}/Similar`, ...(params ? [params] : [])] as const;
};

export const getGetSimilarShowsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSimilarShows>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarShowsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarShows>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSimilarShowsQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSimilarShows>>> = ({
    signal,
  }) => getSimilarShows(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSimilarShows>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSimilarShowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSimilarShows>>
>;
export type GetSimilarShowsQueryError = ErrorType<void>;

export function useGetSimilarShows<
  TData = Awaited<ReturnType<typeof getSimilarShows>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetSimilarShowsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarShows>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarShows>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarShows<
  TData = Awaited<ReturnType<typeof getSimilarShows>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarShowsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarShows>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarShows>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarShows<
  TData = Awaited<ReturnType<typeof getSimilarShows>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarShowsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarShows>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets similar items.
 */

export function useGetSimilarShows<
  TData = Awaited<ReturnType<typeof getSimilarShows>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarShowsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarShows>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSimilarShowsQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets similar items.
 */
export const getSimilarTrailers = (
  itemId: string,
  params?: GetSimilarTrailersParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Trailers/${itemId}/Similar`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSimilarTrailersQueryKey = (
  itemId: string,
  params?: GetSimilarTrailersParams
) => {
  return [`/Trailers/${itemId}/Similar`, ...(params ? [params] : [])] as const;
};

export const getGetSimilarTrailersQueryOptions = <
  TData = Awaited<ReturnType<typeof getSimilarTrailers>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarTrailersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarTrailers>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSimilarTrailersQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSimilarTrailers>>
  > = ({ signal }) => getSimilarTrailers(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSimilarTrailers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSimilarTrailersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSimilarTrailers>>
>;
export type GetSimilarTrailersQueryError = ErrorType<void>;

export function useGetSimilarTrailers<
  TData = Awaited<ReturnType<typeof getSimilarTrailers>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetSimilarTrailersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarTrailers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarTrailers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarTrailers<
  TData = Awaited<ReturnType<typeof getSimilarTrailers>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarTrailersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarTrailers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimilarTrailers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSimilarTrailers<
  TData = Awaited<ReturnType<typeof getSimilarTrailers>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarTrailersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarTrailers>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets similar items.
 */

export function useGetSimilarTrailers<
  TData = Awaited<ReturnType<typeof getSimilarTrailers>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetSimilarTrailersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSimilarTrailers>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSimilarTrailersQueryOptions(
    itemId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets all virtual folders.
 */
export const getVirtualFolders = (signal?: AbortSignal) => {
  return apiInstance<VirtualFolderInfo[]>({
    url: `/Library/VirtualFolders`,
    method: "GET",
    signal,
  });
};

export const getGetVirtualFoldersQueryKey = () => {
  return [`/Library/VirtualFolders`] as const;
};

export const getGetVirtualFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getVirtualFolders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getVirtualFolders>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVirtualFoldersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVirtualFolders>>
  > = ({ signal }) => getVirtualFolders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getVirtualFolders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetVirtualFoldersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVirtualFolders>>
>;
export type GetVirtualFoldersQueryError = ErrorType<void>;

export function useGetVirtualFolders<
  TData = Awaited<ReturnType<typeof getVirtualFolders>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getVirtualFolders>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getVirtualFolders>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVirtualFolders<
  TData = Awaited<ReturnType<typeof getVirtualFolders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getVirtualFolders>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getVirtualFolders>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVirtualFolders<
  TData = Awaited<ReturnType<typeof getVirtualFolders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getVirtualFolders>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all virtual folders.
 */

export function useGetVirtualFolders<
  TData = Awaited<ReturnType<typeof getVirtualFolders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getVirtualFolders>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetVirtualFoldersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Adds a virtual folder.
 */
export const addVirtualFolder = (
  addVirtualFolderDto: AddVirtualFolderDto,
  params?: AddVirtualFolderParams
) => {
  return apiInstance<void>({
    url: `/Library/VirtualFolders`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: addVirtualFolderDto,
    params,
  });
};

export const getAddVirtualFolderMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addVirtualFolder>>,
    TError,
    { data: AddVirtualFolderDto; params?: AddVirtualFolderParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addVirtualFolder>>,
  TError,
  { data: AddVirtualFolderDto; params?: AddVirtualFolderParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addVirtualFolder>>,
    { data: AddVirtualFolderDto; params?: AddVirtualFolderParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return addVirtualFolder(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddVirtualFolderMutationResult = NonNullable<
  Awaited<ReturnType<typeof addVirtualFolder>>
>;
export type AddVirtualFolderMutationBody = AddVirtualFolderDto;
export type AddVirtualFolderMutationError = ErrorType<void>;

/**
 * @summary Adds a virtual folder.
 */
export const useAddVirtualFolder = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addVirtualFolder>>,
    TError,
    { data: AddVirtualFolderDto; params?: AddVirtualFolderParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof addVirtualFolder>>,
  TError,
  { data: AddVirtualFolderDto; params?: AddVirtualFolderParams },
  TContext
> => {
  const mutationOptions = getAddVirtualFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Removes a virtual folder.
 */
export const removeVirtualFolder = (params?: RemoveVirtualFolderParams) => {
  return apiInstance<void>({
    url: `/Library/VirtualFolders`,
    method: "DELETE",
    params,
  });
};

export const getRemoveVirtualFolderMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeVirtualFolder>>,
    TError,
    { params?: RemoveVirtualFolderParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeVirtualFolder>>,
  TError,
  { params?: RemoveVirtualFolderParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeVirtualFolder>>,
    { params?: RemoveVirtualFolderParams }
  > = (props) => {
    const { params } = props ?? {};

    return removeVirtualFolder(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveVirtualFolderMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeVirtualFolder>>
>;

export type RemoveVirtualFolderMutationError = ErrorType<void>;

/**
 * @summary Removes a virtual folder.
 */
export const useRemoveVirtualFolder = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeVirtualFolder>>,
    TError,
    { params?: RemoveVirtualFolderParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof removeVirtualFolder>>,
  TError,
  { params?: RemoveVirtualFolderParams },
  TContext
> => {
  const mutationOptions = getRemoveVirtualFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update library options.
 */
export const updateLibraryOptions = (
  updateLibraryOptionsDto: UpdateLibraryOptionsDto
) => {
  return apiInstance<void>({
    url: `/Library/VirtualFolders/LibraryOptions`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: updateLibraryOptionsDto,
  });
};

export const getUpdateLibraryOptionsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateLibraryOptions>>,
    TError,
    { data: UpdateLibraryOptionsDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateLibraryOptions>>,
  TError,
  { data: UpdateLibraryOptionsDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateLibraryOptions>>,
    { data: UpdateLibraryOptionsDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateLibraryOptions(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateLibraryOptionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateLibraryOptions>>
>;
export type UpdateLibraryOptionsMutationBody = UpdateLibraryOptionsDto;
export type UpdateLibraryOptionsMutationError = ErrorType<void>;

/**
 * @summary Update library options.
 */
export const useUpdateLibraryOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateLibraryOptions>>,
    TError,
    { data: UpdateLibraryOptionsDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateLibraryOptions>>,
  TError,
  { data: UpdateLibraryOptionsDto },
  TContext
> => {
  const mutationOptions = getUpdateLibraryOptionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Renames a virtual folder.
 */
export const renameVirtualFolder = (params?: RenameVirtualFolderParams) => {
  return apiInstance<void>({
    url: `/Library/VirtualFolders/Name`,
    method: "POST",
    params,
  });
};

export const getRenameVirtualFolderMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof renameVirtualFolder>>,
    TError,
    { params?: RenameVirtualFolderParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof renameVirtualFolder>>,
  TError,
  { params?: RenameVirtualFolderParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof renameVirtualFolder>>,
    { params?: RenameVirtualFolderParams }
  > = (props) => {
    const { params } = props ?? {};

    return renameVirtualFolder(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RenameVirtualFolderMutationResult = NonNullable<
  Awaited<ReturnType<typeof renameVirtualFolder>>
>;

export type RenameVirtualFolderMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Renames a virtual folder.
 */
export const useRenameVirtualFolder = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof renameVirtualFolder>>,
    TError,
    { params?: RenameVirtualFolderParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof renameVirtualFolder>>,
  TError,
  { params?: RenameVirtualFolderParams },
  TContext
> => {
  const mutationOptions = getRenameVirtualFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Add a media path to a library.
 */
export const addMediaPath = (
  mediaPathDto: MediaPathDto,
  params?: AddMediaPathParams
) => {
  return apiInstance<void>({
    url: `/Library/VirtualFolders/Paths`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: mediaPathDto,
    params,
  });
};

export const getAddMediaPathMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addMediaPath>>,
    TError,
    { data: MediaPathDto; params?: AddMediaPathParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addMediaPath>>,
  TError,
  { data: MediaPathDto; params?: AddMediaPathParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addMediaPath>>,
    { data: MediaPathDto; params?: AddMediaPathParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return addMediaPath(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddMediaPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof addMediaPath>>
>;
export type AddMediaPathMutationBody = MediaPathDto;
export type AddMediaPathMutationError = ErrorType<void>;

/**
 * @summary Add a media path to a library.
 */
export const useAddMediaPath = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addMediaPath>>,
    TError,
    { data: MediaPathDto; params?: AddMediaPathParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof addMediaPath>>,
  TError,
  { data: MediaPathDto; params?: AddMediaPathParams },
  TContext
> => {
  const mutationOptions = getAddMediaPathMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Remove a media path.
 */
export const removeMediaPath = (params?: RemoveMediaPathParams) => {
  return apiInstance<void>({
    url: `/Library/VirtualFolders/Paths`,
    method: "DELETE",
    params,
  });
};

export const getRemoveMediaPathMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeMediaPath>>,
    TError,
    { params?: RemoveMediaPathParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeMediaPath>>,
  TError,
  { params?: RemoveMediaPathParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeMediaPath>>,
    { params?: RemoveMediaPathParams }
  > = (props) => {
    const { params } = props ?? {};

    return removeMediaPath(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveMediaPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeMediaPath>>
>;

export type RemoveMediaPathMutationError = ErrorType<void>;

/**
 * @summary Remove a media path.
 */
export const useRemoveMediaPath = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeMediaPath>>,
    TError,
    { params?: RemoveMediaPathParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof removeMediaPath>>,
  TError,
  { params?: RemoveMediaPathParams },
  TContext
> => {
  const mutationOptions = getRemoveMediaPathMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a media path.
 */
export const updateMediaPath = (
  updateMediaPathRequestDto: UpdateMediaPathRequestDto
) => {
  return apiInstance<void>({
    url: `/Library/VirtualFolders/Paths/Update`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: updateMediaPathRequestDto,
  });
};

export const getUpdateMediaPathMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMediaPath>>,
    TError,
    { data: UpdateMediaPathRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMediaPath>>,
  TError,
  { data: UpdateMediaPathRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMediaPath>>,
    { data: UpdateMediaPathRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateMediaPath(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMediaPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMediaPath>>
>;
export type UpdateMediaPathMutationBody = UpdateMediaPathRequestDto;
export type UpdateMediaPathMutationError = ErrorType<void>;

/**
 * @summary Updates a media path.
 */
export const useUpdateMediaPath = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMediaPath>>,
    TError,
    { data: UpdateMediaPathRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateMediaPath>>,
  TError,
  { data: UpdateMediaPathRequestDto },
  TContext
> => {
  const mutationOptions = getUpdateMediaPathMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get channel mapping options.
 */
export const getChannelMappingOptions = (
  params?: GetChannelMappingOptionsParams,
  signal?: AbortSignal
) => {
  return apiInstance<ChannelMappingOptionsDto>({
    url: `/LiveTv/ChannelMappingOptions`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetChannelMappingOptionsQueryKey = (
  params?: GetChannelMappingOptionsParams
) => {
  return [
    `/LiveTv/ChannelMappingOptions`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetChannelMappingOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getChannelMappingOptions>>,
  TError = ErrorType<void>
>(
  params?: GetChannelMappingOptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelMappingOptions>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetChannelMappingOptionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getChannelMappingOptions>>
  > = ({ signal }) => getChannelMappingOptions(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getChannelMappingOptions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetChannelMappingOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getChannelMappingOptions>>
>;
export type GetChannelMappingOptionsQueryError = ErrorType<void>;

export function useGetChannelMappingOptions<
  TData = Awaited<ReturnType<typeof getChannelMappingOptions>>,
  TError = ErrorType<void>
>(
  params: undefined | GetChannelMappingOptionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelMappingOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelMappingOptions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannelMappingOptions<
  TData = Awaited<ReturnType<typeof getChannelMappingOptions>>,
  TError = ErrorType<void>
>(
  params?: GetChannelMappingOptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelMappingOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelMappingOptions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannelMappingOptions<
  TData = Awaited<ReturnType<typeof getChannelMappingOptions>>,
  TError = ErrorType<void>
>(
  params?: GetChannelMappingOptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelMappingOptions>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get channel mapping options.
 */

export function useGetChannelMappingOptions<
  TData = Awaited<ReturnType<typeof getChannelMappingOptions>>,
  TError = ErrorType<void>
>(
  params?: GetChannelMappingOptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChannelMappingOptions>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetChannelMappingOptionsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Set channel mappings.
 */
export const setChannelMapping = (
  setChannelMappingDto: SetChannelMappingDto
) => {
  return apiInstance<TunerChannelMapping>({
    url: `/LiveTv/ChannelMappings`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: setChannelMappingDto,
  });
};

export const getSetChannelMappingMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setChannelMapping>>,
    TError,
    { data: SetChannelMappingDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setChannelMapping>>,
  TError,
  { data: SetChannelMappingDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setChannelMapping>>,
    { data: SetChannelMappingDto }
  > = (props) => {
    const { data } = props ?? {};

    return setChannelMapping(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetChannelMappingMutationResult = NonNullable<
  Awaited<ReturnType<typeof setChannelMapping>>
>;
export type SetChannelMappingMutationBody = SetChannelMappingDto;
export type SetChannelMappingMutationError = ErrorType<void>;

/**
 * @summary Set channel mappings.
 */
export const useSetChannelMapping = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setChannelMapping>>,
    TError,
    { data: SetChannelMappingDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof setChannelMapping>>,
  TError,
  { data: SetChannelMappingDto },
  TContext
> => {
  const mutationOptions = getSetChannelMappingMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets available live tv channels.
 */
export const getLiveTvChannels = (
  params?: GetLiveTvChannelsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/LiveTv/Channels`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLiveTvChannelsQueryKey = (
  params?: GetLiveTvChannelsParams
) => {
  return [`/LiveTv/Channels`, ...(params ? [params] : [])] as const;
};

export const getGetLiveTvChannelsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLiveTvChannels>>,
  TError = ErrorType<void>
>(
  params?: GetLiveTvChannelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvChannels>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLiveTvChannelsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLiveTvChannels>>
  > = ({ signal }) => getLiveTvChannels(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLiveTvChannels>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLiveTvChannelsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLiveTvChannels>>
>;
export type GetLiveTvChannelsQueryError = ErrorType<void>;

export function useGetLiveTvChannels<
  TData = Awaited<ReturnType<typeof getLiveTvChannels>>,
  TError = ErrorType<void>
>(
  params: undefined | GetLiveTvChannelsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvChannels>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveTvChannels>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveTvChannels<
  TData = Awaited<ReturnType<typeof getLiveTvChannels>>,
  TError = ErrorType<void>
>(
  params?: GetLiveTvChannelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvChannels>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveTvChannels>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveTvChannels<
  TData = Awaited<ReturnType<typeof getLiveTvChannels>>,
  TError = ErrorType<void>
>(
  params?: GetLiveTvChannelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvChannels>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available live tv channels.
 */

export function useGetLiveTvChannels<
  TData = Awaited<ReturnType<typeof getLiveTvChannels>>,
  TError = ErrorType<void>
>(
  params?: GetLiveTvChannelsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvChannels>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLiveTvChannelsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a live tv channel.
 */
export const getChannel = (
  channelId: string,
  params?: GetChannelParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/LiveTv/Channels/${channelId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetChannelQueryKey = (
  channelId: string,
  params?: GetChannelParams
) => {
  return [
    `/LiveTv/Channels/${channelId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetChannelQueryOptions = <
  TData = Awaited<ReturnType<typeof getChannel>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params?: GetChannelParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannel>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetChannelQueryKey(channelId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannel>>> = ({
    signal,
  }) => getChannel(channelId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!channelId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getChannel>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetChannelQueryResult = NonNullable<
  Awaited<ReturnType<typeof getChannel>>
>;
export type GetChannelQueryError = ErrorType<void>;

export function useGetChannel<
  TData = Awaited<ReturnType<typeof getChannel>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params: undefined | GetChannelParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannel>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannel>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannel<
  TData = Awaited<ReturnType<typeof getChannel>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params?: GetChannelParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannel>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannel>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetChannel<
  TData = Awaited<ReturnType<typeof getChannel>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params?: GetChannelParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannel>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a live tv channel.
 */

export function useGetChannel<
  TData = Awaited<ReturnType<typeof getChannel>>,
  TError = ErrorType<void>
>(
  channelId: string,
  params?: GetChannelParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getChannel>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetChannelQueryOptions(channelId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get guid info.
 */
export const getGuideInfo = (signal?: AbortSignal) => {
  return apiInstance<GuideInfo>({
    url: `/LiveTv/GuideInfo`,
    method: "GET",
    signal,
  });
};

export const getGetGuideInfoQueryKey = () => {
  return [`/LiveTv/GuideInfo`] as const;
};

export const getGetGuideInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getGuideInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGuideInfo>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGuideInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGuideInfo>>> = ({
    signal,
  }) => getGuideInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGuideInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetGuideInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGuideInfo>>
>;
export type GetGuideInfoQueryError = ErrorType<void>;

export function useGetGuideInfo<
  TData = Awaited<ReturnType<typeof getGuideInfo>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGuideInfo>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getGuideInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGuideInfo<
  TData = Awaited<ReturnType<typeof getGuideInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGuideInfo>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getGuideInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGuideInfo<
  TData = Awaited<ReturnType<typeof getGuideInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGuideInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get guid info.
 */

export function useGetGuideInfo<
  TData = Awaited<ReturnType<typeof getGuideInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGuideInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetGuideInfoQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets available live tv services.
 */
export const getLiveTvInfo = (signal?: AbortSignal) => {
  return apiInstance<LiveTvInfo>({
    url: `/LiveTv/Info`,
    method: "GET",
    signal,
  });
};

export const getGetLiveTvInfoQueryKey = () => {
  return [`/LiveTv/Info`] as const;
};

export const getGetLiveTvInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getLiveTvInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getLiveTvInfo>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLiveTvInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLiveTvInfo>>> = ({
    signal,
  }) => getLiveTvInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLiveTvInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLiveTvInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLiveTvInfo>>
>;
export type GetLiveTvInfoQueryError = ErrorType<void>;

export function useGetLiveTvInfo<
  TData = Awaited<ReturnType<typeof getLiveTvInfo>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getLiveTvInfo>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getLiveTvInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveTvInfo<
  TData = Awaited<ReturnType<typeof getLiveTvInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getLiveTvInfo>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getLiveTvInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveTvInfo<
  TData = Awaited<ReturnType<typeof getLiveTvInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getLiveTvInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available live tv services.
 */

export function useGetLiveTvInfo<
  TData = Awaited<ReturnType<typeof getLiveTvInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getLiveTvInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLiveTvInfoQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Adds a listings provider.
 */
export const addListingProvider = (
  listingsProviderInfo: ListingsProviderInfo,
  params?: AddListingProviderParams
) => {
  return apiInstance<ListingsProviderInfo>({
    url: `/LiveTv/ListingProviders`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: listingsProviderInfo,
    params,
  });
};

export const getAddListingProviderMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addListingProvider>>,
    TError,
    { data: ListingsProviderInfo; params?: AddListingProviderParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addListingProvider>>,
  TError,
  { data: ListingsProviderInfo; params?: AddListingProviderParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addListingProvider>>,
    { data: ListingsProviderInfo; params?: AddListingProviderParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return addListingProvider(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddListingProviderMutationResult = NonNullable<
  Awaited<ReturnType<typeof addListingProvider>>
>;
export type AddListingProviderMutationBody = ListingsProviderInfo;
export type AddListingProviderMutationError = ErrorType<void>;

/**
 * @summary Adds a listings provider.
 */
export const useAddListingProvider = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addListingProvider>>,
    TError,
    { data: ListingsProviderInfo; params?: AddListingProviderParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof addListingProvider>>,
  TError,
  { data: ListingsProviderInfo; params?: AddListingProviderParams },
  TContext
> => {
  const mutationOptions = getAddListingProviderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Delete listing provider.
 */
export const deleteListingProvider = (params?: DeleteListingProviderParams) => {
  return apiInstance<void>({
    url: `/LiveTv/ListingProviders`,
    method: "DELETE",
    params,
  });
};

export const getDeleteListingProviderMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteListingProvider>>,
    TError,
    { params?: DeleteListingProviderParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteListingProvider>>,
  TError,
  { params?: DeleteListingProviderParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteListingProvider>>,
    { params?: DeleteListingProviderParams }
  > = (props) => {
    const { params } = props ?? {};

    return deleteListingProvider(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteListingProviderMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteListingProvider>>
>;

export type DeleteListingProviderMutationError = ErrorType<void>;

/**
 * @summary Delete listing provider.
 */
export const useDeleteListingProvider = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteListingProvider>>,
    TError,
    { params?: DeleteListingProviderParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteListingProvider>>,
  TError,
  { params?: DeleteListingProviderParams },
  TContext
> => {
  const mutationOptions = getDeleteListingProviderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets default listings provider info.
 */
export const getDefaultListingProvider = (signal?: AbortSignal) => {
  return apiInstance<ListingsProviderInfo>({
    url: `/LiveTv/ListingProviders/Default`,
    method: "GET",
    signal,
  });
};

export const getGetDefaultListingProviderQueryKey = () => {
  return [`/LiveTv/ListingProviders/Default`] as const;
};

export const getGetDefaultListingProviderQueryOptions = <
  TData = Awaited<ReturnType<typeof getDefaultListingProvider>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultListingProvider>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDefaultListingProviderQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDefaultListingProvider>>
  > = ({ signal }) => getDefaultListingProvider(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDefaultListingProvider>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDefaultListingProviderQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDefaultListingProvider>>
>;
export type GetDefaultListingProviderQueryError = ErrorType<void>;

export function useGetDefaultListingProvider<
  TData = Awaited<ReturnType<typeof getDefaultListingProvider>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultListingProvider>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDefaultListingProvider>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultListingProvider<
  TData = Awaited<ReturnType<typeof getDefaultListingProvider>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultListingProvider>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getDefaultListingProvider>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultListingProvider<
  TData = Awaited<ReturnType<typeof getDefaultListingProvider>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultListingProvider>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets default listings provider info.
 */

export function useGetDefaultListingProvider<
  TData = Awaited<ReturnType<typeof getDefaultListingProvider>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDefaultListingProvider>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDefaultListingProviderQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets available lineups.
 */
export const getLineups = (params?: GetLineupsParams, signal?: AbortSignal) => {
  return apiInstance<NameIdPair[]>({
    url: `/LiveTv/ListingProviders/Lineups`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLineupsQueryKey = (params?: GetLineupsParams) => {
  return [
    `/LiveTv/ListingProviders/Lineups`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLineupsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLineups>>,
  TError = ErrorType<void>
>(
  params?: GetLineupsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLineups>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLineupsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLineups>>> = ({
    signal,
  }) => getLineups(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLineups>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLineupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLineups>>
>;
export type GetLineupsQueryError = ErrorType<void>;

export function useGetLineups<
  TData = Awaited<ReturnType<typeof getLineups>>,
  TError = ErrorType<void>
>(
  params: undefined | GetLineupsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLineups>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLineups>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLineups<
  TData = Awaited<ReturnType<typeof getLineups>>,
  TError = ErrorType<void>
>(
  params?: GetLineupsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLineups>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLineups>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLineups<
  TData = Awaited<ReturnType<typeof getLineups>>,
  TError = ErrorType<void>
>(
  params?: GetLineupsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLineups>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available lineups.
 */

export function useGetLineups<
  TData = Awaited<ReturnType<typeof getLineups>>,
  TError = ErrorType<void>
>(
  params?: GetLineupsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLineups>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLineupsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets available countries.
 */
export const getSchedulesDirectCountries = (signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/LiveTv/ListingProviders/SchedulesDirect/Countries`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetSchedulesDirectCountriesQueryKey = () => {
  return [`/LiveTv/ListingProviders/SchedulesDirect/Countries`] as const;
};

export const getGetSchedulesDirectCountriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSchedulesDirectCountriesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSchedulesDirectCountries>>
  > = ({ signal }) => getSchedulesDirectCountries(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSchedulesDirectCountriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSchedulesDirectCountries>>
>;
export type GetSchedulesDirectCountriesQueryError = ErrorType<void>;

export function useGetSchedulesDirectCountries<
  TData = Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSchedulesDirectCountries<
  TData = Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSchedulesDirectCountries<
  TData = Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available countries.
 */

export function useGetSchedulesDirectCountries<
  TData = Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getSchedulesDirectCountries>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSchedulesDirectCountriesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a live tv recording stream.
 */
export const getLiveRecordingFile = (
  recordingId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/LiveTv/LiveRecordings/${recordingId}/stream`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetLiveRecordingFileQueryKey = (recordingId: string) => {
  return [`/LiveTv/LiveRecordings/${recordingId}/stream`] as const;
};

export const getGetLiveRecordingFileQueryOptions = <
  TData = Awaited<ReturnType<typeof getLiveRecordingFile>>,
  TError = ErrorType<ProblemDetails>
>(
  recordingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveRecordingFile>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLiveRecordingFileQueryKey(recordingId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLiveRecordingFile>>
  > = ({ signal }) => getLiveRecordingFile(recordingId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!recordingId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLiveRecordingFile>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLiveRecordingFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLiveRecordingFile>>
>;
export type GetLiveRecordingFileQueryError = ErrorType<ProblemDetails>;

export function useGetLiveRecordingFile<
  TData = Awaited<ReturnType<typeof getLiveRecordingFile>>,
  TError = ErrorType<ProblemDetails>
>(
  recordingId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveRecordingFile>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveRecordingFile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveRecordingFile<
  TData = Awaited<ReturnType<typeof getLiveRecordingFile>>,
  TError = ErrorType<ProblemDetails>
>(
  recordingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveRecordingFile>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveRecordingFile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveRecordingFile<
  TData = Awaited<ReturnType<typeof getLiveRecordingFile>>,
  TError = ErrorType<ProblemDetails>
>(
  recordingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveRecordingFile>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a live tv recording stream.
 */

export function useGetLiveRecordingFile<
  TData = Awaited<ReturnType<typeof getLiveRecordingFile>>,
  TError = ErrorType<ProblemDetails>
>(
  recordingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveRecordingFile>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLiveRecordingFileQueryOptions(
    recordingId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a live tv channel stream.
 */
export const getLiveStreamFile = (
  streamId: string,
  container: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/LiveTv/LiveStreamFiles/${streamId}/stream.${container}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetLiveStreamFileQueryKey = (
  streamId: string,
  container: string
) => {
  return [`/LiveTv/LiveStreamFiles/${streamId}/stream.${container}`] as const;
};

export const getGetLiveStreamFileQueryOptions = <
  TData = Awaited<ReturnType<typeof getLiveStreamFile>>,
  TError = ErrorType<ProblemDetails>
>(
  streamId: string,
  container: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveStreamFile>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLiveStreamFileQueryKey(streamId, container);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLiveStreamFile>>
  > = ({ signal }) => getLiveStreamFile(streamId, container, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(streamId && container),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLiveStreamFile>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLiveStreamFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLiveStreamFile>>
>;
export type GetLiveStreamFileQueryError = ErrorType<ProblemDetails>;

export function useGetLiveStreamFile<
  TData = Awaited<ReturnType<typeof getLiveStreamFile>>,
  TError = ErrorType<ProblemDetails>
>(
  streamId: string,
  container: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveStreamFile>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveStreamFile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveStreamFile<
  TData = Awaited<ReturnType<typeof getLiveStreamFile>>,
  TError = ErrorType<ProblemDetails>
>(
  streamId: string,
  container: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveStreamFile>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveStreamFile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveStreamFile<
  TData = Awaited<ReturnType<typeof getLiveStreamFile>>,
  TError = ErrorType<ProblemDetails>
>(
  streamId: string,
  container: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveStreamFile>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a live tv channel stream.
 */

export function useGetLiveStreamFile<
  TData = Awaited<ReturnType<typeof getLiveStreamFile>>,
  TError = ErrorType<ProblemDetails>
>(
  streamId: string,
  container: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveStreamFile>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLiveStreamFileQueryOptions(
    streamId,
    container,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets available live tv epgs.
 */
export const getLiveTvPrograms = (
  params?: GetLiveTvProgramsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/LiveTv/Programs`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLiveTvProgramsQueryKey = (
  params?: GetLiveTvProgramsParams
) => {
  return [`/LiveTv/Programs`, ...(params ? [params] : [])] as const;
};

export const getGetLiveTvProgramsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLiveTvPrograms>>,
  TError = ErrorType<void>
>(
  params?: GetLiveTvProgramsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvPrograms>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLiveTvProgramsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLiveTvPrograms>>
  > = ({ signal }) => getLiveTvPrograms(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLiveTvPrograms>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLiveTvProgramsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLiveTvPrograms>>
>;
export type GetLiveTvProgramsQueryError = ErrorType<void>;

export function useGetLiveTvPrograms<
  TData = Awaited<ReturnType<typeof getLiveTvPrograms>>,
  TError = ErrorType<void>
>(
  params: undefined | GetLiveTvProgramsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvPrograms>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveTvPrograms>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveTvPrograms<
  TData = Awaited<ReturnType<typeof getLiveTvPrograms>>,
  TError = ErrorType<void>
>(
  params?: GetLiveTvProgramsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvPrograms>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveTvPrograms>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLiveTvPrograms<
  TData = Awaited<ReturnType<typeof getLiveTvPrograms>>,
  TError = ErrorType<void>
>(
  params?: GetLiveTvProgramsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvPrograms>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available live tv epgs.
 */

export function useGetLiveTvPrograms<
  TData = Awaited<ReturnType<typeof getLiveTvPrograms>>,
  TError = ErrorType<void>
>(
  params?: GetLiveTvProgramsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveTvPrograms>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLiveTvProgramsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets available live tv epgs.
 */
export const getPrograms = (getProgramsDto: GetProgramsDto) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/LiveTv/Programs`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: getProgramsDto,
  });
};

export const getGetProgramsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPrograms>>,
    TError,
    { data: GetProgramsDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getPrograms>>,
  TError,
  { data: GetProgramsDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getPrograms>>,
    { data: GetProgramsDto }
  > = (props) => {
    const { data } = props ?? {};

    return getPrograms(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetProgramsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getPrograms>>
>;
export type GetProgramsMutationBody = GetProgramsDto;
export type GetProgramsMutationError = ErrorType<void>;

/**
 * @summary Gets available live tv epgs.
 */
export const useGetPrograms = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPrograms>>,
    TError,
    { data: GetProgramsDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getPrograms>>,
  TError,
  { data: GetProgramsDto },
  TContext
> => {
  const mutationOptions = getGetProgramsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a live tv program.
 */
export const getProgram = (
  programId: string,
  params?: GetProgramParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/LiveTv/Programs/${programId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetProgramQueryKey = (
  programId: string,
  params?: GetProgramParams
) => {
  return [
    `/LiveTv/Programs/${programId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetProgramQueryOptions = <
  TData = Awaited<ReturnType<typeof getProgram>>,
  TError = ErrorType<void>
>(
  programId: string,
  params?: GetProgramParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProgramQueryKey(programId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgram>>> = ({
    signal,
  }) => getProgram(programId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!programId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProgram>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetProgramQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProgram>>
>;
export type GetProgramQueryError = ErrorType<void>;

export function useGetProgram<
  TData = Awaited<ReturnType<typeof getProgram>>,
  TError = ErrorType<void>
>(
  programId: string,
  params: undefined | GetProgramParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgram>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetProgram<
  TData = Awaited<ReturnType<typeof getProgram>>,
  TError = ErrorType<void>
>(
  programId: string,
  params?: GetProgramParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgram>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetProgram<
  TData = Awaited<ReturnType<typeof getProgram>>,
  TError = ErrorType<void>
>(
  programId: string,
  params?: GetProgramParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a live tv program.
 */

export function useGetProgram<
  TData = Awaited<ReturnType<typeof getProgram>>,
  TError = ErrorType<void>
>(
  programId: string,
  params?: GetProgramParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetProgramQueryOptions(programId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets recommended live tv epgs.
 */
export const getRecommendedPrograms = (
  params?: GetRecommendedProgramsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/LiveTv/Programs/Recommended`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRecommendedProgramsQueryKey = (
  params?: GetRecommendedProgramsParams
) => {
  return [`/LiveTv/Programs/Recommended`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendedProgramsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendedPrograms>>,
  TError = ErrorType<void>
>(
  params?: GetRecommendedProgramsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecommendedPrograms>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecommendedProgramsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecommendedPrograms>>
  > = ({ signal }) => getRecommendedPrograms(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendedPrograms>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRecommendedProgramsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecommendedPrograms>>
>;
export type GetRecommendedProgramsQueryError = ErrorType<void>;

export function useGetRecommendedPrograms<
  TData = Awaited<ReturnType<typeof getRecommendedPrograms>>,
  TError = ErrorType<void>
>(
  params: undefined | GetRecommendedProgramsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecommendedPrograms>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedPrograms>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecommendedPrograms<
  TData = Awaited<ReturnType<typeof getRecommendedPrograms>>,
  TError = ErrorType<void>
>(
  params?: GetRecommendedProgramsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecommendedPrograms>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecommendedPrograms>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecommendedPrograms<
  TData = Awaited<ReturnType<typeof getRecommendedPrograms>>,
  TError = ErrorType<void>
>(
  params?: GetRecommendedProgramsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecommendedPrograms>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets recommended live tv epgs.
 */

export function useGetRecommendedPrograms<
  TData = Awaited<ReturnType<typeof getRecommendedPrograms>>,
  TError = ErrorType<void>
>(
  params?: GetRecommendedProgramsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecommendedPrograms>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRecommendedProgramsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets live tv recordings.
 */
export const getRecordings = (
  params?: GetRecordingsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/LiveTv/Recordings`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRecordingsQueryKey = (params?: GetRecordingsParams) => {
  return [`/LiveTv/Recordings`, ...(params ? [params] : [])] as const;
};

export const getGetRecordingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecordings>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecordings>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecordingsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecordings>>> = ({
    signal,
  }) => getRecordings(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecordings>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRecordingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecordings>>
>;
export type GetRecordingsQueryError = ErrorType<void>;

export function useGetRecordings<
  TData = Awaited<ReturnType<typeof getRecordings>>,
  TError = ErrorType<void>
>(
  params: undefined | GetRecordingsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecordings>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordings>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordings<
  TData = Awaited<ReturnType<typeof getRecordings>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecordings>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordings>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordings<
  TData = Awaited<ReturnType<typeof getRecordings>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecordings>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets live tv recordings.
 */

export function useGetRecordings<
  TData = Awaited<ReturnType<typeof getRecordings>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecordings>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRecordingsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a live tv recording.
 */
export const getRecording = (
  recordingId: string,
  params?: GetRecordingParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/LiveTv/Recordings/${recordingId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRecordingQueryKey = (
  recordingId: string,
  params?: GetRecordingParams
) => {
  return [
    `/LiveTv/Recordings/${recordingId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetRecordingQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecording>>,
  TError = ErrorType<void>
>(
  recordingId: string,
  params?: GetRecordingParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecordingQueryKey(recordingId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecording>>> = ({
    signal,
  }) => getRecording(recordingId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!recordingId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecording>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRecordingQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecording>>
>;
export type GetRecordingQueryError = ErrorType<void>;

export function useGetRecording<
  TData = Awaited<ReturnType<typeof getRecording>>,
  TError = ErrorType<void>
>(
  recordingId: string,
  params: undefined | GetRecordingParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecording>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecording<
  TData = Awaited<ReturnType<typeof getRecording>>,
  TError = ErrorType<void>
>(
  recordingId: string,
  params?: GetRecordingParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecording>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecording<
  TData = Awaited<ReturnType<typeof getRecording>>,
  TError = ErrorType<void>
>(
  recordingId: string,
  params?: GetRecordingParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a live tv recording.
 */

export function useGetRecording<
  TData = Awaited<ReturnType<typeof getRecording>>,
  TError = ErrorType<void>
>(
  recordingId: string,
  params?: GetRecordingParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRecordingQueryOptions(
    recordingId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Deletes a live tv recording.
 */
export const deleteRecording = (recordingId: string) => {
  return apiInstance<void>({
    url: `/LiveTv/Recordings/${recordingId}`,
    method: "DELETE",
  });
};

export const getDeleteRecordingMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRecording>>,
    TError,
    { recordingId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRecording>>,
  TError,
  { recordingId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRecording>>,
    { recordingId: string }
  > = (props) => {
    const { recordingId } = props ?? {};

    return deleteRecording(recordingId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRecordingMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRecording>>
>;

export type DeleteRecordingMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Deletes a live tv recording.
 */
export const useDeleteRecording = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRecording>>,
    TError,
    { recordingId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteRecording>>,
  TError,
  { recordingId: string },
  TContext
> => {
  const mutationOptions = getDeleteRecordingMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets recording folders.
 */
export const getRecordingFolders = (
  params?: GetRecordingFoldersParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/LiveTv/Recordings/Folders`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRecordingFoldersQueryKey = (
  params?: GetRecordingFoldersParams
) => {
  return [`/LiveTv/Recordings/Folders`, ...(params ? [params] : [])] as const;
};

export const getGetRecordingFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecordingFolders>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingFoldersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingFolders>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecordingFoldersQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecordingFolders>>
  > = ({ signal }) => getRecordingFolders(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecordingFolders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRecordingFoldersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecordingFolders>>
>;
export type GetRecordingFoldersQueryError = ErrorType<void>;

export function useGetRecordingFolders<
  TData = Awaited<ReturnType<typeof getRecordingFolders>>,
  TError = ErrorType<void>
>(
  params: undefined | GetRecordingFoldersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingFolders>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingFolders>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordingFolders<
  TData = Awaited<ReturnType<typeof getRecordingFolders>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingFoldersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingFolders>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingFolders>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordingFolders<
  TData = Awaited<ReturnType<typeof getRecordingFolders>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingFoldersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingFolders>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets recording folders.
 */

export function useGetRecordingFolders<
  TData = Awaited<ReturnType<typeof getRecordingFolders>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingFoldersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingFolders>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRecordingFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @deprecated
 * @summary Gets live tv recording groups.
 */
export const getRecordingGroups = (
  params?: GetRecordingGroupsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/LiveTv/Recordings/Groups`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRecordingGroupsQueryKey = (
  params?: GetRecordingGroupsParams
) => {
  return [`/LiveTv/Recordings/Groups`, ...(params ? [params] : [])] as const;
};

export const getGetRecordingGroupsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecordingGroups>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingGroupsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroups>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecordingGroupsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecordingGroups>>
  > = ({ signal }) => getRecordingGroups(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecordingGroups>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRecordingGroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecordingGroups>>
>;
export type GetRecordingGroupsQueryError = ErrorType<void>;

export function useGetRecordingGroups<
  TData = Awaited<ReturnType<typeof getRecordingGroups>>,
  TError = ErrorType<void>
>(
  params: undefined | GetRecordingGroupsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroups>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingGroups>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordingGroups<
  TData = Awaited<ReturnType<typeof getRecordingGroups>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingGroupsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroups>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingGroups>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordingGroups<
  TData = Awaited<ReturnType<typeof getRecordingGroups>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingGroupsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroups>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @deprecated
 * @summary Gets live tv recording groups.
 */

export function useGetRecordingGroups<
  TData = Awaited<ReturnType<typeof getRecordingGroups>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingGroupsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroups>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRecordingGroupsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @deprecated
 * @summary Get recording group.
 */
export const getRecordingGroup = (groupId: string, signal?: AbortSignal) => {
  return apiInstance<unknown>({
    url: `/LiveTv/Recordings/Groups/${groupId}`,
    method: "GET",
    signal,
  });
};

export const getGetRecordingGroupQueryKey = (groupId: string) => {
  return [`/LiveTv/Recordings/Groups/${groupId}`] as const;
};

export const getGetRecordingGroupQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecordingGroup>>,
  TError = ErrorType<void | ProblemDetails>
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroup>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecordingGroupQueryKey(groupId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecordingGroup>>
  > = ({ signal }) => getRecordingGroup(groupId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!groupId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecordingGroup>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRecordingGroupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecordingGroup>>
>;
export type GetRecordingGroupQueryError = ErrorType<void | ProblemDetails>;

export function useGetRecordingGroup<
  TData = Awaited<ReturnType<typeof getRecordingGroup>>,
  TError = ErrorType<void | ProblemDetails>
>(
  groupId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroup>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingGroup>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordingGroup<
  TData = Awaited<ReturnType<typeof getRecordingGroup>>,
  TError = ErrorType<void | ProblemDetails>
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroup>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingGroup>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordingGroup<
  TData = Awaited<ReturnType<typeof getRecordingGroup>>,
  TError = ErrorType<void | ProblemDetails>
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroup>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @deprecated
 * @summary Get recording group.
 */

export function useGetRecordingGroup<
  TData = Awaited<ReturnType<typeof getRecordingGroup>>,
  TError = ErrorType<void | ProblemDetails>
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingGroup>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRecordingGroupQueryOptions(groupId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @deprecated
 * @summary Gets live tv recording series.
 */
export const getRecordingsSeries = (
  params?: GetRecordingsSeriesParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/LiveTv/Recordings/Series`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRecordingsSeriesQueryKey = (
  params?: GetRecordingsSeriesParams
) => {
  return [`/LiveTv/Recordings/Series`, ...(params ? [params] : [])] as const;
};

export const getGetRecordingsSeriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecordingsSeries>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingsSeriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingsSeries>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecordingsSeriesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecordingsSeries>>
  > = ({ signal }) => getRecordingsSeries(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecordingsSeries>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRecordingsSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecordingsSeries>>
>;
export type GetRecordingsSeriesQueryError = ErrorType<void>;

export function useGetRecordingsSeries<
  TData = Awaited<ReturnType<typeof getRecordingsSeries>>,
  TError = ErrorType<void>
>(
  params: undefined | GetRecordingsSeriesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingsSeries>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingsSeries>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordingsSeries<
  TData = Awaited<ReturnType<typeof getRecordingsSeries>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingsSeriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingsSeries>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingsSeries>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRecordingsSeries<
  TData = Awaited<ReturnType<typeof getRecordingsSeries>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingsSeriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingsSeries>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @deprecated
 * @summary Gets live tv recording series.
 */

export function useGetRecordingsSeries<
  TData = Awaited<ReturnType<typeof getRecordingsSeries>>,
  TError = ErrorType<void>
>(
  params?: GetRecordingsSeriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecordingsSeries>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRecordingsSeriesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets live tv series timers.
 */
export const getSeriesTimers = (
  params?: GetSeriesTimersParams,
  signal?: AbortSignal
) => {
  return apiInstance<SeriesTimerInfoDtoQueryResult>({
    url: `/LiveTv/SeriesTimers`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSeriesTimersQueryKey = (params?: GetSeriesTimersParams) => {
  return [`/LiveTv/SeriesTimers`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesTimersQueryOptions = <
  TData = Awaited<ReturnType<typeof getSeriesTimers>>,
  TError = ErrorType<void>
>(
  params?: GetSeriesTimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSeriesTimers>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSeriesTimersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeriesTimers>>> = ({
    signal,
  }) => getSeriesTimers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSeriesTimers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSeriesTimersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSeriesTimers>>
>;
export type GetSeriesTimersQueryError = ErrorType<void>;

export function useGetSeriesTimers<
  TData = Awaited<ReturnType<typeof getSeriesTimers>>,
  TError = ErrorType<void>
>(
  params: undefined | GetSeriesTimersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSeriesTimers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSeriesTimers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSeriesTimers<
  TData = Awaited<ReturnType<typeof getSeriesTimers>>,
  TError = ErrorType<void>
>(
  params?: GetSeriesTimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSeriesTimers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSeriesTimers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSeriesTimers<
  TData = Awaited<ReturnType<typeof getSeriesTimers>>,
  TError = ErrorType<void>
>(
  params?: GetSeriesTimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSeriesTimers>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets live tv series timers.
 */

export function useGetSeriesTimers<
  TData = Awaited<ReturnType<typeof getSeriesTimers>>,
  TError = ErrorType<void>
>(
  params?: GetSeriesTimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSeriesTimers>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSeriesTimersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates a live tv series timer.
 */
export const createSeriesTimer = (seriesTimerInfoDto: SeriesTimerInfoDto) => {
  return apiInstance<void>({
    url: `/LiveTv/SeriesTimers`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: seriesTimerInfoDto,
  });
};

export const getCreateSeriesTimerMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSeriesTimer>>,
    TError,
    { data: SeriesTimerInfoDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSeriesTimer>>,
  TError,
  { data: SeriesTimerInfoDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSeriesTimer>>,
    { data: SeriesTimerInfoDto }
  > = (props) => {
    const { data } = props ?? {};

    return createSeriesTimer(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSeriesTimerMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSeriesTimer>>
>;
export type CreateSeriesTimerMutationBody = SeriesTimerInfoDto;
export type CreateSeriesTimerMutationError = ErrorType<void>;

/**
 * @summary Creates a live tv series timer.
 */
export const useCreateSeriesTimer = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSeriesTimer>>,
    TError,
    { data: SeriesTimerInfoDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createSeriesTimer>>,
  TError,
  { data: SeriesTimerInfoDto },
  TContext
> => {
  const mutationOptions = getCreateSeriesTimerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a live tv series timer.
 */
export const getSeriesTimer = (timerId: string, signal?: AbortSignal) => {
  return apiInstance<SeriesTimerInfoDto>({
    url: `/LiveTv/SeriesTimers/${timerId}`,
    method: "GET",
    signal,
  });
};

export const getGetSeriesTimerQueryKey = (timerId: string) => {
  return [`/LiveTv/SeriesTimers/${timerId}`] as const;
};

export const getGetSeriesTimerQueryOptions = <
  TData = Awaited<ReturnType<typeof getSeriesTimer>>,
  TError = ErrorType<void | ProblemDetails>
>(
  timerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeriesTimer>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSeriesTimerQueryKey(timerId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeriesTimer>>> = ({
    signal,
  }) => getSeriesTimer(timerId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!timerId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSeriesTimer>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSeriesTimerQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSeriesTimer>>
>;
export type GetSeriesTimerQueryError = ErrorType<void | ProblemDetails>;

export function useGetSeriesTimer<
  TData = Awaited<ReturnType<typeof getSeriesTimer>>,
  TError = ErrorType<void | ProblemDetails>
>(
  timerId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeriesTimer>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSeriesTimer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSeriesTimer<
  TData = Awaited<ReturnType<typeof getSeriesTimer>>,
  TError = ErrorType<void | ProblemDetails>
>(
  timerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeriesTimer>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSeriesTimer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSeriesTimer<
  TData = Awaited<ReturnType<typeof getSeriesTimer>>,
  TError = ErrorType<void | ProblemDetails>
>(
  timerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeriesTimer>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a live tv series timer.
 */

export function useGetSeriesTimer<
  TData = Awaited<ReturnType<typeof getSeriesTimer>>,
  TError = ErrorType<void | ProblemDetails>
>(
  timerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeriesTimer>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSeriesTimerQueryOptions(timerId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Cancels a live tv series timer.
 */
export const cancelSeriesTimer = (timerId: string) => {
  return apiInstance<void>({
    url: `/LiveTv/SeriesTimers/${timerId}`,
    method: "DELETE",
  });
};

export const getCancelSeriesTimerMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelSeriesTimer>>,
    TError,
    { timerId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelSeriesTimer>>,
  TError,
  { timerId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelSeriesTimer>>,
    { timerId: string }
  > = (props) => {
    const { timerId } = props ?? {};

    return cancelSeriesTimer(timerId);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelSeriesTimerMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelSeriesTimer>>
>;

export type CancelSeriesTimerMutationError = ErrorType<void>;

/**
 * @summary Cancels a live tv series timer.
 */
export const useCancelSeriesTimer = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelSeriesTimer>>,
    TError,
    { timerId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof cancelSeriesTimer>>,
  TError,
  { timerId: string },
  TContext
> => {
  const mutationOptions = getCancelSeriesTimerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a live tv series timer.
 */
export const updateSeriesTimer = (
  timerId: string,
  seriesTimerInfoDto: SeriesTimerInfoDto
) => {
  return apiInstance<void>({
    url: `/LiveTv/SeriesTimers/${timerId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: seriesTimerInfoDto,
  });
};

export const getUpdateSeriesTimerMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSeriesTimer>>,
    TError,
    { timerId: string; data: SeriesTimerInfoDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSeriesTimer>>,
  TError,
  { timerId: string; data: SeriesTimerInfoDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSeriesTimer>>,
    { timerId: string; data: SeriesTimerInfoDto }
  > = (props) => {
    const { timerId, data } = props ?? {};

    return updateSeriesTimer(timerId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSeriesTimerMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSeriesTimer>>
>;
export type UpdateSeriesTimerMutationBody = SeriesTimerInfoDto;
export type UpdateSeriesTimerMutationError = ErrorType<void>;

/**
 * @summary Updates a live tv series timer.
 */
export const useUpdateSeriesTimer = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSeriesTimer>>,
    TError,
    { timerId: string; data: SeriesTimerInfoDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateSeriesTimer>>,
  TError,
  { timerId: string; data: SeriesTimerInfoDto },
  TContext
> => {
  const mutationOptions = getUpdateSeriesTimerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the live tv timers.
 */
export const getTimers = (params?: GetTimersParams, signal?: AbortSignal) => {
  return apiInstance<TimerInfoDtoQueryResult>({
    url: `/LiveTv/Timers`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetTimersQueryKey = (params?: GetTimersParams) => {
  return [`/LiveTv/Timers`, ...(params ? [params] : [])] as const;
};

export const getGetTimersQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimers>>,
  TError = ErrorType<void>
>(
  params?: GetTimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimers>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimers>>> = ({
    signal,
  }) => getTimers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTimers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetTimersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimers>>
>;
export type GetTimersQueryError = ErrorType<void>;

export function useGetTimers<
  TData = Awaited<ReturnType<typeof getTimers>>,
  TError = ErrorType<void>
>(
  params: undefined | GetTimersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTimers<
  TData = Awaited<ReturnType<typeof getTimers>>,
  TError = ErrorType<void>
>(
  params?: GetTimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTimers<
  TData = Awaited<ReturnType<typeof getTimers>>,
  TError = ErrorType<void>
>(
  params?: GetTimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimers>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the live tv timers.
 */

export function useGetTimers<
  TData = Awaited<ReturnType<typeof getTimers>>,
  TError = ErrorType<void>
>(
  params?: GetTimersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimers>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetTimersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates a live tv timer.
 */
export const createTimer = (timerInfoDto: TimerInfoDto) => {
  return apiInstance<void>({
    url: `/LiveTv/Timers`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: timerInfoDto,
  });
};

export const getCreateTimerMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTimer>>,
    TError,
    { data: TimerInfoDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTimer>>,
  TError,
  { data: TimerInfoDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTimer>>,
    { data: TimerInfoDto }
  > = (props) => {
    const { data } = props ?? {};

    return createTimer(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTimerMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTimer>>
>;
export type CreateTimerMutationBody = TimerInfoDto;
export type CreateTimerMutationError = ErrorType<void>;

/**
 * @summary Creates a live tv timer.
 */
export const useCreateTimer = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTimer>>,
    TError,
    { data: TimerInfoDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createTimer>>,
  TError,
  { data: TimerInfoDto },
  TContext
> => {
  const mutationOptions = getCreateTimerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a timer.
 */
export const getTimer = (timerId: string, signal?: AbortSignal) => {
  return apiInstance<TimerInfoDto>({
    url: `/LiveTv/Timers/${timerId}`,
    method: "GET",
    signal,
  });
};

export const getGetTimerQueryKey = (timerId: string) => {
  return [`/LiveTv/Timers/${timerId}`] as const;
};

export const getGetTimerQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimer>>,
  TError = ErrorType<void>
>(
  timerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimer>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimerQueryKey(timerId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimer>>> = ({
    signal,
  }) => getTimer(timerId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!timerId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getTimer>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetTimerQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimer>>
>;
export type GetTimerQueryError = ErrorType<void>;

export function useGetTimer<
  TData = Awaited<ReturnType<typeof getTimer>>,
  TError = ErrorType<void>
>(
  timerId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimer>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTimer<
  TData = Awaited<ReturnType<typeof getTimer>>,
  TError = ErrorType<void>
>(
  timerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimer>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTimer<
  TData = Awaited<ReturnType<typeof getTimer>>,
  TError = ErrorType<void>
>(
  timerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimer>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a timer.
 */

export function useGetTimer<
  TData = Awaited<ReturnType<typeof getTimer>>,
  TError = ErrorType<void>
>(
  timerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimer>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetTimerQueryOptions(timerId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Cancels a live tv timer.
 */
export const cancelTimer = (timerId: string) => {
  return apiInstance<void>({
    url: `/LiveTv/Timers/${timerId}`,
    method: "DELETE",
  });
};

export const getCancelTimerMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelTimer>>,
    TError,
    { timerId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelTimer>>,
  TError,
  { timerId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelTimer>>,
    { timerId: string }
  > = (props) => {
    const { timerId } = props ?? {};

    return cancelTimer(timerId);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelTimerMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelTimer>>
>;

export type CancelTimerMutationError = ErrorType<void>;

/**
 * @summary Cancels a live tv timer.
 */
export const useCancelTimer = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelTimer>>,
    TError,
    { timerId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof cancelTimer>>,
  TError,
  { timerId: string },
  TContext
> => {
  const mutationOptions = getCancelTimerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a live tv timer.
 */
export const updateTimer = (timerId: string, timerInfoDto: TimerInfoDto) => {
  return apiInstance<void>({
    url: `/LiveTv/Timers/${timerId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: timerInfoDto,
  });
};

export const getUpdateTimerMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTimer>>,
    TError,
    { timerId: string; data: TimerInfoDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTimer>>,
  TError,
  { timerId: string; data: TimerInfoDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTimer>>,
    { timerId: string; data: TimerInfoDto }
  > = (props) => {
    const { timerId, data } = props ?? {};

    return updateTimer(timerId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTimerMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTimer>>
>;
export type UpdateTimerMutationBody = TimerInfoDto;
export type UpdateTimerMutationError = ErrorType<void>;

/**
 * @summary Updates a live tv timer.
 */
export const useUpdateTimer = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTimer>>,
    TError,
    { timerId: string; data: TimerInfoDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateTimer>>,
  TError,
  { timerId: string; data: TimerInfoDto },
  TContext
> => {
  const mutationOptions = getUpdateTimerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the default values for a new timer.
 */
export const getDefaultTimer = (
  params?: GetDefaultTimerParams,
  signal?: AbortSignal
) => {
  return apiInstance<SeriesTimerInfoDto>({
    url: `/LiveTv/Timers/Defaults`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDefaultTimerQueryKey = (params?: GetDefaultTimerParams) => {
  return [`/LiveTv/Timers/Defaults`, ...(params ? [params] : [])] as const;
};

export const getGetDefaultTimerQueryOptions = <
  TData = Awaited<ReturnType<typeof getDefaultTimer>>,
  TError = ErrorType<void>
>(
  params?: GetDefaultTimerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDefaultTimer>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultTimerQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultTimer>>> = ({
    signal,
  }) => getDefaultTimer(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDefaultTimer>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDefaultTimerQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDefaultTimer>>
>;
export type GetDefaultTimerQueryError = ErrorType<void>;

export function useGetDefaultTimer<
  TData = Awaited<ReturnType<typeof getDefaultTimer>>,
  TError = ErrorType<void>
>(
  params: undefined | GetDefaultTimerParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDefaultTimer>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultTimer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultTimer<
  TData = Awaited<ReturnType<typeof getDefaultTimer>>,
  TError = ErrorType<void>
>(
  params?: GetDefaultTimerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDefaultTimer>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultTimer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetDefaultTimer<
  TData = Awaited<ReturnType<typeof getDefaultTimer>>,
  TError = ErrorType<void>
>(
  params?: GetDefaultTimerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDefaultTimer>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the default values for a new timer.
 */

export function useGetDefaultTimer<
  TData = Awaited<ReturnType<typeof getDefaultTimer>>,
  TError = ErrorType<void>
>(
  params?: GetDefaultTimerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDefaultTimer>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDefaultTimerQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Adds a tuner host.
 */
export const addTunerHost = (tunerHostInfo: TunerHostInfo) => {
  return apiInstance<TunerHostInfo>({
    url: `/LiveTv/TunerHosts`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: tunerHostInfo,
  });
};

export const getAddTunerHostMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addTunerHost>>,
    TError,
    { data: TunerHostInfo },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addTunerHost>>,
  TError,
  { data: TunerHostInfo },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addTunerHost>>,
    { data: TunerHostInfo }
  > = (props) => {
    const { data } = props ?? {};

    return addTunerHost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddTunerHostMutationResult = NonNullable<
  Awaited<ReturnType<typeof addTunerHost>>
>;
export type AddTunerHostMutationBody = TunerHostInfo;
export type AddTunerHostMutationError = ErrorType<void>;

/**
 * @summary Adds a tuner host.
 */
export const useAddTunerHost = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addTunerHost>>,
    TError,
    { data: TunerHostInfo },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof addTunerHost>>,
  TError,
  { data: TunerHostInfo },
  TContext
> => {
  const mutationOptions = getAddTunerHostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Deletes a tuner host.
 */
export const deleteTunerHost = (params?: DeleteTunerHostParams) => {
  return apiInstance<void>({
    url: `/LiveTv/TunerHosts`,
    method: "DELETE",
    params,
  });
};

export const getDeleteTunerHostMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTunerHost>>,
    TError,
    { params?: DeleteTunerHostParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTunerHost>>,
  TError,
  { params?: DeleteTunerHostParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTunerHost>>,
    { params?: DeleteTunerHostParams }
  > = (props) => {
    const { params } = props ?? {};

    return deleteTunerHost(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTunerHostMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTunerHost>>
>;

export type DeleteTunerHostMutationError = ErrorType<void>;

/**
 * @summary Deletes a tuner host.
 */
export const useDeleteTunerHost = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTunerHost>>,
    TError,
    { params?: DeleteTunerHostParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteTunerHost>>,
  TError,
  { params?: DeleteTunerHostParams },
  TContext
> => {
  const mutationOptions = getDeleteTunerHostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get tuner host types.
 */
export const getTunerHostTypes = (signal?: AbortSignal) => {
  return apiInstance<NameIdPair[]>({
    url: `/LiveTv/TunerHosts/Types`,
    method: "GET",
    signal,
  });
};

export const getGetTunerHostTypesQueryKey = () => {
  return [`/LiveTv/TunerHosts/Types`] as const;
};

export const getGetTunerHostTypesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTunerHostTypes>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getTunerHostTypes>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTunerHostTypesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTunerHostTypes>>
  > = ({ signal }) => getTunerHostTypes(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTunerHostTypes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetTunerHostTypesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTunerHostTypes>>
>;
export type GetTunerHostTypesQueryError = ErrorType<void>;

export function useGetTunerHostTypes<
  TData = Awaited<ReturnType<typeof getTunerHostTypes>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getTunerHostTypes>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getTunerHostTypes>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTunerHostTypes<
  TData = Awaited<ReturnType<typeof getTunerHostTypes>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getTunerHostTypes>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getTunerHostTypes>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTunerHostTypes<
  TData = Awaited<ReturnType<typeof getTunerHostTypes>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getTunerHostTypes>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get tuner host types.
 */

export function useGetTunerHostTypes<
  TData = Awaited<ReturnType<typeof getTunerHostTypes>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getTunerHostTypes>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetTunerHostTypesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Resets a tv tuner.
 */
export const resetTuner = (tunerId: string) => {
  return apiInstance<void>({
    url: `/LiveTv/Tuners/${tunerId}/Reset`,
    method: "POST",
  });
};

export const getResetTunerMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetTuner>>,
    TError,
    { tunerId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetTuner>>,
  TError,
  { tunerId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetTuner>>,
    { tunerId: string }
  > = (props) => {
    const { tunerId } = props ?? {};

    return resetTuner(tunerId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetTunerMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetTuner>>
>;

export type ResetTunerMutationError = ErrorType<void>;

/**
 * @summary Resets a tv tuner.
 */
export const useResetTuner = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetTuner>>,
    TError,
    { tunerId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof resetTuner>>,
  TError,
  { tunerId: string },
  TContext
> => {
  const mutationOptions = getResetTunerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Discover tuners.
 */
export const discoverTuners = (
  params?: DiscoverTunersParams,
  signal?: AbortSignal
) => {
  return apiInstance<TunerHostInfo[]>({
    url: `/LiveTv/Tuners/Discover`,
    method: "GET",
    params,
    signal,
  });
};

export const getDiscoverTunersQueryKey = (params?: DiscoverTunersParams) => {
  return [`/LiveTv/Tuners/Discover`, ...(params ? [params] : [])] as const;
};

export const getDiscoverTunersQueryOptions = <
  TData = Awaited<ReturnType<typeof discoverTuners>>,
  TError = ErrorType<void>
>(
  params?: DiscoverTunersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof discoverTuners>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDiscoverTunersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof discoverTuners>>> = ({
    signal,
  }) => discoverTuners(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof discoverTuners>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DiscoverTunersQueryResult = NonNullable<
  Awaited<ReturnType<typeof discoverTuners>>
>;
export type DiscoverTunersQueryError = ErrorType<void>;

export function useDiscoverTuners<
  TData = Awaited<ReturnType<typeof discoverTuners>>,
  TError = ErrorType<void>
>(
  params: undefined | DiscoverTunersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof discoverTuners>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof discoverTuners>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useDiscoverTuners<
  TData = Awaited<ReturnType<typeof discoverTuners>>,
  TError = ErrorType<void>
>(
  params?: DiscoverTunersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof discoverTuners>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof discoverTuners>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useDiscoverTuners<
  TData = Awaited<ReturnType<typeof discoverTuners>>,
  TError = ErrorType<void>
>(
  params?: DiscoverTunersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof discoverTuners>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Discover tuners.
 */

export function useDiscoverTuners<
  TData = Awaited<ReturnType<typeof discoverTuners>>,
  TError = ErrorType<void>
>(
  params?: DiscoverTunersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof discoverTuners>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDiscoverTunersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Discover tuners.
 */
export const discvoverTuners = (
  params?: DiscvoverTunersParams,
  signal?: AbortSignal
) => {
  return apiInstance<TunerHostInfo[]>({
    url: `/LiveTv/Tuners/Discvover`,
    method: "GET",
    params,
    signal,
  });
};

export const getDiscvoverTunersQueryKey = (params?: DiscvoverTunersParams) => {
  return [`/LiveTv/Tuners/Discvover`, ...(params ? [params] : [])] as const;
};

export const getDiscvoverTunersQueryOptions = <
  TData = Awaited<ReturnType<typeof discvoverTuners>>,
  TError = ErrorType<void>
>(
  params?: DiscvoverTunersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof discvoverTuners>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDiscvoverTunersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof discvoverTuners>>> = ({
    signal,
  }) => discvoverTuners(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof discvoverTuners>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type DiscvoverTunersQueryResult = NonNullable<
  Awaited<ReturnType<typeof discvoverTuners>>
>;
export type DiscvoverTunersQueryError = ErrorType<void>;

export function useDiscvoverTuners<
  TData = Awaited<ReturnType<typeof discvoverTuners>>,
  TError = ErrorType<void>
>(
  params: undefined | DiscvoverTunersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof discvoverTuners>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof discvoverTuners>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useDiscvoverTuners<
  TData = Awaited<ReturnType<typeof discvoverTuners>>,
  TError = ErrorType<void>
>(
  params?: DiscvoverTunersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof discvoverTuners>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof discvoverTuners>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useDiscvoverTuners<
  TData = Awaited<ReturnType<typeof discvoverTuners>>,
  TError = ErrorType<void>
>(
  params?: DiscvoverTunersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof discvoverTuners>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Discover tuners.
 */

export function useDiscvoverTuners<
  TData = Awaited<ReturnType<typeof discvoverTuners>>,
  TError = ErrorType<void>
>(
  params?: DiscvoverTunersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof discvoverTuners>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getDiscvoverTunersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets known countries.
 */
export const getCountries = (signal?: AbortSignal) => {
  return apiInstance<CountryInfo[]>({
    url: `/Localization/Countries`,
    method: "GET",
    signal,
  });
};

export const getGetCountriesQueryKey = () => {
  return [`/Localization/Countries`] as const;
};

export const getGetCountriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getCountries>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCountries>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCountriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCountries>>> = ({
    signal,
  }) => getCountries(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCountries>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCountriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCountries>>
>;
export type GetCountriesQueryError = ErrorType<void>;

export function useGetCountries<
  TData = Awaited<ReturnType<typeof getCountries>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCountries>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCountries>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetCountries<
  TData = Awaited<ReturnType<typeof getCountries>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCountries>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCountries>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetCountries<
  TData = Awaited<ReturnType<typeof getCountries>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCountries>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets known countries.
 */

export function useGetCountries<
  TData = Awaited<ReturnType<typeof getCountries>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCountries>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetCountriesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets known cultures.
 */
export const getCultures = (signal?: AbortSignal) => {
  return apiInstance<CultureDto[]>({
    url: `/Localization/Cultures`,
    method: "GET",
    signal,
  });
};

export const getGetCulturesQueryKey = () => {
  return [`/Localization/Cultures`] as const;
};

export const getGetCulturesQueryOptions = <
  TData = Awaited<ReturnType<typeof getCultures>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCultures>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCulturesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCultures>>> = ({
    signal,
  }) => getCultures(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCultures>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCulturesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCultures>>
>;
export type GetCulturesQueryError = ErrorType<void>;

export function useGetCultures<
  TData = Awaited<ReturnType<typeof getCultures>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCultures>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCultures>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetCultures<
  TData = Awaited<ReturnType<typeof getCultures>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCultures>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCultures>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetCultures<
  TData = Awaited<ReturnType<typeof getCultures>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCultures>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets known cultures.
 */

export function useGetCultures<
  TData = Awaited<ReturnType<typeof getCultures>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCultures>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetCulturesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets localization options.
 */
export const getLocalizationOptions = (signal?: AbortSignal) => {
  return apiInstance<LocalizationOption[]>({
    url: `/Localization/Options`,
    method: "GET",
    signal,
  });
};

export const getGetLocalizationOptionsQueryKey = () => {
  return [`/Localization/Options`] as const;
};

export const getGetLocalizationOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLocalizationOptions>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLocalizationOptions>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLocalizationOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLocalizationOptions>>
  > = ({ signal }) => getLocalizationOptions(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLocalizationOptions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLocalizationOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLocalizationOptions>>
>;
export type GetLocalizationOptionsQueryError = ErrorType<void>;

export function useGetLocalizationOptions<
  TData = Awaited<ReturnType<typeof getLocalizationOptions>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLocalizationOptions>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getLocalizationOptions>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLocalizationOptions<
  TData = Awaited<ReturnType<typeof getLocalizationOptions>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLocalizationOptions>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getLocalizationOptions>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLocalizationOptions<
  TData = Awaited<ReturnType<typeof getLocalizationOptions>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLocalizationOptions>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets localization options.
 */

export function useGetLocalizationOptions<
  TData = Awaited<ReturnType<typeof getLocalizationOptions>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLocalizationOptions>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLocalizationOptionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets known parental ratings.
 */
export const getParentalRatings = (signal?: AbortSignal) => {
  return apiInstance<ParentalRating[]>({
    url: `/Localization/ParentalRatings`,
    method: "GET",
    signal,
  });
};

export const getGetParentalRatingsQueryKey = () => {
  return [`/Localization/ParentalRatings`] as const;
};

export const getGetParentalRatingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getParentalRatings>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getParentalRatings>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetParentalRatingsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getParentalRatings>>
  > = ({ signal }) => getParentalRatings(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getParentalRatings>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetParentalRatingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getParentalRatings>>
>;
export type GetParentalRatingsQueryError = ErrorType<void>;

export function useGetParentalRatings<
  TData = Awaited<ReturnType<typeof getParentalRatings>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getParentalRatings>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getParentalRatings>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetParentalRatings<
  TData = Awaited<ReturnType<typeof getParentalRatings>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getParentalRatings>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getParentalRatings>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetParentalRatings<
  TData = Awaited<ReturnType<typeof getParentalRatings>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getParentalRatings>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets known parental ratings.
 */

export function useGetParentalRatings<
  TData = Awaited<ReturnType<typeof getParentalRatings>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getParentalRatings>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetParentalRatingsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets live playback media info for an item.
 */
export const getPlaybackInfo = (
  itemId: string,
  params: GetPlaybackInfoParams,
  signal?: AbortSignal
) => {
  return apiInstance<PlaybackInfoResponse>({
    url: `/Items/${itemId}/PlaybackInfo`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPlaybackInfoQueryKey = (
  itemId: string,
  params: GetPlaybackInfoParams
) => {
  return [
    `/Items/${itemId}/PlaybackInfo`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetPlaybackInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlaybackInfo>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetPlaybackInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaybackInfo>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPlaybackInfoQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlaybackInfo>>> = ({
    signal,
  }) => getPlaybackInfo(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlaybackInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPlaybackInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlaybackInfo>>
>;
export type GetPlaybackInfoQueryError = ErrorType<void>;

export function useGetPlaybackInfo<
  TData = Awaited<ReturnType<typeof getPlaybackInfo>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetPlaybackInfoParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaybackInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlaybackInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPlaybackInfo<
  TData = Awaited<ReturnType<typeof getPlaybackInfo>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetPlaybackInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaybackInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlaybackInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPlaybackInfo<
  TData = Awaited<ReturnType<typeof getPlaybackInfo>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetPlaybackInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaybackInfo>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets live playback media info for an item.
 */

export function useGetPlaybackInfo<
  TData = Awaited<ReturnType<typeof getPlaybackInfo>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: GetPlaybackInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaybackInfo>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPlaybackInfoQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
Query parameters are obsolete.
 * @summary Gets live playback media info for an item.
 */
export const getPostedPlaybackInfo = (
  itemId: string,
  playbackInfoDto: PlaybackInfoDto,
  params?: GetPostedPlaybackInfoParams
) => {
  return apiInstance<PlaybackInfoResponse>({
    url: `/Items/${itemId}/PlaybackInfo`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: playbackInfoDto,
    params,
  });
};

export const getGetPostedPlaybackInfoMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPostedPlaybackInfo>>,
    TError,
    {
      itemId: string;
      data: PlaybackInfoDto;
      params?: GetPostedPlaybackInfoParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getPostedPlaybackInfo>>,
  TError,
  {
    itemId: string;
    data: PlaybackInfoDto;
    params?: GetPostedPlaybackInfoParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getPostedPlaybackInfo>>,
    {
      itemId: string;
      data: PlaybackInfoDto;
      params?: GetPostedPlaybackInfoParams;
    }
  > = (props) => {
    const { itemId, data, params } = props ?? {};

    return getPostedPlaybackInfo(itemId, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetPostedPlaybackInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof getPostedPlaybackInfo>>
>;
export type GetPostedPlaybackInfoMutationBody = PlaybackInfoDto;
export type GetPostedPlaybackInfoMutationError = ErrorType<void>;

/**
 * @summary Gets live playback media info for an item.
 */
export const useGetPostedPlaybackInfo = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPostedPlaybackInfo>>,
    TError,
    {
      itemId: string;
      data: PlaybackInfoDto;
      params?: GetPostedPlaybackInfoParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getPostedPlaybackInfo>>,
  TError,
  {
    itemId: string;
    data: PlaybackInfoDto;
    params?: GetPostedPlaybackInfoParams;
  },
  TContext
> => {
  const mutationOptions = getGetPostedPlaybackInfoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Closes a media source.
 */
export const closeLiveStream = (params: CloseLiveStreamParams) => {
  return apiInstance<void>({
    url: `/LiveStreams/Close`,
    method: "POST",
    params,
  });
};

export const getCloseLiveStreamMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof closeLiveStream>>,
    TError,
    { params: CloseLiveStreamParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof closeLiveStream>>,
  TError,
  { params: CloseLiveStreamParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof closeLiveStream>>,
    { params: CloseLiveStreamParams }
  > = (props) => {
    const { params } = props ?? {};

    return closeLiveStream(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CloseLiveStreamMutationResult = NonNullable<
  Awaited<ReturnType<typeof closeLiveStream>>
>;

export type CloseLiveStreamMutationError = ErrorType<void>;

/**
 * @summary Closes a media source.
 */
export const useCloseLiveStream = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof closeLiveStream>>,
    TError,
    { params: CloseLiveStreamParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof closeLiveStream>>,
  TError,
  { params: CloseLiveStreamParams },
  TContext
> => {
  const mutationOptions = getCloseLiveStreamMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Opens a media source.
 */
export const openLiveStream = (
  openLiveStreamDto: OpenLiveStreamDto,
  params?: OpenLiveStreamParams
) => {
  return apiInstance<LiveStreamResponse>({
    url: `/LiveStreams/Open`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: openLiveStreamDto,
    params,
  });
};

export const getOpenLiveStreamMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof openLiveStream>>,
    TError,
    { data: OpenLiveStreamDto; params?: OpenLiveStreamParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof openLiveStream>>,
  TError,
  { data: OpenLiveStreamDto; params?: OpenLiveStreamParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof openLiveStream>>,
    { data: OpenLiveStreamDto; params?: OpenLiveStreamParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return openLiveStream(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type OpenLiveStreamMutationResult = NonNullable<
  Awaited<ReturnType<typeof openLiveStream>>
>;
export type OpenLiveStreamMutationBody = OpenLiveStreamDto;
export type OpenLiveStreamMutationError = ErrorType<void>;

/**
 * @summary Opens a media source.
 */
export const useOpenLiveStream = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof openLiveStream>>,
    TError,
    { data: OpenLiveStreamDto; params?: OpenLiveStreamParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof openLiveStream>>,
  TError,
  { data: OpenLiveStreamDto; params?: OpenLiveStreamParams },
  TContext
> => {
  const mutationOptions = getOpenLiveStreamMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Tests the network with a request with the size of the bitrate.
 */
export const getBitrateTestBytes = (
  params?: GetBitrateTestBytesParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Playback/BitrateTest`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetBitrateTestBytesQueryKey = (
  params?: GetBitrateTestBytesParams
) => {
  return [`/Playback/BitrateTest`, ...(params ? [params] : [])] as const;
};

export const getGetBitrateTestBytesQueryOptions = <
  TData = Awaited<ReturnType<typeof getBitrateTestBytes>>,
  TError = ErrorType<void>
>(
  params?: GetBitrateTestBytesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBitrateTestBytes>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetBitrateTestBytesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBitrateTestBytes>>
  > = ({ signal }) => getBitrateTestBytes(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBitrateTestBytes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetBitrateTestBytesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBitrateTestBytes>>
>;
export type GetBitrateTestBytesQueryError = ErrorType<void>;

export function useGetBitrateTestBytes<
  TData = Awaited<ReturnType<typeof getBitrateTestBytes>>,
  TError = ErrorType<void>
>(
  params: undefined | GetBitrateTestBytesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBitrateTestBytes>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBitrateTestBytes>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetBitrateTestBytes<
  TData = Awaited<ReturnType<typeof getBitrateTestBytes>>,
  TError = ErrorType<void>
>(
  params?: GetBitrateTestBytesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBitrateTestBytes>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBitrateTestBytes>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetBitrateTestBytes<
  TData = Awaited<ReturnType<typeof getBitrateTestBytes>>,
  TError = ErrorType<void>
>(
  params?: GetBitrateTestBytesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBitrateTestBytes>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Tests the network with a request with the size of the bitrate.
 */

export function useGetBitrateTestBytes<
  TData = Awaited<ReturnType<typeof getBitrateTestBytes>>,
  TError = ErrorType<void>
>(
  params?: GetBitrateTestBytesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBitrateTestBytes>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetBitrateTestBytesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets movie recommendations.
 */
export const getMovieRecommendations = (
  params?: GetMovieRecommendationsParams,
  signal?: AbortSignal
) => {
  return apiInstance<RecommendationDto[]>({
    url: `/Movies/Recommendations`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetMovieRecommendationsQueryKey = (
  params?: GetMovieRecommendationsParams
) => {
  return [`/Movies/Recommendations`, ...(params ? [params] : [])] as const;
};

export const getGetMovieRecommendationsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMovieRecommendations>>,
  TError = ErrorType<void>
>(
  params?: GetMovieRecommendationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMovieRecommendations>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMovieRecommendationsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMovieRecommendations>>
  > = ({ signal }) => getMovieRecommendations(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMovieRecommendations>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMovieRecommendationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMovieRecommendations>>
>;
export type GetMovieRecommendationsQueryError = ErrorType<void>;

export function useGetMovieRecommendations<
  TData = Awaited<ReturnType<typeof getMovieRecommendations>>,
  TError = ErrorType<void>
>(
  params: undefined | GetMovieRecommendationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMovieRecommendations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMovieRecommendations>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMovieRecommendations<
  TData = Awaited<ReturnType<typeof getMovieRecommendations>>,
  TError = ErrorType<void>
>(
  params?: GetMovieRecommendationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMovieRecommendations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMovieRecommendations>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMovieRecommendations<
  TData = Awaited<ReturnType<typeof getMovieRecommendations>>,
  TError = ErrorType<void>
>(
  params?: GetMovieRecommendationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMovieRecommendations>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets movie recommendations.
 */

export function useGetMovieRecommendations<
  TData = Awaited<ReturnType<typeof getMovieRecommendations>>,
  TError = ErrorType<void>
>(
  params?: GetMovieRecommendationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMovieRecommendations>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMovieRecommendationsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @deprecated
 * @summary Gets all music genres from a given item, folder, or the entire library.
 */
export const getMusicGenres = (
  params?: GetMusicGenresParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/MusicGenres`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetMusicGenresQueryKey = (params?: GetMusicGenresParams) => {
  return [`/MusicGenres`, ...(params ? [params] : [])] as const;
};

export const getGetMusicGenresQueryOptions = <
  TData = Awaited<ReturnType<typeof getMusicGenres>>,
  TError = ErrorType<void>
>(
  params?: GetMusicGenresParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenres>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMusicGenresQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMusicGenres>>> = ({
    signal,
  }) => getMusicGenres(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMusicGenres>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMusicGenresQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMusicGenres>>
>;
export type GetMusicGenresQueryError = ErrorType<void>;

export function useGetMusicGenres<
  TData = Awaited<ReturnType<typeof getMusicGenres>>,
  TError = ErrorType<void>
>(
  params: undefined | GetMusicGenresParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenres>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMusicGenres>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMusicGenres<
  TData = Awaited<ReturnType<typeof getMusicGenres>>,
  TError = ErrorType<void>
>(
  params?: GetMusicGenresParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenres>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMusicGenres>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMusicGenres<
  TData = Awaited<ReturnType<typeof getMusicGenres>>,
  TError = ErrorType<void>
>(
  params?: GetMusicGenresParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenres>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @deprecated
 * @summary Gets all music genres from a given item, folder, or the entire library.
 */

export function useGetMusicGenres<
  TData = Awaited<ReturnType<typeof getMusicGenres>>,
  TError = ErrorType<void>
>(
  params?: GetMusicGenresParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenres>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMusicGenresQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a music genre, by name.
 */
export const getMusicGenre = (
  genreName: string,
  params?: GetMusicGenreParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/MusicGenres/${genreName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetMusicGenreQueryKey = (
  genreName: string,
  params?: GetMusicGenreParams
) => {
  return [`/MusicGenres/${genreName}`, ...(params ? [params] : [])] as const;
};

export const getGetMusicGenreQueryOptions = <
  TData = Awaited<ReturnType<typeof getMusicGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params?: GetMusicGenreParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenre>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMusicGenreQueryKey(genreName, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMusicGenre>>> = ({
    signal,
  }) => getMusicGenre(genreName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!genreName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMusicGenre>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMusicGenreQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMusicGenre>>
>;
export type GetMusicGenreQueryError = ErrorType<void>;

export function useGetMusicGenre<
  TData = Awaited<ReturnType<typeof getMusicGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params: undefined | GetMusicGenreParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenre>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMusicGenre>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMusicGenre<
  TData = Awaited<ReturnType<typeof getMusicGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params?: GetMusicGenreParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenre>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMusicGenre>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetMusicGenre<
  TData = Awaited<ReturnType<typeof getMusicGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params?: GetMusicGenreParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenre>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a music genre, by name.
 */

export function useGetMusicGenre<
  TData = Awaited<ReturnType<typeof getMusicGenre>>,
  TError = ErrorType<void>
>(
  genreName: string,
  params?: GetMusicGenreParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMusicGenre>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMusicGenreQueryOptions(genreName, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a user's notifications.
 */
export const getNotifications = (userId: string, signal?: AbortSignal) => {
  return apiInstance<NotificationResultDto>({
    url: `/Notifications/${userId}`,
    method: "GET",
    signal,
  });
};

export const getGetNotificationsQueryKey = (userId: string) => {
  return [`/Notifications/${userId}`] as const;
};

export const getGetNotificationsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNotificationsQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNotifications>>
  > = ({ signal }) => getNotifications(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotifications>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNotificationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNotifications>>
>;
export type GetNotificationsQueryError = ErrorType<void>;

export function useGetNotifications<
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = ErrorType<void>
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNotifications<
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNotifications<
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a user's notifications.
 */

export function useGetNotifications<
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetNotificationsQueryOptions(userId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Sets notifications as read.
 */
export const setRead = (userId: string) => {
  return apiInstance<void>({
    url: `/Notifications/${userId}/Read`,
    method: "POST",
  });
};

export const getSetReadMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setRead>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setRead>>,
  TError,
  { userId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setRead>>,
    { userId: string }
  > = (props) => {
    const { userId } = props ?? {};

    return setRead(userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetReadMutationResult = NonNullable<
  Awaited<ReturnType<typeof setRead>>
>;

export type SetReadMutationError = ErrorType<void>;

/**
 * @summary Sets notifications as read.
 */
export const useSetRead = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setRead>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof setRead>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationOptions = getSetReadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a user's notification summary.
 */
export const getNotificationsSummary = (
  userId: string,
  signal?: AbortSignal
) => {
  return apiInstance<NotificationsSummaryDto>({
    url: `/Notifications/${userId}/Summary`,
    method: "GET",
    signal,
  });
};

export const getGetNotificationsSummaryQueryKey = (userId: string) => {
  return [`/Notifications/${userId}/Summary`] as const;
};

export const getGetNotificationsSummaryQueryOptions = <
  TData = Awaited<ReturnType<typeof getNotificationsSummary>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsSummary>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNotificationsSummaryQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNotificationsSummary>>
  > = ({ signal }) => getNotificationsSummary(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotificationsSummary>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNotificationsSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNotificationsSummary>>
>;
export type GetNotificationsSummaryQueryError = ErrorType<void>;

export function useGetNotificationsSummary<
  TData = Awaited<ReturnType<typeof getNotificationsSummary>>,
  TError = ErrorType<void>
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsSummary>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationsSummary>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNotificationsSummary<
  TData = Awaited<ReturnType<typeof getNotificationsSummary>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsSummary>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationsSummary>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNotificationsSummary<
  TData = Awaited<ReturnType<typeof getNotificationsSummary>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsSummary>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a user's notification summary.
 */

export function useGetNotificationsSummary<
  TData = Awaited<ReturnType<typeof getNotificationsSummary>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsSummary>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetNotificationsSummaryQueryOptions(userId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Sets notifications as unread.
 */
export const setUnread = (userId: string) => {
  return apiInstance<void>({
    url: `/Notifications/${userId}/Unread`,
    method: "POST",
  });
};

export const getSetUnreadMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setUnread>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setUnread>>,
  TError,
  { userId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setUnread>>,
    { userId: string }
  > = (props) => {
    const { userId } = props ?? {};

    return setUnread(userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetUnreadMutationResult = NonNullable<
  Awaited<ReturnType<typeof setUnread>>
>;

export type SetUnreadMutationError = ErrorType<void>;

/**
 * @summary Sets notifications as unread.
 */
export const useSetUnread = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setUnread>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof setUnread>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationOptions = getSetUnreadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Sends a notification to all admins.
 */
export const createAdminNotification = (
  adminNotificationDto: AdminNotificationDto
) => {
  return apiInstance<void>({
    url: `/Notifications/Admin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminNotificationDto,
  });
};

export const getCreateAdminNotificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAdminNotification>>,
    TError,
    { data: AdminNotificationDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAdminNotification>>,
  TError,
  { data: AdminNotificationDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAdminNotification>>,
    { data: AdminNotificationDto }
  > = (props) => {
    const { data } = props ?? {};

    return createAdminNotification(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAdminNotificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAdminNotification>>
>;
export type CreateAdminNotificationMutationBody = AdminNotificationDto;
export type CreateAdminNotificationMutationError = ErrorType<void>;

/**
 * @summary Sends a notification to all admins.
 */
export const useCreateAdminNotification = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAdminNotification>>,
    TError,
    { data: AdminNotificationDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createAdminNotification>>,
  TError,
  { data: AdminNotificationDto },
  TContext
> => {
  const mutationOptions = getCreateAdminNotificationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets notification services.
 */
export const getNotificationServices = (signal?: AbortSignal) => {
  return apiInstance<NameIdPair[]>({
    url: `/Notifications/Services`,
    method: "GET",
    signal,
  });
};

export const getGetNotificationServicesQueryKey = () => {
  return [`/Notifications/Services`] as const;
};

export const getGetNotificationServicesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNotificationServices>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationServices>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNotificationServicesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNotificationServices>>
  > = ({ signal }) => getNotificationServices(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotificationServices>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNotificationServicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNotificationServices>>
>;
export type GetNotificationServicesQueryError = ErrorType<void>;

export function useGetNotificationServices<
  TData = Awaited<ReturnType<typeof getNotificationServices>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationServices>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNotificationServices>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNotificationServices<
  TData = Awaited<ReturnType<typeof getNotificationServices>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationServices>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNotificationServices>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNotificationServices<
  TData = Awaited<ReturnType<typeof getNotificationServices>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationServices>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets notification services.
 */

export function useGetNotificationServices<
  TData = Awaited<ReturnType<typeof getNotificationServices>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationServices>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetNotificationServicesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets notification types.
 */
export const getNotificationTypes = (signal?: AbortSignal) => {
  return apiInstance<NotificationTypeInfo[]>({
    url: `/Notifications/Types`,
    method: "GET",
    signal,
  });
};

export const getGetNotificationTypesQueryKey = () => {
  return [`/Notifications/Types`] as const;
};

export const getGetNotificationTypesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNotificationTypes>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationTypes>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationTypesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNotificationTypes>>
  > = ({ signal }) => getNotificationTypes(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotificationTypes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNotificationTypesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNotificationTypes>>
>;
export type GetNotificationTypesQueryError = ErrorType<void>;

export function useGetNotificationTypes<
  TData = Awaited<ReturnType<typeof getNotificationTypes>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationTypes>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNotificationTypes>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNotificationTypes<
  TData = Awaited<ReturnType<typeof getNotificationTypes>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationTypes>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNotificationTypes>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNotificationTypes<
  TData = Awaited<ReturnType<typeof getNotificationTypes>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationTypes>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets notification types.
 */

export function useGetNotificationTypes<
  TData = Awaited<ReturnType<typeof getNotificationTypes>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationTypes>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetNotificationTypesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets available packages.
 */
export const getPackages = (signal?: AbortSignal) => {
  return apiInstance<PackageInfo[]>({
    url: `/Packages`,
    method: "GET",
    signal,
  });
};

export const getGetPackagesQueryKey = () => {
  return [`/Packages`] as const;
};

export const getGetPackagesQueryOptions = <
  TData = Awaited<ReturnType<typeof getPackages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPackages>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPackagesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPackages>>> = ({
    signal,
  }) => getPackages(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPackages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPackagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPackages>>
>;
export type GetPackagesQueryError = ErrorType<void>;

export function useGetPackages<
  TData = Awaited<ReturnType<typeof getPackages>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPackages>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPackages>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPackages<
  TData = Awaited<ReturnType<typeof getPackages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPackages>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPackages>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPackages<
  TData = Awaited<ReturnType<typeof getPackages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPackages>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available packages.
 */

export function useGetPackages<
  TData = Awaited<ReturnType<typeof getPackages>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPackages>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPackagesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a package by name or assembly GUID.
 */
export const getPackageInfo = (
  name: string,
  params?: GetPackageInfoParams,
  signal?: AbortSignal
) => {
  return apiInstance<PackageInfo>({
    url: `/Packages/${name}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPackageInfoQueryKey = (
  name: string,
  params?: GetPackageInfoParams
) => {
  return [`/Packages/${name}`, ...(params ? [params] : [])] as const;
};

export const getGetPackageInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getPackageInfo>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetPackageInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPackageInfo>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPackageInfoQueryKey(name, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPackageInfo>>> = ({
    signal,
  }) => getPackageInfo(name, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPackageInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPackageInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPackageInfo>>
>;
export type GetPackageInfoQueryError = ErrorType<void>;

export function useGetPackageInfo<
  TData = Awaited<ReturnType<typeof getPackageInfo>>,
  TError = ErrorType<void>
>(
  name: string,
  params: undefined | GetPackageInfoParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPackageInfo>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPackageInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPackageInfo<
  TData = Awaited<ReturnType<typeof getPackageInfo>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetPackageInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPackageInfo>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPackageInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPackageInfo<
  TData = Awaited<ReturnType<typeof getPackageInfo>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetPackageInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPackageInfo>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a package by name or assembly GUID.
 */

export function useGetPackageInfo<
  TData = Awaited<ReturnType<typeof getPackageInfo>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetPackageInfoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPackageInfo>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPackageInfoQueryOptions(name, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Installs a package.
 */
export const installPackage = (name: string, params?: InstallPackageParams) => {
  return apiInstance<void>({
    url: `/Packages/Installed/${name}`,
    method: "POST",
    params,
  });
};

export const getInstallPackageMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof installPackage>>,
    TError,
    { name: string; params?: InstallPackageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof installPackage>>,
  TError,
  { name: string; params?: InstallPackageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof installPackage>>,
    { name: string; params?: InstallPackageParams }
  > = (props) => {
    const { name, params } = props ?? {};

    return installPackage(name, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type InstallPackageMutationResult = NonNullable<
  Awaited<ReturnType<typeof installPackage>>
>;

export type InstallPackageMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Installs a package.
 */
export const useInstallPackage = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof installPackage>>,
    TError,
    { name: string; params?: InstallPackageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof installPackage>>,
  TError,
  { name: string; params?: InstallPackageParams },
  TContext
> => {
  const mutationOptions = getInstallPackageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Cancels a package installation.
 */
export const cancelPackageInstallation = (packageId: string) => {
  return apiInstance<void>({
    url: `/Packages/Installing/${packageId}`,
    method: "DELETE",
  });
};

export const getCancelPackageInstallationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelPackageInstallation>>,
    TError,
    { packageId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelPackageInstallation>>,
  TError,
  { packageId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelPackageInstallation>>,
    { packageId: string }
  > = (props) => {
    const { packageId } = props ?? {};

    return cancelPackageInstallation(packageId);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelPackageInstallationMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelPackageInstallation>>
>;

export type CancelPackageInstallationMutationError = ErrorType<void>;

/**
 * @summary Cancels a package installation.
 */
export const useCancelPackageInstallation = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelPackageInstallation>>,
    TError,
    { packageId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof cancelPackageInstallation>>,
  TError,
  { packageId: string },
  TContext
> => {
  const mutationOptions = getCancelPackageInstallationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets all package repositories.
 */
export const getRepositories = (signal?: AbortSignal) => {
  return apiInstance<RepositoryInfo[]>({
    url: `/Repositories`,
    method: "GET",
    signal,
  });
};

export const getGetRepositoriesQueryKey = () => {
  return [`/Repositories`] as const;
};

export const getGetRepositoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getRepositories>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRepositories>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRepositoriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRepositories>>> = ({
    signal,
  }) => getRepositories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRepositories>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRepositoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRepositories>>
>;
export type GetRepositoriesQueryError = ErrorType<void>;

export function useGetRepositories<
  TData = Awaited<ReturnType<typeof getRepositories>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRepositories>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getRepositories>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRepositories<
  TData = Awaited<ReturnType<typeof getRepositories>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRepositories>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getRepositories>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRepositories<
  TData = Awaited<ReturnType<typeof getRepositories>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRepositories>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all package repositories.
 */

export function useGetRepositories<
  TData = Awaited<ReturnType<typeof getRepositories>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getRepositories>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRepositoriesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Sets the enabled and existing package repositories.
 */
export const setRepositories = (repositoryInfo: RepositoryInfo[]) => {
  return apiInstance<void>({
    url: `/Repositories`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: repositoryInfo,
  });
};

export const getSetRepositoriesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setRepositories>>,
    TError,
    { data: RepositoryInfo[] },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setRepositories>>,
  TError,
  { data: RepositoryInfo[] },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setRepositories>>,
    { data: RepositoryInfo[] }
  > = (props) => {
    const { data } = props ?? {};

    return setRepositories(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetRepositoriesMutationResult = NonNullable<
  Awaited<ReturnType<typeof setRepositories>>
>;
export type SetRepositoriesMutationBody = RepositoryInfo[];
export type SetRepositoriesMutationError = ErrorType<void>;

/**
 * @summary Sets the enabled and existing package repositories.
 */
export const useSetRepositories = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setRepositories>>,
    TError,
    { data: RepositoryInfo[] },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof setRepositories>>,
  TError,
  { data: RepositoryInfo[] },
  TContext
> => {
  const mutationOptions = getSetRepositoriesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets all persons.
 */
export const getPersons = (params?: GetPersonsParams, signal?: AbortSignal) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Persons`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPersonsQueryKey = (params?: GetPersonsParams) => {
  return [`/Persons`, ...(params ? [params] : [])] as const;
};

export const getGetPersonsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPersons>>,
  TError = ErrorType<void>
>(
  params?: GetPersonsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersons>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPersonsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersons>>> = ({
    signal,
  }) => getPersons(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPersons>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPersonsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPersons>>
>;
export type GetPersonsQueryError = ErrorType<void>;

export function useGetPersons<
  TData = Awaited<ReturnType<typeof getPersons>>,
  TError = ErrorType<void>
>(
  params: undefined | GetPersonsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersons>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersons>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPersons<
  TData = Awaited<ReturnType<typeof getPersons>>,
  TError = ErrorType<void>
>(
  params?: GetPersonsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersons>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersons>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPersons<
  TData = Awaited<ReturnType<typeof getPersons>>,
  TError = ErrorType<void>
>(
  params?: GetPersonsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersons>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all persons.
 */

export function useGetPersons<
  TData = Awaited<ReturnType<typeof getPersons>>,
  TError = ErrorType<void>
>(
  params?: GetPersonsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPersons>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPersonsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get person by name.
 */
export const getPerson = (
  name: string,
  params?: GetPersonParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/Persons/${name}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPersonQueryKey = (
  name: string,
  params?: GetPersonParams
) => {
  return [`/Persons/${name}`, ...(params ? [params] : [])] as const;
};

export const getGetPersonQueryOptions = <
  TData = Awaited<ReturnType<typeof getPerson>>,
  TError = ErrorType<void | ProblemDetails>
>(
  name: string,
  params?: GetPersonParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPerson>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPersonQueryKey(name, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPerson>>> = ({
    signal,
  }) => getPerson(name, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getPerson>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetPersonQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPerson>>
>;
export type GetPersonQueryError = ErrorType<void | ProblemDetails>;

export function useGetPerson<
  TData = Awaited<ReturnType<typeof getPerson>>,
  TError = ErrorType<void | ProblemDetails>
>(
  name: string,
  params: undefined | GetPersonParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPerson>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPerson>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPerson<
  TData = Awaited<ReturnType<typeof getPerson>>,
  TError = ErrorType<void | ProblemDetails>
>(
  name: string,
  params?: GetPersonParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPerson>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPerson>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPerson<
  TData = Awaited<ReturnType<typeof getPerson>>,
  TError = ErrorType<void | ProblemDetails>
>(
  name: string,
  params?: GetPersonParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPerson>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get person by name.
 */

export function useGetPerson<
  TData = Awaited<ReturnType<typeof getPerson>>,
  TError = ErrorType<void | ProblemDetails>
>(
  name: string,
  params?: GetPersonParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPerson>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPersonQueryOptions(name, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
Query parameters are obsolete.
 * @summary Creates a new playlist.
 */
export const createPlaylist = (
  createPlaylistDto: CreatePlaylistDto,
  params?: CreatePlaylistParams
) => {
  return apiInstance<PlaylistCreationResult>({
    url: `/Playlists`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createPlaylistDto,
    params,
  });
};

export const getCreatePlaylistMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPlaylist>>,
    TError,
    { data: CreatePlaylistDto; params?: CreatePlaylistParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPlaylist>>,
  TError,
  { data: CreatePlaylistDto; params?: CreatePlaylistParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPlaylist>>,
    { data: CreatePlaylistDto; params?: CreatePlaylistParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return createPlaylist(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePlaylistMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPlaylist>>
>;
export type CreatePlaylistMutationBody = CreatePlaylistDto;
export type CreatePlaylistMutationError = ErrorType<void>;

/**
 * @summary Creates a new playlist.
 */
export const useCreatePlaylist = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPlaylist>>,
    TError,
    { data: CreatePlaylistDto; params?: CreatePlaylistParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createPlaylist>>,
  TError,
  { data: CreatePlaylistDto; params?: CreatePlaylistParams },
  TContext
> => {
  const mutationOptions = getCreatePlaylistMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Adds items to a playlist.
 */
export const addToPlaylist = (
  playlistId: string,
  params?: AddToPlaylistParams
) => {
  return apiInstance<void>({
    url: `/Playlists/${playlistId}/Items`,
    method: "POST",
    params,
  });
};

export const getAddToPlaylistMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addToPlaylist>>,
    TError,
    { playlistId: string; params?: AddToPlaylistParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addToPlaylist>>,
  TError,
  { playlistId: string; params?: AddToPlaylistParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addToPlaylist>>,
    { playlistId: string; params?: AddToPlaylistParams }
  > = (props) => {
    const { playlistId, params } = props ?? {};

    return addToPlaylist(playlistId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddToPlaylistMutationResult = NonNullable<
  Awaited<ReturnType<typeof addToPlaylist>>
>;

export type AddToPlaylistMutationError = ErrorType<void>;

/**
 * @summary Adds items to a playlist.
 */
export const useAddToPlaylist = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addToPlaylist>>,
    TError,
    { playlistId: string; params?: AddToPlaylistParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof addToPlaylist>>,
  TError,
  { playlistId: string; params?: AddToPlaylistParams },
  TContext
> => {
  const mutationOptions = getAddToPlaylistMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Removes items from a playlist.
 */
export const removeFromPlaylist = (
  playlistId: string,
  params?: RemoveFromPlaylistParams
) => {
  return apiInstance<void>({
    url: `/Playlists/${playlistId}/Items`,
    method: "DELETE",
    params,
  });
};

export const getRemoveFromPlaylistMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeFromPlaylist>>,
    TError,
    { playlistId: string; params?: RemoveFromPlaylistParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeFromPlaylist>>,
  TError,
  { playlistId: string; params?: RemoveFromPlaylistParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeFromPlaylist>>,
    { playlistId: string; params?: RemoveFromPlaylistParams }
  > = (props) => {
    const { playlistId, params } = props ?? {};

    return removeFromPlaylist(playlistId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveFromPlaylistMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeFromPlaylist>>
>;

export type RemoveFromPlaylistMutationError = ErrorType<void>;

/**
 * @summary Removes items from a playlist.
 */
export const useRemoveFromPlaylist = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeFromPlaylist>>,
    TError,
    { playlistId: string; params?: RemoveFromPlaylistParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof removeFromPlaylist>>,
  TError,
  { playlistId: string; params?: RemoveFromPlaylistParams },
  TContext
> => {
  const mutationOptions = getRemoveFromPlaylistMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the original items of a playlist.
 */
export const getPlaylistItems = (
  playlistId: string,
  params: GetPlaylistItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Playlists/${playlistId}/Items`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPlaylistItemsQueryKey = (
  playlistId: string,
  params: GetPlaylistItemsParams
) => {
  return [
    `/Playlists/${playlistId}/Items`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetPlaylistItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlaylistItems>>,
  TError = ErrorType<void>
>(
  playlistId: string,
  params: GetPlaylistItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaylistItems>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPlaylistItemsQueryKey(playlistId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPlaylistItems>>
  > = ({ signal }) => getPlaylistItems(playlistId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!playlistId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlaylistItems>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPlaylistItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlaylistItems>>
>;
export type GetPlaylistItemsQueryError = ErrorType<void>;

export function useGetPlaylistItems<
  TData = Awaited<ReturnType<typeof getPlaylistItems>>,
  TError = ErrorType<void>
>(
  playlistId: string,
  params: GetPlaylistItemsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaylistItems>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlaylistItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPlaylistItems<
  TData = Awaited<ReturnType<typeof getPlaylistItems>>,
  TError = ErrorType<void>
>(
  playlistId: string,
  params: GetPlaylistItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaylistItems>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlaylistItems>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPlaylistItems<
  TData = Awaited<ReturnType<typeof getPlaylistItems>>,
  TError = ErrorType<void>
>(
  playlistId: string,
  params: GetPlaylistItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaylistItems>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the original items of a playlist.
 */

export function useGetPlaylistItems<
  TData = Awaited<ReturnType<typeof getPlaylistItems>>,
  TError = ErrorType<void>
>(
  playlistId: string,
  params: GetPlaylistItemsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPlaylistItems>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPlaylistItemsQueryOptions(
    playlistId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Moves a playlist item.
 */
export const moveItem = (
  playlistId: string,
  itemId: string,
  newIndex: number
) => {
  return apiInstance<void>({
    url: `/Playlists/${playlistId}/Items/${itemId}/Move/${newIndex}`,
    method: "POST",
  });
};

export const getMoveItemMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moveItem>>,
    TError,
    { playlistId: string; itemId: string; newIndex: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moveItem>>,
  TError,
  { playlistId: string; itemId: string; newIndex: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moveItem>>,
    { playlistId: string; itemId: string; newIndex: number }
  > = (props) => {
    const { playlistId, itemId, newIndex } = props ?? {};

    return moveItem(playlistId, itemId, newIndex);
  };

  return { mutationFn, ...mutationOptions };
};

export type MoveItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof moveItem>>
>;

export type MoveItemMutationError = ErrorType<void>;

/**
 * @summary Moves a playlist item.
 */
export const useMoveItem = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moveItem>>,
    TError,
    { playlistId: string; itemId: string; newIndex: number },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof moveItem>>,
  TError,
  { playlistId: string; itemId: string; newIndex: number },
  TContext
> => {
  const mutationOptions = getMoveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports playback has started within a session.
 */
export const reportPlaybackStart = (playbackStartInfo: PlaybackStartInfo) => {
  return apiInstance<void>({
    url: `/Sessions/Playing`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: playbackStartInfo,
  });
};

export const getReportPlaybackStartMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportPlaybackStart>>,
    TError,
    { data: PlaybackStartInfo },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportPlaybackStart>>,
  TError,
  { data: PlaybackStartInfo },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportPlaybackStart>>,
    { data: PlaybackStartInfo }
  > = (props) => {
    const { data } = props ?? {};

    return reportPlaybackStart(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportPlaybackStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportPlaybackStart>>
>;
export type ReportPlaybackStartMutationBody = PlaybackStartInfo;
export type ReportPlaybackStartMutationError = ErrorType<void>;

/**
 * @summary Reports playback has started within a session.
 */
export const useReportPlaybackStart = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportPlaybackStart>>,
    TError,
    { data: PlaybackStartInfo },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof reportPlaybackStart>>,
  TError,
  { data: PlaybackStartInfo },
  TContext
> => {
  const mutationOptions = getReportPlaybackStartMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Pings a playback session.
 */
export const pingPlaybackSession = (params: PingPlaybackSessionParams) => {
  return apiInstance<void>({
    url: `/Sessions/Playing/Ping`,
    method: "POST",
    params,
  });
};

export const getPingPlaybackSessionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pingPlaybackSession>>,
    TError,
    { params: PingPlaybackSessionParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pingPlaybackSession>>,
  TError,
  { params: PingPlaybackSessionParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pingPlaybackSession>>,
    { params: PingPlaybackSessionParams }
  > = (props) => {
    const { params } = props ?? {};

    return pingPlaybackSession(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PingPlaybackSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof pingPlaybackSession>>
>;

export type PingPlaybackSessionMutationError = ErrorType<void>;

/**
 * @summary Pings a playback session.
 */
export const usePingPlaybackSession = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pingPlaybackSession>>,
    TError,
    { params: PingPlaybackSessionParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof pingPlaybackSession>>,
  TError,
  { params: PingPlaybackSessionParams },
  TContext
> => {
  const mutationOptions = getPingPlaybackSessionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports playback progress within a session.
 */
export const reportPlaybackProgress = (
  playbackProgressInfo: PlaybackProgressInfo
) => {
  return apiInstance<void>({
    url: `/Sessions/Playing/Progress`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: playbackProgressInfo,
  });
};

export const getReportPlaybackProgressMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportPlaybackProgress>>,
    TError,
    { data: PlaybackProgressInfo },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportPlaybackProgress>>,
  TError,
  { data: PlaybackProgressInfo },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportPlaybackProgress>>,
    { data: PlaybackProgressInfo }
  > = (props) => {
    const { data } = props ?? {};

    return reportPlaybackProgress(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportPlaybackProgressMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportPlaybackProgress>>
>;
export type ReportPlaybackProgressMutationBody = PlaybackProgressInfo;
export type ReportPlaybackProgressMutationError = ErrorType<void>;

/**
 * @summary Reports playback progress within a session.
 */
export const useReportPlaybackProgress = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportPlaybackProgress>>,
    TError,
    { data: PlaybackProgressInfo },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof reportPlaybackProgress>>,
  TError,
  { data: PlaybackProgressInfo },
  TContext
> => {
  const mutationOptions = getReportPlaybackProgressMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports playback has stopped within a session.
 */
export const reportPlaybackStopped = (playbackStopInfo: PlaybackStopInfo) => {
  return apiInstance<void>({
    url: `/Sessions/Playing/Stopped`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: playbackStopInfo,
  });
};

export const getReportPlaybackStoppedMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportPlaybackStopped>>,
    TError,
    { data: PlaybackStopInfo },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportPlaybackStopped>>,
  TError,
  { data: PlaybackStopInfo },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportPlaybackStopped>>,
    { data: PlaybackStopInfo }
  > = (props) => {
    const { data } = props ?? {};

    return reportPlaybackStopped(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportPlaybackStoppedMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportPlaybackStopped>>
>;
export type ReportPlaybackStoppedMutationBody = PlaybackStopInfo;
export type ReportPlaybackStoppedMutationError = ErrorType<void>;

/**
 * @summary Reports playback has stopped within a session.
 */
export const useReportPlaybackStopped = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportPlaybackStopped>>,
    TError,
    { data: PlaybackStopInfo },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof reportPlaybackStopped>>,
  TError,
  { data: PlaybackStopInfo },
  TContext
> => {
  const mutationOptions = getReportPlaybackStoppedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Marks an item as played for user.
 */
export const markPlayedItem = (
  userId: string,
  itemId: string,
  params?: MarkPlayedItemParams
) => {
  return apiInstance<UserItemDataDto>({
    url: `/Users/${userId}/PlayedItems/${itemId}`,
    method: "POST",
    params,
  });
};

export const getMarkPlayedItemMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markPlayedItem>>,
    TError,
    { userId: string; itemId: string; params?: MarkPlayedItemParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof markPlayedItem>>,
  TError,
  { userId: string; itemId: string; params?: MarkPlayedItemParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markPlayedItem>>,
    { userId: string; itemId: string; params?: MarkPlayedItemParams }
  > = (props) => {
    const { userId, itemId, params } = props ?? {};

    return markPlayedItem(userId, itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkPlayedItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof markPlayedItem>>
>;

export type MarkPlayedItemMutationError = ErrorType<void>;

/**
 * @summary Marks an item as played for user.
 */
export const useMarkPlayedItem = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markPlayedItem>>,
    TError,
    { userId: string; itemId: string; params?: MarkPlayedItemParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof markPlayedItem>>,
  TError,
  { userId: string; itemId: string; params?: MarkPlayedItemParams },
  TContext
> => {
  const mutationOptions = getMarkPlayedItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Marks an item as unplayed for user.
 */
export const markUnplayedItem = (userId: string, itemId: string) => {
  return apiInstance<UserItemDataDto>({
    url: `/Users/${userId}/PlayedItems/${itemId}`,
    method: "DELETE",
  });
};

export const getMarkUnplayedItemMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markUnplayedItem>>,
    TError,
    { userId: string; itemId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof markUnplayedItem>>,
  TError,
  { userId: string; itemId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markUnplayedItem>>,
    { userId: string; itemId: string }
  > = (props) => {
    const { userId, itemId } = props ?? {};

    return markUnplayedItem(userId, itemId);
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkUnplayedItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof markUnplayedItem>>
>;

export type MarkUnplayedItemMutationError = ErrorType<void>;

/**
 * @summary Marks an item as unplayed for user.
 */
export const useMarkUnplayedItem = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markUnplayedItem>>,
    TError,
    { userId: string; itemId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof markUnplayedItem>>,
  TError,
  { userId: string; itemId: string },
  TContext
> => {
  const mutationOptions = getMarkUnplayedItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports that a user has begun playing an item.
 */
export const onPlaybackStart = (
  userId: string,
  itemId: string,
  params?: OnPlaybackStartParams
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/PlayingItems/${itemId}`,
    method: "POST",
    params,
  });
};

export const getOnPlaybackStartMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof onPlaybackStart>>,
    TError,
    { userId: string; itemId: string; params?: OnPlaybackStartParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof onPlaybackStart>>,
  TError,
  { userId: string; itemId: string; params?: OnPlaybackStartParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof onPlaybackStart>>,
    { userId: string; itemId: string; params?: OnPlaybackStartParams }
  > = (props) => {
    const { userId, itemId, params } = props ?? {};

    return onPlaybackStart(userId, itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type OnPlaybackStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof onPlaybackStart>>
>;

export type OnPlaybackStartMutationError = ErrorType<void>;

/**
 * @summary Reports that a user has begun playing an item.
 */
export const useOnPlaybackStart = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof onPlaybackStart>>,
    TError,
    { userId: string; itemId: string; params?: OnPlaybackStartParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof onPlaybackStart>>,
  TError,
  { userId: string; itemId: string; params?: OnPlaybackStartParams },
  TContext
> => {
  const mutationOptions = getOnPlaybackStartMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports that a user has stopped playing an item.
 */
export const onPlaybackStopped = (
  userId: string,
  itemId: string,
  params?: OnPlaybackStoppedParams
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/PlayingItems/${itemId}`,
    method: "DELETE",
    params,
  });
};

export const getOnPlaybackStoppedMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof onPlaybackStopped>>,
    TError,
    { userId: string; itemId: string; params?: OnPlaybackStoppedParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof onPlaybackStopped>>,
  TError,
  { userId: string; itemId: string; params?: OnPlaybackStoppedParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof onPlaybackStopped>>,
    { userId: string; itemId: string; params?: OnPlaybackStoppedParams }
  > = (props) => {
    const { userId, itemId, params } = props ?? {};

    return onPlaybackStopped(userId, itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type OnPlaybackStoppedMutationResult = NonNullable<
  Awaited<ReturnType<typeof onPlaybackStopped>>
>;

export type OnPlaybackStoppedMutationError = ErrorType<void>;

/**
 * @summary Reports that a user has stopped playing an item.
 */
export const useOnPlaybackStopped = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof onPlaybackStopped>>,
    TError,
    { userId: string; itemId: string; params?: OnPlaybackStoppedParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof onPlaybackStopped>>,
  TError,
  { userId: string; itemId: string; params?: OnPlaybackStoppedParams },
  TContext
> => {
  const mutationOptions = getOnPlaybackStoppedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports a user's playback progress.
 */
export const onPlaybackProgress = (
  userId: string,
  itemId: string,
  params?: OnPlaybackProgressParams
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/PlayingItems/${itemId}/Progress`,
    method: "POST",
    params,
  });
};

export const getOnPlaybackProgressMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof onPlaybackProgress>>,
    TError,
    { userId: string; itemId: string; params?: OnPlaybackProgressParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof onPlaybackProgress>>,
  TError,
  { userId: string; itemId: string; params?: OnPlaybackProgressParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof onPlaybackProgress>>,
    { userId: string; itemId: string; params?: OnPlaybackProgressParams }
  > = (props) => {
    const { userId, itemId, params } = props ?? {};

    return onPlaybackProgress(userId, itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type OnPlaybackProgressMutationResult = NonNullable<
  Awaited<ReturnType<typeof onPlaybackProgress>>
>;

export type OnPlaybackProgressMutationError = ErrorType<void>;

/**
 * @summary Reports a user's playback progress.
 */
export const useOnPlaybackProgress = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof onPlaybackProgress>>,
    TError,
    { userId: string; itemId: string; params?: OnPlaybackProgressParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof onPlaybackProgress>>,
  TError,
  { userId: string; itemId: string; params?: OnPlaybackProgressParams },
  TContext
> => {
  const mutationOptions = getOnPlaybackProgressMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a list of currently installed plugins.
 */
export const getPlugins = (signal?: AbortSignal) => {
  return apiInstance<PluginInfo[]>({ url: `/Plugins`, method: "GET", signal });
};

export const getGetPluginsQueryKey = () => {
  return [`/Plugins`] as const;
};

export const getGetPluginsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlugins>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlugins>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPluginsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlugins>>> = ({
    signal,
  }) => getPlugins(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlugins>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPluginsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlugins>>
>;
export type GetPluginsQueryError = ErrorType<void>;

export function useGetPlugins<
  TData = Awaited<ReturnType<typeof getPlugins>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlugins>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPlugins>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPlugins<
  TData = Awaited<ReturnType<typeof getPlugins>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlugins>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPlugins>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPlugins<
  TData = Awaited<ReturnType<typeof getPlugins>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlugins>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a list of currently installed plugins.
 */

export function useGetPlugins<
  TData = Awaited<ReturnType<typeof getPlugins>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlugins>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPluginsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @deprecated
 * @summary Uninstalls a plugin.
 */
export const uninstallPlugin = (pluginId: string) => {
  return apiInstance<void>({ url: `/Plugins/${pluginId}`, method: "DELETE" });
};

export const getUninstallPluginMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uninstallPlugin>>,
    TError,
    { pluginId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uninstallPlugin>>,
  TError,
  { pluginId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uninstallPlugin>>,
    { pluginId: string }
  > = (props) => {
    const { pluginId } = props ?? {};

    return uninstallPlugin(pluginId);
  };

  return { mutationFn, ...mutationOptions };
};

export type UninstallPluginMutationResult = NonNullable<
  Awaited<ReturnType<typeof uninstallPlugin>>
>;

export type UninstallPluginMutationError = ErrorType<void | ProblemDetails>;

/**
 * @deprecated
 * @summary Uninstalls a plugin.
 */
export const useUninstallPlugin = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uninstallPlugin>>,
    TError,
    { pluginId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof uninstallPlugin>>,
  TError,
  { pluginId: string },
  TContext
> => {
  const mutationOptions = getUninstallPluginMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Uninstalls a plugin by version.
 */
export const uninstallPluginByVersion = (pluginId: string, version: string) => {
  return apiInstance<void>({
    url: `/Plugins/${pluginId}/${version}`,
    method: "DELETE",
  });
};

export const getUninstallPluginByVersionMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uninstallPluginByVersion>>,
    TError,
    { pluginId: string; version: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uninstallPluginByVersion>>,
  TError,
  { pluginId: string; version: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uninstallPluginByVersion>>,
    { pluginId: string; version: string }
  > = (props) => {
    const { pluginId, version } = props ?? {};

    return uninstallPluginByVersion(pluginId, version);
  };

  return { mutationFn, ...mutationOptions };
};

export type UninstallPluginByVersionMutationResult = NonNullable<
  Awaited<ReturnType<typeof uninstallPluginByVersion>>
>;

export type UninstallPluginByVersionMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Uninstalls a plugin by version.
 */
export const useUninstallPluginByVersion = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uninstallPluginByVersion>>,
    TError,
    { pluginId: string; version: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof uninstallPluginByVersion>>,
  TError,
  { pluginId: string; version: string },
  TContext
> => {
  const mutationOptions = getUninstallPluginByVersionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Disable a plugin.
 */
export const disablePlugin = (pluginId: string, version: string) => {
  return apiInstance<void>({
    url: `/Plugins/${pluginId}/${version}/Disable`,
    method: "POST",
  });
};

export const getDisablePluginMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof disablePlugin>>,
    TError,
    { pluginId: string; version: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof disablePlugin>>,
  TError,
  { pluginId: string; version: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof disablePlugin>>,
    { pluginId: string; version: string }
  > = (props) => {
    const { pluginId, version } = props ?? {};

    return disablePlugin(pluginId, version);
  };

  return { mutationFn, ...mutationOptions };
};

export type DisablePluginMutationResult = NonNullable<
  Awaited<ReturnType<typeof disablePlugin>>
>;

export type DisablePluginMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Disable a plugin.
 */
export const useDisablePlugin = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof disablePlugin>>,
    TError,
    { pluginId: string; version: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof disablePlugin>>,
  TError,
  { pluginId: string; version: string },
  TContext
> => {
  const mutationOptions = getDisablePluginMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Enables a disabled plugin.
 */
export const enablePlugin = (pluginId: string, version: string) => {
  return apiInstance<void>({
    url: `/Plugins/${pluginId}/${version}/Enable`,
    method: "POST",
  });
};

export const getEnablePluginMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof enablePlugin>>,
    TError,
    { pluginId: string; version: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof enablePlugin>>,
  TError,
  { pluginId: string; version: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof enablePlugin>>,
    { pluginId: string; version: string }
  > = (props) => {
    const { pluginId, version } = props ?? {};

    return enablePlugin(pluginId, version);
  };

  return { mutationFn, ...mutationOptions };
};

export type EnablePluginMutationResult = NonNullable<
  Awaited<ReturnType<typeof enablePlugin>>
>;

export type EnablePluginMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Enables a disabled plugin.
 */
export const useEnablePlugin = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof enablePlugin>>,
    TError,
    { pluginId: string; version: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof enablePlugin>>,
  TError,
  { pluginId: string; version: string },
  TContext
> => {
  const mutationOptions = getEnablePluginMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a plugin's image.
 */
export const getPluginImage = (
  pluginId: string,
  version: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Plugins/${pluginId}/${version}/Image`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetPluginImageQueryKey = (
  pluginId: string,
  version: string
) => {
  return [`/Plugins/${pluginId}/${version}/Image`] as const;
};

export const getGetPluginImageQueryOptions = <
  TData = Awaited<ReturnType<typeof getPluginImage>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  version: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPluginImage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPluginImageQueryKey(pluginId, version);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPluginImage>>> = ({
    signal,
  }) => getPluginImage(pluginId, version, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(pluginId && version),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPluginImage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPluginImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPluginImage>>
>;
export type GetPluginImageQueryError = ErrorType<void | ProblemDetails>;

export function useGetPluginImage<
  TData = Awaited<ReturnType<typeof getPluginImage>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  version: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPluginImage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPluginImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPluginImage<
  TData = Awaited<ReturnType<typeof getPluginImage>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  version: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPluginImage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPluginImage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPluginImage<
  TData = Awaited<ReturnType<typeof getPluginImage>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  version: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPluginImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a plugin's image.
 */

export function useGetPluginImage<
  TData = Awaited<ReturnType<typeof getPluginImage>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  version: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPluginImage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPluginImageQueryOptions(
    pluginId,
    version,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets plugin configuration.
 */
export const getPluginConfiguration = (
  pluginId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BasePluginConfiguration>({
    url: `/Plugins/${pluginId}/Configuration`,
    method: "GET",
    signal,
  });
};

export const getGetPluginConfigurationQueryKey = (pluginId: string) => {
  return [`/Plugins/${pluginId}/Configuration`] as const;
};

export const getGetPluginConfigurationQueryOptions = <
  TData = Awaited<ReturnType<typeof getPluginConfiguration>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPluginConfiguration>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPluginConfigurationQueryKey(pluginId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPluginConfiguration>>
  > = ({ signal }) => getPluginConfiguration(pluginId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!pluginId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPluginConfiguration>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPluginConfigurationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPluginConfiguration>>
>;
export type GetPluginConfigurationQueryError = ErrorType<void | ProblemDetails>;

export function useGetPluginConfiguration<
  TData = Awaited<ReturnType<typeof getPluginConfiguration>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPluginConfiguration>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPluginConfiguration>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPluginConfiguration<
  TData = Awaited<ReturnType<typeof getPluginConfiguration>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPluginConfiguration>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPluginConfiguration>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPluginConfiguration<
  TData = Awaited<ReturnType<typeof getPluginConfiguration>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPluginConfiguration>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets plugin configuration.
 */

export function useGetPluginConfiguration<
  TData = Awaited<ReturnType<typeof getPluginConfiguration>>,
  TError = ErrorType<void | ProblemDetails>
>(
  pluginId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPluginConfiguration>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPluginConfigurationQueryOptions(pluginId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Accepts plugin configuration as JSON body.
 * @summary Updates plugin configuration.
 */
export const updatePluginConfiguration = (pluginId: string) => {
  return apiInstance<void>({
    url: `/Plugins/${pluginId}/Configuration`,
    method: "POST",
  });
};

export const getUpdatePluginConfigurationMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePluginConfiguration>>,
    TError,
    { pluginId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePluginConfiguration>>,
  TError,
  { pluginId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePluginConfiguration>>,
    { pluginId: string }
  > = (props) => {
    const { pluginId } = props ?? {};

    return updatePluginConfiguration(pluginId);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePluginConfigurationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePluginConfiguration>>
>;

export type UpdatePluginConfigurationMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Updates plugin configuration.
 */
export const useUpdatePluginConfiguration = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePluginConfiguration>>,
    TError,
    { pluginId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updatePluginConfiguration>>,
  TError,
  { pluginId: string },
  TContext
> => {
  const mutationOptions = getUpdatePluginConfigurationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a plugin's manifest.
 */
export const getPluginManifest = (pluginId: string) => {
  return apiInstance<void>({
    url: `/Plugins/${pluginId}/Manifest`,
    method: "POST",
  });
};

export const getGetPluginManifestMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPluginManifest>>,
    TError,
    { pluginId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getPluginManifest>>,
  TError,
  { pluginId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getPluginManifest>>,
    { pluginId: string }
  > = (props) => {
    const { pluginId } = props ?? {};

    return getPluginManifest(pluginId);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetPluginManifestMutationResult = NonNullable<
  Awaited<ReturnType<typeof getPluginManifest>>
>;

export type GetPluginManifestMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Gets a plugin's manifest.
 */
export const useGetPluginManifest = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPluginManifest>>,
    TError,
    { pluginId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof getPluginManifest>>,
  TError,
  { pluginId: string },
  TContext
> => {
  const mutationOptions = getGetPluginManifestMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Authorizes a pending quick connect request.
 */
export const authorize = (params: AuthorizeParams) => {
  return apiInstance<boolean>({
    url: `/QuickConnect/Authorize`,
    method: "POST",
    params,
  });
};

export const getAuthorizeMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authorize>>,
    TError,
    { params: AuthorizeParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authorize>>,
  TError,
  { params: AuthorizeParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authorize>>,
    { params: AuthorizeParams }
  > = (props) => {
    const { params } = props ?? {};

    return authorize(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthorizeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authorize>>
>;

export type AuthorizeMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Authorizes a pending quick connect request.
 */
export const useAuthorize = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authorize>>,
    TError,
    { params: AuthorizeParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authorize>>,
  TError,
  { params: AuthorizeParams },
  TContext
> => {
  const mutationOptions = getAuthorizeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Attempts to retrieve authentication information.
 */
export const connect = (params: ConnectParams, signal?: AbortSignal) => {
  return apiInstance<QuickConnectResult>({
    url: `/QuickConnect/Connect`,
    method: "GET",
    params,
    signal,
  });
};

export const getConnectQueryKey = (params: ConnectParams) => {
  return [`/QuickConnect/Connect`, ...(params ? [params] : [])] as const;
};

export const getConnectQueryOptions = <
  TData = Awaited<ReturnType<typeof connect>>,
  TError = ErrorType<ProblemDetails>
>(
  params: ConnectParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof connect>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getConnectQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof connect>>> = ({
    signal,
  }) => connect(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof connect>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ConnectQueryResult = NonNullable<
  Awaited<ReturnType<typeof connect>>
>;
export type ConnectQueryError = ErrorType<ProblemDetails>;

export function useConnect<
  TData = Awaited<ReturnType<typeof connect>>,
  TError = ErrorType<ProblemDetails>
>(
  params: ConnectParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof connect>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof connect>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useConnect<
  TData = Awaited<ReturnType<typeof connect>>,
  TError = ErrorType<ProblemDetails>
>(
  params: ConnectParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof connect>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof connect>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useConnect<
  TData = Awaited<ReturnType<typeof connect>>,
  TError = ErrorType<ProblemDetails>
>(
  params: ConnectParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof connect>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Attempts to retrieve authentication information.
 */

export function useConnect<
  TData = Awaited<ReturnType<typeof connect>>,
  TError = ErrorType<ProblemDetails>
>(
  params: ConnectParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof connect>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getConnectQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the current quick connect state.
 */
export const getEnabled = (signal?: AbortSignal) => {
  return apiInstance<boolean>({
    url: `/QuickConnect/Enabled`,
    method: "GET",
    signal,
  });
};

export const getGetEnabledQueryKey = () => {
  return [`/QuickConnect/Enabled`] as const;
};

export const getGetEnabledQueryOptions = <
  TData = Awaited<ReturnType<typeof getEnabled>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEnabled>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEnabledQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnabled>>> = ({
    signal,
  }) => getEnabled(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEnabled>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetEnabledQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEnabled>>
>;
export type GetEnabledQueryError = ErrorType<unknown>;

export function useGetEnabled<
  TData = Awaited<ReturnType<typeof getEnabled>>,
  TError = ErrorType<unknown>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEnabled>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getEnabled>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetEnabled<
  TData = Awaited<ReturnType<typeof getEnabled>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEnabled>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getEnabled>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetEnabled<
  TData = Awaited<ReturnType<typeof getEnabled>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEnabled>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the current quick connect state.
 */

export function useGetEnabled<
  TData = Awaited<ReturnType<typeof getEnabled>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEnabled>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetEnabledQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Initiate a new quick connect request.
 */
export const initiate = (signal?: AbortSignal) => {
  return apiInstance<QuickConnectResult>({
    url: `/QuickConnect/Initiate`,
    method: "GET",
    signal,
  });
};

export const getInitiateQueryKey = () => {
  return [`/QuickConnect/Initiate`] as const;
};

export const getInitiateQueryOptions = <
  TData = Awaited<ReturnType<typeof initiate>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof initiate>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getInitiateQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof initiate>>> = ({
    signal,
  }) => initiate(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof initiate>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type InitiateQueryResult = NonNullable<
  Awaited<ReturnType<typeof initiate>>
>;
export type InitiateQueryError = ErrorType<void>;

export function useInitiate<
  TData = Awaited<ReturnType<typeof initiate>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof initiate>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof initiate>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useInitiate<
  TData = Awaited<ReturnType<typeof initiate>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof initiate>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof initiate>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useInitiate<
  TData = Awaited<ReturnType<typeof initiate>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof initiate>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Initiate a new quick connect request.
 */

export function useInitiate<
  TData = Awaited<ReturnType<typeof initiate>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof initiate>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getInitiateQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets available remote images for an item.
 */
export const getRemoteImages = (
  itemId: string,
  params?: GetRemoteImagesParams,
  signal?: AbortSignal
) => {
  return apiInstance<RemoteImageResult>({
    url: `/Items/${itemId}/RemoteImages`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRemoteImagesQueryKey = (
  itemId: string,
  params?: GetRemoteImagesParams
) => {
  return [
    `/Items/${itemId}/RemoteImages`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetRemoteImagesQueryOptions = <
  TData = Awaited<ReturnType<typeof getRemoteImages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetRemoteImagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImages>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRemoteImagesQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRemoteImages>>> = ({
    signal,
  }) => getRemoteImages(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRemoteImages>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRemoteImagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRemoteImages>>
>;
export type GetRemoteImagesQueryError = ErrorType<void | ProblemDetails>;

export function useGetRemoteImages<
  TData = Awaited<ReturnType<typeof getRemoteImages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params: undefined | GetRemoteImagesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImages>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRemoteImages>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRemoteImages<
  TData = Awaited<ReturnType<typeof getRemoteImages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetRemoteImagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImages>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRemoteImages>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRemoteImages<
  TData = Awaited<ReturnType<typeof getRemoteImages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetRemoteImagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImages>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available remote images for an item.
 */

export function useGetRemoteImages<
  TData = Awaited<ReturnType<typeof getRemoteImages>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  params?: GetRemoteImagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImages>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRemoteImagesQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Downloads a remote image for an item.
 */
export const downloadRemoteImage = (
  itemId: string,
  params: DownloadRemoteImageParams
) => {
  return apiInstance<void>({
    url: `/Items/${itemId}/RemoteImages/Download`,
    method: "POST",
    params,
  });
};

export const getDownloadRemoteImageMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof downloadRemoteImage>>,
    TError,
    { itemId: string; params: DownloadRemoteImageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof downloadRemoteImage>>,
  TError,
  { itemId: string; params: DownloadRemoteImageParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof downloadRemoteImage>>,
    { itemId: string; params: DownloadRemoteImageParams }
  > = (props) => {
    const { itemId, params } = props ?? {};

    return downloadRemoteImage(itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DownloadRemoteImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof downloadRemoteImage>>
>;

export type DownloadRemoteImageMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Downloads a remote image for an item.
 */
export const useDownloadRemoteImage = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof downloadRemoteImage>>,
    TError,
    { itemId: string; params: DownloadRemoteImageParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof downloadRemoteImage>>,
  TError,
  { itemId: string; params: DownloadRemoteImageParams },
  TContext
> => {
  const mutationOptions = getDownloadRemoteImageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets available remote image providers for an item.
 */
export const getRemoteImageProviders = (
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<ImageProviderInfo[]>({
    url: `/Items/${itemId}/RemoteImages/Providers`,
    method: "GET",
    signal,
  });
};

export const getGetRemoteImageProvidersQueryKey = (itemId: string) => {
  return [`/Items/${itemId}/RemoteImages/Providers`] as const;
};

export const getGetRemoteImageProvidersQueryOptions = <
  TData = Awaited<ReturnType<typeof getRemoteImageProviders>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImageProviders>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRemoteImageProvidersQueryKey(itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRemoteImageProviders>>
  > = ({ signal }) => getRemoteImageProviders(itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRemoteImageProviders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRemoteImageProvidersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRemoteImageProviders>>
>;
export type GetRemoteImageProvidersQueryError =
  ErrorType<void | ProblemDetails>;

export function useGetRemoteImageProviders<
  TData = Awaited<ReturnType<typeof getRemoteImageProviders>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImageProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRemoteImageProviders>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRemoteImageProviders<
  TData = Awaited<ReturnType<typeof getRemoteImageProviders>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImageProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRemoteImageProviders>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRemoteImageProviders<
  TData = Awaited<ReturnType<typeof getRemoteImageProviders>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImageProviders>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets available remote image providers for an item.
 */

export function useGetRemoteImageProviders<
  TData = Awaited<ReturnType<typeof getRemoteImageProviders>>,
  TError = ErrorType<void | ProblemDetails>
>(
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteImageProviders>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRemoteImageProvidersQueryOptions(itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get tasks.
 */
export const getTasks = (params?: GetTasksParams, signal?: AbortSignal) => {
  return apiInstance<TaskInfo[]>({
    url: `/ScheduledTasks`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetTasksQueryKey = (params?: GetTasksParams) => {
  return [`/ScheduledTasks`, ...(params ? [params] : [])] as const;
};

export const getGetTasksQueryOptions = <
  TData = Awaited<ReturnType<typeof getTasks>>,
  TError = ErrorType<void>
>(
  params?: GetTasksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTasksQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTasks>>> = ({
    signal,
  }) => getTasks(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTasks>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetTasksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTasks>>
>;
export type GetTasksQueryError = ErrorType<void>;

export function useGetTasks<
  TData = Awaited<ReturnType<typeof getTasks>>,
  TError = ErrorType<void>
>(
  params: undefined | GetTasksParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTasks>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTasks<
  TData = Awaited<ReturnType<typeof getTasks>>,
  TError = ErrorType<void>
>(
  params?: GetTasksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTasks>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTasks<
  TData = Awaited<ReturnType<typeof getTasks>>,
  TError = ErrorType<void>
>(
  params?: GetTasksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get tasks.
 */

export function useGetTasks<
  TData = Awaited<ReturnType<typeof getTasks>>,
  TError = ErrorType<void>
>(
  params?: GetTasksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetTasksQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get task by id.
 */
export const getTask = (taskId: string, signal?: AbortSignal) => {
  return apiInstance<TaskInfo>({
    url: `/ScheduledTasks/${taskId}`,
    method: "GET",
    signal,
  });
};

export const getGetTaskQueryKey = (taskId: string) => {
  return [`/ScheduledTasks/${taskId}`] as const;
};

export const getGetTaskQueryOptions = <
  TData = Awaited<ReturnType<typeof getTask>>,
  TError = ErrorType<void | ProblemDetails>
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTaskQueryKey(taskId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTask>>> = ({
    signal,
  }) => getTask(taskId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!taskId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetTaskQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTask>>
>;
export type GetTaskQueryError = ErrorType<void | ProblemDetails>;

export function useGetTask<
  TData = Awaited<ReturnType<typeof getTask>>,
  TError = ErrorType<void | ProblemDetails>
>(
  taskId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTask>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTask<
  TData = Awaited<ReturnType<typeof getTask>>,
  TError = ErrorType<void | ProblemDetails>
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTask>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTask<
  TData = Awaited<ReturnType<typeof getTask>>,
  TError = ErrorType<void | ProblemDetails>
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get task by id.
 */

export function useGetTask<
  TData = Awaited<ReturnType<typeof getTask>>,
  TError = ErrorType<void | ProblemDetails>
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetTaskQueryOptions(taskId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update specified task triggers.
 */
export const updateTask = (
  taskId: string,
  taskTriggerInfo: TaskTriggerInfo[]
) => {
  return apiInstance<void>({
    url: `/ScheduledTasks/${taskId}/Triggers`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: taskTriggerInfo,
  });
};

export const getUpdateTaskMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTask>>,
    TError,
    { taskId: string; data: TaskTriggerInfo[] },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTask>>,
  TError,
  { taskId: string; data: TaskTriggerInfo[] },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTask>>,
    { taskId: string; data: TaskTriggerInfo[] }
  > = (props) => {
    const { taskId, data } = props ?? {};

    return updateTask(taskId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTask>>
>;
export type UpdateTaskMutationBody = TaskTriggerInfo[];
export type UpdateTaskMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Update specified task triggers.
 */
export const useUpdateTask = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTask>>,
    TError,
    { taskId: string; data: TaskTriggerInfo[] },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateTask>>,
  TError,
  { taskId: string; data: TaskTriggerInfo[] },
  TContext
> => {
  const mutationOptions = getUpdateTaskMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Start specified task.
 */
export const startTask = (taskId: string) => {
  return apiInstance<void>({
    url: `/ScheduledTasks/Running/${taskId}`,
    method: "POST",
  });
};

export const getStartTaskMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof startTask>>,
    TError,
    { taskId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof startTask>>,
  TError,
  { taskId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof startTask>>,
    { taskId: string }
  > = (props) => {
    const { taskId } = props ?? {};

    return startTask(taskId);
  };

  return { mutationFn, ...mutationOptions };
};

export type StartTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof startTask>>
>;

export type StartTaskMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Start specified task.
 */
export const useStartTask = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof startTask>>,
    TError,
    { taskId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof startTask>>,
  TError,
  { taskId: string },
  TContext
> => {
  const mutationOptions = getStartTaskMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Stop specified task.
 */
export const stopTask = (taskId: string) => {
  return apiInstance<void>({
    url: `/ScheduledTasks/Running/${taskId}`,
    method: "DELETE",
  });
};

export const getStopTaskMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopTask>>,
    TError,
    { taskId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stopTask>>,
  TError,
  { taskId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stopTask>>,
    { taskId: string }
  > = (props) => {
    const { taskId } = props ?? {};

    return stopTask(taskId);
  };

  return { mutationFn, ...mutationOptions };
};

export type StopTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof stopTask>>
>;

export type StopTaskMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Stop specified task.
 */
export const useStopTask = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopTask>>,
    TError,
    { taskId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof stopTask>>,
  TError,
  { taskId: string },
  TContext
> => {
  const mutationOptions = getStopTaskMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the search hint result.
 */
export const get = (params: GetParams, signal?: AbortSignal) => {
  return apiInstance<SearchHintResult>({
    url: `/Search/Hints`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetQueryKey = (params: GetParams) => {
  return [`/Search/Hints`, ...(params ? [params] : [])] as const;
};

export const getGetQueryOptions = <
  TData = Awaited<ReturnType<typeof get>>,
  TError = ErrorType<void>
>(
  params: GetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({
    signal,
  }) => get(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetQueryError = ErrorType<void>;

export function useGet<
  TData = Awaited<ReturnType<typeof get>>,
  TError = ErrorType<void>
>(
  params: GetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof get>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGet<
  TData = Awaited<ReturnType<typeof get>>,
  TError = ErrorType<void>
>(
  params: GetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof get>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGet<
  TData = Awaited<ReturnType<typeof get>>,
  TError = ErrorType<void>
>(
  params: GetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the search hint result.
 */

export function useGet<
  TData = Awaited<ReturnType<typeof get>>,
  TError = ErrorType<void>
>(
  params: GetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all password reset providers.
 */
export const getPasswordResetProviders = (signal?: AbortSignal) => {
  return apiInstance<NameIdPair[]>({
    url: `/Auth/PasswordResetProviders`,
    method: "GET",
    signal,
  });
};

export const getGetPasswordResetProvidersQueryKey = () => {
  return [`/Auth/PasswordResetProviders`] as const;
};

export const getGetPasswordResetProvidersQueryOptions = <
  TData = Awaited<ReturnType<typeof getPasswordResetProviders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPasswordResetProviders>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPasswordResetProvidersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPasswordResetProviders>>
  > = ({ signal }) => getPasswordResetProviders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPasswordResetProviders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPasswordResetProvidersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPasswordResetProviders>>
>;
export type GetPasswordResetProvidersQueryError = ErrorType<void>;

export function useGetPasswordResetProviders<
  TData = Awaited<ReturnType<typeof getPasswordResetProviders>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPasswordResetProviders>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPasswordResetProviders>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPasswordResetProviders<
  TData = Awaited<ReturnType<typeof getPasswordResetProviders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPasswordResetProviders>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPasswordResetProviders>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPasswordResetProviders<
  TData = Awaited<ReturnType<typeof getPasswordResetProviders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPasswordResetProviders>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get all password reset providers.
 */

export function useGetPasswordResetProviders<
  TData = Awaited<ReturnType<typeof getPasswordResetProviders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPasswordResetProviders>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPasswordResetProvidersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all auth providers.
 */
export const getAuthProviders = (signal?: AbortSignal) => {
  return apiInstance<NameIdPair[]>({
    url: `/Auth/Providers`,
    method: "GET",
    signal,
  });
};

export const getGetAuthProvidersQueryKey = () => {
  return [`/Auth/Providers`] as const;
};

export const getGetAuthProvidersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthProviders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAuthProviders>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthProvidersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAuthProviders>>
  > = ({ signal }) => getAuthProviders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthProviders>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAuthProvidersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthProviders>>
>;
export type GetAuthProvidersQueryError = ErrorType<void>;

export function useGetAuthProviders<
  TData = Awaited<ReturnType<typeof getAuthProviders>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAuthProviders>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getAuthProviders>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAuthProviders<
  TData = Awaited<ReturnType<typeof getAuthProviders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAuthProviders>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getAuthProviders>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAuthProviders<
  TData = Awaited<ReturnType<typeof getAuthProviders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAuthProviders>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get all auth providers.
 */

export function useGetAuthProviders<
  TData = Awaited<ReturnType<typeof getAuthProviders>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAuthProviders>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAuthProvidersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a list of sessions.
 */
export const getSessions = (
  params?: GetSessionsParams,
  signal?: AbortSignal
) => {
  return apiInstance<SessionInfo[]>({
    url: `/Sessions`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSessionsQueryKey = (params?: GetSessionsParams) => {
  return [`/Sessions`, ...(params ? [params] : [])] as const;
};

export const getGetSessionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSessions>>,
  TError = ErrorType<void>
>(
  params?: GetSessionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSessions>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSessionsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessions>>> = ({
    signal,
  }) => getSessions(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSessions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSessionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSessions>>
>;
export type GetSessionsQueryError = ErrorType<void>;

export function useGetSessions<
  TData = Awaited<ReturnType<typeof getSessions>>,
  TError = ErrorType<void>
>(
  params: undefined | GetSessionsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSessions>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSessions<
  TData = Awaited<ReturnType<typeof getSessions>>,
  TError = ErrorType<void>
>(
  params?: GetSessionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSessions>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSessions<
  TData = Awaited<ReturnType<typeof getSessions>>,
  TError = ErrorType<void>
>(
  params?: GetSessionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSessions>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a list of sessions.
 */

export function useGetSessions<
  TData = Awaited<ReturnType<typeof getSessions>>,
  TError = ErrorType<void>
>(
  params?: GetSessionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSessions>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSessionsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Issues a full general command to a client.
 */
export const sendFullGeneralCommand = (
  sessionId: string,
  generalCommand: GeneralCommand
) => {
  return apiInstance<void>({
    url: `/Sessions/${sessionId}/Command`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: generalCommand,
  });
};

export const getSendFullGeneralCommandMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendFullGeneralCommand>>,
    TError,
    { sessionId: string; data: GeneralCommand },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendFullGeneralCommand>>,
  TError,
  { sessionId: string; data: GeneralCommand },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendFullGeneralCommand>>,
    { sessionId: string; data: GeneralCommand }
  > = (props) => {
    const { sessionId, data } = props ?? {};

    return sendFullGeneralCommand(sessionId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendFullGeneralCommandMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendFullGeneralCommand>>
>;
export type SendFullGeneralCommandMutationBody = GeneralCommand;
export type SendFullGeneralCommandMutationError = ErrorType<void>;

/**
 * @summary Issues a full general command to a client.
 */
export const useSendFullGeneralCommand = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendFullGeneralCommand>>,
    TError,
    { sessionId: string; data: GeneralCommand },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sendFullGeneralCommand>>,
  TError,
  { sessionId: string; data: GeneralCommand },
  TContext
> => {
  const mutationOptions = getSendFullGeneralCommandMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Issues a general command to a client.
 */
export const sendGeneralCommand = (
  sessionId: string,
  command: GeneralCommandType
) => {
  return apiInstance<void>({
    url: `/Sessions/${sessionId}/Command/${command}`,
    method: "POST",
  });
};

export const getSendGeneralCommandMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendGeneralCommand>>,
    TError,
    { sessionId: string; command: GeneralCommandType },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendGeneralCommand>>,
  TError,
  { sessionId: string; command: GeneralCommandType },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendGeneralCommand>>,
    { sessionId: string; command: GeneralCommandType }
  > = (props) => {
    const { sessionId, command } = props ?? {};

    return sendGeneralCommand(sessionId, command);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendGeneralCommandMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendGeneralCommand>>
>;

export type SendGeneralCommandMutationError = ErrorType<void>;

/**
 * @summary Issues a general command to a client.
 */
export const useSendGeneralCommand = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendGeneralCommand>>,
    TError,
    { sessionId: string; command: GeneralCommandType },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sendGeneralCommand>>,
  TError,
  { sessionId: string; command: GeneralCommandType },
  TContext
> => {
  const mutationOptions = getSendGeneralCommandMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Issues a command to a client to display a message to the user.
 */
export const sendMessageCommand = (
  sessionId: string,
  messageCommand: MessageCommand
) => {
  return apiInstance<void>({
    url: `/Sessions/${sessionId}/Message`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: messageCommand,
  });
};

export const getSendMessageCommandMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendMessageCommand>>,
    TError,
    { sessionId: string; data: MessageCommand },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendMessageCommand>>,
  TError,
  { sessionId: string; data: MessageCommand },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendMessageCommand>>,
    { sessionId: string; data: MessageCommand }
  > = (props) => {
    const { sessionId, data } = props ?? {};

    return sendMessageCommand(sessionId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendMessageCommandMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendMessageCommand>>
>;
export type SendMessageCommandMutationBody = MessageCommand;
export type SendMessageCommandMutationError = ErrorType<void>;

/**
 * @summary Issues a command to a client to display a message to the user.
 */
export const useSendMessageCommand = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendMessageCommand>>,
    TError,
    { sessionId: string; data: MessageCommand },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sendMessageCommand>>,
  TError,
  { sessionId: string; data: MessageCommand },
  TContext
> => {
  const mutationOptions = getSendMessageCommandMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Instructs a session to play an item.
 */
export const play = (sessionId: string, params: PlayParams) => {
  return apiInstance<void>({
    url: `/Sessions/${sessionId}/Playing`,
    method: "POST",
    params,
  });
};

export const getPlayMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof play>>,
    TError,
    { sessionId: string; params: PlayParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof play>>,
  TError,
  { sessionId: string; params: PlayParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof play>>,
    { sessionId: string; params: PlayParams }
  > = (props) => {
    const { sessionId, params } = props ?? {};

    return play(sessionId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlayMutationResult = NonNullable<Awaited<ReturnType<typeof play>>>;

export type PlayMutationError = ErrorType<void>;

/**
 * @summary Instructs a session to play an item.
 */
export const usePlay = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof play>>,
    TError,
    { sessionId: string; params: PlayParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof play>>,
  TError,
  { sessionId: string; params: PlayParams },
  TContext
> => {
  const mutationOptions = getPlayMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Issues a playstate command to a client.
 */
export const sendPlaystateCommand = (
  sessionId: string,
  command: PlaystateCommand,
  params?: SendPlaystateCommandParams
) => {
  return apiInstance<void>({
    url: `/Sessions/${sessionId}/Playing/${command}`,
    method: "POST",
    params,
  });
};

export const getSendPlaystateCommandMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendPlaystateCommand>>,
    TError,
    {
      sessionId: string;
      command: PlaystateCommand;
      params?: SendPlaystateCommandParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendPlaystateCommand>>,
  TError,
  {
    sessionId: string;
    command: PlaystateCommand;
    params?: SendPlaystateCommandParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendPlaystateCommand>>,
    {
      sessionId: string;
      command: PlaystateCommand;
      params?: SendPlaystateCommandParams;
    }
  > = (props) => {
    const { sessionId, command, params } = props ?? {};

    return sendPlaystateCommand(sessionId, command, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendPlaystateCommandMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendPlaystateCommand>>
>;

export type SendPlaystateCommandMutationError = ErrorType<void>;

/**
 * @summary Issues a playstate command to a client.
 */
export const useSendPlaystateCommand = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendPlaystateCommand>>,
    TError,
    {
      sessionId: string;
      command: PlaystateCommand;
      params?: SendPlaystateCommandParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sendPlaystateCommand>>,
  TError,
  {
    sessionId: string;
    command: PlaystateCommand;
    params?: SendPlaystateCommandParams;
  },
  TContext
> => {
  const mutationOptions = getSendPlaystateCommandMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Issues a system command to a client.
 */
export const sendSystemCommand = (
  sessionId: string,
  command: GeneralCommandType
) => {
  return apiInstance<void>({
    url: `/Sessions/${sessionId}/System/${command}`,
    method: "POST",
  });
};

export const getSendSystemCommandMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendSystemCommand>>,
    TError,
    { sessionId: string; command: GeneralCommandType },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendSystemCommand>>,
  TError,
  { sessionId: string; command: GeneralCommandType },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendSystemCommand>>,
    { sessionId: string; command: GeneralCommandType }
  > = (props) => {
    const { sessionId, command } = props ?? {};

    return sendSystemCommand(sessionId, command);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendSystemCommandMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendSystemCommand>>
>;

export type SendSystemCommandMutationError = ErrorType<void>;

/**
 * @summary Issues a system command to a client.
 */
export const useSendSystemCommand = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendSystemCommand>>,
    TError,
    { sessionId: string; command: GeneralCommandType },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof sendSystemCommand>>,
  TError,
  { sessionId: string; command: GeneralCommandType },
  TContext
> => {
  const mutationOptions = getSendSystemCommandMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Adds an additional user to a session.
 */
export const addUserToSession = (sessionId: string, userId: string) => {
  return apiInstance<void>({
    url: `/Sessions/${sessionId}/User/${userId}`,
    method: "POST",
  });
};

export const getAddUserToSessionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addUserToSession>>,
    TError,
    { sessionId: string; userId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addUserToSession>>,
  TError,
  { sessionId: string; userId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addUserToSession>>,
    { sessionId: string; userId: string }
  > = (props) => {
    const { sessionId, userId } = props ?? {};

    return addUserToSession(sessionId, userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddUserToSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof addUserToSession>>
>;

export type AddUserToSessionMutationError = ErrorType<void>;

/**
 * @summary Adds an additional user to a session.
 */
export const useAddUserToSession = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addUserToSession>>,
    TError,
    { sessionId: string; userId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof addUserToSession>>,
  TError,
  { sessionId: string; userId: string },
  TContext
> => {
  const mutationOptions = getAddUserToSessionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Removes an additional user from a session.
 */
export const removeUserFromSession = (sessionId: string, userId: string) => {
  return apiInstance<void>({
    url: `/Sessions/${sessionId}/User/${userId}`,
    method: "DELETE",
  });
};

export const getRemoveUserFromSessionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUserFromSession>>,
    TError,
    { sessionId: string; userId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeUserFromSession>>,
  TError,
  { sessionId: string; userId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUserFromSession>>,
    { sessionId: string; userId: string }
  > = (props) => {
    const { sessionId, userId } = props ?? {};

    return removeUserFromSession(sessionId, userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserFromSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUserFromSession>>
>;

export type RemoveUserFromSessionMutationError = ErrorType<void>;

/**
 * @summary Removes an additional user from a session.
 */
export const useRemoveUserFromSession = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUserFromSession>>,
    TError,
    { sessionId: string; userId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof removeUserFromSession>>,
  TError,
  { sessionId: string; userId: string },
  TContext
> => {
  const mutationOptions = getRemoveUserFromSessionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Instructs a session to browse to an item or view.
 */
export const displayContent = (
  sessionId: string,
  params: DisplayContentParams
) => {
  return apiInstance<void>({
    url: `/Sessions/${sessionId}/Viewing`,
    method: "POST",
    params,
  });
};

export const getDisplayContentMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof displayContent>>,
    TError,
    { sessionId: string; params: DisplayContentParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof displayContent>>,
  TError,
  { sessionId: string; params: DisplayContentParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof displayContent>>,
    { sessionId: string; params: DisplayContentParams }
  > = (props) => {
    const { sessionId, params } = props ?? {};

    return displayContent(sessionId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DisplayContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof displayContent>>
>;

export type DisplayContentMutationError = ErrorType<void>;

/**
 * @summary Instructs a session to browse to an item or view.
 */
export const useDisplayContent = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof displayContent>>,
    TError,
    { sessionId: string; params: DisplayContentParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof displayContent>>,
  TError,
  { sessionId: string; params: DisplayContentParams },
  TContext
> => {
  const mutationOptions = getDisplayContentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates capabilities for a device.
 */
export const postCapabilities = (params?: PostCapabilitiesParams) => {
  return apiInstance<void>({
    url: `/Sessions/Capabilities`,
    method: "POST",
    params,
  });
};

export const getPostCapabilitiesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postCapabilities>>,
    TError,
    { params?: PostCapabilitiesParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postCapabilities>>,
  TError,
  { params?: PostCapabilitiesParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postCapabilities>>,
    { params?: PostCapabilitiesParams }
  > = (props) => {
    const { params } = props ?? {};

    return postCapabilities(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostCapabilitiesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postCapabilities>>
>;

export type PostCapabilitiesMutationError = ErrorType<void>;

/**
 * @summary Updates capabilities for a device.
 */
export const usePostCapabilities = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postCapabilities>>,
    TError,
    { params?: PostCapabilitiesParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postCapabilities>>,
  TError,
  { params?: PostCapabilitiesParams },
  TContext
> => {
  const mutationOptions = getPostCapabilitiesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates capabilities for a device.
 */
export const postFullCapabilities = (
  clientCapabilitiesDto: ClientCapabilitiesDto,
  params?: PostFullCapabilitiesParams
) => {
  return apiInstance<void>({
    url: `/Sessions/Capabilities/Full`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: clientCapabilitiesDto,
    params,
  });
};

export const getPostFullCapabilitiesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postFullCapabilities>>,
    TError,
    { data: ClientCapabilitiesDto; params?: PostFullCapabilitiesParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postFullCapabilities>>,
  TError,
  { data: ClientCapabilitiesDto; params?: PostFullCapabilitiesParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postFullCapabilities>>,
    { data: ClientCapabilitiesDto; params?: PostFullCapabilitiesParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return postFullCapabilities(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostFullCapabilitiesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postFullCapabilities>>
>;
export type PostFullCapabilitiesMutationBody = ClientCapabilitiesDto;
export type PostFullCapabilitiesMutationError = ErrorType<void>;

/**
 * @summary Updates capabilities for a device.
 */
export const usePostFullCapabilities = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postFullCapabilities>>,
    TError,
    { data: ClientCapabilitiesDto; params?: PostFullCapabilitiesParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postFullCapabilities>>,
  TError,
  { data: ClientCapabilitiesDto; params?: PostFullCapabilitiesParams },
  TContext
> => {
  const mutationOptions = getPostFullCapabilitiesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports that a session has ended.
 */
export const reportSessionEnded = () => {
  return apiInstance<void>({ url: `/Sessions/Logout`, method: "POST" });
};

export const getReportSessionEndedMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportSessionEnded>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportSessionEnded>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportSessionEnded>>,
    void
  > = () => {
    return reportSessionEnded();
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportSessionEndedMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportSessionEnded>>
>;

export type ReportSessionEndedMutationError = ErrorType<void>;

/**
 * @summary Reports that a session has ended.
 */
export const useReportSessionEnded = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportSessionEnded>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof reportSessionEnded>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getReportSessionEndedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Reports that a session is viewing an item.
 */
export const reportViewing = (params: ReportViewingParams) => {
  return apiInstance<void>({
    url: `/Sessions/Viewing`,
    method: "POST",
    params,
  });
};

export const getReportViewingMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportViewing>>,
    TError,
    { params: ReportViewingParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportViewing>>,
  TError,
  { params: ReportViewingParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportViewing>>,
    { params: ReportViewingParams }
  > = (props) => {
    const { params } = props ?? {};

    return reportViewing(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportViewingMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportViewing>>
>;

export type ReportViewingMutationError = ErrorType<void>;

/**
 * @summary Reports that a session is viewing an item.
 */
export const useReportViewing = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportViewing>>,
    TError,
    { params: ReportViewingParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof reportViewing>>,
  TError,
  { params: ReportViewingParams },
  TContext
> => {
  const mutationOptions = getReportViewingMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Completes the startup wizard.
 */
export const completeWizard = () => {
  return apiInstance<void>({ url: `/Startup/Complete`, method: "POST" });
};

export const getCompleteWizardMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completeWizard>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof completeWizard>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof completeWizard>>,
    void
  > = () => {
    return completeWizard();
  };

  return { mutationFn, ...mutationOptions };
};

export type CompleteWizardMutationResult = NonNullable<
  Awaited<ReturnType<typeof completeWizard>>
>;

export type CompleteWizardMutationError = ErrorType<void>;

/**
 * @summary Completes the startup wizard.
 */
export const useCompleteWizard = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completeWizard>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof completeWizard>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getCompleteWizardMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the initial startup wizard configuration.
 */
export const getStartupConfiguration = (signal?: AbortSignal) => {
  return apiInstance<StartupConfigurationDto>({
    url: `/Startup/Configuration`,
    method: "GET",
    signal,
  });
};

export const getGetStartupConfigurationQueryKey = () => {
  return [`/Startup/Configuration`] as const;
};

export const getGetStartupConfigurationQueryOptions = <
  TData = Awaited<ReturnType<typeof getStartupConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getStartupConfiguration>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetStartupConfigurationQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStartupConfiguration>>
  > = ({ signal }) => getStartupConfiguration(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStartupConfiguration>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetStartupConfigurationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStartupConfiguration>>
>;
export type GetStartupConfigurationQueryError = ErrorType<void>;

export function useGetStartupConfiguration<
  TData = Awaited<ReturnType<typeof getStartupConfiguration>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getStartupConfiguration>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getStartupConfiguration>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStartupConfiguration<
  TData = Awaited<ReturnType<typeof getStartupConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getStartupConfiguration>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getStartupConfiguration>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStartupConfiguration<
  TData = Awaited<ReturnType<typeof getStartupConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getStartupConfiguration>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the initial startup wizard configuration.
 */

export function useGetStartupConfiguration<
  TData = Awaited<ReturnType<typeof getStartupConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getStartupConfiguration>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetStartupConfigurationQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Sets the initial startup wizard configuration.
 */
export const updateInitialConfiguration = (
  startupConfigurationDto: StartupConfigurationDto
) => {
  return apiInstance<void>({
    url: `/Startup/Configuration`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: startupConfigurationDto,
  });
};

export const getUpdateInitialConfigurationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInitialConfiguration>>,
    TError,
    { data: StartupConfigurationDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInitialConfiguration>>,
  TError,
  { data: StartupConfigurationDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInitialConfiguration>>,
    { data: StartupConfigurationDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateInitialConfiguration(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateInitialConfigurationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInitialConfiguration>>
>;
export type UpdateInitialConfigurationMutationBody = StartupConfigurationDto;
export type UpdateInitialConfigurationMutationError = ErrorType<void>;

/**
 * @summary Sets the initial startup wizard configuration.
 */
export const useUpdateInitialConfiguration = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInitialConfiguration>>,
    TError,
    { data: StartupConfigurationDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateInitialConfiguration>>,
  TError,
  { data: StartupConfigurationDto },
  TContext
> => {
  const mutationOptions = getUpdateInitialConfigurationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the first user.
 */
export const getFirstUser2 = (signal?: AbortSignal) => {
  return apiInstance<StartupUserDto>({
    url: `/Startup/FirstUser`,
    method: "GET",
    signal,
  });
};

export const getGetFirstUser2QueryKey = () => {
  return [`/Startup/FirstUser`] as const;
};

export const getGetFirstUser2QueryOptions = <
  TData = Awaited<ReturnType<typeof getFirstUser2>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser2>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFirstUser2QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFirstUser2>>> = ({
    signal,
  }) => getFirstUser2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFirstUser2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetFirstUser2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getFirstUser2>>
>;
export type GetFirstUser2QueryError = ErrorType<void>;

export function useGetFirstUser2<
  TData = Awaited<ReturnType<typeof getFirstUser2>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser2>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getFirstUser2>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFirstUser2<
  TData = Awaited<ReturnType<typeof getFirstUser2>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser2>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getFirstUser2>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFirstUser2<
  TData = Awaited<ReturnType<typeof getFirstUser2>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser2>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the first user.
 */

export function useGetFirstUser2<
  TData = Awaited<ReturnType<typeof getFirstUser2>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser2>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetFirstUser2QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Sets remote access and UPnP.
 */
export const setRemoteAccess = (
  startupRemoteAccessDto: StartupRemoteAccessDto
) => {
  return apiInstance<void>({
    url: `/Startup/RemoteAccess`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: startupRemoteAccessDto,
  });
};

export const getSetRemoteAccessMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setRemoteAccess>>,
    TError,
    { data: StartupRemoteAccessDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setRemoteAccess>>,
  TError,
  { data: StartupRemoteAccessDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setRemoteAccess>>,
    { data: StartupRemoteAccessDto }
  > = (props) => {
    const { data } = props ?? {};

    return setRemoteAccess(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetRemoteAccessMutationResult = NonNullable<
  Awaited<ReturnType<typeof setRemoteAccess>>
>;
export type SetRemoteAccessMutationBody = StartupRemoteAccessDto;
export type SetRemoteAccessMutationError = ErrorType<void>;

/**
 * @summary Sets remote access and UPnP.
 */
export const useSetRemoteAccess = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setRemoteAccess>>,
    TError,
    { data: StartupRemoteAccessDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof setRemoteAccess>>,
  TError,
  { data: StartupRemoteAccessDto },
  TContext
> => {
  const mutationOptions = getSetRemoteAccessMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the first user.
 */
export const getFirstUser = (signal?: AbortSignal) => {
  return apiInstance<StartupUserDto>({
    url: `/Startup/User`,
    method: "GET",
    signal,
  });
};

export const getGetFirstUserQueryKey = () => {
  return [`/Startup/User`] as const;
};

export const getGetFirstUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getFirstUser>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFirstUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFirstUser>>> = ({
    signal,
  }) => getFirstUser(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFirstUser>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetFirstUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFirstUser>>
>;
export type GetFirstUserQueryError = ErrorType<void>;

export function useGetFirstUser<
  TData = Awaited<ReturnType<typeof getFirstUser>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getFirstUser>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFirstUser<
  TData = Awaited<ReturnType<typeof getFirstUser>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getFirstUser>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFirstUser<
  TData = Awaited<ReturnType<typeof getFirstUser>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the first user.
 */

export function useGetFirstUser<
  TData = Awaited<ReturnType<typeof getFirstUser>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFirstUser>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetFirstUserQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Sets the user name and password.
 */
export const updateStartupUser = (startupUserDto: StartupUserDto) => {
  return apiInstance<void>({
    url: `/Startup/User`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: startupUserDto,
  });
};

export const getUpdateStartupUserMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStartupUser>>,
    TError,
    { data: StartupUserDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateStartupUser>>,
  TError,
  { data: StartupUserDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStartupUser>>,
    { data: StartupUserDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateStartupUser(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateStartupUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateStartupUser>>
>;
export type UpdateStartupUserMutationBody = StartupUserDto;
export type UpdateStartupUserMutationError = ErrorType<void>;

/**
 * @summary Sets the user name and password.
 */
export const useUpdateStartupUser = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStartupUser>>,
    TError,
    { data: StartupUserDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateStartupUser>>,
  TError,
  { data: StartupUserDto },
  TContext
> => {
  const mutationOptions = getUpdateStartupUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets all studios from a given item, folder, or the entire library.
 */
export const getStudios = (params?: GetStudiosParams, signal?: AbortSignal) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Studios`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetStudiosQueryKey = (params?: GetStudiosParams) => {
  return [`/Studios`, ...(params ? [params] : [])] as const;
};

export const getGetStudiosQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudios>>,
  TError = ErrorType<void>
>(
  params?: GetStudiosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudios>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudiosQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudios>>> = ({
    signal,
  }) => getStudios(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudios>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetStudiosQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStudios>>
>;
export type GetStudiosQueryError = ErrorType<void>;

export function useGetStudios<
  TData = Awaited<ReturnType<typeof getStudios>>,
  TError = ErrorType<void>
>(
  params: undefined | GetStudiosParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudios>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudios>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStudios<
  TData = Awaited<ReturnType<typeof getStudios>>,
  TError = ErrorType<void>
>(
  params?: GetStudiosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudios>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudios>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStudios<
  TData = Awaited<ReturnType<typeof getStudios>>,
  TError = ErrorType<void>
>(
  params?: GetStudiosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudios>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all studios from a given item, folder, or the entire library.
 */

export function useGetStudios<
  TData = Awaited<ReturnType<typeof getStudios>>,
  TError = ErrorType<void>
>(
  params?: GetStudiosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudios>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetStudiosQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a studio by name.
 */
export const getStudio = (
  name: string,
  params?: GetStudioParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/Studios/${name}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetStudioQueryKey = (
  name: string,
  params?: GetStudioParams
) => {
  return [`/Studios/${name}`, ...(params ? [params] : [])] as const;
};

export const getGetStudioQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudio>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetStudioParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudio>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudioQueryKey(name, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudio>>> = ({
    signal,
  }) => getStudio(name, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getStudio>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetStudioQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStudio>>
>;
export type GetStudioQueryError = ErrorType<void>;

export function useGetStudio<
  TData = Awaited<ReturnType<typeof getStudio>>,
  TError = ErrorType<void>
>(
  name: string,
  params: undefined | GetStudioParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudio>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudio>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStudio<
  TData = Awaited<ReturnType<typeof getStudio>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetStudioParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudio>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudio>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetStudio<
  TData = Awaited<ReturnType<typeof getStudio>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetStudioParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudio>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a studio by name.
 */

export function useGetStudio<
  TData = Awaited<ReturnType<typeof getStudio>>,
  TError = ErrorType<void>
>(
  name: string,
  params?: GetStudioParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStudio>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetStudioQueryOptions(name, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a list of available fallback font files.
 */
export const getFallbackFontList = (signal?: AbortSignal) => {
  return apiInstance<FontFile[]>({
    url: `/FallbackFont/Fonts`,
    method: "GET",
    signal,
  });
};

export const getGetFallbackFontListQueryKey = () => {
  return [`/FallbackFont/Fonts`] as const;
};

export const getGetFallbackFontListQueryOptions = <
  TData = Awaited<ReturnType<typeof getFallbackFontList>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getFallbackFontList>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFallbackFontListQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFallbackFontList>>
  > = ({ signal }) => getFallbackFontList(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFallbackFontList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetFallbackFontListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFallbackFontList>>
>;
export type GetFallbackFontListQueryError = ErrorType<void>;

export function useGetFallbackFontList<
  TData = Awaited<ReturnType<typeof getFallbackFontList>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getFallbackFontList>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getFallbackFontList>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFallbackFontList<
  TData = Awaited<ReturnType<typeof getFallbackFontList>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getFallbackFontList>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getFallbackFontList>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFallbackFontList<
  TData = Awaited<ReturnType<typeof getFallbackFontList>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getFallbackFontList>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a list of available fallback font files.
 */

export function useGetFallbackFontList<
  TData = Awaited<ReturnType<typeof getFallbackFontList>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getFallbackFontList>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetFallbackFontListQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a fallback font file.
 */
export const getFallbackFont = (name: string, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/FallbackFont/Fonts/${name}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetFallbackFontQueryKey = (name: string) => {
  return [`/FallbackFont/Fonts/${name}`] as const;
};

export const getGetFallbackFontQueryOptions = <
  TData = Awaited<ReturnType<typeof getFallbackFont>>,
  TError = ErrorType<void>
>(
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFallbackFont>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFallbackFontQueryKey(name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFallbackFont>>> = ({
    signal,
  }) => getFallbackFont(name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getFallbackFont>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetFallbackFontQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFallbackFont>>
>;
export type GetFallbackFontQueryError = ErrorType<void>;

export function useGetFallbackFont<
  TData = Awaited<ReturnType<typeof getFallbackFont>>,
  TError = ErrorType<void>
>(
  name: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFallbackFont>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFallbackFont>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFallbackFont<
  TData = Awaited<ReturnType<typeof getFallbackFont>>,
  TError = ErrorType<void>
>(
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFallbackFont>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFallbackFont>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetFallbackFont<
  TData = Awaited<ReturnType<typeof getFallbackFont>>,
  TError = ErrorType<void>
>(
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFallbackFont>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a fallback font file.
 */

export function useGetFallbackFont<
  TData = Awaited<ReturnType<typeof getFallbackFont>>,
  TError = ErrorType<void>
>(
  name: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFallbackFont>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetFallbackFontQueryOptions(name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Search remote subtitles.
 */
export const searchRemoteSubtitles = (
  itemId: string,
  language: string,
  params?: SearchRemoteSubtitlesParams,
  signal?: AbortSignal
) => {
  return apiInstance<RemoteSubtitleInfo[]>({
    url: `/Items/${itemId}/RemoteSearch/Subtitles/${language}`,
    method: "GET",
    params,
    signal,
  });
};

export const getSearchRemoteSubtitlesQueryKey = (
  itemId: string,
  language: string,
  params?: SearchRemoteSubtitlesParams
) => {
  return [
    `/Items/${itemId}/RemoteSearch/Subtitles/${language}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSearchRemoteSubtitlesQueryOptions = <
  TData = Awaited<ReturnType<typeof searchRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  itemId: string,
  language: string,
  params?: SearchRemoteSubtitlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchRemoteSubtitles>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSearchRemoteSubtitlesQueryKey(itemId, language, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchRemoteSubtitles>>
  > = ({ signal }) => searchRemoteSubtitles(itemId, language, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && language),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof searchRemoteSubtitles>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchRemoteSubtitlesQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchRemoteSubtitles>>
>;
export type SearchRemoteSubtitlesQueryError = ErrorType<void>;

export function useSearchRemoteSubtitles<
  TData = Awaited<ReturnType<typeof searchRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  itemId: string,
  language: string,
  params: undefined | SearchRemoteSubtitlesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchRemoteSubtitles>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchRemoteSubtitles>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useSearchRemoteSubtitles<
  TData = Awaited<ReturnType<typeof searchRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  itemId: string,
  language: string,
  params?: SearchRemoteSubtitlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchRemoteSubtitles>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchRemoteSubtitles>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useSearchRemoteSubtitles<
  TData = Awaited<ReturnType<typeof searchRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  itemId: string,
  language: string,
  params?: SearchRemoteSubtitlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchRemoteSubtitles>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Search remote subtitles.
 */

export function useSearchRemoteSubtitles<
  TData = Awaited<ReturnType<typeof searchRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  itemId: string,
  language: string,
  params?: SearchRemoteSubtitlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchRemoteSubtitles>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchRemoteSubtitlesQueryOptions(
    itemId,
    language,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Downloads a remote subtitle.
 */
export const downloadRemoteSubtitles = (itemId: string, subtitleId: string) => {
  return apiInstance<void>({
    url: `/Items/${itemId}/RemoteSearch/Subtitles/${subtitleId}`,
    method: "POST",
  });
};

export const getDownloadRemoteSubtitlesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof downloadRemoteSubtitles>>,
    TError,
    { itemId: string; subtitleId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof downloadRemoteSubtitles>>,
  TError,
  { itemId: string; subtitleId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof downloadRemoteSubtitles>>,
    { itemId: string; subtitleId: string }
  > = (props) => {
    const { itemId, subtitleId } = props ?? {};

    return downloadRemoteSubtitles(itemId, subtitleId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DownloadRemoteSubtitlesMutationResult = NonNullable<
  Awaited<ReturnType<typeof downloadRemoteSubtitles>>
>;

export type DownloadRemoteSubtitlesMutationError = ErrorType<void>;

/**
 * @summary Downloads a remote subtitle.
 */
export const useDownloadRemoteSubtitles = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof downloadRemoteSubtitles>>,
    TError,
    { itemId: string; subtitleId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof downloadRemoteSubtitles>>,
  TError,
  { itemId: string; subtitleId: string },
  TContext
> => {
  const mutationOptions = getDownloadRemoteSubtitlesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the remote subtitles.
 */
export const getRemoteSubtitles = (id: string, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/Providers/Subtitles/Subtitles/${id}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetRemoteSubtitlesQueryKey = (id: string) => {
  return [`/Providers/Subtitles/Subtitles/${id}`] as const;
};

export const getGetRemoteSubtitlesQueryOptions = <
  TData = Awaited<ReturnType<typeof getRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteSubtitles>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRemoteSubtitlesQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRemoteSubtitles>>
  > = ({ signal }) => getRemoteSubtitles(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRemoteSubtitles>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRemoteSubtitlesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRemoteSubtitles>>
>;
export type GetRemoteSubtitlesQueryError = ErrorType<void>;

export function useGetRemoteSubtitles<
  TData = Awaited<ReturnType<typeof getRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteSubtitles>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRemoteSubtitles>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRemoteSubtitles<
  TData = Awaited<ReturnType<typeof getRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteSubtitles>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRemoteSubtitles>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRemoteSubtitles<
  TData = Awaited<ReturnType<typeof getRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteSubtitles>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the remote subtitles.
 */

export function useGetRemoteSubtitles<
  TData = Awaited<ReturnType<typeof getRemoteSubtitles>>,
  TError = ErrorType<void>
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRemoteSubtitles>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRemoteSubtitlesQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an HLS subtitle playlist.
 */
export const getSubtitlePlaylist = (
  itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/${mediaSourceId}/Subtitles/${index}/subtitles.m3u8`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetSubtitlePlaylistQueryKey = (
  itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams
) => {
  return [
    `/Videos/${itemId}/${mediaSourceId}/Subtitles/${index}/subtitles.m3u8`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSubtitlePlaylistQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubtitlePlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitlePlaylist>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSubtitlePlaylistQueryKey(itemId, mediaSourceId, index, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSubtitlePlaylist>>
  > = ({ signal }) =>
    getSubtitlePlaylist(itemId, mediaSourceId, index, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && mediaSourceId && index),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSubtitlePlaylist>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSubtitlePlaylistQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubtitlePlaylist>>
>;
export type GetSubtitlePlaylistQueryError = ErrorType<void>;

export function useGetSubtitlePlaylist<
  TData = Awaited<ReturnType<typeof getSubtitlePlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitlePlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubtitlePlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSubtitlePlaylist<
  TData = Awaited<ReturnType<typeof getSubtitlePlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitlePlaylist>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubtitlePlaylist>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSubtitlePlaylist<
  TData = Awaited<ReturnType<typeof getSubtitlePlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitlePlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets an HLS subtitle playlist.
 */

export function useGetSubtitlePlaylist<
  TData = Awaited<ReturnType<typeof getSubtitlePlaylist>>,
  TError = ErrorType<void>
>(
  itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitlePlaylist>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSubtitlePlaylistQueryOptions(
    itemId,
    mediaSourceId,
    index,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Upload an external subtitle file.
 */
export const uploadSubtitle = (
  itemId: string,
  uploadSubtitleDto: UploadSubtitleDto
) => {
  return apiInstance<void>({
    url: `/Videos/${itemId}/Subtitles`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: uploadSubtitleDto,
  });
};

export const getUploadSubtitleMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadSubtitle>>,
    TError,
    { itemId: string; data: UploadSubtitleDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadSubtitle>>,
  TError,
  { itemId: string; data: UploadSubtitleDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadSubtitle>>,
    { itemId: string; data: UploadSubtitleDto }
  > = (props) => {
    const { itemId, data } = props ?? {};

    return uploadSubtitle(itemId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadSubtitleMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadSubtitle>>
>;
export type UploadSubtitleMutationBody = UploadSubtitleDto;
export type UploadSubtitleMutationError = ErrorType<void>;

/**
 * @summary Upload an external subtitle file.
 */
export const useUploadSubtitle = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadSubtitle>>,
    TError,
    { itemId: string; data: UploadSubtitleDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof uploadSubtitle>>,
  TError,
  { itemId: string; data: UploadSubtitleDto },
  TContext
> => {
  const mutationOptions = getUploadSubtitleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Deletes an external subtitle file.
 */
export const deleteSubtitle = (itemId: string, index: number) => {
  return apiInstance<void>({
    url: `/Videos/${itemId}/Subtitles/${index}`,
    method: "DELETE",
  });
};

export const getDeleteSubtitleMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSubtitle>>,
    TError,
    { itemId: string; index: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSubtitle>>,
  TError,
  { itemId: string; index: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSubtitle>>,
    { itemId: string; index: number }
  > = (props) => {
    const { itemId, index } = props ?? {};

    return deleteSubtitle(itemId, index);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSubtitleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSubtitle>>
>;

export type DeleteSubtitleMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Deletes an external subtitle file.
 */
export const useDeleteSubtitle = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSubtitle>>,
    TError,
    { itemId: string; index: number },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteSubtitle>>,
  TError,
  { itemId: string; index: number },
  TContext
> => {
  const mutationOptions = getDeleteSubtitleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets subtitles in a specified format.
 */
export const getSubtitleWithTicks = (
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params?: GetSubtitleWithTicksParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${routeItemId}/${routeMediaSourceId}/Subtitles/${routeIndex}/${routeStartPositionTicks}/Stream.${routeFormat}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetSubtitleWithTicksQueryKey = (
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params?: GetSubtitleWithTicksParams
) => {
  return [
    `/Videos/${routeItemId}/${routeMediaSourceId}/Subtitles/${routeIndex}/${routeStartPositionTicks}/Stream.${routeFormat}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSubtitleWithTicksQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubtitleWithTicks>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params?: GetSubtitleWithTicksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitleWithTicks>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSubtitleWithTicksQueryKey(
      routeItemId,
      routeMediaSourceId,
      routeIndex,
      routeStartPositionTicks,
      routeFormat,
      params
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSubtitleWithTicks>>
  > = ({ signal }) =>
    getSubtitleWithTicks(
      routeItemId,
      routeMediaSourceId,
      routeIndex,
      routeStartPositionTicks,
      routeFormat,
      params,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(
      routeItemId &&
      routeMediaSourceId &&
      routeIndex &&
      routeStartPositionTicks &&
      routeFormat
    ),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSubtitleWithTicks>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSubtitleWithTicksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubtitleWithTicks>>
>;
export type GetSubtitleWithTicksQueryError = ErrorType<unknown>;

export function useGetSubtitleWithTicks<
  TData = Awaited<ReturnType<typeof getSubtitleWithTicks>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params: undefined | GetSubtitleWithTicksParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitleWithTicks>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubtitleWithTicks>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSubtitleWithTicks<
  TData = Awaited<ReturnType<typeof getSubtitleWithTicks>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params?: GetSubtitleWithTicksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitleWithTicks>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubtitleWithTicks>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSubtitleWithTicks<
  TData = Awaited<ReturnType<typeof getSubtitleWithTicks>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params?: GetSubtitleWithTicksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitleWithTicks>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets subtitles in a specified format.
 */

export function useGetSubtitleWithTicks<
  TData = Awaited<ReturnType<typeof getSubtitleWithTicks>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params?: GetSubtitleWithTicksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubtitleWithTicks>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSubtitleWithTicksQueryOptions(
    routeItemId,
    routeMediaSourceId,
    routeIndex,
    routeStartPositionTicks,
    routeFormat,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets subtitles in a specified format.
 */
export const getSubtitle = (
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params?: GetSubtitleParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${routeItemId}/${routeMediaSourceId}/Subtitles/${routeIndex}/Stream.${routeFormat}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetSubtitleQueryKey = (
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params?: GetSubtitleParams
) => {
  return [
    `/Videos/${routeItemId}/${routeMediaSourceId}/Subtitles/${routeIndex}/Stream.${routeFormat}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSubtitleQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubtitle>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params?: GetSubtitleParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubtitle>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSubtitleQueryKey(
      routeItemId,
      routeMediaSourceId,
      routeIndex,
      routeFormat,
      params
    );

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubtitle>>> = ({
    signal,
  }) =>
    getSubtitle(
      routeItemId,
      routeMediaSourceId,
      routeIndex,
      routeFormat,
      params,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(routeItemId && routeMediaSourceId && routeIndex && routeFormat),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSubtitle>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSubtitleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubtitle>>
>;
export type GetSubtitleQueryError = ErrorType<unknown>;

export function useGetSubtitle<
  TData = Awaited<ReturnType<typeof getSubtitle>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params: undefined | GetSubtitleParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubtitle>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubtitle>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSubtitle<
  TData = Awaited<ReturnType<typeof getSubtitle>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params?: GetSubtitleParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubtitle>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubtitle>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSubtitle<
  TData = Awaited<ReturnType<typeof getSubtitle>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params?: GetSubtitleParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubtitle>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets subtitles in a specified format.
 */

export function useGetSubtitle<
  TData = Awaited<ReturnType<typeof getSubtitle>>,
  TError = ErrorType<unknown>
>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params?: GetSubtitleParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubtitle>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSubtitleQueryOptions(
    routeItemId,
    routeMediaSourceId,
    routeIndex,
    routeFormat,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets suggestions.
 */
export const getSuggestions = (
  userId: string,
  params?: GetSuggestionsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Users/${userId}/Suggestions`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSuggestionsQueryKey = (
  userId: string,
  params?: GetSuggestionsParams
) => {
  return [`/Users/${userId}/Suggestions`, ...(params ? [params] : [])] as const;
};

export const getGetSuggestionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSuggestions>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetSuggestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSuggestions>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSuggestionsQueryKey(userId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSuggestions>>> = ({
    signal,
  }) => getSuggestions(userId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSuggestions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSuggestionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSuggestions>>
>;
export type GetSuggestionsQueryError = ErrorType<void>;

export function useGetSuggestions<
  TData = Awaited<ReturnType<typeof getSuggestions>>,
  TError = ErrorType<void>
>(
  userId: string,
  params: undefined | GetSuggestionsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSuggestions>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSuggestions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSuggestions<
  TData = Awaited<ReturnType<typeof getSuggestions>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetSuggestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSuggestions>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSuggestions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSuggestions<
  TData = Awaited<ReturnType<typeof getSuggestions>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetSuggestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSuggestions>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets suggestions.
 */

export function useGetSuggestions<
  TData = Awaited<ReturnType<typeof getSuggestions>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetSuggestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSuggestions>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSuggestionsQueryOptions(userId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Notify SyncPlay group that member is buffering.
 */
export const syncPlayBuffering = (bufferRequestDto: BufferRequestDto) => {
  return apiInstance<void>({
    url: `/SyncPlay/Buffering`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: bufferRequestDto,
  });
};

export const getSyncPlayBufferingMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayBuffering>>,
    TError,
    { data: BufferRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayBuffering>>,
  TError,
  { data: BufferRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayBuffering>>,
    { data: BufferRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayBuffering(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayBufferingMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayBuffering>>
>;
export type SyncPlayBufferingMutationBody = BufferRequestDto;
export type SyncPlayBufferingMutationError = ErrorType<void>;

/**
 * @summary Notify SyncPlay group that member is buffering.
 */
export const useSyncPlayBuffering = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayBuffering>>,
    TError,
    { data: BufferRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayBuffering>>,
  TError,
  { data: BufferRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayBufferingMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Join an existing SyncPlay group.
 */
export const syncPlayJoinGroup = (joinGroupRequestDto: JoinGroupRequestDto) => {
  return apiInstance<void>({
    url: `/SyncPlay/Join`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: joinGroupRequestDto,
  });
};

export const getSyncPlayJoinGroupMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayJoinGroup>>,
    TError,
    { data: JoinGroupRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayJoinGroup>>,
  TError,
  { data: JoinGroupRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayJoinGroup>>,
    { data: JoinGroupRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayJoinGroup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayJoinGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayJoinGroup>>
>;
export type SyncPlayJoinGroupMutationBody = JoinGroupRequestDto;
export type SyncPlayJoinGroupMutationError = ErrorType<void>;

/**
 * @summary Join an existing SyncPlay group.
 */
export const useSyncPlayJoinGroup = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayJoinGroup>>,
    TError,
    { data: JoinGroupRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayJoinGroup>>,
  TError,
  { data: JoinGroupRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayJoinGroupMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Leave the joined SyncPlay group.
 */
export const syncPlayLeaveGroup = () => {
  return apiInstance<void>({ url: `/SyncPlay/Leave`, method: "POST" });
};

export const getSyncPlayLeaveGroupMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayLeaveGroup>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayLeaveGroup>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayLeaveGroup>>,
    void
  > = () => {
    return syncPlayLeaveGroup();
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayLeaveGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayLeaveGroup>>
>;

export type SyncPlayLeaveGroupMutationError = ErrorType<void>;

/**
 * @summary Leave the joined SyncPlay group.
 */
export const useSyncPlayLeaveGroup = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayLeaveGroup>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayLeaveGroup>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getSyncPlayLeaveGroupMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets all SyncPlay groups.
 */
export const syncPlayGetGroups = (signal?: AbortSignal) => {
  return apiInstance<GroupInfoDto[]>({
    url: `/SyncPlay/List`,
    method: "GET",
    signal,
  });
};

export const getSyncPlayGetGroupsQueryKey = () => {
  return [`/SyncPlay/List`] as const;
};

export const getSyncPlayGetGroupsQueryOptions = <
  TData = Awaited<ReturnType<typeof syncPlayGetGroups>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof syncPlayGetGroups>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSyncPlayGetGroupsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof syncPlayGetGroups>>
  > = ({ signal }) => syncPlayGetGroups(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof syncPlayGetGroups>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SyncPlayGetGroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayGetGroups>>
>;
export type SyncPlayGetGroupsQueryError = ErrorType<void>;

export function useSyncPlayGetGroups<
  TData = Awaited<ReturnType<typeof syncPlayGetGroups>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof syncPlayGetGroups>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof syncPlayGetGroups>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useSyncPlayGetGroups<
  TData = Awaited<ReturnType<typeof syncPlayGetGroups>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof syncPlayGetGroups>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof syncPlayGetGroups>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useSyncPlayGetGroups<
  TData = Awaited<ReturnType<typeof syncPlayGetGroups>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof syncPlayGetGroups>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets all SyncPlay groups.
 */

export function useSyncPlayGetGroups<
  TData = Awaited<ReturnType<typeof syncPlayGetGroups>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof syncPlayGetGroups>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSyncPlayGetGroupsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Request to move an item in the playlist in SyncPlay group.
 */
export const syncPlayMovePlaylistItem = (
  movePlaylistItemRequestDto: MovePlaylistItemRequestDto
) => {
  return apiInstance<void>({
    url: `/SyncPlay/MovePlaylistItem`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: movePlaylistItemRequestDto,
  });
};

export const getSyncPlayMovePlaylistItemMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>,
    TError,
    { data: MovePlaylistItemRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>,
  TError,
  { data: MovePlaylistItemRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>,
    { data: MovePlaylistItemRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayMovePlaylistItem(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayMovePlaylistItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>
>;
export type SyncPlayMovePlaylistItemMutationBody = MovePlaylistItemRequestDto;
export type SyncPlayMovePlaylistItemMutationError = ErrorType<void>;

/**
 * @summary Request to move an item in the playlist in SyncPlay group.
 */
export const useSyncPlayMovePlaylistItem = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>,
    TError,
    { data: MovePlaylistItemRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>,
  TError,
  { data: MovePlaylistItemRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayMovePlaylistItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create a new SyncPlay group.
 */
export const syncPlayCreateGroup = (newGroupRequestDto: NewGroupRequestDto) => {
  return apiInstance<void>({
    url: `/SyncPlay/New`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: newGroupRequestDto,
  });
};

export const getSyncPlayCreateGroupMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayCreateGroup>>,
    TError,
    { data: NewGroupRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayCreateGroup>>,
  TError,
  { data: NewGroupRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayCreateGroup>>,
    { data: NewGroupRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayCreateGroup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayCreateGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayCreateGroup>>
>;
export type SyncPlayCreateGroupMutationBody = NewGroupRequestDto;
export type SyncPlayCreateGroupMutationError = ErrorType<void>;

/**
 * @summary Create a new SyncPlay group.
 */
export const useSyncPlayCreateGroup = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayCreateGroup>>,
    TError,
    { data: NewGroupRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayCreateGroup>>,
  TError,
  { data: NewGroupRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayCreateGroupMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request next item in SyncPlay group.
 */
export const syncPlayNextItem = (nextItemRequestDto: NextItemRequestDto) => {
  return apiInstance<void>({
    url: `/SyncPlay/NextItem`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: nextItemRequestDto,
  });
};

export const getSyncPlayNextItemMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayNextItem>>,
    TError,
    { data: NextItemRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayNextItem>>,
  TError,
  { data: NextItemRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayNextItem>>,
    { data: NextItemRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayNextItem(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayNextItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayNextItem>>
>;
export type SyncPlayNextItemMutationBody = NextItemRequestDto;
export type SyncPlayNextItemMutationError = ErrorType<void>;

/**
 * @summary Request next item in SyncPlay group.
 */
export const useSyncPlayNextItem = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayNextItem>>,
    TError,
    { data: NextItemRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayNextItem>>,
  TError,
  { data: NextItemRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayNextItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request pause in SyncPlay group.
 */
export const syncPlayPause = () => {
  return apiInstance<void>({ url: `/SyncPlay/Pause`, method: "POST" });
};

export const getSyncPlayPauseMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayPause>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayPause>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayPause>>,
    void
  > = () => {
    return syncPlayPause();
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayPauseMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayPause>>
>;

export type SyncPlayPauseMutationError = ErrorType<void>;

/**
 * @summary Request pause in SyncPlay group.
 */
export const useSyncPlayPause = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayPause>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayPause>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getSyncPlayPauseMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Update session ping.
 */
export const syncPlayPing = (pingRequestDto: PingRequestDto) => {
  return apiInstance<void>({
    url: `/SyncPlay/Ping`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: pingRequestDto,
  });
};

export const getSyncPlayPingMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayPing>>,
    TError,
    { data: PingRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayPing>>,
  TError,
  { data: PingRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayPing>>,
    { data: PingRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayPing(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayPingMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayPing>>
>;
export type SyncPlayPingMutationBody = PingRequestDto;
export type SyncPlayPingMutationError = ErrorType<void>;

/**
 * @summary Update session ping.
 */
export const useSyncPlayPing = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayPing>>,
    TError,
    { data: PingRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayPing>>,
  TError,
  { data: PingRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayPingMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request previous item in SyncPlay group.
 */
export const syncPlayPreviousItem = (
  previousItemRequestDto: PreviousItemRequestDto
) => {
  return apiInstance<void>({
    url: `/SyncPlay/PreviousItem`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: previousItemRequestDto,
  });
};

export const getSyncPlayPreviousItemMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayPreviousItem>>,
    TError,
    { data: PreviousItemRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayPreviousItem>>,
  TError,
  { data: PreviousItemRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayPreviousItem>>,
    { data: PreviousItemRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayPreviousItem(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayPreviousItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayPreviousItem>>
>;
export type SyncPlayPreviousItemMutationBody = PreviousItemRequestDto;
export type SyncPlayPreviousItemMutationError = ErrorType<void>;

/**
 * @summary Request previous item in SyncPlay group.
 */
export const useSyncPlayPreviousItem = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayPreviousItem>>,
    TError,
    { data: PreviousItemRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayPreviousItem>>,
  TError,
  { data: PreviousItemRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayPreviousItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request to queue items to the playlist of a SyncPlay group.
 */
export const syncPlayQueue = (queueRequestDto: QueueRequestDto) => {
  return apiInstance<void>({
    url: `/SyncPlay/Queue`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queueRequestDto,
  });
};

export const getSyncPlayQueueMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayQueue>>,
    TError,
    { data: QueueRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayQueue>>,
  TError,
  { data: QueueRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayQueue>>,
    { data: QueueRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayQueue(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayQueueMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayQueue>>
>;
export type SyncPlayQueueMutationBody = QueueRequestDto;
export type SyncPlayQueueMutationError = ErrorType<void>;

/**
 * @summary Request to queue items to the playlist of a SyncPlay group.
 */
export const useSyncPlayQueue = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayQueue>>,
    TError,
    { data: QueueRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayQueue>>,
  TError,
  { data: QueueRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayQueueMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Notify SyncPlay group that member is ready for playback.
 */
export const syncPlayReady = (readyRequestDto: ReadyRequestDto) => {
  return apiInstance<void>({
    url: `/SyncPlay/Ready`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: readyRequestDto,
  });
};

export const getSyncPlayReadyMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayReady>>,
    TError,
    { data: ReadyRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayReady>>,
  TError,
  { data: ReadyRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayReady>>,
    { data: ReadyRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayReady(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayReadyMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayReady>>
>;
export type SyncPlayReadyMutationBody = ReadyRequestDto;
export type SyncPlayReadyMutationError = ErrorType<void>;

/**
 * @summary Notify SyncPlay group that member is ready for playback.
 */
export const useSyncPlayReady = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayReady>>,
    TError,
    { data: ReadyRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayReady>>,
  TError,
  { data: ReadyRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayReadyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request to remove items from the playlist in SyncPlay group.
 */
export const syncPlayRemoveFromPlaylist = (
  removeFromPlaylistRequestDto: RemoveFromPlaylistRequestDto
) => {
  return apiInstance<void>({
    url: `/SyncPlay/RemoveFromPlaylist`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: removeFromPlaylistRequestDto,
  });
};

export const getSyncPlayRemoveFromPlaylistMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>,
    TError,
    { data: RemoveFromPlaylistRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>,
  TError,
  { data: RemoveFromPlaylistRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>,
    { data: RemoveFromPlaylistRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlayRemoveFromPlaylist(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayRemoveFromPlaylistMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>
>;
export type SyncPlayRemoveFromPlaylistMutationBody =
  RemoveFromPlaylistRequestDto;
export type SyncPlayRemoveFromPlaylistMutationError = ErrorType<void>;

/**
 * @summary Request to remove items from the playlist in SyncPlay group.
 */
export const useSyncPlayRemoveFromPlaylist = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>,
    TError,
    { data: RemoveFromPlaylistRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>,
  TError,
  { data: RemoveFromPlaylistRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlayRemoveFromPlaylistMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request seek in SyncPlay group.
 */
export const syncPlaySeek = (seekRequestDto: SeekRequestDto) => {
  return apiInstance<void>({
    url: `/SyncPlay/Seek`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: seekRequestDto,
  });
};

export const getSyncPlaySeekMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySeek>>,
    TError,
    { data: SeekRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlaySeek>>,
  TError,
  { data: SeekRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlaySeek>>,
    { data: SeekRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlaySeek(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlaySeekMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlaySeek>>
>;
export type SyncPlaySeekMutationBody = SeekRequestDto;
export type SyncPlaySeekMutationError = ErrorType<void>;

/**
 * @summary Request seek in SyncPlay group.
 */
export const useSyncPlaySeek = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySeek>>,
    TError,
    { data: SeekRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlaySeek>>,
  TError,
  { data: SeekRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlaySeekMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request SyncPlay group to ignore member during group-wait.
 */
export const syncPlaySetIgnoreWait = (
  ignoreWaitRequestDto: IgnoreWaitRequestDto
) => {
  return apiInstance<void>({
    url: `/SyncPlay/SetIgnoreWait`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: ignoreWaitRequestDto,
  });
};

export const getSyncPlaySetIgnoreWaitMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>,
    TError,
    { data: IgnoreWaitRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>,
  TError,
  { data: IgnoreWaitRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>,
    { data: IgnoreWaitRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlaySetIgnoreWait(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlaySetIgnoreWaitMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>
>;
export type SyncPlaySetIgnoreWaitMutationBody = IgnoreWaitRequestDto;
export type SyncPlaySetIgnoreWaitMutationError = ErrorType<void>;

/**
 * @summary Request SyncPlay group to ignore member during group-wait.
 */
export const useSyncPlaySetIgnoreWait = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>,
    TError,
    { data: IgnoreWaitRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>,
  TError,
  { data: IgnoreWaitRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlaySetIgnoreWaitMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request to set new playlist in SyncPlay group.
 */
export const syncPlaySetNewQueue = (playRequestDto: PlayRequestDto) => {
  return apiInstance<void>({
    url: `/SyncPlay/SetNewQueue`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: playRequestDto,
  });
};

export const getSyncPlaySetNewQueueMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetNewQueue>>,
    TError,
    { data: PlayRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlaySetNewQueue>>,
  TError,
  { data: PlayRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlaySetNewQueue>>,
    { data: PlayRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlaySetNewQueue(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlaySetNewQueueMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlaySetNewQueue>>
>;
export type SyncPlaySetNewQueueMutationBody = PlayRequestDto;
export type SyncPlaySetNewQueueMutationError = ErrorType<void>;

/**
 * @summary Request to set new playlist in SyncPlay group.
 */
export const useSyncPlaySetNewQueue = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetNewQueue>>,
    TError,
    { data: PlayRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlaySetNewQueue>>,
  TError,
  { data: PlayRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlaySetNewQueueMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request to change playlist item in SyncPlay group.
 */
export const syncPlaySetPlaylistItem = (
  setPlaylistItemRequestDto: SetPlaylistItemRequestDto
) => {
  return apiInstance<void>({
    url: `/SyncPlay/SetPlaylistItem`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: setPlaylistItemRequestDto,
  });
};

export const getSyncPlaySetPlaylistItemMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>,
    TError,
    { data: SetPlaylistItemRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>,
  TError,
  { data: SetPlaylistItemRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>,
    { data: SetPlaylistItemRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlaySetPlaylistItem(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlaySetPlaylistItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>
>;
export type SyncPlaySetPlaylistItemMutationBody = SetPlaylistItemRequestDto;
export type SyncPlaySetPlaylistItemMutationError = ErrorType<void>;

/**
 * @summary Request to change playlist item in SyncPlay group.
 */
export const useSyncPlaySetPlaylistItem = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>,
    TError,
    { data: SetPlaylistItemRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>,
  TError,
  { data: SetPlaylistItemRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlaySetPlaylistItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request to set repeat mode in SyncPlay group.
 */
export const syncPlaySetRepeatMode = (
  setRepeatModeRequestDto: SetRepeatModeRequestDto
) => {
  return apiInstance<void>({
    url: `/SyncPlay/SetRepeatMode`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: setRepeatModeRequestDto,
  });
};

export const getSyncPlaySetRepeatModeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetRepeatMode>>,
    TError,
    { data: SetRepeatModeRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlaySetRepeatMode>>,
  TError,
  { data: SetRepeatModeRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlaySetRepeatMode>>,
    { data: SetRepeatModeRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlaySetRepeatMode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlaySetRepeatModeMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlaySetRepeatMode>>
>;
export type SyncPlaySetRepeatModeMutationBody = SetRepeatModeRequestDto;
export type SyncPlaySetRepeatModeMutationError = ErrorType<void>;

/**
 * @summary Request to set repeat mode in SyncPlay group.
 */
export const useSyncPlaySetRepeatMode = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetRepeatMode>>,
    TError,
    { data: SetRepeatModeRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlaySetRepeatMode>>,
  TError,
  { data: SetRepeatModeRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlaySetRepeatModeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request to set shuffle mode in SyncPlay group.
 */
export const syncPlaySetShuffleMode = (
  setShuffleModeRequestDto: SetShuffleModeRequestDto
) => {
  return apiInstance<void>({
    url: `/SyncPlay/SetShuffleMode`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: setShuffleModeRequestDto,
  });
};

export const getSyncPlaySetShuffleModeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetShuffleMode>>,
    TError,
    { data: SetShuffleModeRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlaySetShuffleMode>>,
  TError,
  { data: SetShuffleModeRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlaySetShuffleMode>>,
    { data: SetShuffleModeRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return syncPlaySetShuffleMode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlaySetShuffleModeMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlaySetShuffleMode>>
>;
export type SyncPlaySetShuffleModeMutationBody = SetShuffleModeRequestDto;
export type SyncPlaySetShuffleModeMutationError = ErrorType<void>;

/**
 * @summary Request to set shuffle mode in SyncPlay group.
 */
export const useSyncPlaySetShuffleMode = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlaySetShuffleMode>>,
    TError,
    { data: SetShuffleModeRequestDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlaySetShuffleMode>>,
  TError,
  { data: SetShuffleModeRequestDto },
  TContext
> => {
  const mutationOptions = getSyncPlaySetShuffleModeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request stop in SyncPlay group.
 */
export const syncPlayStop = () => {
  return apiInstance<void>({ url: `/SyncPlay/Stop`, method: "POST" });
};

export const getSyncPlayStopMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayStop>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayStop>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayStop>>,
    void
  > = () => {
    return syncPlayStop();
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayStop>>
>;

export type SyncPlayStopMutationError = ErrorType<void>;

/**
 * @summary Request stop in SyncPlay group.
 */
export const useSyncPlayStop = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayStop>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayStop>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getSyncPlayStopMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Request unpause in SyncPlay group.
 */
export const syncPlayUnpause = () => {
  return apiInstance<void>({ url: `/SyncPlay/Unpause`, method: "POST" });
};

export const getSyncPlayUnpauseMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayUnpause>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof syncPlayUnpause>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof syncPlayUnpause>>,
    void
  > = () => {
    return syncPlayUnpause();
  };

  return { mutationFn, ...mutationOptions };
};

export type SyncPlayUnpauseMutationResult = NonNullable<
  Awaited<ReturnType<typeof syncPlayUnpause>>
>;

export type SyncPlayUnpauseMutationError = ErrorType<void>;

/**
 * @summary Request unpause in SyncPlay group.
 */
export const useSyncPlayUnpause = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof syncPlayUnpause>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof syncPlayUnpause>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getSyncPlayUnpauseMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets information about the request endpoint.
 */
export const getEndpointInfo = (signal?: AbortSignal) => {
  return apiInstance<EndPointInfo>({
    url: `/System/Endpoint`,
    method: "GET",
    signal,
  });
};

export const getGetEndpointInfoQueryKey = () => {
  return [`/System/Endpoint`] as const;
};

export const getGetEndpointInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getEndpointInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEndpointInfo>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEndpointInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointInfo>>> = ({
    signal,
  }) => getEndpointInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEndpointInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetEndpointInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEndpointInfo>>
>;
export type GetEndpointInfoQueryError = ErrorType<void>;

export function useGetEndpointInfo<
  TData = Awaited<ReturnType<typeof getEndpointInfo>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEndpointInfo>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getEndpointInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetEndpointInfo<
  TData = Awaited<ReturnType<typeof getEndpointInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEndpointInfo>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getEndpointInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetEndpointInfo<
  TData = Awaited<ReturnType<typeof getEndpointInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEndpointInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets information about the request endpoint.
 */

export function useGetEndpointInfo<
  TData = Awaited<ReturnType<typeof getEndpointInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEndpointInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetEndpointInfoQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets information about the server.
 */
export const getSystemInfo = (signal?: AbortSignal) => {
  return apiInstance<SystemInfo>({
    url: `/System/Info`,
    method: "GET",
    signal,
  });
};

export const getGetSystemInfoQueryKey = () => {
  return [`/System/Info`] as const;
};

export const getGetSystemInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getSystemInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemInfo>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSystemInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemInfo>>> = ({
    signal,
  }) => getSystemInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSystemInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSystemInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSystemInfo>>
>;
export type GetSystemInfoQueryError = ErrorType<void>;

export function useGetSystemInfo<
  TData = Awaited<ReturnType<typeof getSystemInfo>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemInfo>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getSystemInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSystemInfo<
  TData = Awaited<ReturnType<typeof getSystemInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemInfo>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getSystemInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSystemInfo<
  TData = Awaited<ReturnType<typeof getSystemInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets information about the server.
 */

export function useGetSystemInfo<
  TData = Awaited<ReturnType<typeof getSystemInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSystemInfoQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets public information about the server.
 */
export const getPublicSystemInfo = (signal?: AbortSignal) => {
  return apiInstance<PublicSystemInfo>({
    url: `/System/Info/Public`,
    method: "GET",
    signal,
  });
};

export const getGetPublicSystemInfoQueryKey = () => {
  return [`/System/Info/Public`] as const;
};

export const getGetPublicSystemInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicSystemInfo>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPublicSystemInfo>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicSystemInfoQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPublicSystemInfo>>
  > = ({ signal }) => getPublicSystemInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicSystemInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPublicSystemInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPublicSystemInfo>>
>;
export type GetPublicSystemInfoQueryError = ErrorType<unknown>;

export function useGetPublicSystemInfo<
  TData = Awaited<ReturnType<typeof getPublicSystemInfo>>,
  TError = ErrorType<unknown>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPublicSystemInfo>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPublicSystemInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPublicSystemInfo<
  TData = Awaited<ReturnType<typeof getPublicSystemInfo>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPublicSystemInfo>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPublicSystemInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPublicSystemInfo<
  TData = Awaited<ReturnType<typeof getPublicSystemInfo>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPublicSystemInfo>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets public information about the server.
 */

export function useGetPublicSystemInfo<
  TData = Awaited<ReturnType<typeof getPublicSystemInfo>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPublicSystemInfo>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPublicSystemInfoQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a list of available server log files.
 */
export const getServerLogs = (signal?: AbortSignal) => {
  return apiInstance<LogFile[]>({ url: `/System/Logs`, method: "GET", signal });
};

export const getGetServerLogsQueryKey = () => {
  return [`/System/Logs`] as const;
};

export const getGetServerLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof getServerLogs>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getServerLogs>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetServerLogsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getServerLogs>>> = ({
    signal,
  }) => getServerLogs(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getServerLogs>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetServerLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getServerLogs>>
>;
export type GetServerLogsQueryError = ErrorType<void>;

export function useGetServerLogs<
  TData = Awaited<ReturnType<typeof getServerLogs>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getServerLogs>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getServerLogs>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetServerLogs<
  TData = Awaited<ReturnType<typeof getServerLogs>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getServerLogs>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getServerLogs>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetServerLogs<
  TData = Awaited<ReturnType<typeof getServerLogs>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getServerLogs>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a list of available server log files.
 */

export function useGetServerLogs<
  TData = Awaited<ReturnType<typeof getServerLogs>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getServerLogs>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetServerLogsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a log file.
 */
export const getLogFile = (params: GetLogFileParams, signal?: AbortSignal) => {
  return apiInstance<Blob>({
    url: `/System/Logs/Log`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetLogFileQueryKey = (params: GetLogFileParams) => {
  return [`/System/Logs/Log`, ...(params ? [params] : [])] as const;
};

export const getGetLogFileQueryOptions = <
  TData = Awaited<ReturnType<typeof getLogFile>>,
  TError = ErrorType<void>
>(
  params: GetLogFileParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogFile>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLogFileQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLogFile>>> = ({
    signal,
  }) => getLogFile(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLogFile>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLogFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLogFile>>
>;
export type GetLogFileQueryError = ErrorType<void>;

export function useGetLogFile<
  TData = Awaited<ReturnType<typeof getLogFile>>,
  TError = ErrorType<void>
>(
  params: GetLogFileParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogFile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogFile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLogFile<
  TData = Awaited<ReturnType<typeof getLogFile>>,
  TError = ErrorType<void>
>(
  params: GetLogFileParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogFile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogFile>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLogFile<
  TData = Awaited<ReturnType<typeof getLogFile>>,
  TError = ErrorType<void>
>(
  params: GetLogFileParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogFile>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a log file.
 */

export function useGetLogFile<
  TData = Awaited<ReturnType<typeof getLogFile>>,
  TError = ErrorType<void>
>(
  params: GetLogFileParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLogFile>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLogFileQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Pings the system.
 */
export const getPingSystem = (signal?: AbortSignal) => {
  return apiInstance<string>({ url: `/System/Ping`, method: "GET", signal });
};

export const getGetPingSystemQueryKey = () => {
  return [`/System/Ping`] as const;
};

export const getGetPingSystemQueryOptions = <
  TData = Awaited<ReturnType<typeof getPingSystem>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPingSystem>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPingSystemQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPingSystem>>> = ({
    signal,
  }) => getPingSystem(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPingSystem>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPingSystemQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPingSystem>>
>;
export type GetPingSystemQueryError = ErrorType<unknown>;

export function useGetPingSystem<
  TData = Awaited<ReturnType<typeof getPingSystem>>,
  TError = ErrorType<unknown>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPingSystem>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPingSystem>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPingSystem<
  TData = Awaited<ReturnType<typeof getPingSystem>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPingSystem>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPingSystem>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPingSystem<
  TData = Awaited<ReturnType<typeof getPingSystem>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPingSystem>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Pings the system.
 */

export function useGetPingSystem<
  TData = Awaited<ReturnType<typeof getPingSystem>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPingSystem>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPingSystemQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Pings the system.
 */
export const postPingSystem = () => {
  return apiInstance<string>({ url: `/System/Ping`, method: "POST" });
};

export const getPostPingSystemMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPingSystem>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postPingSystem>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPingSystem>>,
    void
  > = () => {
    return postPingSystem();
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPingSystemMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPingSystem>>
>;

export type PostPingSystemMutationError = ErrorType<unknown>;

/**
 * @summary Pings the system.
 */
export const usePostPingSystem = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPingSystem>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof postPingSystem>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getPostPingSystemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Restarts the application.
 */
export const restartApplication = () => {
  return apiInstance<void>({ url: `/System/Restart`, method: "POST" });
};

export const getRestartApplicationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof restartApplication>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof restartApplication>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof restartApplication>>,
    void
  > = () => {
    return restartApplication();
  };

  return { mutationFn, ...mutationOptions };
};

export type RestartApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof restartApplication>>
>;

export type RestartApplicationMutationError = ErrorType<void>;

/**
 * @summary Restarts the application.
 */
export const useRestartApplication = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof restartApplication>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof restartApplication>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getRestartApplicationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Shuts down the application.
 */
export const shutdownApplication = () => {
  return apiInstance<void>({ url: `/System/Shutdown`, method: "POST" });
};

export const getShutdownApplicationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof shutdownApplication>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof shutdownApplication>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof shutdownApplication>>,
    void
  > = () => {
    return shutdownApplication();
  };

  return { mutationFn, ...mutationOptions };
};

export type ShutdownApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof shutdownApplication>>
>;

export type ShutdownApplicationMutationError = ErrorType<void>;

/**
 * @summary Shuts down the application.
 */
export const useShutdownApplication = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof shutdownApplication>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof shutdownApplication>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getShutdownApplicationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @deprecated
 * @summary Gets wake on lan information.
 */
export const getWakeOnLanInfo = (signal?: AbortSignal) => {
  return apiInstance<WakeOnLanInfo[]>({
    url: `/System/WakeOnLanInfo`,
    method: "GET",
    signal,
  });
};

export const getGetWakeOnLanInfoQueryKey = () => {
  return [`/System/WakeOnLanInfo`] as const;
};

export const getGetWakeOnLanInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getWakeOnLanInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getWakeOnLanInfo>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWakeOnLanInfoQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getWakeOnLanInfo>>
  > = ({ signal }) => getWakeOnLanInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWakeOnLanInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetWakeOnLanInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getWakeOnLanInfo>>
>;
export type GetWakeOnLanInfoQueryError = ErrorType<void>;

export function useGetWakeOnLanInfo<
  TData = Awaited<ReturnType<typeof getWakeOnLanInfo>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getWakeOnLanInfo>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getWakeOnLanInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetWakeOnLanInfo<
  TData = Awaited<ReturnType<typeof getWakeOnLanInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getWakeOnLanInfo>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getWakeOnLanInfo>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetWakeOnLanInfo<
  TData = Awaited<ReturnType<typeof getWakeOnLanInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getWakeOnLanInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @deprecated
 * @summary Gets wake on lan information.
 */

export function useGetWakeOnLanInfo<
  TData = Awaited<ReturnType<typeof getWakeOnLanInfo>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getWakeOnLanInfo>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetWakeOnLanInfoQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the current UTC time.
 */
export const getUtcTime = (signal?: AbortSignal) => {
  return apiInstance<UtcTimeResponse>({
    url: `/GetUtcTime`,
    method: "GET",
    signal,
  });
};

export const getGetUtcTimeQueryKey = () => {
  return [`/GetUtcTime`] as const;
};

export const getGetUtcTimeQueryOptions = <
  TData = Awaited<ReturnType<typeof getUtcTime>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUtcTime>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUtcTimeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUtcTime>>> = ({
    signal,
  }) => getUtcTime(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUtcTime>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUtcTimeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUtcTime>>
>;
export type GetUtcTimeQueryError = ErrorType<unknown>;

export function useGetUtcTime<
  TData = Awaited<ReturnType<typeof getUtcTime>>,
  TError = ErrorType<unknown>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUtcTime>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getUtcTime>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUtcTime<
  TData = Awaited<ReturnType<typeof getUtcTime>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUtcTime>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getUtcTime>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUtcTime<
  TData = Awaited<ReturnType<typeof getUtcTime>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUtcTime>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the current UTC time.
 */

export function useGetUtcTime<
  TData = Awaited<ReturnType<typeof getUtcTime>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUtcTime>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUtcTimeQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the TMDb image configuration options.
 */
export const tmdbClientConfiguration = (signal?: AbortSignal) => {
  return apiInstance<ConfigImageTypes>({
    url: `/Tmdb/ClientConfiguration`,
    method: "GET",
    signal,
  });
};

export const getTmdbClientConfigurationQueryKey = () => {
  return [`/Tmdb/ClientConfiguration`] as const;
};

export const getTmdbClientConfigurationQueryOptions = <
  TData = Awaited<ReturnType<typeof tmdbClientConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof tmdbClientConfiguration>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTmdbClientConfigurationQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tmdbClientConfiguration>>
  > = ({ signal }) => tmdbClientConfiguration(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tmdbClientConfiguration>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type TmdbClientConfigurationQueryResult = NonNullable<
  Awaited<ReturnType<typeof tmdbClientConfiguration>>
>;
export type TmdbClientConfigurationQueryError = ErrorType<void>;

export function useTmdbClientConfiguration<
  TData = Awaited<ReturnType<typeof tmdbClientConfiguration>>,
  TError = ErrorType<void>
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof tmdbClientConfiguration>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof tmdbClientConfiguration>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTmdbClientConfiguration<
  TData = Awaited<ReturnType<typeof tmdbClientConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof tmdbClientConfiguration>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof tmdbClientConfiguration>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useTmdbClientConfiguration<
  TData = Awaited<ReturnType<typeof tmdbClientConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof tmdbClientConfiguration>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the TMDb image configuration options.
 */

export function useTmdbClientConfiguration<
  TData = Awaited<ReturnType<typeof tmdbClientConfiguration>>,
  TError = ErrorType<void>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof tmdbClientConfiguration>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getTmdbClientConfigurationQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Finds movies and trailers similar to a given trailer.
 */
export const getTrailers = (
  params?: GetTrailersParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Trailers`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetTrailersQueryKey = (params?: GetTrailersParams) => {
  return [`/Trailers`, ...(params ? [params] : [])] as const;
};

export const getGetTrailersQueryOptions = <
  TData = Awaited<ReturnType<typeof getTrailers>>,
  TError = ErrorType<void>
>(
  params?: GetTrailersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTrailers>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTrailersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTrailers>>> = ({
    signal,
  }) => getTrailers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTrailers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetTrailersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTrailers>>
>;
export type GetTrailersQueryError = ErrorType<void>;

export function useGetTrailers<
  TData = Awaited<ReturnType<typeof getTrailers>>,
  TError = ErrorType<void>
>(
  params: undefined | GetTrailersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTrailers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTrailers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTrailers<
  TData = Awaited<ReturnType<typeof getTrailers>>,
  TError = ErrorType<void>
>(
  params?: GetTrailersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTrailers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTrailers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetTrailers<
  TData = Awaited<ReturnType<typeof getTrailers>>,
  TError = ErrorType<void>
>(
  params?: GetTrailersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTrailers>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Finds movies and trailers similar to a given trailer.
 */

export function useGetTrailers<
  TData = Awaited<ReturnType<typeof getTrailers>>,
  TError = ErrorType<void>
>(
  params?: GetTrailersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTrailers>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetTrailersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets episodes for a tv season.
 */
export const getEpisodes = (
  seriesId: string,
  params?: GetEpisodesParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Shows/${seriesId}/Episodes`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetEpisodesQueryKey = (
  seriesId: string,
  params?: GetEpisodesParams
) => {
  return [`/Shows/${seriesId}/Episodes`, ...(params ? [params] : [])] as const;
};

export const getGetEpisodesQueryOptions = <
  TData = Awaited<ReturnType<typeof getEpisodes>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params?: GetEpisodesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEpisodes>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetEpisodesQueryKey(seriesId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEpisodes>>> = ({
    signal,
  }) => getEpisodes(seriesId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!seriesId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEpisodes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetEpisodesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEpisodes>>
>;
export type GetEpisodesQueryError = ErrorType<void | ProblemDetails>;

export function useGetEpisodes<
  TData = Awaited<ReturnType<typeof getEpisodes>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params: undefined | GetEpisodesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEpisodes>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEpisodes>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetEpisodes<
  TData = Awaited<ReturnType<typeof getEpisodes>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params?: GetEpisodesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEpisodes>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEpisodes>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetEpisodes<
  TData = Awaited<ReturnType<typeof getEpisodes>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params?: GetEpisodesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEpisodes>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets episodes for a tv season.
 */

export function useGetEpisodes<
  TData = Awaited<ReturnType<typeof getEpisodes>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params?: GetEpisodesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEpisodes>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetEpisodesQueryOptions(seriesId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets seasons for a tv series.
 */
export const getSeasons = (
  seriesId: string,
  params?: GetSeasonsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Shows/${seriesId}/Seasons`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSeasonsQueryKey = (
  seriesId: string,
  params?: GetSeasonsParams
) => {
  return [`/Shows/${seriesId}/Seasons`, ...(params ? [params] : [])] as const;
};

export const getGetSeasonsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSeasons>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params?: GetSeasonsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeasons>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSeasonsQueryKey(seriesId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeasons>>> = ({
    signal,
  }) => getSeasons(seriesId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!seriesId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSeasons>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSeasonsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSeasons>>
>;
export type GetSeasonsQueryError = ErrorType<void | ProblemDetails>;

export function useGetSeasons<
  TData = Awaited<ReturnType<typeof getSeasons>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params: undefined | GetSeasonsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeasons>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSeasons>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSeasons<
  TData = Awaited<ReturnType<typeof getSeasons>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params?: GetSeasonsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeasons>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSeasons>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSeasons<
  TData = Awaited<ReturnType<typeof getSeasons>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params?: GetSeasonsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeasons>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets seasons for a tv series.
 */

export function useGetSeasons<
  TData = Awaited<ReturnType<typeof getSeasons>>,
  TError = ErrorType<void | ProblemDetails>
>(
  seriesId: string,
  params?: GetSeasonsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSeasons>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSeasonsQueryOptions(seriesId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a list of next up episodes.
 */
export const getNextUp = (params?: GetNextUpParams, signal?: AbortSignal) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Shows/NextUp`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetNextUpQueryKey = (params?: GetNextUpParams) => {
  return [`/Shows/NextUp`, ...(params ? [params] : [])] as const;
};

export const getGetNextUpQueryOptions = <
  TData = Awaited<ReturnType<typeof getNextUp>>,
  TError = ErrorType<void>
>(
  params?: GetNextUpParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNextUp>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNextUpQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNextUp>>> = ({
    signal,
  }) => getNextUp(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNextUp>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNextUpQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNextUp>>
>;
export type GetNextUpQueryError = ErrorType<void>;

export function useGetNextUp<
  TData = Awaited<ReturnType<typeof getNextUp>>,
  TError = ErrorType<void>
>(
  params: undefined | GetNextUpParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNextUp>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNextUp>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNextUp<
  TData = Awaited<ReturnType<typeof getNextUp>>,
  TError = ErrorType<void>
>(
  params?: GetNextUpParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNextUp>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNextUp>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetNextUp<
  TData = Awaited<ReturnType<typeof getNextUp>>,
  TError = ErrorType<void>
>(
  params?: GetNextUpParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNextUp>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a list of next up episodes.
 */

export function useGetNextUp<
  TData = Awaited<ReturnType<typeof getNextUp>>,
  TError = ErrorType<void>
>(
  params?: GetNextUpParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNextUp>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetNextUpQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a list of upcoming episodes.
 */
export const getUpcomingEpisodes = (
  params?: GetUpcomingEpisodesParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Shows/Upcoming`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetUpcomingEpisodesQueryKey = (
  params?: GetUpcomingEpisodesParams
) => {
  return [`/Shows/Upcoming`, ...(params ? [params] : [])] as const;
};

export const getGetUpcomingEpisodesQueryOptions = <
  TData = Awaited<ReturnType<typeof getUpcomingEpisodes>>,
  TError = ErrorType<void>
>(
  params?: GetUpcomingEpisodesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingEpisodes>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUpcomingEpisodesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUpcomingEpisodes>>
  > = ({ signal }) => getUpcomingEpisodes(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUpcomingEpisodes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUpcomingEpisodesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUpcomingEpisodes>>
>;
export type GetUpcomingEpisodesQueryError = ErrorType<void>;

export function useGetUpcomingEpisodes<
  TData = Awaited<ReturnType<typeof getUpcomingEpisodes>>,
  TError = ErrorType<void>
>(
  params: undefined | GetUpcomingEpisodesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingEpisodes>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingEpisodes>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUpcomingEpisodes<
  TData = Awaited<ReturnType<typeof getUpcomingEpisodes>>,
  TError = ErrorType<void>
>(
  params?: GetUpcomingEpisodesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingEpisodes>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingEpisodes>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUpcomingEpisodes<
  TData = Awaited<ReturnType<typeof getUpcomingEpisodes>>,
  TError = ErrorType<void>
>(
  params?: GetUpcomingEpisodesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingEpisodes>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a list of upcoming episodes.
 */

export function useGetUpcomingEpisodes<
  TData = Awaited<ReturnType<typeof getUpcomingEpisodes>>,
  TError = ErrorType<void>
>(
  params?: GetUpcomingEpisodesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingEpisodes>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUpcomingEpisodesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an audio stream.
 */
export const getUniversalAudioStream = (
  itemId: string,
  params?: GetUniversalAudioStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/universal`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetUniversalAudioStreamQueryKey = (
  itemId: string,
  params?: GetUniversalAudioStreamParams
) => {
  return [`/Audio/${itemId}/universal`, ...(params ? [params] : [])] as const;
};

export const getGetUniversalAudioStreamQueryOptions = <
  TData = Awaited<ReturnType<typeof getUniversalAudioStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetUniversalAudioStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUniversalAudioStream>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetUniversalAudioStreamQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUniversalAudioStream>>
  > = ({ signal }) => getUniversalAudioStream(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUniversalAudioStream>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUniversalAudioStreamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUniversalAudioStream>>
>;
export type GetUniversalAudioStreamQueryError = ErrorType<void>;

export function useGetUniversalAudioStream<
  TData = Awaited<ReturnType<typeof getUniversalAudioStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetUniversalAudioStreamParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUniversalAudioStream>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUniversalAudioStream>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUniversalAudioStream<
  TData = Awaited<ReturnType<typeof getUniversalAudioStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetUniversalAudioStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUniversalAudioStream>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUniversalAudioStream>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUniversalAudioStream<
  TData = Awaited<ReturnType<typeof getUniversalAudioStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetUniversalAudioStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUniversalAudioStream>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets an audio stream.
 */

export function useGetUniversalAudioStream<
  TData = Awaited<ReturnType<typeof getUniversalAudioStream>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetUniversalAudioStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUniversalAudioStream>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUniversalAudioStreamQueryOptions(
    itemId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets an audio stream.
 */
export const headUniversalAudioStream = (
  itemId: string,
  params?: HeadUniversalAudioStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Audio/${itemId}/universal`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadUniversalAudioStreamMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headUniversalAudioStream>>,
    TError,
    { itemId: string; params?: HeadUniversalAudioStreamParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headUniversalAudioStream>>,
  TError,
  { itemId: string; params?: HeadUniversalAudioStreamParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headUniversalAudioStream>>,
    { itemId: string; params?: HeadUniversalAudioStreamParams }
  > = (props) => {
    const { itemId, params } = props ?? {};

    return headUniversalAudioStream(itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadUniversalAudioStreamMutationResult = NonNullable<
  Awaited<ReturnType<typeof headUniversalAudioStream>>
>;

export type HeadUniversalAudioStreamMutationError = ErrorType<void>;

/**
 * @summary Gets an audio stream.
 */
export const useHeadUniversalAudioStream = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headUniversalAudioStream>>,
    TError,
    { itemId: string; params?: HeadUniversalAudioStreamParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headUniversalAudioStream>>,
  TError,
  { itemId: string; params?: HeadUniversalAudioStreamParams },
  TContext
> => {
  const mutationOptions = getHeadUniversalAudioStreamMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a list of users.
 */
export const getUsers = (params?: GetUsersParams, signal?: AbortSignal) => {
  return apiInstance<UserDto[]>({
    url: `/Users`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetUsersQueryKey = (params?: GetUsersParams) => {
  return [`/Users`, ...(params ? [params] : [])] as const;
};

export const getGetUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<void>
>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({
    signal,
  }) => getUsers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsers>>
>;
export type GetUsersQueryError = ErrorType<void>;

export function useGetUsers<
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<void>
>(
  params: undefined | GetUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUsers<
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<void>
>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUsers<
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<void>
>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a list of users.
 */

export function useGetUsers<
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<void>
>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUsersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a user by Id.
 */
export const getUserById = (userId: string, signal?: AbortSignal) => {
  return apiInstance<UserDto>({
    url: `/Users/${userId}`,
    method: "GET",
    signal,
  });
};

export const getGetUserByIdQueryKey = (userId: string) => {
  return [`/Users/${userId}`] as const;
};

export const getGetUserByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserByIdQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({
    signal,
  }) => getUserById(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserById>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserById>>
>;
export type GetUserByIdQueryError = ErrorType<void | ProblemDetails>;

export function useGetUserById<
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUserById<
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUserById<
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a user by Id.
 */

export function useGetUserById<
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserByIdQueryOptions(userId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Deletes a user.
 */
export const deleteUser = (userId: string) => {
  return apiInstance<void>({ url: `/Users/${userId}`, method: "DELETE" });
};

export const getDeleteUserMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { userId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { userId: string }
  > = (props) => {
    const { userId } = props ?? {};

    return deleteUser(userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>;

export type DeleteUserMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Deletes a user.
 */
export const useDeleteUser = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a user.
 */
export const updateUser = (userId: string, userDto: UserDto) => {
  return apiInstance<void>({
    url: `/Users/${userId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userDto,
  });
};

export const getUpdateUserMutationOptions = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { userId: string; data: UserDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { userId: string; data: UserDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { userId: string; data: UserDto }
  > = (props) => {
    const { userId, data } = props ?? {};

    return updateUser(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>;
export type UpdateUserMutationBody = UserDto;
export type UpdateUserMutationError = ErrorType<ProblemDetails | void>;

/**
 * @summary Updates a user.
 */
export const useUpdateUser = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { userId: string; data: UserDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { userId: string; data: UserDto },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Authenticates a user.
 */
export const authenticateUser = (
  userId: string,
  params: AuthenticateUserParams
) => {
  return apiInstance<AuthenticationResult>({
    url: `/Users/${userId}/Authenticate`,
    method: "POST",
    params,
  });
};

export const getAuthenticateUserMutationOptions = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authenticateUser>>,
    TError,
    { userId: string; params: AuthenticateUserParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authenticateUser>>,
  TError,
  { userId: string; params: AuthenticateUserParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authenticateUser>>,
    { userId: string; params: AuthenticateUserParams }
  > = (props) => {
    const { userId, params } = props ?? {};

    return authenticateUser(userId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthenticateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof authenticateUser>>
>;

export type AuthenticateUserMutationError = ErrorType<ProblemDetails>;

/**
 * @summary Authenticates a user.
 */
export const useAuthenticateUser = <
  TError = ErrorType<ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authenticateUser>>,
    TError,
    { userId: string; params: AuthenticateUserParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authenticateUser>>,
  TError,
  { userId: string; params: AuthenticateUserParams },
  TContext
> => {
  const mutationOptions = getAuthenticateUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a user configuration.
 */
export const updateUserConfiguration = (
  userId: string,
  userConfiguration: UserConfiguration
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/Configuration`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userConfiguration,
  });
};

export const getUpdateUserConfigurationMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserConfiguration>>,
    TError,
    { userId: string; data: UserConfiguration },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUserConfiguration>>,
  TError,
  { userId: string; data: UserConfiguration },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUserConfiguration>>,
    { userId: string; data: UserConfiguration }
  > = (props) => {
    const { userId, data } = props ?? {};

    return updateUserConfiguration(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserConfigurationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUserConfiguration>>
>;
export type UpdateUserConfigurationMutationBody = UserConfiguration;
export type UpdateUserConfigurationMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Updates a user configuration.
 */
export const useUpdateUserConfiguration = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserConfiguration>>,
    TError,
    { userId: string; data: UserConfiguration },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateUserConfiguration>>,
  TError,
  { userId: string; data: UserConfiguration },
  TContext
> => {
  const mutationOptions = getUpdateUserConfigurationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a user's easy password.
 */
export const updateUserEasyPassword = (
  userId: string,
  updateUserEasyPassword: UpdateUserEasyPassword
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/EasyPassword`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: updateUserEasyPassword,
  });
};

export const getUpdateUserEasyPasswordMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserEasyPassword>>,
    TError,
    { userId: string; data: UpdateUserEasyPassword },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUserEasyPassword>>,
  TError,
  { userId: string; data: UpdateUserEasyPassword },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUserEasyPassword>>,
    { userId: string; data: UpdateUserEasyPassword }
  > = (props) => {
    const { userId, data } = props ?? {};

    return updateUserEasyPassword(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserEasyPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUserEasyPassword>>
>;
export type UpdateUserEasyPasswordMutationBody = UpdateUserEasyPassword;
export type UpdateUserEasyPasswordMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Updates a user's easy password.
 */
export const useUpdateUserEasyPassword = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserEasyPassword>>,
    TError,
    { userId: string; data: UpdateUserEasyPassword },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateUserEasyPassword>>,
  TError,
  { userId: string; data: UpdateUserEasyPassword },
  TContext
> => {
  const mutationOptions = getUpdateUserEasyPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a user's password.
 */
export const updateUserPassword = (
  userId: string,
  updateUserPassword: UpdateUserPassword
) => {
  return apiInstance<void>({
    url: `/Users/${userId}/Password`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: updateUserPassword,
  });
};

export const getUpdateUserPasswordMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserPassword>>,
    TError,
    { userId: string; data: UpdateUserPassword },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUserPassword>>,
  TError,
  { userId: string; data: UpdateUserPassword },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUserPassword>>,
    { userId: string; data: UpdateUserPassword }
  > = (props) => {
    const { userId, data } = props ?? {};

    return updateUserPassword(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUserPassword>>
>;
export type UpdateUserPasswordMutationBody = UpdateUserPassword;
export type UpdateUserPasswordMutationError = ErrorType<void | ProblemDetails>;

/**
 * @summary Updates a user's password.
 */
export const useUpdateUserPassword = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserPassword>>,
    TError,
    { userId: string; data: UpdateUserPassword },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateUserPassword>>,
  TError,
  { userId: string; data: UpdateUserPassword },
  TContext
> => {
  const mutationOptions = getUpdateUserPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a user policy.
 */
export const updateUserPolicy = (userId: string, userPolicy: UserPolicy) => {
  return apiInstance<void>({
    url: `/Users/${userId}/Policy`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userPolicy,
  });
};

export const getUpdateUserPolicyMutationOptions = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserPolicy>>,
    TError,
    { userId: string; data: UserPolicy },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUserPolicy>>,
  TError,
  { userId: string; data: UserPolicy },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUserPolicy>>,
    { userId: string; data: UserPolicy }
  > = (props) => {
    const { userId, data } = props ?? {};

    return updateUserPolicy(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserPolicyMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUserPolicy>>
>;
export type UpdateUserPolicyMutationBody = UserPolicy;
export type UpdateUserPolicyMutationError = ErrorType<ProblemDetails | void>;

/**
 * @summary Updates a user policy.
 */
export const useUpdateUserPolicy = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserPolicy>>,
    TError,
    { userId: string; data: UserPolicy },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateUserPolicy>>,
  TError,
  { userId: string; data: UserPolicy },
  TContext
> => {
  const mutationOptions = getUpdateUserPolicyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Authenticates a user by name.
 */
export const authenticateUserByName = (
  authenticateUserByName: AuthenticateUserByName
) => {
  return apiInstance<AuthenticationResult>({
    url: `/Users/AuthenticateByName`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authenticateUserByName,
  });
};

export const getAuthenticateUserByNameMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authenticateUserByName>>,
    TError,
    { data: AuthenticateUserByName },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authenticateUserByName>>,
  TError,
  { data: AuthenticateUserByName },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authenticateUserByName>>,
    { data: AuthenticateUserByName }
  > = (props) => {
    const { data } = props ?? {};

    return authenticateUserByName(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthenticateUserByNameMutationResult = NonNullable<
  Awaited<ReturnType<typeof authenticateUserByName>>
>;
export type AuthenticateUserByNameMutationBody = AuthenticateUserByName;
export type AuthenticateUserByNameMutationError = ErrorType<unknown>;

/**
 * @summary Authenticates a user by name.
 */
export const useAuthenticateUserByName = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authenticateUserByName>>,
    TError,
    { data: AuthenticateUserByName },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authenticateUserByName>>,
  TError,
  { data: AuthenticateUserByName },
  TContext
> => {
  const mutationOptions = getAuthenticateUserByNameMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Authenticates a user with quick connect.
 */
export const authenticateWithQuickConnect = (
  quickConnectDto: QuickConnectDto
) => {
  return apiInstance<AuthenticationResult>({
    url: `/Users/AuthenticateWithQuickConnect`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: quickConnectDto,
  });
};

export const getAuthenticateWithQuickConnectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authenticateWithQuickConnect>>,
    TError,
    { data: QuickConnectDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authenticateWithQuickConnect>>,
  TError,
  { data: QuickConnectDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authenticateWithQuickConnect>>,
    { data: QuickConnectDto }
  > = (props) => {
    const { data } = props ?? {};

    return authenticateWithQuickConnect(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthenticateWithQuickConnectMutationResult = NonNullable<
  Awaited<ReturnType<typeof authenticateWithQuickConnect>>
>;
export type AuthenticateWithQuickConnectMutationBody = QuickConnectDto;
export type AuthenticateWithQuickConnectMutationError = ErrorType<void>;

/**
 * @summary Authenticates a user with quick connect.
 */
export const useAuthenticateWithQuickConnect = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authenticateWithQuickConnect>>,
    TError,
    { data: QuickConnectDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authenticateWithQuickConnect>>,
  TError,
  { data: QuickConnectDto },
  TContext
> => {
  const mutationOptions =
    getAuthenticateWithQuickConnectMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Initiates the forgot password process for a local user.
 */
export const forgotPassword = (forgotPasswordDto: ForgotPasswordDto) => {
  return apiInstance<ForgotPasswordResult>({
    url: `/Users/ForgotPassword`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: forgotPasswordDto,
  });
};

export const getForgotPasswordMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof forgotPassword>>,
    TError,
    { data: ForgotPasswordDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof forgotPassword>>,
  TError,
  { data: ForgotPasswordDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof forgotPassword>>,
    { data: ForgotPasswordDto }
  > = (props) => {
    const { data } = props ?? {};

    return forgotPassword(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ForgotPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof forgotPassword>>
>;
export type ForgotPasswordMutationBody = ForgotPasswordDto;
export type ForgotPasswordMutationError = ErrorType<unknown>;

/**
 * @summary Initiates the forgot password process for a local user.
 */
export const useForgotPassword = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof forgotPassword>>,
    TError,
    { data: ForgotPasswordDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof forgotPassword>>,
  TError,
  { data: ForgotPasswordDto },
  TContext
> => {
  const mutationOptions = getForgotPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Redeems a forgot password pin.
 */
export const forgotPasswordPin = (
  forgotPasswordPinDto: ForgotPasswordPinDto
) => {
  return apiInstance<PinRedeemResult>({
    url: `/Users/ForgotPassword/Pin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: forgotPasswordPinDto,
  });
};

export const getForgotPasswordPinMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof forgotPasswordPin>>,
    TError,
    { data: ForgotPasswordPinDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof forgotPasswordPin>>,
  TError,
  { data: ForgotPasswordPinDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof forgotPasswordPin>>,
    { data: ForgotPasswordPinDto }
  > = (props) => {
    const { data } = props ?? {};

    return forgotPasswordPin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ForgotPasswordPinMutationResult = NonNullable<
  Awaited<ReturnType<typeof forgotPasswordPin>>
>;
export type ForgotPasswordPinMutationBody = ForgotPasswordPinDto;
export type ForgotPasswordPinMutationError = ErrorType<unknown>;

/**
 * @summary Redeems a forgot password pin.
 */
export const useForgotPasswordPin = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof forgotPasswordPin>>,
    TError,
    { data: ForgotPasswordPinDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof forgotPasswordPin>>,
  TError,
  { data: ForgotPasswordPinDto },
  TContext
> => {
  const mutationOptions = getForgotPasswordPinMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets the user based on auth token.
 */
export const getCurrentUser = (signal?: AbortSignal) => {
  return apiInstance<UserDto>({ url: `/Users/Me`, method: "GET", signal });
};

export const getGetCurrentUserQueryKey = () => {
  return [`/Users/Me`] as const;
};

export const getGetCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<ProblemDetails | void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({
    signal,
  }) => getCurrentUser(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentUser>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCurrentUser>>
>;
export type GetCurrentUserQueryError = ErrorType<ProblemDetails | void>;

export function useGetCurrentUser<
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<ProblemDetails | void>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCurrentUser>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetCurrentUser<
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<ProblemDetails | void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCurrentUser>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetCurrentUser<
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<ProblemDetails | void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the user based on auth token.
 */

export function useGetCurrentUser<
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<ProblemDetails | void>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetCurrentUserQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates a user.
 */
export const createUserByName = (createUserByName: CreateUserByName) => {
  return apiInstance<UserDto>({
    url: `/Users/New`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createUserByName,
  });
};

export const getCreateUserByNameMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUserByName>>,
    TError,
    { data: CreateUserByName },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUserByName>>,
  TError,
  { data: CreateUserByName },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUserByName>>,
    { data: CreateUserByName }
  > = (props) => {
    const { data } = props ?? {};

    return createUserByName(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUserByNameMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUserByName>>
>;
export type CreateUserByNameMutationBody = CreateUserByName;
export type CreateUserByNameMutationError = ErrorType<void>;

/**
 * @summary Creates a user.
 */
export const useCreateUserByName = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUserByName>>,
    TError,
    { data: CreateUserByName },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createUserByName>>,
  TError,
  { data: CreateUserByName },
  TContext
> => {
  const mutationOptions = getCreateUserByNameMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a list of publicly visible users for display on a login screen.
 */
export const getPublicUsers = (signal?: AbortSignal) => {
  return apiInstance<UserDto[]>({
    url: `/Users/Public`,
    method: "GET",
    signal,
  });
};

export const getGetPublicUsersQueryKey = () => {
  return [`/Users/Public`] as const;
};

export const getGetPublicUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicUsers>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPublicUsers>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicUsersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicUsers>>> = ({
    signal,
  }) => getPublicUsers(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPublicUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPublicUsers>>
>;
export type GetPublicUsersQueryError = ErrorType<unknown>;

export function useGetPublicUsers<
  TData = Awaited<ReturnType<typeof getPublicUsers>>,
  TError = ErrorType<unknown>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPublicUsers>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPublicUsers>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPublicUsers<
  TData = Awaited<ReturnType<typeof getPublicUsers>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPublicUsers>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getPublicUsers>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetPublicUsers<
  TData = Awaited<ReturnType<typeof getPublicUsers>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPublicUsers>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a list of publicly visible users for display on a login screen.
 */

export function useGetPublicUsers<
  TData = Awaited<ReturnType<typeof getPublicUsers>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPublicUsers>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPublicUsersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Marks an item as a favorite.
 */
export const markFavoriteItem = (userId: string, itemId: string) => {
  return apiInstance<UserItemDataDto>({
    url: `/Users/${userId}/FavoriteItems/${itemId}`,
    method: "POST",
  });
};

export const getMarkFavoriteItemMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markFavoriteItem>>,
    TError,
    { userId: string; itemId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof markFavoriteItem>>,
  TError,
  { userId: string; itemId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markFavoriteItem>>,
    { userId: string; itemId: string }
  > = (props) => {
    const { userId, itemId } = props ?? {};

    return markFavoriteItem(userId, itemId);
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkFavoriteItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof markFavoriteItem>>
>;

export type MarkFavoriteItemMutationError = ErrorType<void>;

/**
 * @summary Marks an item as a favorite.
 */
export const useMarkFavoriteItem = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markFavoriteItem>>,
    TError,
    { userId: string; itemId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof markFavoriteItem>>,
  TError,
  { userId: string; itemId: string },
  TContext
> => {
  const mutationOptions = getMarkFavoriteItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Unmarks item as a favorite.
 */
export const unmarkFavoriteItem = (userId: string, itemId: string) => {
  return apiInstance<UserItemDataDto>({
    url: `/Users/${userId}/FavoriteItems/${itemId}`,
    method: "DELETE",
  });
};

export const getUnmarkFavoriteItemMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unmarkFavoriteItem>>,
    TError,
    { userId: string; itemId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unmarkFavoriteItem>>,
  TError,
  { userId: string; itemId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unmarkFavoriteItem>>,
    { userId: string; itemId: string }
  > = (props) => {
    const { userId, itemId } = props ?? {};

    return unmarkFavoriteItem(userId, itemId);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnmarkFavoriteItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof unmarkFavoriteItem>>
>;

export type UnmarkFavoriteItemMutationError = ErrorType<void>;

/**
 * @summary Unmarks item as a favorite.
 */
export const useUnmarkFavoriteItem = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unmarkFavoriteItem>>,
    TError,
    { userId: string; itemId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof unmarkFavoriteItem>>,
  TError,
  { userId: string; itemId: string },
  TContext
> => {
  const mutationOptions = getUnmarkFavoriteItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets an item from a user's library.
 */
export const getItem = (
  userId: string,
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/Users/${userId}/Items/${itemId}`,
    method: "GET",
    signal,
  });
};

export const getGetItemQueryKey = (userId: string, itemId: string) => {
  return [`/Users/${userId}/Items/${itemId}`] as const;
};

export const getGetItemQueryOptions = <
  TData = Awaited<ReturnType<typeof getItem>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItem>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemQueryKey(userId, itemId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItem>>> = ({
    signal,
  }) => getItem(userId, itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && itemId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getItem>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetItemQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItem>>
>;
export type GetItemQueryError = ErrorType<void>;

export function useGetItem<
  TData = Awaited<ReturnType<typeof getItem>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItem>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItem>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItem<
  TData = Awaited<ReturnType<typeof getItem>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItem>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItem>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetItem<
  TData = Awaited<ReturnType<typeof getItem>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItem>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets an item from a user's library.
 */

export function useGetItem<
  TData = Awaited<ReturnType<typeof getItem>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getItem>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetItemQueryOptions(userId, itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets intros to play before the main media item plays.
 */
export const getIntros = (
  userId: string,
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Users/${userId}/Items/${itemId}/Intros`,
    method: "GET",
    signal,
  });
};

export const getGetIntrosQueryKey = (userId: string, itemId: string) => {
  return [`/Users/${userId}/Items/${itemId}/Intros`] as const;
};

export const getGetIntrosQueryOptions = <
  TData = Awaited<ReturnType<typeof getIntros>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIntros>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetIntrosQueryKey(userId, itemId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIntros>>> = ({
    signal,
  }) => getIntros(userId, itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && itemId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getIntros>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetIntrosQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIntros>>
>;
export type GetIntrosQueryError = ErrorType<void>;

export function useGetIntros<
  TData = Awaited<ReturnType<typeof getIntros>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIntros>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIntros>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetIntros<
  TData = Awaited<ReturnType<typeof getIntros>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIntros>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIntros>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetIntros<
  TData = Awaited<ReturnType<typeof getIntros>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIntros>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets intros to play before the main media item plays.
 */

export function useGetIntros<
  TData = Awaited<ReturnType<typeof getIntros>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIntros>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetIntrosQueryOptions(userId, itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets local trailers for an item.
 */
export const getLocalTrailers = (
  userId: string,
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto[]>({
    url: `/Users/${userId}/Items/${itemId}/LocalTrailers`,
    method: "GET",
    signal,
  });
};

export const getGetLocalTrailersQueryKey = (userId: string, itemId: string) => {
  return [`/Users/${userId}/Items/${itemId}/LocalTrailers`] as const;
};

export const getGetLocalTrailersQueryOptions = <
  TData = Awaited<ReturnType<typeof getLocalTrailers>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLocalTrailers>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLocalTrailersQueryKey(userId, itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLocalTrailers>>
  > = ({ signal }) => getLocalTrailers(userId, itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && itemId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLocalTrailers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLocalTrailersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLocalTrailers>>
>;
export type GetLocalTrailersQueryError = ErrorType<void>;

export function useGetLocalTrailers<
  TData = Awaited<ReturnType<typeof getLocalTrailers>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLocalTrailers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocalTrailers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLocalTrailers<
  TData = Awaited<ReturnType<typeof getLocalTrailers>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLocalTrailers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocalTrailers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLocalTrailers<
  TData = Awaited<ReturnType<typeof getLocalTrailers>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLocalTrailers>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets local trailers for an item.
 */

export function useGetLocalTrailers<
  TData = Awaited<ReturnType<typeof getLocalTrailers>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLocalTrailers>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLocalTrailersQueryOptions(userId, itemId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Deletes a user's saved personal rating for an item.
 */
export const deleteUserItemRating = (userId: string, itemId: string) => {
  return apiInstance<UserItemDataDto>({
    url: `/Users/${userId}/Items/${itemId}/Rating`,
    method: "DELETE",
  });
};

export const getDeleteUserItemRatingMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUserItemRating>>,
    TError,
    { userId: string; itemId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUserItemRating>>,
  TError,
  { userId: string; itemId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUserItemRating>>,
    { userId: string; itemId: string }
  > = (props) => {
    const { userId, itemId } = props ?? {};

    return deleteUserItemRating(userId, itemId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserItemRatingMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUserItemRating>>
>;

export type DeleteUserItemRatingMutationError = ErrorType<void>;

/**
 * @summary Deletes a user's saved personal rating for an item.
 */
export const useDeleteUserItemRating = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUserItemRating>>,
    TError,
    { userId: string; itemId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteUserItemRating>>,
  TError,
  { userId: string; itemId: string },
  TContext
> => {
  const mutationOptions = getDeleteUserItemRatingMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Updates a user's rating for an item.
 */
export const updateUserItemRating = (
  userId: string,
  itemId: string,
  params?: UpdateUserItemRatingParams
) => {
  return apiInstance<UserItemDataDto>({
    url: `/Users/${userId}/Items/${itemId}/Rating`,
    method: "POST",
    params,
  });
};

export const getUpdateUserItemRatingMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserItemRating>>,
    TError,
    { userId: string; itemId: string; params?: UpdateUserItemRatingParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUserItemRating>>,
  TError,
  { userId: string; itemId: string; params?: UpdateUserItemRatingParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUserItemRating>>,
    { userId: string; itemId: string; params?: UpdateUserItemRatingParams }
  > = (props) => {
    const { userId, itemId, params } = props ?? {};

    return updateUserItemRating(userId, itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserItemRatingMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUserItemRating>>
>;

export type UpdateUserItemRatingMutationError = ErrorType<void>;

/**
 * @summary Updates a user's rating for an item.
 */
export const useUpdateUserItemRating = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserItemRating>>,
    TError,
    { userId: string; itemId: string; params?: UpdateUserItemRatingParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateUserItemRating>>,
  TError,
  { userId: string; itemId: string; params?: UpdateUserItemRatingParams },
  TContext
> => {
  const mutationOptions = getUpdateUserItemRatingMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets special features for an item.
 */
export const getSpecialFeatures = (
  userId: string,
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto[]>({
    url: `/Users/${userId}/Items/${itemId}/SpecialFeatures`,
    method: "GET",
    signal,
  });
};

export const getGetSpecialFeaturesQueryKey = (
  userId: string,
  itemId: string
) => {
  return [`/Users/${userId}/Items/${itemId}/SpecialFeatures`] as const;
};

export const getGetSpecialFeaturesQueryOptions = <
  TData = Awaited<ReturnType<typeof getSpecialFeatures>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpecialFeatures>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpecialFeaturesQueryKey(userId, itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpecialFeatures>>
  > = ({ signal }) => getSpecialFeatures(userId, itemId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && itemId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSpecialFeatures>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSpecialFeaturesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpecialFeatures>>
>;
export type GetSpecialFeaturesQueryError = ErrorType<void>;

export function useGetSpecialFeatures<
  TData = Awaited<ReturnType<typeof getSpecialFeatures>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpecialFeatures>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpecialFeatures>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSpecialFeatures<
  TData = Awaited<ReturnType<typeof getSpecialFeatures>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpecialFeatures>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpecialFeatures>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetSpecialFeatures<
  TData = Awaited<ReturnType<typeof getSpecialFeatures>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpecialFeatures>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets special features for an item.
 */

export function useGetSpecialFeatures<
  TData = Awaited<ReturnType<typeof getSpecialFeatures>>,
  TError = ErrorType<void>
>(
  userId: string,
  itemId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpecialFeatures>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSpecialFeaturesQueryOptions(
    userId,
    itemId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets latest media.
 */
export const getLatestMedia = (
  userId: string,
  params?: GetLatestMediaParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto[]>({
    url: `/Users/${userId}/Items/Latest`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLatestMediaQueryKey = (
  userId: string,
  params?: GetLatestMediaParams
) => {
  return [
    `/Users/${userId}/Items/Latest`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLatestMediaQueryOptions = <
  TData = Awaited<ReturnType<typeof getLatestMedia>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetLatestMediaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLatestMedia>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLatestMediaQueryKey(userId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLatestMedia>>> = ({
    signal,
  }) => getLatestMedia(userId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLatestMedia>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLatestMediaQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLatestMedia>>
>;
export type GetLatestMediaQueryError = ErrorType<void>;

export function useGetLatestMedia<
  TData = Awaited<ReturnType<typeof getLatestMedia>>,
  TError = ErrorType<void>
>(
  userId: string,
  params: undefined | GetLatestMediaParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLatestMedia>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestMedia>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLatestMedia<
  TData = Awaited<ReturnType<typeof getLatestMedia>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetLatestMediaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLatestMedia>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestMedia>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetLatestMedia<
  TData = Awaited<ReturnType<typeof getLatestMedia>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetLatestMediaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLatestMedia>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets latest media.
 */

export function useGetLatestMedia<
  TData = Awaited<ReturnType<typeof getLatestMedia>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetLatestMediaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLatestMedia>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLatestMediaQueryOptions(userId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets the root folder from a user's library.
 */
export const getRootFolder = (userId: string, signal?: AbortSignal) => {
  return apiInstance<BaseItemDto>({
    url: `/Users/${userId}/Items/Root`,
    method: "GET",
    signal,
  });
};

export const getGetRootFolderQueryKey = (userId: string) => {
  return [`/Users/${userId}/Items/Root`] as const;
};

export const getGetRootFolderQueryOptions = <
  TData = Awaited<ReturnType<typeof getRootFolder>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRootFolder>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRootFolderQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRootFolder>>> = ({
    signal,
  }) => getRootFolder(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRootFolder>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetRootFolderQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRootFolder>>
>;
export type GetRootFolderQueryError = ErrorType<void>;

export function useGetRootFolder<
  TData = Awaited<ReturnType<typeof getRootFolder>>,
  TError = ErrorType<void>
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRootFolder>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRootFolder>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRootFolder<
  TData = Awaited<ReturnType<typeof getRootFolder>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRootFolder>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRootFolder>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetRootFolder<
  TData = Awaited<ReturnType<typeof getRootFolder>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRootFolder>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets the root folder from a user's library.
 */

export function useGetRootFolder<
  TData = Awaited<ReturnType<typeof getRootFolder>>,
  TError = ErrorType<void>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRootFolder>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRootFolderQueryOptions(userId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get user view grouping options.
 */
export const getGroupingOptions = (userId: string, signal?: AbortSignal) => {
  return apiInstance<SpecialViewOptionDto[]>({
    url: `/Users/${userId}/GroupingOptions`,
    method: "GET",
    signal,
  });
};

export const getGetGroupingOptionsQueryKey = (userId: string) => {
  return [`/Users/${userId}/GroupingOptions`] as const;
};

export const getGetGroupingOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroupingOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupingOptions>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroupingOptionsQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroupingOptions>>
  > = ({ signal }) => getGroupingOptions(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGroupingOptions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetGroupingOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroupingOptions>>
>;
export type GetGroupingOptionsQueryError = ErrorType<void | ProblemDetails>;

export function useGetGroupingOptions<
  TData = Awaited<ReturnType<typeof getGroupingOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupingOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupingOptions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGroupingOptions<
  TData = Awaited<ReturnType<typeof getGroupingOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupingOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupingOptions>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetGroupingOptions<
  TData = Awaited<ReturnType<typeof getGroupingOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupingOptions>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get user view grouping options.
 */

export function useGetGroupingOptions<
  TData = Awaited<ReturnType<typeof getGroupingOptions>>,
  TError = ErrorType<void | ProblemDetails>
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupingOptions>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetGroupingOptionsQueryOptions(userId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get user views.
 */
export const getUserViews = (
  userId: string,
  params?: GetUserViewsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Users/${userId}/Views`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetUserViewsQueryKey = (
  userId: string,
  params?: GetUserViewsParams
) => {
  return [`/Users/${userId}/Views`, ...(params ? [params] : [])] as const;
};

export const getGetUserViewsQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserViews>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetUserViewsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserViews>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserViewsQueryKey(userId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserViews>>> = ({
    signal,
  }) => getUserViews(userId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserViews>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserViewsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserViews>>
>;
export type GetUserViewsQueryError = ErrorType<void>;

export function useGetUserViews<
  TData = Awaited<ReturnType<typeof getUserViews>>,
  TError = ErrorType<void>
>(
  userId: string,
  params: undefined | GetUserViewsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserViews>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserViews>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUserViews<
  TData = Awaited<ReturnType<typeof getUserViews>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetUserViewsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserViews>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserViews>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetUserViews<
  TData = Awaited<ReturnType<typeof getUserViews>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetUserViewsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserViews>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get user views.
 */

export function useGetUserViews<
  TData = Awaited<ReturnType<typeof getUserViews>>,
  TError = ErrorType<void>
>(
  userId: string,
  params?: GetUserViewsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserViews>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserViewsQueryOptions(userId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get video attachment.
 */
export const getAttachment = (
  videoId: string,
  mediaSourceId: string,
  index: number,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${videoId}/${mediaSourceId}/Attachments/${index}`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getGetAttachmentQueryKey = (
  videoId: string,
  mediaSourceId: string,
  index: number
) => {
  return [`/Videos/${videoId}/${mediaSourceId}/Attachments/${index}`] as const;
};

export const getGetAttachmentQueryOptions = <
  TData = Awaited<ReturnType<typeof getAttachment>>,
  TError = ErrorType<ProblemDetails>
>(
  videoId: string,
  mediaSourceId: string,
  index: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttachment>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAttachmentQueryKey(videoId, mediaSourceId, index);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAttachment>>> = ({
    signal,
  }) => getAttachment(videoId, mediaSourceId, index, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(videoId && mediaSourceId && index),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAttachment>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAttachmentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAttachment>>
>;
export type GetAttachmentQueryError = ErrorType<ProblemDetails>;

export function useGetAttachment<
  TData = Awaited<ReturnType<typeof getAttachment>>,
  TError = ErrorType<ProblemDetails>
>(
  videoId: string,
  mediaSourceId: string,
  index: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttachment>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttachment>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAttachment<
  TData = Awaited<ReturnType<typeof getAttachment>>,
  TError = ErrorType<ProblemDetails>
>(
  videoId: string,
  mediaSourceId: string,
  index: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttachment>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttachment>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAttachment<
  TData = Awaited<ReturnType<typeof getAttachment>>,
  TError = ErrorType<ProblemDetails>
>(
  videoId: string,
  mediaSourceId: string,
  index: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttachment>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get video attachment.
 */

export function useGetAttachment<
  TData = Awaited<ReturnType<typeof getAttachment>>,
  TError = ErrorType<ProblemDetails>
>(
  videoId: string,
  mediaSourceId: string,
  index: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttachment>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAttachmentQueryOptions(
    videoId,
    mediaSourceId,
    index,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets additional parts for a video.
 */
export const getAdditionalPart = (
  itemId: string,
  params?: GetAdditionalPartParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Videos/${itemId}/AdditionalParts`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetAdditionalPartQueryKey = (
  itemId: string,
  params?: GetAdditionalPartParams
) => {
  return [
    `/Videos/${itemId}/AdditionalParts`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAdditionalPartQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdditionalPart>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetAdditionalPartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdditionalPart>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAdditionalPartQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAdditionalPart>>
  > = ({ signal }) => getAdditionalPart(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAdditionalPart>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAdditionalPartQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAdditionalPart>>
>;
export type GetAdditionalPartQueryError = ErrorType<void>;

export function useGetAdditionalPart<
  TData = Awaited<ReturnType<typeof getAdditionalPart>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params: undefined | GetAdditionalPartParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdditionalPart>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdditionalPart>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAdditionalPart<
  TData = Awaited<ReturnType<typeof getAdditionalPart>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetAdditionalPartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdditionalPart>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdditionalPart>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetAdditionalPart<
  TData = Awaited<ReturnType<typeof getAdditionalPart>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetAdditionalPartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdditionalPart>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets additional parts for a video.
 */

export function useGetAdditionalPart<
  TData = Awaited<ReturnType<typeof getAdditionalPart>>,
  TError = ErrorType<void>
>(
  itemId: string,
  params?: GetAdditionalPartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdditionalPart>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAdditionalPartQueryOptions(
    itemId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Removes alternate video sources.
 */
export const deleteAlternateSources = (itemId: string) => {
  return apiInstance<void>({
    url: `/Videos/${itemId}/AlternateSources`,
    method: "DELETE",
  });
};

export const getDeleteAlternateSourcesMutationOptions = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAlternateSources>>,
    TError,
    { itemId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAlternateSources>>,
  TError,
  { itemId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAlternateSources>>,
    { itemId: string }
  > = (props) => {
    const { itemId } = props ?? {};

    return deleteAlternateSources(itemId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAlternateSourcesMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAlternateSources>>
>;

export type DeleteAlternateSourcesMutationError =
  ErrorType<void | ProblemDetails>;

/**
 * @summary Removes alternate video sources.
 */
export const useDeleteAlternateSources = <
  TError = ErrorType<void | ProblemDetails>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAlternateSources>>,
    TError,
    { itemId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteAlternateSources>>,
  TError,
  { itemId: string },
  TContext
> => {
  const mutationOptions = getDeleteAlternateSourcesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a video stream.
 */
export const getVideoStream = (
  itemId: string,
  params?: GetVideoStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/stream`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetVideoStreamQueryKey = (
  itemId: string,
  params?: GetVideoStreamParams
) => {
  return [`/Videos/${itemId}/stream`, ...(params ? [params] : [])] as const;
};

export const getGetVideoStreamQueryOptions = <
  TData = Awaited<ReturnType<typeof getVideoStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params?: GetVideoStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVideoStream>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVideoStreamQueryKey(itemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVideoStream>>> = ({
    signal,
  }) => getVideoStream(itemId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getVideoStream>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetVideoStreamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVideoStream>>
>;
export type GetVideoStreamQueryError = ErrorType<unknown>;

export function useGetVideoStream<
  TData = Awaited<ReturnType<typeof getVideoStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params: undefined | GetVideoStreamParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVideoStream>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideoStream>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVideoStream<
  TData = Awaited<ReturnType<typeof getVideoStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params?: GetVideoStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVideoStream>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideoStream>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVideoStream<
  TData = Awaited<ReturnType<typeof getVideoStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params?: GetVideoStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVideoStream>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a video stream.
 */

export function useGetVideoStream<
  TData = Awaited<ReturnType<typeof getVideoStream>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  params?: GetVideoStreamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVideoStream>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetVideoStreamQueryOptions(itemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a video stream.
 */
export const headVideoStream = (
  itemId: string,
  params?: HeadVideoStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/stream`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadVideoStreamMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headVideoStream>>,
    TError,
    { itemId: string; params?: HeadVideoStreamParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headVideoStream>>,
  TError,
  { itemId: string; params?: HeadVideoStreamParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headVideoStream>>,
    { itemId: string; params?: HeadVideoStreamParams }
  > = (props) => {
    const { itemId, params } = props ?? {};

    return headVideoStream(itemId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadVideoStreamMutationResult = NonNullable<
  Awaited<ReturnType<typeof headVideoStream>>
>;

export type HeadVideoStreamMutationError = ErrorType<unknown>;

/**
 * @summary Gets a video stream.
 */
export const useHeadVideoStream = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headVideoStream>>,
    TError,
    { itemId: string; params?: HeadVideoStreamParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headVideoStream>>,
  TError,
  { itemId: string; params?: HeadVideoStreamParams },
  TContext
> => {
  const mutationOptions = getHeadVideoStreamMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Gets a video stream.
 */
export const getVideoStreamByContainer = (
  itemId: string,
  container: string,
  params?: GetVideoStreamByContainerParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/stream.${container}`,
    method: "GET",
    params,
    responseType: "blob",
    signal,
  });
};

export const getGetVideoStreamByContainerQueryKey = (
  itemId: string,
  container: string,
  params?: GetVideoStreamByContainerParams
) => {
  return [
    `/Videos/${itemId}/stream.${container}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetVideoStreamByContainerQueryOptions = <
  TData = Awaited<ReturnType<typeof getVideoStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params?: GetVideoStreamByContainerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVideoStreamByContainer>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetVideoStreamByContainerQueryKey(itemId, container, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVideoStreamByContainer>>
  > = ({ signal }) =>
    getVideoStreamByContainer(itemId, container, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(itemId && container),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getVideoStreamByContainer>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetVideoStreamByContainerQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVideoStreamByContainer>>
>;
export type GetVideoStreamByContainerQueryError = ErrorType<unknown>;

export function useGetVideoStreamByContainer<
  TData = Awaited<ReturnType<typeof getVideoStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params: undefined | GetVideoStreamByContainerParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVideoStreamByContainer>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideoStreamByContainer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVideoStreamByContainer<
  TData = Awaited<ReturnType<typeof getVideoStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params?: GetVideoStreamByContainerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVideoStreamByContainer>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVideoStreamByContainer>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetVideoStreamByContainer<
  TData = Awaited<ReturnType<typeof getVideoStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params?: GetVideoStreamByContainerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVideoStreamByContainer>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a video stream.
 */

export function useGetVideoStreamByContainer<
  TData = Awaited<ReturnType<typeof getVideoStreamByContainer>>,
  TError = ErrorType<unknown>
>(
  itemId: string,
  container: string,
  params?: GetVideoStreamByContainerParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVideoStreamByContainer>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetVideoStreamByContainerQueryOptions(
    itemId,
    container,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a video stream.
 */
export const headVideoStreamByContainer = (
  itemId: string,
  container: string,
  params?: HeadVideoStreamByContainerParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>({
    url: `/Videos/${itemId}/stream.${container}`,
    method: "HEAD",
    params,
    responseType: "blob",
    signal,
  });
};

export const getHeadVideoStreamByContainerMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headVideoStreamByContainer>>,
    TError,
    {
      itemId: string;
      container: string;
      params?: HeadVideoStreamByContainerParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof headVideoStreamByContainer>>,
  TError,
  {
    itemId: string;
    container: string;
    params?: HeadVideoStreamByContainerParams;
  },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof headVideoStreamByContainer>>,
    {
      itemId: string;
      container: string;
      params?: HeadVideoStreamByContainerParams;
    }
  > = (props) => {
    const { itemId, container, params } = props ?? {};

    return headVideoStreamByContainer(itemId, container, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HeadVideoStreamByContainerMutationResult = NonNullable<
  Awaited<ReturnType<typeof headVideoStreamByContainer>>
>;

export type HeadVideoStreamByContainerMutationError = ErrorType<unknown>;

/**
 * @summary Gets a video stream.
 */
export const useHeadVideoStreamByContainer = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof headVideoStreamByContainer>>,
    TError,
    {
      itemId: string;
      container: string;
      params?: HeadVideoStreamByContainerParams;
    },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof headVideoStreamByContainer>>,
  TError,
  {
    itemId: string;
    container: string;
    params?: HeadVideoStreamByContainerParams;
  },
  TContext
> => {
  const mutationOptions = getHeadVideoStreamByContainerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Merges videos into a single record.
 */
export const mergeVersions = (params: MergeVersionsParams) => {
  return apiInstance<void>({
    url: `/Videos/MergeVersions`,
    method: "POST",
    params,
  });
};

export const getMergeVersionsMutationOptions = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mergeVersions>>,
    TError,
    { params: MergeVersionsParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof mergeVersions>>,
  TError,
  { params: MergeVersionsParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mergeVersions>>,
    { params: MergeVersionsParams }
  > = (props) => {
    const { params } = props ?? {};

    return mergeVersions(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MergeVersionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof mergeVersions>>
>;

export type MergeVersionsMutationError = ErrorType<ProblemDetails | void>;

/**
 * @summary Merges videos into a single record.
 */
export const useMergeVersions = <
  TError = ErrorType<ProblemDetails | void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mergeVersions>>,
    TError,
    { params: MergeVersionsParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof mergeVersions>>,
  TError,
  { params: MergeVersionsParams },
  TContext
> => {
  const mutationOptions = getMergeVersionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get years.
 */
export const getYears = (params?: GetYearsParams, signal?: AbortSignal) => {
  return apiInstance<BaseItemDtoQueryResult>({
    url: `/Years`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetYearsQueryKey = (params?: GetYearsParams) => {
  return [`/Years`, ...(params ? [params] : [])] as const;
};

export const getGetYearsQueryOptions = <
  TData = Awaited<ReturnType<typeof getYears>>,
  TError = ErrorType<void>
>(
  params?: GetYearsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYears>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetYearsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getYears>>> = ({
    signal,
  }) => getYears(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getYears>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetYearsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getYears>>
>;
export type GetYearsQueryError = ErrorType<void>;

export function useGetYears<
  TData = Awaited<ReturnType<typeof getYears>>,
  TError = ErrorType<void>
>(
  params: undefined | GetYearsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYears>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getYears>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetYears<
  TData = Awaited<ReturnType<typeof getYears>>,
  TError = ErrorType<void>
>(
  params?: GetYearsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYears>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getYears>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetYears<
  TData = Awaited<ReturnType<typeof getYears>>,
  TError = ErrorType<void>
>(
  params?: GetYearsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYears>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Get years.
 */

export function useGetYears<
  TData = Awaited<ReturnType<typeof getYears>>,
  TError = ErrorType<void>
>(
  params?: GetYearsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYears>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetYearsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a year.
 */
export const getYear = (
  year: number,
  params?: GetYearParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>({
    url: `/Years/${year}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetYearQueryKey = (year: number, params?: GetYearParams) => {
  return [`/Years/${year}`, ...(params ? [params] : [])] as const;
};

export const getGetYearQueryOptions = <
  TData = Awaited<ReturnType<typeof getYear>>,
  TError = ErrorType<void | ProblemDetails>
>(
  year: number,
  params?: GetYearParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYear>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetYearQueryKey(year, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getYear>>> = ({
    signal,
  }) => getYear(year, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!year,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getYear>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetYearQueryResult = NonNullable<
  Awaited<ReturnType<typeof getYear>>
>;
export type GetYearQueryError = ErrorType<void | ProblemDetails>;

export function useGetYear<
  TData = Awaited<ReturnType<typeof getYear>>,
  TError = ErrorType<void | ProblemDetails>
>(
  year: number,
  params: undefined | GetYearParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYear>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getYear>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetYear<
  TData = Awaited<ReturnType<typeof getYear>>,
  TError = ErrorType<void | ProblemDetails>
>(
  year: number,
  params?: GetYearParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYear>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getYear>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
export function useGetYear<
  TData = Awaited<ReturnType<typeof getYear>>,
  TError = ErrorType<void | ProblemDetails>
>(
  year: number,
  params?: GetYearParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYear>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey };
/**
 * @summary Gets a year.
 */

export function useGetYear<
  TData = Awaited<ReturnType<typeof getYear>>,
  TError = ErrorType<void | ProblemDetails>
>(
  year: number,
  params?: GetYearParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getYear>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetYearQueryOptions(year, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
