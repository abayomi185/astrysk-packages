
/**
 * Generated by orval v6.11.1 🍺
 * Do not edit manually.
 * Jellyfin API
 * OpenAPI spec version: 10.8.8
 */
import {
  useQuery,
  useMutation
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
import type {
  ActivityLogEntryQueryResult,
  GetLogEntriesParams,
  AuthenticationInfoQueryResult,
  CreateKeyParams,
  BaseItemDtoQueryResult,
  GetArtistsParams,
  BaseItemDto,
  GetArtistByNameParams,
  GetAlbumArtistsParams,
  GetAudioStreamParams,
  HeadAudioStreamParams,
  GetAudioStreamByContainerParams,
  HeadAudioStreamByContainerParams,
  BrandingOptions,
  GetChannelsParams,
  ChannelFeatures,
  GetChannelItemsParams,
  GetLatestChannelItemsParams,
  ClientLogDocumentResponseDto,
  ProblemDetails,
  CollectionCreationResult,
  CreateCollectionParams,
  AddToCollectionParams,
  RemoveFromCollectionParams,
  ServerConfiguration,
  MetadataOptions,
  MediaEncoderPathDto,
  GetDashboardConfigurationPageParams,
  ConfigurationPageInfo,
  GetConfigurationPagesParams,
  DeviceInfoQueryResult,
  GetDevicesParams,
  DeleteDeviceParams,
  DeviceInfo,
  GetDeviceInfoParams,
  DeviceOptions,
  GetDeviceOptionsParams,
  DeviceOptionsDto,
  UpdateDeviceOptionsParams,
  DisplayPreferencesDto,
  GetDisplayPreferencesParams,
  UpdateDisplayPreferencesParams,
  DeviceProfileInfo,
  DeviceProfile,
  GetHlsAudioSegmentParams,
  GetVariantHlsAudioPlaylistParams,
  GetMasterHlsAudioPlaylistParams,
  HeadMasterHlsAudioPlaylistParams,
  GetHlsVideoSegmentParams,
  GetLiveHlsStreamParams,
  GetVariantHlsVideoPlaylistParams,
  GetMasterHlsVideoPlaylistParams,
  HeadMasterHlsVideoPlaylistParams,
  DefaultDirectoryBrowserInfoDto,
  FileSystemEntryInfo,
  GetDirectoryContentsParams,
  GetParentPathParams,
  ValidatePathDto,
  QueryFiltersLegacy,
  GetQueryFiltersLegacyParams,
  QueryFilters,
  GetQueryFiltersParams,
  GetGenresParams,
  GetGenreParams,
  StopEncodingProcessParams,
  GetArtistImageParams,
  ImageType,
  HeadArtistImageParams,
  GetSplashscreenParams,
  GetGenreImageParams,
  HeadGenreImageParams,
  GetGenreImageByIndexParams,
  HeadGenreImageByIndexParams,
  ImageInfo,
  DeleteItemImageParams,
  GetItemImageParams,
  HeadItemImageParams,
  GetItemImageByIndexParams,
  HeadItemImageByIndexParams,
  GetItemImage2Params,
  ImageFormat,
  HeadItemImage2Params,
  UpdateItemImageIndexParams,
  GetMusicGenreImageParams,
  HeadMusicGenreImageParams,
  GetMusicGenreImageByIndexParams,
  HeadMusicGenreImageByIndexParams,
  GetPersonImageParams,
  HeadPersonImageParams,
  GetPersonImageByIndexParams,
  HeadPersonImageByIndexParams,
  GetStudioImageParams,
  HeadStudioImageParams,
  GetStudioImageByIndexParams,
  HeadStudioImageByIndexParams,
  PostUserImageParams,
  DeleteUserImageParams,
  GetUserImageParams,
  HeadUserImageParams,
  GetUserImageByIndexParams,
  HeadUserImageByIndexParams,
  ImageByNameInfo,
  GetInstantMixFromAlbumParams,
  GetInstantMixFromArtistsParams,
  GetInstantMixFromArtists2Params,
  GetInstantMixFromItemParams,
  GetInstantMixFromMusicGenreByNameParams,
  GetInstantMixFromMusicGenreByIdParams,
  GetInstantMixFromPlaylistParams,
  GetInstantMixFromSongParams,
  ExternalIdInfo,
  RemoteSearchResult,
  ApplySearchCriteriaParams,
  BookInfoRemoteSearchQuery,
  BoxSetInfoRemoteSearchQuery,
  MovieInfoRemoteSearchQuery,
  AlbumInfoRemoteSearchQuery,
  ArtistInfoRemoteSearchQuery,
  MusicVideoInfoRemoteSearchQuery,
  PersonLookupInfoRemoteSearchQuery,
  SeriesInfoRemoteSearchQuery,
  TrailerInfoRemoteSearchQuery,
  RefreshItemParams,
  GetItemsParams,
  DeleteItemsParams,
  GetItemsByUserIdParams,
  GetResumeItemsParams,
  UpdateItemContentTypeParams,
  MetadataEditorInfo,
  GetSimilarAlbumsParams,
  GetSimilarArtistsParams,
  GetAncestorsParams,
  GetSimilarItemsParams,
  AllThemeMediaResult,
  GetThemeMediaParams,
  ThemeMediaResult,
  GetThemeSongsParams,
  GetThemeVideosParams,
  ItemCounts,
  GetItemCountsParams,
  LibraryOptionsResultDto,
  GetLibraryOptionsInfoParams,
  MediaUpdateInfoDto,
  GetMediaFoldersParams,
  PostAddedMoviesParams,
  PostUpdatedMoviesParams,
  PostAddedSeriesParams,
  PostUpdatedSeriesParams,
  GetSimilarMoviesParams,
  GetSimilarShowsParams,
  GetSimilarTrailersParams,
  VirtualFolderInfo,
  AddVirtualFolderDto,
  AddVirtualFolderParams,
  RemoveVirtualFolderParams,
  UpdateLibraryOptionsDto,
  RenameVirtualFolderParams,
  MediaPathDto,
  AddMediaPathParams,
  RemoveMediaPathParams,
  UpdateMediaPathRequestDto,
  ChannelMappingOptionsDto,
  GetChannelMappingOptionsParams,
  TunerChannelMapping,
  SetChannelMappingDto,
  GetLiveTvChannelsParams,
  GetChannelParams,
  GuideInfo,
  LiveTvInfo,
  ListingsProviderInfo,
  AddListingProviderParams,
  DeleteListingProviderParams,
  NameIdPair,
  GetLineupsParams,
  GetLiveTvProgramsParams,
  GetProgramsDto,
  GetProgramParams,
  GetRecommendedProgramsParams,
  GetRecordingsParams,
  GetRecordingParams,
  GetRecordingFoldersParams,
  GetRecordingGroupsParams,
  GetRecordingsSeriesParams,
  SeriesTimerInfoDtoQueryResult,
  GetSeriesTimersParams,
  SeriesTimerInfoDto,
  TimerInfoDtoQueryResult,
  GetTimersParams,
  TimerInfoDto,
  GetDefaultTimerParams,
  TunerHostInfo,
  DeleteTunerHostParams,
  DiscoverTunersParams,
  DiscvoverTunersParams,
  CountryInfo,
  CultureDto,
  LocalizationOption,
  ParentalRating,
  PlaybackInfoResponse,
  GetPlaybackInfoParams,
  PlaybackInfoDto,
  GetPostedPlaybackInfoParams,
  CloseLiveStreamParams,
  LiveStreamResponse,
  OpenLiveStreamDto,
  OpenLiveStreamParams,
  GetBitrateTestBytesParams,
  RecommendationDto,
  GetMovieRecommendationsParams,
  GetMusicGenresParams,
  GetMusicGenreParams,
  NotificationResultDto,
  NotificationsSummaryDto,
  AdminNotificationDto,
  NotificationTypeInfo,
  PackageInfo,
  GetPackageInfoParams,
  InstallPackageParams,
  RepositoryInfo,
  GetPersonsParams,
  GetPersonParams,
  PlaylistCreationResult,
  CreatePlaylistDto,
  CreatePlaylistParams,
  AddToPlaylistParams,
  RemoveFromPlaylistParams,
  GetPlaylistItemsParams,
  PlaybackStartInfo,
  PingPlaybackSessionParams,
  PlaybackProgressInfo,
  PlaybackStopInfo,
  UserItemDataDto,
  MarkPlayedItemParams,
  OnPlaybackStartParams,
  OnPlaybackStoppedParams,
  OnPlaybackProgressParams,
  PluginInfo,
  BasePluginConfiguration,
  AuthorizeParams,
  QuickConnectResult,
  ConnectParams,
  RemoteImageResult,
  GetRemoteImagesParams,
  DownloadRemoteImageParams,
  ImageProviderInfo,
  TaskInfo,
  GetTasksParams,
  TaskTriggerInfo,
  SearchHintResult,
  GetParams,
  SessionInfo,
  GetSessionsParams,
  GeneralCommand,
  GeneralCommandType,
  MessageCommand,
  PlayParams,
  SendPlaystateCommandParams,
  PlaystateCommand,
  DisplayContentParams,
  PostCapabilitiesParams,
  ClientCapabilitiesDto,
  PostFullCapabilitiesParams,
  ReportViewingParams,
  StartupConfigurationDto,
  StartupUserDto,
  StartupRemoteAccessDto,
  GetStudiosParams,
  GetStudioParams,
  FontFile,
  RemoteSubtitleInfo,
  SearchRemoteSubtitlesParams,
  GetSubtitlePlaylistParams,
  UploadSubtitleDto,
  GetSubtitleWithTicksParams,
  GetSubtitleParams,
  GetSuggestionsParams,
  BufferRequestDto,
  JoinGroupRequestDto,
  GroupInfoDto,
  MovePlaylistItemRequestDto,
  NewGroupRequestDto,
  NextItemRequestDto,
  PingRequestDto,
  PreviousItemRequestDto,
  QueueRequestDto,
  ReadyRequestDto,
  RemoveFromPlaylistRequestDto,
  SeekRequestDto,
  IgnoreWaitRequestDto,
  PlayRequestDto,
  SetPlaylistItemRequestDto,
  SetRepeatModeRequestDto,
  SetShuffleModeRequestDto,
  EndPointInfo,
  SystemInfo,
  PublicSystemInfo,
  LogFile,
  GetLogFileParams,
  WakeOnLanInfo,
  UtcTimeResponse,
  ConfigImageTypes,
  GetTrailersParams,
  GetEpisodesParams,
  GetSeasonsParams,
  GetNextUpParams,
  GetUpcomingEpisodesParams,
  GetUniversalAudioStreamParams,
  HeadUniversalAudioStreamParams,
  UserDto,
  GetUsersParams,
  AuthenticationResult,
  AuthenticateUserParams,
  UserConfiguration,
  UpdateUserEasyPassword,
  UpdateUserPassword,
  UserPolicy,
  AuthenticateUserByName,
  QuickConnectDto,
  ForgotPasswordResult,
  ForgotPasswordDto,
  PinRedeemResult,
  ForgotPasswordPinDto,
  CreateUserByName,
  UpdateUserItemRatingParams,
  GetLatestMediaParams,
  SpecialViewOptionDto,
  GetUserViewsParams,
  GetAdditionalPartParams,
  GetVideoStreamParams,
  HeadVideoStreamParams,
  GetVideoStreamByContainerParams,
  HeadVideoStreamByContainerParams,
  MergeVersionsParams,
  GetYearsParams,
  GetYearParams
} from './model'
import { apiInstance } from '@astrysk/api/apiInstance';
import type { ErrorType } from '@astrysk/api/apiInstance';



/**
 * @summary Gets activity log entries.
 */
export const getLogEntries = (
  params?: GetLogEntriesParams,
  signal?: AbortSignal
) => {
  return apiInstance<ActivityLogEntryQueryResult>(
    {
      url: `/System/ActivityLog/Entries`, method: 'get',
      params, signal
    },
  );
}


export const getGetLogEntriesQueryKey = (params?: GetLogEntriesParams,) => [`/System/ActivityLog/Entries`, ...(params ? [params] : [])];


export type GetLogEntriesQueryResult = NonNullable<Awaited<ReturnType<typeof getLogEntries>>>
export type GetLogEntriesQueryError = ErrorType<void>

export const useGetLogEntries = <TData = Awaited<ReturnType<typeof getLogEntries>>, TError = ErrorType<void>>(
  params?: GetLogEntriesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLogEntries>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLogEntriesQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLogEntries>>> = ({ signal }) => getLogEntries(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLogEntries>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get all keys.
 */
export const getKeys = (

  signal?: AbortSignal
) => {
  return apiInstance<AuthenticationInfoQueryResult>(
    {
      url: `/Auth/Keys`, method: 'get', signal
    },
  );
}


export const getGetKeysQueryKey = () => [`/Auth/Keys`];


export type GetKeysQueryResult = NonNullable<Awaited<ReturnType<typeof getKeys>>>
export type GetKeysQueryError = ErrorType<void>

export const useGetKeys = <TData = Awaited<ReturnType<typeof getKeys>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getKeys>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetKeysQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getKeys>>> = ({ signal }) => getKeys(signal);




  const query = useQuery<Awaited<ReturnType<typeof getKeys>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Create a new api key.
 */
export const createKey = (
  params: CreateKeyParams,
) => {
  return apiInstance<void>(
    {
      url: `/Auth/Keys`, method: 'post',
      params
    },
  );
}



export type CreateKeyMutationResult = NonNullable<Awaited<ReturnType<typeof createKey>>>

export type CreateKeyMutationError = ErrorType<unknown>

export const useCreateKey = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof createKey>>, TError, { params: CreateKeyParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createKey>>, { params: CreateKeyParams }> = (props) => {
    const { params } = props ?? {};

    return createKey(params,)
  }



  return useMutation<Awaited<ReturnType<typeof createKey>>, TError, { params: CreateKeyParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Remove an api key.
 */
export const revokeKey = (
  key: string,
) => {
  return apiInstance<void>(
    {
      url: `/Auth/Keys/${key}`, method: 'delete'
    },
  );
}



export type RevokeKeyMutationResult = NonNullable<Awaited<ReturnType<typeof revokeKey>>>

export type RevokeKeyMutationError = ErrorType<unknown>

export const useRevokeKey = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof revokeKey>>, TError, { key: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof revokeKey>>, { key: string }> = (props) => {
    const { key } = props ?? {};

    return revokeKey(key,)
  }



  return useMutation<Awaited<ReturnType<typeof revokeKey>>, TError, { key: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets all artists from a given item, folder, or the entire library.
 */
export const getArtists = (
  params?: GetArtistsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Artists`, method: 'get',
      params, signal
    },
  );
}


export const getGetArtistsQueryKey = (params?: GetArtistsParams,) => [`/Artists`, ...(params ? [params] : [])];


export type GetArtistsQueryResult = NonNullable<Awaited<ReturnType<typeof getArtists>>>
export type GetArtistsQueryError = ErrorType<void>

export const useGetArtists = <TData = Awaited<ReturnType<typeof getArtists>>, TError = ErrorType<void>>(
  params?: GetArtistsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getArtists>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetArtistsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getArtists>>> = ({ signal }) => getArtists(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getArtists>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an artist by name.
 */
export const getArtistByName = (
  name: string,
  params?: GetArtistByNameParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/Artists/${name}`, method: 'get',
      params, signal
    },
  );
}


export const getGetArtistByNameQueryKey = (name: string,
  params?: GetArtistByNameParams,) => [`/Artists/${name}`, ...(params ? [params] : [])];


export type GetArtistByNameQueryResult = NonNullable<Awaited<ReturnType<typeof getArtistByName>>>
export type GetArtistByNameQueryError = ErrorType<void>

export const useGetArtistByName = <TData = Awaited<ReturnType<typeof getArtistByName>>, TError = ErrorType<void>>(
  name: string,
  params?: GetArtistByNameParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getArtistByName>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetArtistByNameQueryKey(name, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getArtistByName>>> = ({ signal }) => getArtistByName(name, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getArtistByName>>, TError, TData>(queryKey, queryFn, { enabled: !!(name), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets all album artists from a given item, folder, or the entire library.
 */
export const getAlbumArtists = (
  params?: GetAlbumArtistsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Artists/AlbumArtists`, method: 'get',
      params, signal
    },
  );
}


export const getGetAlbumArtistsQueryKey = (params?: GetAlbumArtistsParams,) => [`/Artists/AlbumArtists`, ...(params ? [params] : [])];


export type GetAlbumArtistsQueryResult = NonNullable<Awaited<ReturnType<typeof getAlbumArtists>>>
export type GetAlbumArtistsQueryError = ErrorType<void>

export const useGetAlbumArtists = <TData = Awaited<ReturnType<typeof getAlbumArtists>>, TError = ErrorType<void>>(
  params?: GetAlbumArtistsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAlbumArtists>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlbumArtistsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlbumArtists>>> = ({ signal }) => getAlbumArtists(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getAlbumArtists>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an audio stream.
 */
export const getAudioStream = (
  itemId: string,
  params?: GetAudioStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/stream`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetAudioStreamQueryKey = (itemId: string,
  params?: GetAudioStreamParams,) => [`/Audio/${itemId}/stream`, ...(params ? [params] : [])];


export type GetAudioStreamQueryResult = NonNullable<Awaited<ReturnType<typeof getAudioStream>>>
export type GetAudioStreamQueryError = ErrorType<unknown>

export const useGetAudioStream = <TData = Awaited<ReturnType<typeof getAudioStream>>, TError = ErrorType<unknown>>(
  itemId: string,
  params?: GetAudioStreamParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAudioStream>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAudioStreamQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAudioStream>>> = ({ signal }) => getAudioStream(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getAudioStream>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an audio stream.
 */
export const headAudioStream = (
  itemId: string,
  params?: HeadAudioStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/stream`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadAudioStreamMutationResult = NonNullable<Awaited<ReturnType<typeof headAudioStream>>>

export type HeadAudioStreamMutationError = ErrorType<unknown>

export const useHeadAudioStream = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headAudioStream>>, TError, { itemId: string; params?: HeadAudioStreamParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headAudioStream>>, { itemId: string; params?: HeadAudioStreamParams }> = (props) => {
    const { itemId, params } = props ?? {};

    return headAudioStream(itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headAudioStream>>, TError, { itemId: string; params?: HeadAudioStreamParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets an audio stream.
 */
export const getAudioStreamByContainer = (
  itemId: string,
  container: string,
  params?: GetAudioStreamByContainerParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/stream.${container}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetAudioStreamByContainerQueryKey = (itemId: string,
  container: string,
  params?: GetAudioStreamByContainerParams,) => [`/Audio/${itemId}/stream.${container}`, ...(params ? [params] : [])];


export type GetAudioStreamByContainerQueryResult = NonNullable<Awaited<ReturnType<typeof getAudioStreamByContainer>>>
export type GetAudioStreamByContainerQueryError = ErrorType<unknown>

export const useGetAudioStreamByContainer = <TData = Awaited<ReturnType<typeof getAudioStreamByContainer>>, TError = ErrorType<unknown>>(
  itemId: string,
  container: string,
  params?: GetAudioStreamByContainerParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAudioStreamByContainer>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAudioStreamByContainerQueryKey(itemId, container, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAudioStreamByContainer>>> = ({ signal }) => getAudioStreamByContainer(itemId, container, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getAudioStreamByContainer>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && container), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an audio stream.
 */
export const headAudioStreamByContainer = (
  itemId: string,
  container: string,
  params?: HeadAudioStreamByContainerParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/stream.${container}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadAudioStreamByContainerMutationResult = NonNullable<Awaited<ReturnType<typeof headAudioStreamByContainer>>>

export type HeadAudioStreamByContainerMutationError = ErrorType<unknown>

export const useHeadAudioStreamByContainer = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headAudioStreamByContainer>>, TError, { itemId: string; container: string; params?: HeadAudioStreamByContainerParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headAudioStreamByContainer>>, { itemId: string; container: string; params?: HeadAudioStreamByContainerParams }> = (props) => {
    const { itemId, container, params } = props ?? {};

    return headAudioStreamByContainer(itemId, container, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headAudioStreamByContainer>>, TError, { itemId: string; container: string; params?: HeadAudioStreamByContainerParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets branding configuration.
 */
export const getBrandingOptions = (

  signal?: AbortSignal
) => {
  return apiInstance<BrandingOptions>(
    {
      url: `/Branding/Configuration`, method: 'get', signal
    },
  );
}


export const getGetBrandingOptionsQueryKey = () => [`/Branding/Configuration`];


export type GetBrandingOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof getBrandingOptions>>>
export type GetBrandingOptionsQueryError = ErrorType<unknown>

export const useGetBrandingOptions = <TData = Awaited<ReturnType<typeof getBrandingOptions>>, TError = ErrorType<unknown>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getBrandingOptions>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBrandingOptionsQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBrandingOptions>>> = ({ signal }) => getBrandingOptions(signal);




  const query = useQuery<Awaited<ReturnType<typeof getBrandingOptions>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets branding css.
 */
export const getBrandingCss = (

  signal?: AbortSignal
) => {
  return apiInstance<string | void>(
    {
      url: `/Branding/Css`, method: 'get', signal
    },
  );
}


export const getGetBrandingCssQueryKey = () => [`/Branding/Css`];


export type GetBrandingCssQueryResult = NonNullable<Awaited<ReturnType<typeof getBrandingCss>>>
export type GetBrandingCssQueryError = ErrorType<unknown>

export const useGetBrandingCss = <TData = Awaited<ReturnType<typeof getBrandingCss>>, TError = ErrorType<unknown>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBrandingCssQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBrandingCss>>> = ({ signal }) => getBrandingCss(signal);




  const query = useQuery<Awaited<ReturnType<typeof getBrandingCss>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets branding css.
 */
export const getBrandingCss2 = (

  signal?: AbortSignal
) => {
  return apiInstance<string | void>(
    {
      url: `/Branding/Css.css`, method: 'get', signal
    },
  );
}


export const getGetBrandingCss2QueryKey = () => [`/Branding/Css.css`];


export type GetBrandingCss2QueryResult = NonNullable<Awaited<ReturnType<typeof getBrandingCss2>>>
export type GetBrandingCss2QueryError = ErrorType<unknown>

export const useGetBrandingCss2 = <TData = Awaited<ReturnType<typeof getBrandingCss2>>, TError = ErrorType<unknown>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getBrandingCss2>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBrandingCss2QueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBrandingCss2>>> = ({ signal }) => getBrandingCss2(signal);




  const query = useQuery<Awaited<ReturnType<typeof getBrandingCss2>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets available channels.
 */
export const getChannels = (
  params?: GetChannelsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Channels`, method: 'get',
      params, signal
    },
  );
}


export const getGetChannelsQueryKey = (params?: GetChannelsParams,) => [`/Channels`, ...(params ? [params] : [])];


export type GetChannelsQueryResult = NonNullable<Awaited<ReturnType<typeof getChannels>>>
export type GetChannelsQueryError = ErrorType<void>

export const useGetChannels = <TData = Awaited<ReturnType<typeof getChannels>>, TError = ErrorType<void>>(
  params?: GetChannelsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChannelsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannels>>> = ({ signal }) => getChannels(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getChannels>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get channel features.
 */
export const getChannelFeatures = (
  channelId: string,
  signal?: AbortSignal
) => {
  return apiInstance<ChannelFeatures>(
    {
      url: `/Channels/${channelId}/Features`, method: 'get', signal
    },
  );
}


export const getGetChannelFeaturesQueryKey = (channelId: string,) => [`/Channels/${channelId}/Features`];


export type GetChannelFeaturesQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelFeatures>>>
export type GetChannelFeaturesQueryError = ErrorType<void>

export const useGetChannelFeatures = <TData = Awaited<ReturnType<typeof getChannelFeatures>>, TError = ErrorType<void>>(
  channelId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getChannelFeatures>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChannelFeaturesQueryKey(channelId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelFeatures>>> = ({ signal }) => getChannelFeatures(channelId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getChannelFeatures>>, TError, TData>(queryKey, queryFn, { enabled: !!(channelId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get channel items.
 */
export const getChannelItems = (
  channelId: string,
  params?: GetChannelItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Channels/${channelId}/Items`, method: 'get',
      params, signal
    },
  );
}


export const getGetChannelItemsQueryKey = (channelId: string,
  params?: GetChannelItemsParams,) => [`/Channels/${channelId}/Items`, ...(params ? [params] : [])];


export type GetChannelItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelItems>>>
export type GetChannelItemsQueryError = ErrorType<void>

export const useGetChannelItems = <TData = Awaited<ReturnType<typeof getChannelItems>>, TError = ErrorType<void>>(
  channelId: string,
  params?: GetChannelItemsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getChannelItems>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChannelItemsQueryKey(channelId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelItems>>> = ({ signal }) => getChannelItems(channelId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getChannelItems>>, TError, TData>(queryKey, queryFn, { enabled: !!(channelId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get all channel features.
 */
export const getAllChannelFeatures = (

  signal?: AbortSignal
) => {
  return apiInstance<ChannelFeatures[]>(
    {
      url: `/Channels/Features`, method: 'get', signal
    },
  );
}


export const getGetAllChannelFeaturesQueryKey = () => [`/Channels/Features`];


export type GetAllChannelFeaturesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllChannelFeatures>>>
export type GetAllChannelFeaturesQueryError = ErrorType<void>

export const useGetAllChannelFeatures = <TData = Awaited<ReturnType<typeof getAllChannelFeatures>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAllChannelFeatures>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllChannelFeaturesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllChannelFeatures>>> = ({ signal }) => getAllChannelFeatures(signal);




  const query = useQuery<Awaited<ReturnType<typeof getAllChannelFeatures>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets latest channel items.
 */
export const getLatestChannelItems = (
  params?: GetLatestChannelItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Channels/Items/Latest`, method: 'get',
      params, signal
    },
  );
}


export const getGetLatestChannelItemsQueryKey = (params?: GetLatestChannelItemsParams,) => [`/Channels/Items/Latest`, ...(params ? [params] : [])];


export type GetLatestChannelItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getLatestChannelItems>>>
export type GetLatestChannelItemsQueryError = ErrorType<void>

export const useGetLatestChannelItems = <TData = Awaited<ReturnType<typeof getLatestChannelItems>>, TError = ErrorType<void>>(
  params?: GetLatestChannelItemsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLatestChannelItems>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLatestChannelItemsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLatestChannelItems>>> = ({ signal }) => getLatestChannelItems(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLatestChannelItems>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Upload a document.
 */
export const logFile = (
  logFileBody: Blob,
) => {
  return apiInstance<ClientLogDocumentResponseDto>(
    {
      url: `/ClientLog/Document`, method: 'post',
      headers: { 'Content-Type': 'text/plain', },
      data: logFileBody
    },
  );
}



export type LogFileMutationResult = NonNullable<Awaited<ReturnType<typeof logFile>>>
export type LogFileMutationBody = Blob
export type LogFileMutationError = ErrorType<void | ProblemDetails>

export const useLogFile = <TError = ErrorType<void | ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof logFile>>, TError, { data: Blob }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof logFile>>, { data: Blob }> = (props) => {
    const { data } = props ?? {};

    return logFile(data,)
  }



  return useMutation<Awaited<ReturnType<typeof logFile>>, TError, { data: Blob }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Creates a new collection.
 */
export const createCollection = (
  params?: CreateCollectionParams,
) => {
  return apiInstance<CollectionCreationResult>(
    {
      url: `/Collections`, method: 'post',
      params
    },
  );
}



export type CreateCollectionMutationResult = NonNullable<Awaited<ReturnType<typeof createCollection>>>

export type CreateCollectionMutationError = ErrorType<void>

export const useCreateCollection = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof createCollection>>, TError, { params?: CreateCollectionParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCollection>>, { params?: CreateCollectionParams }> = (props) => {
    const { params } = props ?? {};

    return createCollection(params,)
  }



  return useMutation<Awaited<ReturnType<typeof createCollection>>, TError, { params?: CreateCollectionParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Adds items to a collection.
 */
export const addToCollection = (
  collectionId: string,
  params: AddToCollectionParams,
) => {
  return apiInstance<void>(
    {
      url: `/Collections/${collectionId}/Items`, method: 'post',
      params
    },
  );
}



export type AddToCollectionMutationResult = NonNullable<Awaited<ReturnType<typeof addToCollection>>>

export type AddToCollectionMutationError = ErrorType<unknown>

export const useAddToCollection = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof addToCollection>>, TError, { collectionId: string; params: AddToCollectionParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToCollection>>, { collectionId: string; params: AddToCollectionParams }> = (props) => {
    const { collectionId, params } = props ?? {};

    return addToCollection(collectionId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof addToCollection>>, TError, { collectionId: string; params: AddToCollectionParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Removes items from a collection.
 */
export const removeFromCollection = (
  collectionId: string,
  params: RemoveFromCollectionParams,
) => {
  return apiInstance<void>(
    {
      url: `/Collections/${collectionId}/Items`, method: 'delete',
      params
    },
  );
}



export type RemoveFromCollectionMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromCollection>>>

export type RemoveFromCollectionMutationError = ErrorType<unknown>

export const useRemoveFromCollection = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeFromCollection>>, TError, { collectionId: string; params: RemoveFromCollectionParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromCollection>>, { collectionId: string; params: RemoveFromCollectionParams }> = (props) => {
    const { collectionId, params } = props ?? {};

    return removeFromCollection(collectionId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof removeFromCollection>>, TError, { collectionId: string; params: RemoveFromCollectionParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets application configuration.
 */
export const getConfiguration = (

  signal?: AbortSignal
) => {
  return apiInstance<ServerConfiguration>(
    {
      url: `/System/Configuration`, method: 'get', signal
    },
  );
}


export const getGetConfigurationQueryKey = () => [`/System/Configuration`];


export type GetConfigurationQueryResult = NonNullable<Awaited<ReturnType<typeof getConfiguration>>>
export type GetConfigurationQueryError = ErrorType<void>

export const useGetConfiguration = <TData = Awaited<ReturnType<typeof getConfiguration>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getConfiguration>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConfigurationQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfiguration>>> = ({ signal }) => getConfiguration(signal);




  const query = useQuery<Awaited<ReturnType<typeof getConfiguration>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Updates application configuration.
 */
export const updateConfiguration = (
  serverConfiguration: ServerConfiguration,
) => {
  return apiInstance<void>(
    {
      url: `/System/Configuration`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: serverConfiguration
    },
  );
}



export type UpdateConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof updateConfiguration>>>
export type UpdateConfigurationMutationBody = ServerConfiguration
export type UpdateConfigurationMutationError = ErrorType<unknown>

export const useUpdateConfiguration = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateConfiguration>>, TError, { data: ServerConfiguration }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConfiguration>>, { data: ServerConfiguration }> = (props) => {
    const { data } = props ?? {};

    return updateConfiguration(data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateConfiguration>>, TError, { data: ServerConfiguration }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a named configuration.
 */
export const getNamedConfiguration = (
  key: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/System/Configuration/${key}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetNamedConfigurationQueryKey = (key: string,) => [`/System/Configuration/${key}`];


export type GetNamedConfigurationQueryResult = NonNullable<Awaited<ReturnType<typeof getNamedConfiguration>>>
export type GetNamedConfigurationQueryError = ErrorType<void>

export const useGetNamedConfiguration = <TData = Awaited<ReturnType<typeof getNamedConfiguration>>, TError = ErrorType<void>>(
  key: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNamedConfiguration>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNamedConfigurationQueryKey(key);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNamedConfiguration>>> = ({ signal }) => getNamedConfiguration(key, signal);




  const query = useQuery<Awaited<ReturnType<typeof getNamedConfiguration>>, TError, TData>(queryKey, queryFn, { enabled: !!(key), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Updates named configuration.
 */
export const updateNamedConfiguration = (
  key: string,
  updateNamedConfigurationBody: unknown,
) => {
  return apiInstance<void>(
    {
      url: `/System/Configuration/${key}`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: updateNamedConfigurationBody
    },
  );
}



export type UpdateNamedConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof updateNamedConfiguration>>>
export type UpdateNamedConfigurationMutationBody = unknown
export type UpdateNamedConfigurationMutationError = ErrorType<unknown>

export const useUpdateNamedConfiguration = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateNamedConfiguration>>, TError, { key: string; data: unknown }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNamedConfiguration>>, { key: string; data: unknown }> = (props) => {
    const { key, data } = props ?? {};

    return updateNamedConfiguration(key, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateNamedConfiguration>>, TError, { key: string; data: unknown }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a default MetadataOptions object.
 */
export const getDefaultMetadataOptions = (

  signal?: AbortSignal
) => {
  return apiInstance<MetadataOptions>(
    {
      url: `/System/Configuration/MetadataOptions/Default`, method: 'get', signal
    },
  );
}


export const getGetDefaultMetadataOptionsQueryKey = () => [`/System/Configuration/MetadataOptions/Default`];


export type GetDefaultMetadataOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof getDefaultMetadataOptions>>>
export type GetDefaultMetadataOptionsQueryError = ErrorType<void>

export const useGetDefaultMetadataOptions = <TData = Awaited<ReturnType<typeof getDefaultMetadataOptions>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDefaultMetadataOptions>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultMetadataOptionsQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultMetadataOptions>>> = ({ signal }) => getDefaultMetadataOptions(signal);




  const query = useQuery<Awaited<ReturnType<typeof getDefaultMetadataOptions>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Updates the path to the media encoder.
 */
export const updateMediaEncoderPath = (
  mediaEncoderPathDto: MediaEncoderPathDto,
) => {
  return apiInstance<void>(
    {
      url: `/System/MediaEncoder/Path`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: mediaEncoderPathDto
    },
  );
}



export type UpdateMediaEncoderPathMutationResult = NonNullable<Awaited<ReturnType<typeof updateMediaEncoderPath>>>
export type UpdateMediaEncoderPathMutationBody = MediaEncoderPathDto
export type UpdateMediaEncoderPathMutationError = ErrorType<unknown>

export const useUpdateMediaEncoderPath = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateMediaEncoderPath>>, TError, { data: MediaEncoderPathDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMediaEncoderPath>>, { data: MediaEncoderPathDto }> = (props) => {
    const { data } = props ?? {};

    return updateMediaEncoderPath(data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateMediaEncoderPath>>, TError, { data: MediaEncoderPathDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a dashboard configuration page.
 */
export const getDashboardConfigurationPage = (
  params?: GetDashboardConfigurationPageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/web/ConfigurationPage`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetDashboardConfigurationPageQueryKey = (params?: GetDashboardConfigurationPageParams,) => [`/web/ConfigurationPage`, ...(params ? [params] : [])];


export type GetDashboardConfigurationPageQueryResult = NonNullable<Awaited<ReturnType<typeof getDashboardConfigurationPage>>>
export type GetDashboardConfigurationPageQueryError = ErrorType<ProblemDetails>

export const useGetDashboardConfigurationPage = <TData = Awaited<ReturnType<typeof getDashboardConfigurationPage>>, TError = ErrorType<ProblemDetails>>(
  params?: GetDashboardConfigurationPageParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDashboardConfigurationPage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDashboardConfigurationPageQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDashboardConfigurationPage>>> = ({ signal }) => getDashboardConfigurationPage(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDashboardConfigurationPage>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the configuration pages.
 */
export const getConfigurationPages = (
  params?: GetConfigurationPagesParams,
  signal?: AbortSignal
) => {
  return apiInstance<ConfigurationPageInfo[]>(
    {
      url: `/web/ConfigurationPages`, method: 'get',
      params, signal
    },
  );
}


export const getGetConfigurationPagesQueryKey = (params?: GetConfigurationPagesParams,) => [`/web/ConfigurationPages`, ...(params ? [params] : [])];


export type GetConfigurationPagesQueryResult = NonNullable<Awaited<ReturnType<typeof getConfigurationPages>>>
export type GetConfigurationPagesQueryError = ErrorType<void | ProblemDetails>

export const useGetConfigurationPages = <TData = Awaited<ReturnType<typeof getConfigurationPages>>, TError = ErrorType<void | ProblemDetails>>(
  params?: GetConfigurationPagesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getConfigurationPages>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConfigurationPagesQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfigurationPages>>> = ({ signal }) => getConfigurationPages(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getConfigurationPages>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get Devices.
 */
export const getDevices = (
  params?: GetDevicesParams,
  signal?: AbortSignal
) => {
  return apiInstance<DeviceInfoQueryResult>(
    {
      url: `/Devices`, method: 'get',
      params, signal
    },
  );
}


export const getGetDevicesQueryKey = (params?: GetDevicesParams,) => [`/Devices`, ...(params ? [params] : [])];


export type GetDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof getDevices>>>
export type GetDevicesQueryError = ErrorType<void>

export const useGetDevices = <TData = Awaited<ReturnType<typeof getDevices>>, TError = ErrorType<void>>(
  params?: GetDevicesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDevices>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDevicesQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDevices>>> = ({ signal }) => getDevices(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDevices>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Deletes a device.
 */
export const deleteDevice = (
  params: DeleteDeviceParams,
) => {
  return apiInstance<void>(
    {
      url: `/Devices`, method: 'delete',
      params
    },
  );
}



export type DeleteDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDevice>>>

export type DeleteDeviceMutationError = ErrorType<ProblemDetails>

export const useDeleteDevice = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteDevice>>, TError, { params: DeleteDeviceParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDevice>>, { params: DeleteDeviceParams }> = (props) => {
    const { params } = props ?? {};

    return deleteDevice(params,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteDevice>>, TError, { params: DeleteDeviceParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get info for a device.
 */
export const getDeviceInfo = (
  params: GetDeviceInfoParams,
  signal?: AbortSignal
) => {
  return apiInstance<DeviceInfo>(
    {
      url: `/Devices/Info`, method: 'get',
      params, signal
    },
  );
}


export const getGetDeviceInfoQueryKey = (params: GetDeviceInfoParams,) => [`/Devices/Info`, ...(params ? [params] : [])];


export type GetDeviceInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getDeviceInfo>>>
export type GetDeviceInfoQueryError = ErrorType<void | ProblemDetails>

export const useGetDeviceInfo = <TData = Awaited<ReturnType<typeof getDeviceInfo>>, TError = ErrorType<void | ProblemDetails>>(
  params: GetDeviceInfoParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDeviceInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDeviceInfoQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeviceInfo>>> = ({ signal }) => getDeviceInfo(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDeviceInfo>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get options for a device.
 */
export const getDeviceOptions = (
  params: GetDeviceOptionsParams,
  signal?: AbortSignal
) => {
  return apiInstance<DeviceOptions>(
    {
      url: `/Devices/Options`, method: 'get',
      params, signal
    },
  );
}


export const getGetDeviceOptionsQueryKey = (params: GetDeviceOptionsParams,) => [`/Devices/Options`, ...(params ? [params] : [])];


export type GetDeviceOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof getDeviceOptions>>>
export type GetDeviceOptionsQueryError = ErrorType<void | ProblemDetails>

export const useGetDeviceOptions = <TData = Awaited<ReturnType<typeof getDeviceOptions>>, TError = ErrorType<void | ProblemDetails>>(
  params: GetDeviceOptionsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDeviceOptions>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDeviceOptionsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeviceOptions>>> = ({ signal }) => getDeviceOptions(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDeviceOptions>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Update device options.
 */
export const updateDeviceOptions = (
  deviceOptionsDto: DeviceOptionsDto,
  params: UpdateDeviceOptionsParams,
) => {
  return apiInstance<void>(
    {
      url: `/Devices/Options`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: deviceOptionsDto,
      params
    },
  );
}



export type UpdateDeviceOptionsMutationResult = NonNullable<Awaited<ReturnType<typeof updateDeviceOptions>>>
export type UpdateDeviceOptionsMutationBody = DeviceOptionsDto
export type UpdateDeviceOptionsMutationError = ErrorType<unknown>

export const useUpdateDeviceOptions = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateDeviceOptions>>, TError, { data: DeviceOptionsDto; params: UpdateDeviceOptionsParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDeviceOptions>>, { data: DeviceOptionsDto; params: UpdateDeviceOptionsParams }> = (props) => {
    const { data, params } = props ?? {};

    return updateDeviceOptions(data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof updateDeviceOptions>>, TError, { data: DeviceOptionsDto; params: UpdateDeviceOptionsParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get Display Preferences.
 */
export const getDisplayPreferences = (
  displayPreferencesId: string,
  params: GetDisplayPreferencesParams,
  signal?: AbortSignal
) => {
  return apiInstance<DisplayPreferencesDto>(
    {
      url: `/DisplayPreferences/${displayPreferencesId}`, method: 'get',
      params, signal
    },
  );
}


export const getGetDisplayPreferencesQueryKey = (displayPreferencesId: string,
  params: GetDisplayPreferencesParams,) => [`/DisplayPreferences/${displayPreferencesId}`, ...(params ? [params] : [])];


export type GetDisplayPreferencesQueryResult = NonNullable<Awaited<ReturnType<typeof getDisplayPreferences>>>
export type GetDisplayPreferencesQueryError = ErrorType<void>

export const useGetDisplayPreferences = <TData = Awaited<ReturnType<typeof getDisplayPreferences>>, TError = ErrorType<void>>(
  displayPreferencesId: string,
  params: GetDisplayPreferencesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDisplayPreferences>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDisplayPreferencesQueryKey(displayPreferencesId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDisplayPreferences>>> = ({ signal }) => getDisplayPreferences(displayPreferencesId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDisplayPreferences>>, TError, TData>(queryKey, queryFn, { enabled: !!(displayPreferencesId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Update Display Preferences.
 */
export const updateDisplayPreferences = (
  displayPreferencesId: string,
  displayPreferencesDto: DisplayPreferencesDto,
  params: UpdateDisplayPreferencesParams,
) => {
  return apiInstance<void>(
    {
      url: `/DisplayPreferences/${displayPreferencesId}`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: displayPreferencesDto,
      params
    },
  );
}



export type UpdateDisplayPreferencesMutationResult = NonNullable<Awaited<ReturnType<typeof updateDisplayPreferences>>>
export type UpdateDisplayPreferencesMutationBody = DisplayPreferencesDto
export type UpdateDisplayPreferencesMutationError = ErrorType<unknown>

export const useUpdateDisplayPreferences = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateDisplayPreferences>>, TError, { displayPreferencesId: string; data: DisplayPreferencesDto; params: UpdateDisplayPreferencesParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDisplayPreferences>>, { displayPreferencesId: string; data: DisplayPreferencesDto; params: UpdateDisplayPreferencesParams }> = (props) => {
    const { displayPreferencesId, data, params } = props ?? {};

    return updateDisplayPreferences(displayPreferencesId, data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof updateDisplayPreferences>>, TError, { displayPreferencesId: string; data: DisplayPreferencesDto; params: UpdateDisplayPreferencesParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get profile infos.
 */
export const getProfileInfos = (

  signal?: AbortSignal
) => {
  return apiInstance<DeviceProfileInfo[]>(
    {
      url: `/Dlna/ProfileInfos`, method: 'get', signal
    },
  );
}


export const getGetProfileInfosQueryKey = () => [`/Dlna/ProfileInfos`];


export type GetProfileInfosQueryResult = NonNullable<Awaited<ReturnType<typeof getProfileInfos>>>
export type GetProfileInfosQueryError = ErrorType<void>

export const useGetProfileInfos = <TData = Awaited<ReturnType<typeof getProfileInfos>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getProfileInfos>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProfileInfosQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfileInfos>>> = ({ signal }) => getProfileInfos(signal);




  const query = useQuery<Awaited<ReturnType<typeof getProfileInfos>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates a profile.
 */
export const createProfile = (
  deviceProfile: DeviceProfile,
) => {
  return apiInstance<void>(
    {
      url: `/Dlna/Profiles`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: deviceProfile
    },
  );
}



export type CreateProfileMutationResult = NonNullable<Awaited<ReturnType<typeof createProfile>>>
export type CreateProfileMutationBody = DeviceProfile
export type CreateProfileMutationError = ErrorType<unknown>

export const useCreateProfile = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof createProfile>>, TError, { data: DeviceProfile }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProfile>>, { data: DeviceProfile }> = (props) => {
    const { data } = props ?? {};

    return createProfile(data,)
  }



  return useMutation<Awaited<ReturnType<typeof createProfile>>, TError, { data: DeviceProfile }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a single profile.
 */
export const getProfile = (
  profileId: string,
  signal?: AbortSignal
) => {
  return apiInstance<DeviceProfile>(
    {
      url: `/Dlna/Profiles/${profileId}`, method: 'get', signal
    },
  );
}


export const getGetProfileQueryKey = (profileId: string,) => [`/Dlna/Profiles/${profileId}`];


export type GetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getProfile>>>
export type GetProfileQueryError = ErrorType<void | ProblemDetails>

export const useGetProfile = <TData = Awaited<ReturnType<typeof getProfile>>, TError = ErrorType<void | ProblemDetails>>(
  profileId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProfileQueryKey(profileId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({ signal }) => getProfile(profileId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getProfile>>, TError, TData>(queryKey, queryFn, { enabled: !!(profileId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Deletes a profile.
 */
export const deleteProfile = (
  profileId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Dlna/Profiles/${profileId}`, method: 'delete'
    },
  );
}



export type DeleteProfileMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProfile>>>

export type DeleteProfileMutationError = ErrorType<ProblemDetails>

export const useDeleteProfile = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteProfile>>, TError, { profileId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProfile>>, { profileId: string }> = (props) => {
    const { profileId } = props ?? {};

    return deleteProfile(profileId,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteProfile>>, TError, { profileId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a profile.
 */
export const updateProfile = (
  profileId: string,
  deviceProfile: DeviceProfile,
) => {
  return apiInstance<void>(
    {
      url: `/Dlna/Profiles/${profileId}`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: deviceProfile
    },
  );
}



export type UpdateProfileMutationResult = NonNullable<Awaited<ReturnType<typeof updateProfile>>>
export type UpdateProfileMutationBody = DeviceProfile
export type UpdateProfileMutationError = ErrorType<ProblemDetails>

export const useUpdateProfile = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateProfile>>, TError, { profileId: string; data: DeviceProfile }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProfile>>, { profileId: string; data: DeviceProfile }> = (props) => {
    const { profileId, data } = props ?? {};

    return updateProfile(profileId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateProfile>>, TError, { profileId: string; data: DeviceProfile }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the default profile.
 */
export const getDefaultProfile = (

  signal?: AbortSignal
) => {
  return apiInstance<DeviceProfile>(
    {
      url: `/Dlna/Profiles/Default`, method: 'get', signal
    },
  );
}


export const getGetDefaultProfileQueryKey = () => [`/Dlna/Profiles/Default`];


export type GetDefaultProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getDefaultProfile>>>
export type GetDefaultProfileQueryError = ErrorType<void>

export const useGetDefaultProfile = <TData = Awaited<ReturnType<typeof getDefaultProfile>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDefaultProfile>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultProfileQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultProfile>>> = ({ signal }) => getDefaultProfile(signal);




  const query = useQuery<Awaited<ReturnType<typeof getDefaultProfile>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getConnectionManager = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/ConnectionManager`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetConnectionManagerQueryKey = (serverId: string,) => [`/Dlna/${serverId}/ConnectionManager`];


export type GetConnectionManagerQueryResult = NonNullable<Awaited<ReturnType<typeof getConnectionManager>>>
export type GetConnectionManagerQueryError = ErrorType<void>

export const useGetConnectionManager = <TData = Awaited<ReturnType<typeof getConnectionManager>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getConnectionManager>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConnectionManagerQueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConnectionManager>>> = ({ signal }) => getConnectionManager(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getConnectionManager>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getConnectionManager2 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/ConnectionManager/ConnectionManager`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetConnectionManager2QueryKey = (serverId: string,) => [`/Dlna/${serverId}/ConnectionManager/ConnectionManager`];


export type GetConnectionManager2QueryResult = NonNullable<Awaited<ReturnType<typeof getConnectionManager2>>>
export type GetConnectionManager2QueryError = ErrorType<void>

export const useGetConnectionManager2 = <TData = Awaited<ReturnType<typeof getConnectionManager2>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getConnectionManager2>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConnectionManager2QueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConnectionManager2>>> = ({ signal }) => getConnectionManager2(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getConnectionManager2>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getConnectionManager3 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/ConnectionManager/ConnectionManager.xml`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetConnectionManager3QueryKey = (serverId: string,) => [`/Dlna/${serverId}/ConnectionManager/ConnectionManager.xml`];


export type GetConnectionManager3QueryResult = NonNullable<Awaited<ReturnType<typeof getConnectionManager3>>>
export type GetConnectionManager3QueryError = ErrorType<void>

export const useGetConnectionManager3 = <TData = Awaited<ReturnType<typeof getConnectionManager3>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getConnectionManager3>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConnectionManager3QueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConnectionManager3>>> = ({ signal }) => getConnectionManager3(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getConnectionManager3>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Process a connection manager control request.
 */
export const processConnectionManagerControlRequest = (
  serverId: string,
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/ConnectionManager/Control`, method: 'post',
      responseType: 'blob'
    },
  );
}



export type ProcessConnectionManagerControlRequestMutationResult = NonNullable<Awaited<ReturnType<typeof processConnectionManagerControlRequest>>>

export type ProcessConnectionManagerControlRequestMutationError = ErrorType<void>

export const useProcessConnectionManagerControlRequest = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof processConnectionManagerControlRequest>>, TError, { serverId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof processConnectionManagerControlRequest>>, { serverId: string }> = (props) => {
    const { serverId } = props ?? {};

    return processConnectionManagerControlRequest(serverId,)
  }



  return useMutation<Awaited<ReturnType<typeof processConnectionManagerControlRequest>>, TError, { serverId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets Dlna content directory xml.
 */
export const getContentDirectory = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/ContentDirectory`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetContentDirectoryQueryKey = (serverId: string,) => [`/Dlna/${serverId}/ContentDirectory`];


export type GetContentDirectoryQueryResult = NonNullable<Awaited<ReturnType<typeof getContentDirectory>>>
export type GetContentDirectoryQueryError = ErrorType<void>

export const useGetContentDirectory = <TData = Awaited<ReturnType<typeof getContentDirectory>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getContentDirectory>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetContentDirectoryQueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getContentDirectory>>> = ({ signal }) => getContentDirectory(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getContentDirectory>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets Dlna content directory xml.
 */
export const getContentDirectory2 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/ContentDirectory/ContentDirectory`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetContentDirectory2QueryKey = (serverId: string,) => [`/Dlna/${serverId}/ContentDirectory/ContentDirectory`];


export type GetContentDirectory2QueryResult = NonNullable<Awaited<ReturnType<typeof getContentDirectory2>>>
export type GetContentDirectory2QueryError = ErrorType<void>

export const useGetContentDirectory2 = <TData = Awaited<ReturnType<typeof getContentDirectory2>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getContentDirectory2>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetContentDirectory2QueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getContentDirectory2>>> = ({ signal }) => getContentDirectory2(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getContentDirectory2>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets Dlna content directory xml.
 */
export const getContentDirectory3 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/ContentDirectory/ContentDirectory.xml`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetContentDirectory3QueryKey = (serverId: string,) => [`/Dlna/${serverId}/ContentDirectory/ContentDirectory.xml`];


export type GetContentDirectory3QueryResult = NonNullable<Awaited<ReturnType<typeof getContentDirectory3>>>
export type GetContentDirectory3QueryError = ErrorType<void>

export const useGetContentDirectory3 = <TData = Awaited<ReturnType<typeof getContentDirectory3>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getContentDirectory3>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetContentDirectory3QueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getContentDirectory3>>> = ({ signal }) => getContentDirectory3(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getContentDirectory3>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Process a content directory control request.
 */
export const processContentDirectoryControlRequest = (
  serverId: string,
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/ContentDirectory/Control`, method: 'post',
      responseType: 'blob'
    },
  );
}



export type ProcessContentDirectoryControlRequestMutationResult = NonNullable<Awaited<ReturnType<typeof processContentDirectoryControlRequest>>>

export type ProcessContentDirectoryControlRequestMutationError = ErrorType<void>

export const useProcessContentDirectoryControlRequest = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof processContentDirectoryControlRequest>>, TError, { serverId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof processContentDirectoryControlRequest>>, { serverId: string }> = (props) => {
    const { serverId } = props ?? {};

    return processContentDirectoryControlRequest(serverId,)
  }



  return useMutation<Awaited<ReturnType<typeof processContentDirectoryControlRequest>>, TError, { serverId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get Description Xml.
 */
export const getDescriptionXml = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/description`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetDescriptionXmlQueryKey = (serverId: string,) => [`/Dlna/${serverId}/description`];


export type GetDescriptionXmlQueryResult = NonNullable<Awaited<ReturnType<typeof getDescriptionXml>>>
export type GetDescriptionXmlQueryError = ErrorType<void>

export const useGetDescriptionXml = <TData = Awaited<ReturnType<typeof getDescriptionXml>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDescriptionXml>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDescriptionXmlQueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDescriptionXml>>> = ({ signal }) => getDescriptionXml(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDescriptionXml>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get Description Xml.
 */
export const getDescriptionXml2 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/description.xml`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetDescriptionXml2QueryKey = (serverId: string,) => [`/Dlna/${serverId}/description.xml`];


export type GetDescriptionXml2QueryResult = NonNullable<Awaited<ReturnType<typeof getDescriptionXml2>>>
export type GetDescriptionXml2QueryError = ErrorType<void>

export const useGetDescriptionXml2 = <TData = Awaited<ReturnType<typeof getDescriptionXml2>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDescriptionXml2>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDescriptionXml2QueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDescriptionXml2>>> = ({ signal }) => getDescriptionXml2(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDescriptionXml2>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a server icon.
 */
export const getIconId = (
  serverId: string,
  fileName: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/icons/${fileName}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetIconIdQueryKey = (serverId: string,
  fileName: string,) => [`/Dlna/${serverId}/icons/${fileName}`];


export type GetIconIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIconId>>>
export type GetIconIdQueryError = ErrorType<void | ProblemDetails>

export const useGetIconId = <TData = Awaited<ReturnType<typeof getIconId>>, TError = ErrorType<void | ProblemDetails>>(
  serverId: string,
  fileName: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getIconId>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIconIdQueryKey(serverId, fileName);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIconId>>> = ({ signal }) => getIconId(serverId, fileName, signal);




  const query = useQuery<Awaited<ReturnType<typeof getIconId>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId && fileName), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getMediaReceiverRegistrar = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/MediaReceiverRegistrar`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetMediaReceiverRegistrarQueryKey = (serverId: string,) => [`/Dlna/${serverId}/MediaReceiverRegistrar`];


export type GetMediaReceiverRegistrarQueryResult = NonNullable<Awaited<ReturnType<typeof getMediaReceiverRegistrar>>>
export type GetMediaReceiverRegistrarQueryError = ErrorType<void>

export const useGetMediaReceiverRegistrar = <TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMediaReceiverRegistrar>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaReceiverRegistrarQueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMediaReceiverRegistrar>>> = ({ signal }) => getMediaReceiverRegistrar(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMediaReceiverRegistrar>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Process a media receiver registrar control request.
 */
export const processMediaReceiverRegistrarControlRequest = (
  serverId: string,
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/MediaReceiverRegistrar/Control`, method: 'post',
      responseType: 'blob'
    },
  );
}



export type ProcessMediaReceiverRegistrarControlRequestMutationResult = NonNullable<Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>>

export type ProcessMediaReceiverRegistrarControlRequestMutationError = ErrorType<void>

export const useProcessMediaReceiverRegistrarControlRequest = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>, TError, { serverId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>, { serverId: string }> = (props) => {
    const { serverId } = props ?? {};

    return processMediaReceiverRegistrarControlRequest(serverId,)
  }



  return useMutation<Awaited<ReturnType<typeof processMediaReceiverRegistrarControlRequest>>, TError, { serverId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getMediaReceiverRegistrar2 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetMediaReceiverRegistrar2QueryKey = (serverId: string,) => [`/Dlna/${serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar`];


export type GetMediaReceiverRegistrar2QueryResult = NonNullable<Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>>
export type GetMediaReceiverRegistrar2QueryError = ErrorType<void>

export const useGetMediaReceiverRegistrar2 = <TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaReceiverRegistrar2QueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>> = ({ signal }) => getMediaReceiverRegistrar2(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMediaReceiverRegistrar2>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets Dlna media receiver registrar xml.
 */
export const getMediaReceiverRegistrar3 = (
  serverId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/${serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar.xml`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetMediaReceiverRegistrar3QueryKey = (serverId: string,) => [`/Dlna/${serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar.xml`];


export type GetMediaReceiverRegistrar3QueryResult = NonNullable<Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>>
export type GetMediaReceiverRegistrar3QueryError = ErrorType<void>

export const useGetMediaReceiverRegistrar3 = <TData = Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>, TError = ErrorType<void>>(
  serverId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaReceiverRegistrar3QueryKey(serverId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>> = ({ signal }) => getMediaReceiverRegistrar3(serverId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMediaReceiverRegistrar3>>, TError, TData>(queryKey, queryFn, { enabled: !!(serverId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a server icon.
 */
export const getIcon = (
  fileName: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Dlna/icons/${fileName}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetIconQueryKey = (fileName: string,) => [`/Dlna/icons/${fileName}`];


export type GetIconQueryResult = NonNullable<Awaited<ReturnType<typeof getIcon>>>
export type GetIconQueryError = ErrorType<void | ProblemDetails>

export const useGetIcon = <TData = Awaited<ReturnType<typeof getIcon>>, TError = ErrorType<void | ProblemDetails>>(
  fileName: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getIcon>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIconQueryKey(fileName);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIcon>>> = ({ signal }) => getIcon(fileName, signal);




  const query = useQuery<Awaited<ReturnType<typeof getIcon>>, TError, TData>(queryKey, queryFn, { enabled: !!(fileName), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a video stream using HTTP live streaming.
 */
export const getHlsAudioSegment = (
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/hls1/${playlistId}/${segmentId}.${container}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetHlsAudioSegmentQueryKey = (itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams,) => [`/Audio/${itemId}/hls1/${playlistId}/${segmentId}.${container}`, ...(params ? [params] : [])];


export type GetHlsAudioSegmentQueryResult = NonNullable<Awaited<ReturnType<typeof getHlsAudioSegment>>>
export type GetHlsAudioSegmentQueryError = ErrorType<void>

export const useGetHlsAudioSegment = <TData = Awaited<ReturnType<typeof getHlsAudioSegment>>, TError = ErrorType<void>>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsAudioSegmentParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getHlsAudioSegment>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHlsAudioSegmentQueryKey(itemId, playlistId, segmentId, container, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHlsAudioSegment>>> = ({ signal }) => getHlsAudioSegment(itemId, playlistId, segmentId, container, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getHlsAudioSegment>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && playlistId && segmentId && container), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an audio stream using HTTP live streaming.
 */
export const getVariantHlsAudioPlaylist = (
  itemId: string,
  params?: GetVariantHlsAudioPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/main.m3u8`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetVariantHlsAudioPlaylistQueryKey = (itemId: string,
  params?: GetVariantHlsAudioPlaylistParams,) => [`/Audio/${itemId}/main.m3u8`, ...(params ? [params] : [])];


export type GetVariantHlsAudioPlaylistQueryResult = NonNullable<Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>>
export type GetVariantHlsAudioPlaylistQueryError = ErrorType<void>

export const useGetVariantHlsAudioPlaylist = <TData = Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetVariantHlsAudioPlaylistParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVariantHlsAudioPlaylistQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>> = ({ signal }) => getVariantHlsAudioPlaylist(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getVariantHlsAudioPlaylist>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an audio hls playlist stream.
 */
export const getMasterHlsAudioPlaylist = (
  itemId: string,
  params: GetMasterHlsAudioPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/master.m3u8`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetMasterHlsAudioPlaylistQueryKey = (itemId: string,
  params: GetMasterHlsAudioPlaylistParams,) => [`/Audio/${itemId}/master.m3u8`, ...(params ? [params] : [])];


export type GetMasterHlsAudioPlaylistQueryResult = NonNullable<Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>>
export type GetMasterHlsAudioPlaylistQueryError = ErrorType<void>

export const useGetMasterHlsAudioPlaylist = <TData = Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>, TError = ErrorType<void>>(
  itemId: string,
  params: GetMasterHlsAudioPlaylistParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMasterHlsAudioPlaylistQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>> = ({ signal }) => getMasterHlsAudioPlaylist(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMasterHlsAudioPlaylist>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an audio hls playlist stream.
 */
export const headMasterHlsAudioPlaylist = (
  itemId: string,
  params: HeadMasterHlsAudioPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/master.m3u8`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadMasterHlsAudioPlaylistMutationResult = NonNullable<Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>>

export type HeadMasterHlsAudioPlaylistMutationError = ErrorType<void>

export const useHeadMasterHlsAudioPlaylist = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>, TError, { itemId: string; params: HeadMasterHlsAudioPlaylistParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>, { itemId: string; params: HeadMasterHlsAudioPlaylistParams }> = (props) => {
    const { itemId, params } = props ?? {};

    return headMasterHlsAudioPlaylist(itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headMasterHlsAudioPlaylist>>, TError, { itemId: string; params: HeadMasterHlsAudioPlaylistParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a video stream using HTTP live streaming.
 */
export const getHlsVideoSegment = (
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/hls1/${playlistId}/${segmentId}.${container}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetHlsVideoSegmentQueryKey = (itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams,) => [`/Videos/${itemId}/hls1/${playlistId}/${segmentId}.${container}`, ...(params ? [params] : [])];


export type GetHlsVideoSegmentQueryResult = NonNullable<Awaited<ReturnType<typeof getHlsVideoSegment>>>
export type GetHlsVideoSegmentQueryError = ErrorType<void>

export const useGetHlsVideoSegment = <TData = Awaited<ReturnType<typeof getHlsVideoSegment>>, TError = ErrorType<void>>(
  itemId: string,
  playlistId: string,
  segmentId: number,
  container: string,
  params: GetHlsVideoSegmentParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getHlsVideoSegment>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHlsVideoSegmentQueryKey(itemId, playlistId, segmentId, container, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHlsVideoSegment>>> = ({ signal }) => getHlsVideoSegment(itemId, playlistId, segmentId, container, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getHlsVideoSegment>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && playlistId && segmentId && container), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a hls live stream.
 */
export const getLiveHlsStream = (
  itemId: string,
  params?: GetLiveHlsStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/live.m3u8`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetLiveHlsStreamQueryKey = (itemId: string,
  params?: GetLiveHlsStreamParams,) => [`/Videos/${itemId}/live.m3u8`, ...(params ? [params] : [])];


export type GetLiveHlsStreamQueryResult = NonNullable<Awaited<ReturnType<typeof getLiveHlsStream>>>
export type GetLiveHlsStreamQueryError = ErrorType<void>

export const useGetLiveHlsStream = <TData = Awaited<ReturnType<typeof getLiveHlsStream>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetLiveHlsStreamParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLiveHlsStream>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLiveHlsStreamQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLiveHlsStream>>> = ({ signal }) => getLiveHlsStream(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLiveHlsStream>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a video stream using HTTP live streaming.
 */
export const getVariantHlsVideoPlaylist = (
  itemId: string,
  params?: GetVariantHlsVideoPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/main.m3u8`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetVariantHlsVideoPlaylistQueryKey = (itemId: string,
  params?: GetVariantHlsVideoPlaylistParams,) => [`/Videos/${itemId}/main.m3u8`, ...(params ? [params] : [])];


export type GetVariantHlsVideoPlaylistQueryResult = NonNullable<Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>>
export type GetVariantHlsVideoPlaylistQueryError = ErrorType<void>

export const useGetVariantHlsVideoPlaylist = <TData = Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetVariantHlsVideoPlaylistParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVariantHlsVideoPlaylistQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>> = ({ signal }) => getVariantHlsVideoPlaylist(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getVariantHlsVideoPlaylist>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a video hls playlist stream.
 */
export const getMasterHlsVideoPlaylist = (
  itemId: string,
  params: GetMasterHlsVideoPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/master.m3u8`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetMasterHlsVideoPlaylistQueryKey = (itemId: string,
  params: GetMasterHlsVideoPlaylistParams,) => [`/Videos/${itemId}/master.m3u8`, ...(params ? [params] : [])];


export type GetMasterHlsVideoPlaylistQueryResult = NonNullable<Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>>
export type GetMasterHlsVideoPlaylistQueryError = ErrorType<void>

export const useGetMasterHlsVideoPlaylist = <TData = Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>, TError = ErrorType<void>>(
  itemId: string,
  params: GetMasterHlsVideoPlaylistParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMasterHlsVideoPlaylistQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>> = ({ signal }) => getMasterHlsVideoPlaylist(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMasterHlsVideoPlaylist>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a video hls playlist stream.
 */
export const headMasterHlsVideoPlaylist = (
  itemId: string,
  params: HeadMasterHlsVideoPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/master.m3u8`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadMasterHlsVideoPlaylistMutationResult = NonNullable<Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>>

export type HeadMasterHlsVideoPlaylistMutationError = ErrorType<void>

export const useHeadMasterHlsVideoPlaylist = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>, TError, { itemId: string; params: HeadMasterHlsVideoPlaylistParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>, { itemId: string; params: HeadMasterHlsVideoPlaylistParams }> = (props) => {
    const { itemId, params } = props ?? {};

    return headMasterHlsVideoPlaylist(itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headMasterHlsVideoPlaylist>>, TError, { itemId: string; params: HeadMasterHlsVideoPlaylistParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get Default directory browser.
 */
export const getDefaultDirectoryBrowser = (

  signal?: AbortSignal
) => {
  return apiInstance<DefaultDirectoryBrowserInfoDto>(
    {
      url: `/Environment/DefaultDirectoryBrowser`, method: 'get', signal
    },
  );
}


export const getGetDefaultDirectoryBrowserQueryKey = () => [`/Environment/DefaultDirectoryBrowser`];


export type GetDefaultDirectoryBrowserQueryResult = NonNullable<Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>>
export type GetDefaultDirectoryBrowserQueryError = ErrorType<void>

export const useGetDefaultDirectoryBrowser = <TData = Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultDirectoryBrowserQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>> = ({ signal }) => getDefaultDirectoryBrowser(signal);




  const query = useQuery<Awaited<ReturnType<typeof getDefaultDirectoryBrowser>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the contents of a given directory in the file system.
 */
export const getDirectoryContents = (
  params: GetDirectoryContentsParams,
  signal?: AbortSignal
) => {
  return apiInstance<FileSystemEntryInfo[]>(
    {
      url: `/Environment/DirectoryContents`, method: 'get',
      params, signal
    },
  );
}


export const getGetDirectoryContentsQueryKey = (params: GetDirectoryContentsParams,) => [`/Environment/DirectoryContents`, ...(params ? [params] : [])];


export type GetDirectoryContentsQueryResult = NonNullable<Awaited<ReturnType<typeof getDirectoryContents>>>
export type GetDirectoryContentsQueryError = ErrorType<void>

export const useGetDirectoryContents = <TData = Awaited<ReturnType<typeof getDirectoryContents>>, TError = ErrorType<void>>(
  params: GetDirectoryContentsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDirectoryContents>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDirectoryContentsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDirectoryContents>>> = ({ signal }) => getDirectoryContents(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDirectoryContents>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets available drives from the server's file system.
 */
export const getDrives = (

  signal?: AbortSignal
) => {
  return apiInstance<FileSystemEntryInfo[]>(
    {
      url: `/Environment/Drives`, method: 'get', signal
    },
  );
}


export const getGetDrivesQueryKey = () => [`/Environment/Drives`];


export type GetDrivesQueryResult = NonNullable<Awaited<ReturnType<typeof getDrives>>>
export type GetDrivesQueryError = ErrorType<void>

export const useGetDrives = <TData = Awaited<ReturnType<typeof getDrives>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDrives>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDrivesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDrives>>> = ({ signal }) => getDrives(signal);




  const query = useQuery<Awaited<ReturnType<typeof getDrives>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @deprecated
 * @summary Gets network paths.
 */
export const getNetworkShares = (

  signal?: AbortSignal
) => {
  return apiInstance<FileSystemEntryInfo[]>(
    {
      url: `/Environment/NetworkShares`, method: 'get', signal
    },
  );
}


export const getGetNetworkSharesQueryKey = () => [`/Environment/NetworkShares`];


export type GetNetworkSharesQueryResult = NonNullable<Awaited<ReturnType<typeof getNetworkShares>>>
export type GetNetworkSharesQueryError = ErrorType<void>

export const useGetNetworkShares = <TData = Awaited<ReturnType<typeof getNetworkShares>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNetworkShares>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNetworkSharesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNetworkShares>>> = ({ signal }) => getNetworkShares(signal);




  const query = useQuery<Awaited<ReturnType<typeof getNetworkShares>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the parent path of a given path.
 */
export const getParentPath = (
  params: GetParentPathParams,
  signal?: AbortSignal
) => {
  return apiInstance<string>(
    {
      url: `/Environment/ParentPath`, method: 'get',
      params, signal
    },
  );
}


export const getGetParentPathQueryKey = (params: GetParentPathParams,) => [`/Environment/ParentPath`, ...(params ? [params] : [])];


export type GetParentPathQueryResult = NonNullable<Awaited<ReturnType<typeof getParentPath>>>
export type GetParentPathQueryError = ErrorType<void>

export const useGetParentPath = <TData = Awaited<ReturnType<typeof getParentPath>>, TError = ErrorType<void>>(
  params: GetParentPathParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getParentPath>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetParentPathQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getParentPath>>> = ({ signal }) => getParentPath(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getParentPath>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Validates path.
 */
export const validatePath = (
  validatePathDto: ValidatePathDto,
) => {
  return apiInstance<void>(
    {
      url: `/Environment/ValidatePath`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: validatePathDto
    },
  );
}



export type ValidatePathMutationResult = NonNullable<Awaited<ReturnType<typeof validatePath>>>
export type ValidatePathMutationBody = ValidatePathDto
export type ValidatePathMutationError = ErrorType<ProblemDetails>

export const useValidatePath = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof validatePath>>, TError, { data: ValidatePathDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof validatePath>>, { data: ValidatePathDto }> = (props) => {
    const { data } = props ?? {};

    return validatePath(data,)
  }



  return useMutation<Awaited<ReturnType<typeof validatePath>>, TError, { data: ValidatePathDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets legacy query filters.
 */
export const getQueryFiltersLegacy = (
  params?: GetQueryFiltersLegacyParams,
  signal?: AbortSignal
) => {
  return apiInstance<QueryFiltersLegacy>(
    {
      url: `/Items/Filters`, method: 'get',
      params, signal
    },
  );
}


export const getGetQueryFiltersLegacyQueryKey = (params?: GetQueryFiltersLegacyParams,) => [`/Items/Filters`, ...(params ? [params] : [])];


export type GetQueryFiltersLegacyQueryResult = NonNullable<Awaited<ReturnType<typeof getQueryFiltersLegacy>>>
export type GetQueryFiltersLegacyQueryError = ErrorType<void>

export const useGetQueryFiltersLegacy = <TData = Awaited<ReturnType<typeof getQueryFiltersLegacy>>, TError = ErrorType<void>>(
  params?: GetQueryFiltersLegacyParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getQueryFiltersLegacy>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryFiltersLegacyQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getQueryFiltersLegacy>>> = ({ signal }) => getQueryFiltersLegacy(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getQueryFiltersLegacy>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets query filters.
 */
export const getQueryFilters = (
  params?: GetQueryFiltersParams,
  signal?: AbortSignal
) => {
  return apiInstance<QueryFilters>(
    {
      url: `/Items/Filters2`, method: 'get',
      params, signal
    },
  );
}


export const getGetQueryFiltersQueryKey = (params?: GetQueryFiltersParams,) => [`/Items/Filters2`, ...(params ? [params] : [])];


export type GetQueryFiltersQueryResult = NonNullable<Awaited<ReturnType<typeof getQueryFilters>>>
export type GetQueryFiltersQueryError = ErrorType<void>

export const useGetQueryFilters = <TData = Awaited<ReturnType<typeof getQueryFilters>>, TError = ErrorType<void>>(
  params?: GetQueryFiltersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getQueryFilters>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryFiltersQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getQueryFilters>>> = ({ signal }) => getQueryFilters(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getQueryFilters>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets all genres from a given item, folder, or the entire library.
 */
export const getGenres = (
  params?: GetGenresParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Genres`, method: 'get',
      params, signal
    },
  );
}


export const getGetGenresQueryKey = (params?: GetGenresParams,) => [`/Genres`, ...(params ? [params] : [])];


export type GetGenresQueryResult = NonNullable<Awaited<ReturnType<typeof getGenres>>>
export type GetGenresQueryError = ErrorType<void>

export const useGetGenres = <TData = Awaited<ReturnType<typeof getGenres>>, TError = ErrorType<void>>(
  params?: GetGenresParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getGenres>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGenresQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenres>>> = ({ signal }) => getGenres(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getGenres>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a genre, by name.
 */
export const getGenre = (
  genreName: string,
  params?: GetGenreParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/Genres/${genreName}`, method: 'get',
      params, signal
    },
  );
}


export const getGetGenreQueryKey = (genreName: string,
  params?: GetGenreParams,) => [`/Genres/${genreName}`, ...(params ? [params] : [])];


export type GetGenreQueryResult = NonNullable<Awaited<ReturnType<typeof getGenre>>>
export type GetGenreQueryError = ErrorType<void>

export const useGetGenre = <TData = Awaited<ReturnType<typeof getGenre>>, TError = ErrorType<void>>(
  genreName: string,
  params?: GetGenreParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getGenre>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGenreQueryKey(genreName, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenre>>> = ({ signal }) => getGenre(genreName, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getGenre>>, TError, TData>(queryKey, queryFn, { enabled: !!(genreName), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the specified audio segment for an audio item.
 */
export const getHlsAudioSegmentLegacyAac = (
  itemId: string,
  segmentId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/hls/${segmentId}/stream.aac`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetHlsAudioSegmentLegacyAacQueryKey = (itemId: string,
  segmentId: string,) => [`/Audio/${itemId}/hls/${segmentId}/stream.aac`];


export type GetHlsAudioSegmentLegacyAacQueryResult = NonNullable<Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>>
export type GetHlsAudioSegmentLegacyAacQueryError = ErrorType<unknown>

export const useGetHlsAudioSegmentLegacyAac = <TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>, TError = ErrorType<unknown>>(
  itemId: string,
  segmentId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHlsAudioSegmentLegacyAacQueryKey(itemId, segmentId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>> = ({ signal }) => getHlsAudioSegmentLegacyAac(itemId, segmentId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getHlsAudioSegmentLegacyAac>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && segmentId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the specified audio segment for an audio item.
 */
export const getHlsAudioSegmentLegacyMp3 = (
  itemId: string,
  segmentId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/hls/${segmentId}/stream.mp3`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetHlsAudioSegmentLegacyMp3QueryKey = (itemId: string,
  segmentId: string,) => [`/Audio/${itemId}/hls/${segmentId}/stream.mp3`];


export type GetHlsAudioSegmentLegacyMp3QueryResult = NonNullable<Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>>
export type GetHlsAudioSegmentLegacyMp3QueryError = ErrorType<unknown>

export const useGetHlsAudioSegmentLegacyMp3 = <TData = Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>, TError = ErrorType<unknown>>(
  itemId: string,
  segmentId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHlsAudioSegmentLegacyMp3QueryKey(itemId, segmentId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>> = ({ signal }) => getHlsAudioSegmentLegacyMp3(itemId, segmentId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getHlsAudioSegmentLegacyMp3>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && segmentId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a hls video segment.
 */
export const getHlsVideoSegmentLegacy = (
  itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/hls/${playlistId}/${segmentId}.${segmentContainer}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetHlsVideoSegmentLegacyQueryKey = (itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string,) => [`/Videos/${itemId}/hls/${playlistId}/${segmentId}.${segmentContainer}`];


export type GetHlsVideoSegmentLegacyQueryResult = NonNullable<Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>>
export type GetHlsVideoSegmentLegacyQueryError = ErrorType<ProblemDetails>

export const useGetHlsVideoSegmentLegacy = <TData = Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>, TError = ErrorType<ProblemDetails>>(
  itemId: string,
  playlistId: string,
  segmentId: string,
  segmentContainer: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHlsVideoSegmentLegacyQueryKey(itemId, playlistId, segmentId, segmentContainer);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>> = ({ signal }) => getHlsVideoSegmentLegacy(itemId, playlistId, segmentId, segmentContainer, signal);




  const query = useQuery<Awaited<ReturnType<typeof getHlsVideoSegmentLegacy>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && playlistId && segmentId && segmentContainer), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a hls video playlist.
 */
export const getHlsPlaylistLegacy = (
  itemId: string,
  playlistId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/hls/${playlistId}/stream.m3u8`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetHlsPlaylistLegacyQueryKey = (itemId: string,
  playlistId: string,) => [`/Videos/${itemId}/hls/${playlistId}/stream.m3u8`];


export type GetHlsPlaylistLegacyQueryResult = NonNullable<Awaited<ReturnType<typeof getHlsPlaylistLegacy>>>
export type GetHlsPlaylistLegacyQueryError = ErrorType<void>

export const useGetHlsPlaylistLegacy = <TData = Awaited<ReturnType<typeof getHlsPlaylistLegacy>>, TError = ErrorType<void>>(
  itemId: string,
  playlistId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getHlsPlaylistLegacy>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHlsPlaylistLegacyQueryKey(itemId, playlistId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHlsPlaylistLegacy>>> = ({ signal }) => getHlsPlaylistLegacy(itemId, playlistId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getHlsPlaylistLegacy>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && playlistId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Stops an active encoding.
 */
export const stopEncodingProcess = (
  params: StopEncodingProcessParams,
) => {
  return apiInstance<void>(
    {
      url: `/Videos/ActiveEncodings`, method: 'delete',
      params
    },
  );
}



export type StopEncodingProcessMutationResult = NonNullable<Awaited<ReturnType<typeof stopEncodingProcess>>>

export type StopEncodingProcessMutationError = ErrorType<unknown>

export const useStopEncodingProcess = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof stopEncodingProcess>>, TError, { params: StopEncodingProcessParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof stopEncodingProcess>>, { params: StopEncodingProcessParams }> = (props) => {
    const { params } = props ?? {};

    return stopEncodingProcess(params,)
  }



  return useMutation<Awaited<ReturnType<typeof stopEncodingProcess>>, TError, { params: StopEncodingProcessParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get artist image by name.
 */
export const getArtistImage = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetArtistImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Artists/${name}/Images/${imageType}/${imageIndex}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetArtistImageQueryKey = (name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetArtistImageParams,) => [`/Artists/${name}/Images/${imageType}/${imageIndex}`, ...(params ? [params] : [])];


export type GetArtistImageQueryResult = NonNullable<Awaited<ReturnType<typeof getArtistImage>>>
export type GetArtistImageQueryError = ErrorType<ProblemDetails>

export const useGetArtistImage = <TData = Awaited<ReturnType<typeof getArtistImage>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetArtistImageParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getArtistImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetArtistImageQueryKey(name, imageType, imageIndex, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getArtistImage>>> = ({ signal }) => getArtistImage(name, imageType, imageIndex, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getArtistImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && imageType && imageIndex), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get artist image by name.
 */
export const headArtistImage = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadArtistImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Artists/${name}/Images/${imageType}/${imageIndex}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadArtistImageMutationResult = NonNullable<Awaited<ReturnType<typeof headArtistImage>>>

export type HeadArtistImageMutationError = ErrorType<ProblemDetails>

export const useHeadArtistImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headArtistImage>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadArtistImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headArtistImage>>, { name: string; imageType: ImageType; imageIndex: number; params?: HeadArtistImageParams }> = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headArtistImage(name, imageType, imageIndex, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headArtistImage>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadArtistImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Generates or gets the splashscreen.
 */
export const getSplashscreen = (
  params?: GetSplashscreenParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Branding/Splashscreen`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetSplashscreenQueryKey = (params?: GetSplashscreenParams,) => [`/Branding/Splashscreen`, ...(params ? [params] : [])];


export type GetSplashscreenQueryResult = NonNullable<Awaited<ReturnType<typeof getSplashscreen>>>
export type GetSplashscreenQueryError = ErrorType<unknown>

export const useGetSplashscreen = <TData = Awaited<ReturnType<typeof getSplashscreen>>, TError = ErrorType<unknown>>(
  params?: GetSplashscreenParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSplashscreen>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSplashscreenQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSplashscreen>>> = ({ signal }) => getSplashscreen(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSplashscreen>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Uploads a custom splashscreen.
The body is expected to the image contents base64 encoded.
 */
export const uploadCustomSplashscreen = (
  uploadCustomSplashscreenBody: Blob,
) => {
  return apiInstance<void>(
    {
      url: `/Branding/Splashscreen`, method: 'post',
      headers: { 'Content-Type': 'image/*', },
      data: uploadCustomSplashscreenBody
    },
  );
}



export type UploadCustomSplashscreenMutationResult = NonNullable<Awaited<ReturnType<typeof uploadCustomSplashscreen>>>
export type UploadCustomSplashscreenMutationBody = Blob
export type UploadCustomSplashscreenMutationError = ErrorType<ProblemDetails>

export const useUploadCustomSplashscreen = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof uploadCustomSplashscreen>>, TError, { data: Blob }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadCustomSplashscreen>>, { data: Blob }> = (props) => {
    const { data } = props ?? {};

    return uploadCustomSplashscreen(data,)
  }



  return useMutation<Awaited<ReturnType<typeof uploadCustomSplashscreen>>, TError, { data: Blob }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Delete a custom splashscreen.
 */
export const deleteCustomSplashscreen = (

) => {
  return apiInstance<void>(
    {
      url: `/Branding/Splashscreen`, method: 'delete'
    },
  );
}



export type DeleteCustomSplashscreenMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCustomSplashscreen>>>

export type DeleteCustomSplashscreenMutationError = ErrorType<unknown>

export const useDeleteCustomSplashscreen = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteCustomSplashscreen>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCustomSplashscreen>>, TVariables> = () => {


    return deleteCustomSplashscreen()
  }



  return useMutation<Awaited<ReturnType<typeof deleteCustomSplashscreen>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get genre image by name.
 */
export const getGenreImage = (
  name: string,
  imageType: ImageType,
  params?: GetGenreImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Genres/${name}/Images/${imageType}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetGenreImageQueryKey = (name: string,
  imageType: ImageType,
  params?: GetGenreImageParams,) => [`/Genres/${name}/Images/${imageType}`, ...(params ? [params] : [])];


export type GetGenreImageQueryResult = NonNullable<Awaited<ReturnType<typeof getGenreImage>>>
export type GetGenreImageQueryError = ErrorType<ProblemDetails>

export const useGetGenreImage = <TData = Awaited<ReturnType<typeof getGenreImage>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  imageType: ImageType,
  params?: GetGenreImageParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getGenreImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGenreImageQueryKey(name, imageType, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenreImage>>> = ({ signal }) => getGenreImage(name, imageType, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getGenreImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && imageType), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get genre image by name.
 */
export const headGenreImage = (
  name: string,
  imageType: ImageType,
  params?: HeadGenreImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Genres/${name}/Images/${imageType}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadGenreImageMutationResult = NonNullable<Awaited<ReturnType<typeof headGenreImage>>>

export type HeadGenreImageMutationError = ErrorType<ProblemDetails>

export const useHeadGenreImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headGenreImage>>, TError, { name: string; imageType: ImageType; params?: HeadGenreImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headGenreImage>>, { name: string; imageType: ImageType; params?: HeadGenreImageParams }> = (props) => {
    const { name, imageType, params } = props ?? {};

    return headGenreImage(name, imageType, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headGenreImage>>, TError, { name: string; imageType: ImageType; params?: HeadGenreImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get genre image by name.
 */
export const getGenreImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetGenreImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Genres/${name}/Images/${imageType}/${imageIndex}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetGenreImageByIndexQueryKey = (name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetGenreImageByIndexParams,) => [`/Genres/${name}/Images/${imageType}/${imageIndex}`, ...(params ? [params] : [])];


export type GetGenreImageByIndexQueryResult = NonNullable<Awaited<ReturnType<typeof getGenreImageByIndex>>>
export type GetGenreImageByIndexQueryError = ErrorType<ProblemDetails>

export const useGetGenreImageByIndex = <TData = Awaited<ReturnType<typeof getGenreImageByIndex>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetGenreImageByIndexParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getGenreImageByIndex>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGenreImageByIndexQueryKey(name, imageType, imageIndex, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenreImageByIndex>>> = ({ signal }) => getGenreImageByIndex(name, imageType, imageIndex, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getGenreImageByIndex>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && imageType && imageIndex), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get genre image by name.
 */
export const headGenreImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadGenreImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Genres/${name}/Images/${imageType}/${imageIndex}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadGenreImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof headGenreImageByIndex>>>

export type HeadGenreImageByIndexMutationError = ErrorType<ProblemDetails>

export const useHeadGenreImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headGenreImageByIndex>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadGenreImageByIndexParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headGenreImageByIndex>>, { name: string; imageType: ImageType; imageIndex: number; params?: HeadGenreImageByIndexParams }> = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headGenreImageByIndex(name, imageType, imageIndex, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headGenreImageByIndex>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadGenreImageByIndexParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get item image infos.
 */
export const getItemImageInfos = (
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<ImageInfo[]>(
    {
      url: `/Items/${itemId}/Images`, method: 'get', signal
    },
  );
}


export const getGetItemImageInfosQueryKey = (itemId: string,) => [`/Items/${itemId}/Images`];


export type GetItemImageInfosQueryResult = NonNullable<Awaited<ReturnType<typeof getItemImageInfos>>>
export type GetItemImageInfosQueryError = ErrorType<void | ProblemDetails>

export const useGetItemImageInfos = <TData = Awaited<ReturnType<typeof getItemImageInfos>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getItemImageInfos>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemImageInfosQueryKey(itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemImageInfos>>> = ({ signal }) => getItemImageInfos(itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getItemImageInfos>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Delete an item's image.
 */
export const deleteItemImage = (
  itemId: string,
  imageType: ImageType,
  params?: DeleteItemImageParams,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}/Images/${imageType}`, method: 'delete',
      params
    },
  );
}



export type DeleteItemImageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteItemImage>>>

export type DeleteItemImageMutationError = ErrorType<ProblemDetails>

export const useDeleteItemImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteItemImage>>, TError, { itemId: string; imageType: ImageType; params?: DeleteItemImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteItemImage>>, { itemId: string; imageType: ImageType; params?: DeleteItemImageParams }> = (props) => {
    const { itemId, imageType, params } = props ?? {};

    return deleteItemImage(itemId, imageType, params,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteItemImage>>, TError, { itemId: string; imageType: ImageType; params?: DeleteItemImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Set item image.
 */
export const setItemImage = (
  itemId: string,
  imageType: ImageType,
  setItemImageBody: Blob,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}/Images/${imageType}`, method: 'post',
      headers: { 'Content-Type': 'image/*', },
      data: setItemImageBody
    },
  );
}



export type SetItemImageMutationResult = NonNullable<Awaited<ReturnType<typeof setItemImage>>>
export type SetItemImageMutationBody = Blob
export type SetItemImageMutationError = ErrorType<ProblemDetails>

export const useSetItemImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof setItemImage>>, TError, { itemId: string; imageType: ImageType; data: Blob }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setItemImage>>, { itemId: string; imageType: ImageType; data: Blob }> = (props) => {
    const { itemId, imageType, data } = props ?? {};

    return setItemImage(itemId, imageType, data,)
  }



  return useMutation<Awaited<ReturnType<typeof setItemImage>>, TError, { itemId: string; imageType: ImageType; data: Blob }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the item's image.
 */
export const getItemImage = (
  itemId: string,
  imageType: ImageType,
  params?: GetItemImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Items/${itemId}/Images/${imageType}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetItemImageQueryKey = (itemId: string,
  imageType: ImageType,
  params?: GetItemImageParams,) => [`/Items/${itemId}/Images/${imageType}`, ...(params ? [params] : [])];


export type GetItemImageQueryResult = NonNullable<Awaited<ReturnType<typeof getItemImage>>>
export type GetItemImageQueryError = ErrorType<ProblemDetails>

export const useGetItemImage = <TData = Awaited<ReturnType<typeof getItemImage>>, TError = ErrorType<ProblemDetails>>(
  itemId: string,
  imageType: ImageType,
  params?: GetItemImageParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getItemImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemImageQueryKey(itemId, imageType, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemImage>>> = ({ signal }) => getItemImage(itemId, imageType, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getItemImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && imageType), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the item's image.
 */
export const headItemImage = (
  itemId: string,
  imageType: ImageType,
  params?: HeadItemImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Items/${itemId}/Images/${imageType}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadItemImageMutationResult = NonNullable<Awaited<ReturnType<typeof headItemImage>>>

export type HeadItemImageMutationError = ErrorType<ProblemDetails>

export const useHeadItemImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headItemImage>>, TError, { itemId: string; imageType: ImageType; params?: HeadItemImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headItemImage>>, { itemId: string; imageType: ImageType; params?: HeadItemImageParams }> = (props) => {
    const { itemId, imageType, params } = props ?? {};

    return headItemImage(itemId, imageType, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headItemImage>>, TError, { itemId: string; imageType: ImageType; params?: HeadItemImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Delete an item's image.
 */
export const deleteItemImageByIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}/Images/${imageType}/${imageIndex}`, method: 'delete'
    },
  );
}



export type DeleteItemImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof deleteItemImageByIndex>>>

export type DeleteItemImageByIndexMutationError = ErrorType<ProblemDetails>

export const useDeleteItemImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteItemImageByIndex>>, TError, { itemId: string; imageType: ImageType; imageIndex: number }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteItemImageByIndex>>, { itemId: string; imageType: ImageType; imageIndex: number }> = (props) => {
    const { itemId, imageType, imageIndex } = props ?? {};

    return deleteItemImageByIndex(itemId, imageType, imageIndex,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteItemImageByIndex>>, TError, { itemId: string; imageType: ImageType; imageIndex: number }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Set item image.
 */
export const setItemImageByIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  setItemImageByIndexBody: Blob,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}/Images/${imageType}/${imageIndex}`, method: 'post',
      headers: { 'Content-Type': 'image/*', },
      data: setItemImageByIndexBody
    },
  );
}



export type SetItemImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof setItemImageByIndex>>>
export type SetItemImageByIndexMutationBody = Blob
export type SetItemImageByIndexMutationError = ErrorType<ProblemDetails>

export const useSetItemImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof setItemImageByIndex>>, TError, { itemId: string; imageType: ImageType; imageIndex: number; data: Blob }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setItemImageByIndex>>, { itemId: string; imageType: ImageType; imageIndex: number; data: Blob }> = (props) => {
    const { itemId, imageType, imageIndex, data } = props ?? {};

    return setItemImageByIndex(itemId, imageType, imageIndex, data,)
  }



  return useMutation<Awaited<ReturnType<typeof setItemImageByIndex>>, TError, { itemId: string; imageType: ImageType; imageIndex: number; data: Blob }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the item's image.
 */
export const getItemImageByIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetItemImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Items/${itemId}/Images/${imageType}/${imageIndex}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetItemImageByIndexQueryKey = (itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetItemImageByIndexParams,) => [`/Items/${itemId}/Images/${imageType}/${imageIndex}`, ...(params ? [params] : [])];


export type GetItemImageByIndexQueryResult = NonNullable<Awaited<ReturnType<typeof getItemImageByIndex>>>
export type GetItemImageByIndexQueryError = ErrorType<ProblemDetails>

export const useGetItemImageByIndex = <TData = Awaited<ReturnType<typeof getItemImageByIndex>>, TError = ErrorType<ProblemDetails>>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetItemImageByIndexParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getItemImageByIndex>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemImageByIndexQueryKey(itemId, imageType, imageIndex, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemImageByIndex>>> = ({ signal }) => getItemImageByIndex(itemId, imageType, imageIndex, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getItemImageByIndex>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && imageType && imageIndex), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the item's image.
 */
export const headItemImageByIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadItemImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Items/${itemId}/Images/${imageType}/${imageIndex}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadItemImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof headItemImageByIndex>>>

export type HeadItemImageByIndexMutationError = ErrorType<ProblemDetails>

export const useHeadItemImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headItemImageByIndex>>, TError, { itemId: string; imageType: ImageType; imageIndex: number; params?: HeadItemImageByIndexParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headItemImageByIndex>>, { itemId: string; imageType: ImageType; imageIndex: number; params?: HeadItemImageByIndexParams }> = (props) => {
    const { itemId, imageType, imageIndex, params } = props ?? {};

    return headItemImageByIndex(itemId, imageType, imageIndex, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headItemImageByIndex>>, TError, { itemId: string; imageType: ImageType; imageIndex: number; params?: HeadItemImageByIndexParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the item's image.
 */
export const getItemImage2 = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: GetItemImage2Params,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Items/${itemId}/Images/${imageType}/${imageIndex}/${tag}/${format}/${maxWidth}/${maxHeight}/${percentPlayed}/${unplayedCount}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetItemImage2QueryKey = (itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: GetItemImage2Params,) => [`/Items/${itemId}/Images/${imageType}/${imageIndex}/${tag}/${format}/${maxWidth}/${maxHeight}/${percentPlayed}/${unplayedCount}`, ...(params ? [params] : [])];


export type GetItemImage2QueryResult = NonNullable<Awaited<ReturnType<typeof getItemImage2>>>
export type GetItemImage2QueryError = ErrorType<ProblemDetails>

export const useGetItemImage2 = <TData = Awaited<ReturnType<typeof getItemImage2>>, TError = ErrorType<ProblemDetails>>(
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: GetItemImage2Params, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getItemImage2>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemImage2QueryKey(itemId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemImage2>>> = ({ signal }) => getItemImage2(itemId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getItemImage2>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && imageType && imageIndex && tag && format && maxWidth && maxHeight && percentPlayed && unplayedCount), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the item's image.
 */
export const headItemImage2 = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  tag: string,
  format: ImageFormat,
  maxWidth: number,
  maxHeight: number,
  percentPlayed: number,
  unplayedCount: number,
  params?: HeadItemImage2Params,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Items/${itemId}/Images/${imageType}/${imageIndex}/${tag}/${format}/${maxWidth}/${maxHeight}/${percentPlayed}/${unplayedCount}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadItemImage2MutationResult = NonNullable<Awaited<ReturnType<typeof headItemImage2>>>

export type HeadItemImage2MutationError = ErrorType<ProblemDetails>

export const useHeadItemImage2 = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headItemImage2>>, TError, { itemId: string; imageType: ImageType; imageIndex: number; tag: string; format: ImageFormat; maxWidth: number; maxHeight: number; percentPlayed: number; unplayedCount: number; params?: HeadItemImage2Params }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headItemImage2>>, { itemId: string; imageType: ImageType; imageIndex: number; tag: string; format: ImageFormat; maxWidth: number; maxHeight: number; percentPlayed: number; unplayedCount: number; params?: HeadItemImage2Params }> = (props) => {
    const { itemId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, params } = props ?? {};

    return headItemImage2(itemId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headItemImage2>>, TError, { itemId: string; imageType: ImageType; imageIndex: number; tag: string; format: ImageFormat; maxWidth: number; maxHeight: number; percentPlayed: number; unplayedCount: number; params?: HeadItemImage2Params }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates the index for an item image.
 */
export const updateItemImageIndex = (
  itemId: string,
  imageType: ImageType,
  imageIndex: number,
  params: UpdateItemImageIndexParams,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}/Images/${imageType}/${imageIndex}/Index`, method: 'post',
      params
    },
  );
}



export type UpdateItemImageIndexMutationResult = NonNullable<Awaited<ReturnType<typeof updateItemImageIndex>>>

export type UpdateItemImageIndexMutationError = ErrorType<ProblemDetails>

export const useUpdateItemImageIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateItemImageIndex>>, TError, { itemId: string; imageType: ImageType; imageIndex: number; params: UpdateItemImageIndexParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateItemImageIndex>>, { itemId: string; imageType: ImageType; imageIndex: number; params: UpdateItemImageIndexParams }> = (props) => {
    const { itemId, imageType, imageIndex, params } = props ?? {};

    return updateItemImageIndex(itemId, imageType, imageIndex, params,)
  }



  return useMutation<Awaited<ReturnType<typeof updateItemImageIndex>>, TError, { itemId: string; imageType: ImageType; imageIndex: number; params: UpdateItemImageIndexParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get music genre image by name.
 */
export const getMusicGenreImage = (
  name: string,
  imageType: ImageType,
  params?: GetMusicGenreImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/MusicGenres/${name}/Images/${imageType}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetMusicGenreImageQueryKey = (name: string,
  imageType: ImageType,
  params?: GetMusicGenreImageParams,) => [`/MusicGenres/${name}/Images/${imageType}`, ...(params ? [params] : [])];


export type GetMusicGenreImageQueryResult = NonNullable<Awaited<ReturnType<typeof getMusicGenreImage>>>
export type GetMusicGenreImageQueryError = ErrorType<ProblemDetails>

export const useGetMusicGenreImage = <TData = Awaited<ReturnType<typeof getMusicGenreImage>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  imageType: ImageType,
  params?: GetMusicGenreImageParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMusicGenreImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMusicGenreImageQueryKey(name, imageType, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMusicGenreImage>>> = ({ signal }) => getMusicGenreImage(name, imageType, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMusicGenreImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && imageType), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get music genre image by name.
 */
export const headMusicGenreImage = (
  name: string,
  imageType: ImageType,
  params?: HeadMusicGenreImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/MusicGenres/${name}/Images/${imageType}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadMusicGenreImageMutationResult = NonNullable<Awaited<ReturnType<typeof headMusicGenreImage>>>

export type HeadMusicGenreImageMutationError = ErrorType<ProblemDetails>

export const useHeadMusicGenreImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headMusicGenreImage>>, TError, { name: string; imageType: ImageType; params?: HeadMusicGenreImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headMusicGenreImage>>, { name: string; imageType: ImageType; params?: HeadMusicGenreImageParams }> = (props) => {
    const { name, imageType, params } = props ?? {};

    return headMusicGenreImage(name, imageType, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headMusicGenreImage>>, TError, { name: string; imageType: ImageType; params?: HeadMusicGenreImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get music genre image by name.
 */
export const getMusicGenreImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetMusicGenreImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/MusicGenres/${name}/Images/${imageType}/${imageIndex}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetMusicGenreImageByIndexQueryKey = (name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetMusicGenreImageByIndexParams,) => [`/MusicGenres/${name}/Images/${imageType}/${imageIndex}`, ...(params ? [params] : [])];


export type GetMusicGenreImageByIndexQueryResult = NonNullable<Awaited<ReturnType<typeof getMusicGenreImageByIndex>>>
export type GetMusicGenreImageByIndexQueryError = ErrorType<ProblemDetails>

export const useGetMusicGenreImageByIndex = <TData = Awaited<ReturnType<typeof getMusicGenreImageByIndex>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetMusicGenreImageByIndexParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMusicGenreImageByIndex>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMusicGenreImageByIndexQueryKey(name, imageType, imageIndex, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMusicGenreImageByIndex>>> = ({ signal }) => getMusicGenreImageByIndex(name, imageType, imageIndex, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMusicGenreImageByIndex>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && imageType && imageIndex), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get music genre image by name.
 */
export const headMusicGenreImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadMusicGenreImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/MusicGenres/${name}/Images/${imageType}/${imageIndex}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadMusicGenreImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof headMusicGenreImageByIndex>>>

export type HeadMusicGenreImageByIndexMutationError = ErrorType<ProblemDetails>

export const useHeadMusicGenreImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headMusicGenreImageByIndex>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadMusicGenreImageByIndexParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headMusicGenreImageByIndex>>, { name: string; imageType: ImageType; imageIndex: number; params?: HeadMusicGenreImageByIndexParams }> = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headMusicGenreImageByIndex(name, imageType, imageIndex, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headMusicGenreImageByIndex>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadMusicGenreImageByIndexParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get person image by name.
 */
export const getPersonImage = (
  name: string,
  imageType: ImageType,
  params?: GetPersonImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Persons/${name}/Images/${imageType}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetPersonImageQueryKey = (name: string,
  imageType: ImageType,
  params?: GetPersonImageParams,) => [`/Persons/${name}/Images/${imageType}`, ...(params ? [params] : [])];


export type GetPersonImageQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonImage>>>
export type GetPersonImageQueryError = ErrorType<ProblemDetails>

export const useGetPersonImage = <TData = Awaited<ReturnType<typeof getPersonImage>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  imageType: ImageType,
  params?: GetPersonImageParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPersonImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPersonImageQueryKey(name, imageType, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonImage>>> = ({ signal }) => getPersonImage(name, imageType, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getPersonImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && imageType), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get person image by name.
 */
export const headPersonImage = (
  name: string,
  imageType: ImageType,
  params?: HeadPersonImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Persons/${name}/Images/${imageType}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadPersonImageMutationResult = NonNullable<Awaited<ReturnType<typeof headPersonImage>>>

export type HeadPersonImageMutationError = ErrorType<ProblemDetails>

export const useHeadPersonImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headPersonImage>>, TError, { name: string; imageType: ImageType; params?: HeadPersonImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headPersonImage>>, { name: string; imageType: ImageType; params?: HeadPersonImageParams }> = (props) => {
    const { name, imageType, params } = props ?? {};

    return headPersonImage(name, imageType, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headPersonImage>>, TError, { name: string; imageType: ImageType; params?: HeadPersonImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get person image by name.
 */
export const getPersonImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetPersonImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Persons/${name}/Images/${imageType}/${imageIndex}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetPersonImageByIndexQueryKey = (name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetPersonImageByIndexParams,) => [`/Persons/${name}/Images/${imageType}/${imageIndex}`, ...(params ? [params] : [])];


export type GetPersonImageByIndexQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonImageByIndex>>>
export type GetPersonImageByIndexQueryError = ErrorType<ProblemDetails>

export const useGetPersonImageByIndex = <TData = Awaited<ReturnType<typeof getPersonImageByIndex>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetPersonImageByIndexParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPersonImageByIndex>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPersonImageByIndexQueryKey(name, imageType, imageIndex, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonImageByIndex>>> = ({ signal }) => getPersonImageByIndex(name, imageType, imageIndex, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getPersonImageByIndex>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && imageType && imageIndex), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get person image by name.
 */
export const headPersonImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadPersonImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Persons/${name}/Images/${imageType}/${imageIndex}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadPersonImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof headPersonImageByIndex>>>

export type HeadPersonImageByIndexMutationError = ErrorType<ProblemDetails>

export const useHeadPersonImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headPersonImageByIndex>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadPersonImageByIndexParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headPersonImageByIndex>>, { name: string; imageType: ImageType; imageIndex: number; params?: HeadPersonImageByIndexParams }> = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headPersonImageByIndex(name, imageType, imageIndex, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headPersonImageByIndex>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadPersonImageByIndexParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get studio image by name.
 */
export const getStudioImage = (
  name: string,
  imageType: ImageType,
  params?: GetStudioImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Studios/${name}/Images/${imageType}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetStudioImageQueryKey = (name: string,
  imageType: ImageType,
  params?: GetStudioImageParams,) => [`/Studios/${name}/Images/${imageType}`, ...(params ? [params] : [])];


export type GetStudioImageQueryResult = NonNullable<Awaited<ReturnType<typeof getStudioImage>>>
export type GetStudioImageQueryError = ErrorType<ProblemDetails>

export const useGetStudioImage = <TData = Awaited<ReturnType<typeof getStudioImage>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  imageType: ImageType,
  params?: GetStudioImageParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getStudioImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudioImageQueryKey(name, imageType, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudioImage>>> = ({ signal }) => getStudioImage(name, imageType, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getStudioImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && imageType), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get studio image by name.
 */
export const headStudioImage = (
  name: string,
  imageType: ImageType,
  params?: HeadStudioImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Studios/${name}/Images/${imageType}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadStudioImageMutationResult = NonNullable<Awaited<ReturnType<typeof headStudioImage>>>

export type HeadStudioImageMutationError = ErrorType<ProblemDetails>

export const useHeadStudioImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headStudioImage>>, TError, { name: string; imageType: ImageType; params?: HeadStudioImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headStudioImage>>, { name: string; imageType: ImageType; params?: HeadStudioImageParams }> = (props) => {
    const { name, imageType, params } = props ?? {};

    return headStudioImage(name, imageType, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headStudioImage>>, TError, { name: string; imageType: ImageType; params?: HeadStudioImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get studio image by name.
 */
export const getStudioImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetStudioImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Studios/${name}/Images/${imageType}/${imageIndex}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetStudioImageByIndexQueryKey = (name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetStudioImageByIndexParams,) => [`/Studios/${name}/Images/${imageType}/${imageIndex}`, ...(params ? [params] : [])];


export type GetStudioImageByIndexQueryResult = NonNullable<Awaited<ReturnType<typeof getStudioImageByIndex>>>
export type GetStudioImageByIndexQueryError = ErrorType<ProblemDetails>

export const useGetStudioImageByIndex = <TData = Awaited<ReturnType<typeof getStudioImageByIndex>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetStudioImageByIndexParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getStudioImageByIndex>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudioImageByIndexQueryKey(name, imageType, imageIndex, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudioImageByIndex>>> = ({ signal }) => getStudioImageByIndex(name, imageType, imageIndex, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getStudioImageByIndex>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && imageType && imageIndex), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get studio image by name.
 */
export const headStudioImageByIndex = (
  name: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadStudioImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Studios/${name}/Images/${imageType}/${imageIndex}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadStudioImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof headStudioImageByIndex>>>

export type HeadStudioImageByIndexMutationError = ErrorType<ProblemDetails>

export const useHeadStudioImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headStudioImageByIndex>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadStudioImageByIndexParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headStudioImageByIndex>>, { name: string; imageType: ImageType; imageIndex: number; params?: HeadStudioImageByIndexParams }> = (props) => {
    const { name, imageType, imageIndex, params } = props ?? {};

    return headStudioImageByIndex(name, imageType, imageIndex, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headStudioImageByIndex>>, TError, { name: string; imageType: ImageType; imageIndex: number; params?: HeadStudioImageByIndexParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Sets the user image.
 */
export const postUserImage = (
  userId: string,
  imageType: ImageType,
  postUserImageBody: Blob,
  params?: PostUserImageParams,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/Images/${imageType}`, method: 'post',
      headers: { 'Content-Type': 'image/*', },
      data: postUserImageBody,
      params
    },
  );
}



export type PostUserImageMutationResult = NonNullable<Awaited<ReturnType<typeof postUserImage>>>
export type PostUserImageMutationBody = Blob
export type PostUserImageMutationError = ErrorType<ProblemDetails>

export const usePostUserImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUserImage>>, TError, { userId: string; imageType: ImageType; data: Blob; params?: PostUserImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUserImage>>, { userId: string; imageType: ImageType; data: Blob; params?: PostUserImageParams }> = (props) => {
    const { userId, imageType, data, params } = props ?? {};

    return postUserImage(userId, imageType, data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof postUserImage>>, TError, { userId: string; imageType: ImageType; data: Blob; params?: PostUserImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Delete the user's image.
 */
export const deleteUserImage = (
  userId: string,
  imageType: ImageType,
  params?: DeleteUserImageParams,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/Images/${imageType}`, method: 'delete',
      params
    },
  );
}



export type DeleteUserImageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserImage>>>

export type DeleteUserImageMutationError = ErrorType<ProblemDetails>

export const useDeleteUserImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUserImage>>, TError, { userId: string; imageType: ImageType; params?: DeleteUserImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserImage>>, { userId: string; imageType: ImageType; params?: DeleteUserImageParams }> = (props) => {
    const { userId, imageType, params } = props ?? {};

    return deleteUserImage(userId, imageType, params,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteUserImage>>, TError, { userId: string; imageType: ImageType; params?: DeleteUserImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get user profile image.
 */
export const getUserImage = (
  userId: string,
  imageType: ImageType,
  params?: GetUserImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Users/${userId}/Images/${imageType}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetUserImageQueryKey = (userId: string,
  imageType: ImageType,
  params?: GetUserImageParams,) => [`/Users/${userId}/Images/${imageType}`, ...(params ? [params] : [])];


export type GetUserImageQueryResult = NonNullable<Awaited<ReturnType<typeof getUserImage>>>
export type GetUserImageQueryError = ErrorType<ProblemDetails>

export const useGetUserImage = <TData = Awaited<ReturnType<typeof getUserImage>>, TError = ErrorType<ProblemDetails>>(
  userId: string,
  imageType: ImageType,
  params?: GetUserImageParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserImageQueryKey(userId, imageType, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserImage>>> = ({ signal }) => getUserImage(userId, imageType, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getUserImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId && imageType), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get user profile image.
 */
export const headUserImage = (
  userId: string,
  imageType: ImageType,
  params?: HeadUserImageParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Users/${userId}/Images/${imageType}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadUserImageMutationResult = NonNullable<Awaited<ReturnType<typeof headUserImage>>>

export type HeadUserImageMutationError = ErrorType<ProblemDetails>

export const useHeadUserImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headUserImage>>, TError, { userId: string; imageType: ImageType; params?: HeadUserImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headUserImage>>, { userId: string; imageType: ImageType; params?: HeadUserImageParams }> = (props) => {
    const { userId, imageType, params } = props ?? {};

    return headUserImage(userId, imageType, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headUserImage>>, TError, { userId: string; imageType: ImageType; params?: HeadUserImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get user profile image.
 */
export const getUserImageByIndex = (
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetUserImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Users/${userId}/Images/${imageType}/${imageIndex}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetUserImageByIndexQueryKey = (userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetUserImageByIndexParams,) => [`/Users/${userId}/Images/${imageType}/${imageIndex}`, ...(params ? [params] : [])];


export type GetUserImageByIndexQueryResult = NonNullable<Awaited<ReturnType<typeof getUserImageByIndex>>>
export type GetUserImageByIndexQueryError = ErrorType<ProblemDetails>

export const useGetUserImageByIndex = <TData = Awaited<ReturnType<typeof getUserImageByIndex>>, TError = ErrorType<ProblemDetails>>(
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: GetUserImageByIndexParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserImageByIndex>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserImageByIndexQueryKey(userId, imageType, imageIndex, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserImageByIndex>>> = ({ signal }) => getUserImageByIndex(userId, imageType, imageIndex, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getUserImageByIndex>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId && imageType && imageIndex), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get user profile image.
 */
export const headUserImageByIndex = (
  userId: string,
  imageType: ImageType,
  imageIndex: number,
  params?: HeadUserImageByIndexParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Users/${userId}/Images/${imageType}/${imageIndex}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadUserImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof headUserImageByIndex>>>

export type HeadUserImageByIndexMutationError = ErrorType<ProblemDetails>

export const useHeadUserImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headUserImageByIndex>>, TError, { userId: string; imageType: ImageType; imageIndex: number; params?: HeadUserImageByIndexParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headUserImageByIndex>>, { userId: string; imageType: ImageType; imageIndex: number; params?: HeadUserImageByIndexParams }> = (props) => {
    const { userId, imageType, imageIndex, params } = props ?? {};

    return headUserImageByIndex(userId, imageType, imageIndex, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headUserImageByIndex>>, TError, { userId: string; imageType: ImageType; imageIndex: number; params?: HeadUserImageByIndexParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Sets the user image.
 */
export const postUserImageByIndex = (
  userId: string,
  imageType: ImageType,
  index: number,
  postUserImageByIndexBody: Blob,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/Images/${imageType}/${index}`, method: 'post',
      headers: { 'Content-Type': 'image/*', },
      data: postUserImageByIndexBody
    },
  );
}



export type PostUserImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof postUserImageByIndex>>>
export type PostUserImageByIndexMutationBody = Blob
export type PostUserImageByIndexMutationError = ErrorType<ProblemDetails>

export const usePostUserImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUserImageByIndex>>, TError, { userId: string; imageType: ImageType; index: number; data: Blob }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUserImageByIndex>>, { userId: string; imageType: ImageType; index: number; data: Blob }> = (props) => {
    const { userId, imageType, index, data } = props ?? {};

    return postUserImageByIndex(userId, imageType, index, data,)
  }



  return useMutation<Awaited<ReturnType<typeof postUserImageByIndex>>, TError, { userId: string; imageType: ImageType; index: number; data: Blob }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Delete the user's image.
 */
export const deleteUserImageByIndex = (
  userId: string,
  imageType: ImageType,
  index: number,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/Images/${imageType}/${index}`, method: 'delete'
    },
  );
}



export type DeleteUserImageByIndexMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserImageByIndex>>>

export type DeleteUserImageByIndexMutationError = ErrorType<ProblemDetails>

export const useDeleteUserImageByIndex = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUserImageByIndex>>, TError, { userId: string; imageType: ImageType; index: number }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserImageByIndex>>, { userId: string; imageType: ImageType; index: number }> = (props) => {
    const { userId, imageType, index } = props ?? {};

    return deleteUserImageByIndex(userId, imageType, index,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteUserImageByIndex>>, TError, { userId: string; imageType: ImageType; index: number }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get all general images.
 */
export const getGeneralImages = (

  signal?: AbortSignal
) => {
  return apiInstance<ImageByNameInfo[]>(
    {
      url: `/Images/General`, method: 'get', signal
    },
  );
}


export const getGetGeneralImagesQueryKey = () => [`/Images/General`];


export type GetGeneralImagesQueryResult = NonNullable<Awaited<ReturnType<typeof getGeneralImages>>>
export type GetGeneralImagesQueryError = ErrorType<void>

export const useGetGeneralImages = <TData = Awaited<ReturnType<typeof getGeneralImages>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getGeneralImages>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGeneralImagesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGeneralImages>>> = ({ signal }) => getGeneralImages(signal);




  const query = useQuery<Awaited<ReturnType<typeof getGeneralImages>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get General Image.
 */
export const getGeneralImage = (
  name: string,
  type: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Images/General/${name}/${type}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetGeneralImageQueryKey = (name: string,
  type: string,) => [`/Images/General/${name}/${type}`];


export type GetGeneralImageQueryResult = NonNullable<Awaited<ReturnType<typeof getGeneralImage>>>
export type GetGeneralImageQueryError = ErrorType<ProblemDetails>

export const useGetGeneralImage = <TData = Awaited<ReturnType<typeof getGeneralImage>>, TError = ErrorType<ProblemDetails>>(
  name: string,
  type: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getGeneralImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGeneralImageQueryKey(name, type);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGeneralImage>>> = ({ signal }) => getGeneralImage(name, type, signal);




  const query = useQuery<Awaited<ReturnType<typeof getGeneralImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(name && type), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get all media info images.
 */
export const getMediaInfoImages = (

  signal?: AbortSignal
) => {
  return apiInstance<ImageByNameInfo[]>(
    {
      url: `/Images/MediaInfo`, method: 'get', signal
    },
  );
}


export const getGetMediaInfoImagesQueryKey = () => [`/Images/MediaInfo`];


export type GetMediaInfoImagesQueryResult = NonNullable<Awaited<ReturnType<typeof getMediaInfoImages>>>
export type GetMediaInfoImagesQueryError = ErrorType<void>

export const useGetMediaInfoImages = <TData = Awaited<ReturnType<typeof getMediaInfoImages>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMediaInfoImages>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaInfoImagesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMediaInfoImages>>> = ({ signal }) => getMediaInfoImages(signal);




  const query = useQuery<Awaited<ReturnType<typeof getMediaInfoImages>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get media info image.
 */
export const getMediaInfoImage = (
  theme: string,
  name: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Images/MediaInfo/${theme}/${name}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetMediaInfoImageQueryKey = (theme: string,
  name: string,) => [`/Images/MediaInfo/${theme}/${name}`];


export type GetMediaInfoImageQueryResult = NonNullable<Awaited<ReturnType<typeof getMediaInfoImage>>>
export type GetMediaInfoImageQueryError = ErrorType<ProblemDetails>

export const useGetMediaInfoImage = <TData = Awaited<ReturnType<typeof getMediaInfoImage>>, TError = ErrorType<ProblemDetails>>(
  theme: string,
  name: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMediaInfoImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaInfoImageQueryKey(theme, name);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMediaInfoImage>>> = ({ signal }) => getMediaInfoImage(theme, name, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMediaInfoImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(theme && name), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get all general images.
 */
export const getRatingImages = (

  signal?: AbortSignal
) => {
  return apiInstance<ImageByNameInfo[]>(
    {
      url: `/Images/Ratings`, method: 'get', signal
    },
  );
}


export const getGetRatingImagesQueryKey = () => [`/Images/Ratings`];


export type GetRatingImagesQueryResult = NonNullable<Awaited<ReturnType<typeof getRatingImages>>>
export type GetRatingImagesQueryError = ErrorType<void>

export const useGetRatingImages = <TData = Awaited<ReturnType<typeof getRatingImages>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRatingImages>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRatingImagesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRatingImages>>> = ({ signal }) => getRatingImages(signal);




  const query = useQuery<Awaited<ReturnType<typeof getRatingImages>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get rating image.
 */
export const getRatingImage = (
  theme: string,
  name: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Images/Ratings/${theme}/${name}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetRatingImageQueryKey = (theme: string,
  name: string,) => [`/Images/Ratings/${theme}/${name}`];


export type GetRatingImageQueryResult = NonNullable<Awaited<ReturnType<typeof getRatingImage>>>
export type GetRatingImageQueryError = ErrorType<ProblemDetails>

export const useGetRatingImage = <TData = Awaited<ReturnType<typeof getRatingImage>>, TError = ErrorType<ProblemDetails>>(
  theme: string,
  name: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRatingImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRatingImageQueryKey(theme, name);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRatingImage>>> = ({ signal }) => getRatingImage(theme, name, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRatingImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(theme && name), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates an instant playlist based on a given album.
 */
export const getInstantMixFromAlbum = (
  id: string,
  params?: GetInstantMixFromAlbumParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Albums/${id}/InstantMix`, method: 'get',
      params, signal
    },
  );
}


export const getGetInstantMixFromAlbumQueryKey = (id: string,
  params?: GetInstantMixFromAlbumParams,) => [`/Albums/${id}/InstantMix`, ...(params ? [params] : [])];


export type GetInstantMixFromAlbumQueryResult = NonNullable<Awaited<ReturnType<typeof getInstantMixFromAlbum>>>
export type GetInstantMixFromAlbumQueryError = ErrorType<void>

export const useGetInstantMixFromAlbum = <TData = Awaited<ReturnType<typeof getInstantMixFromAlbum>>, TError = ErrorType<void>>(
  id: string,
  params?: GetInstantMixFromAlbumParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getInstantMixFromAlbum>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInstantMixFromAlbumQueryKey(id, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstantMixFromAlbum>>> = ({ signal }) => getInstantMixFromAlbum(id, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getInstantMixFromAlbum>>, TError, TData>(queryKey, queryFn, { enabled: !!(id), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates an instant playlist based on a given artist.
 */
export const getInstantMixFromArtists = (
  id: string,
  params?: GetInstantMixFromArtistsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Artists/${id}/InstantMix`, method: 'get',
      params, signal
    },
  );
}


export const getGetInstantMixFromArtistsQueryKey = (id: string,
  params?: GetInstantMixFromArtistsParams,) => [`/Artists/${id}/InstantMix`, ...(params ? [params] : [])];


export type GetInstantMixFromArtistsQueryResult = NonNullable<Awaited<ReturnType<typeof getInstantMixFromArtists>>>
export type GetInstantMixFromArtistsQueryError = ErrorType<void>

export const useGetInstantMixFromArtists = <TData = Awaited<ReturnType<typeof getInstantMixFromArtists>>, TError = ErrorType<void>>(
  id: string,
  params?: GetInstantMixFromArtistsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getInstantMixFromArtists>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInstantMixFromArtistsQueryKey(id, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstantMixFromArtists>>> = ({ signal }) => getInstantMixFromArtists(id, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getInstantMixFromArtists>>, TError, TData>(queryKey, queryFn, { enabled: !!(id), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @deprecated
 * @summary Creates an instant playlist based on a given artist.
 */
export const getInstantMixFromArtists2 = (
  params: GetInstantMixFromArtists2Params,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Artists/InstantMix`, method: 'get',
      params, signal
    },
  );
}


export const getGetInstantMixFromArtists2QueryKey = (params: GetInstantMixFromArtists2Params,) => [`/Artists/InstantMix`, ...(params ? [params] : [])];


export type GetInstantMixFromArtists2QueryResult = NonNullable<Awaited<ReturnType<typeof getInstantMixFromArtists2>>>
export type GetInstantMixFromArtists2QueryError = ErrorType<void>

export const useGetInstantMixFromArtists2 = <TData = Awaited<ReturnType<typeof getInstantMixFromArtists2>>, TError = ErrorType<void>>(
  params: GetInstantMixFromArtists2Params, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getInstantMixFromArtists2>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInstantMixFromArtists2QueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstantMixFromArtists2>>> = ({ signal }) => getInstantMixFromArtists2(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getInstantMixFromArtists2>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates an instant playlist based on a given item.
 */
export const getInstantMixFromItem = (
  id: string,
  params?: GetInstantMixFromItemParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Items/${id}/InstantMix`, method: 'get',
      params, signal
    },
  );
}


export const getGetInstantMixFromItemQueryKey = (id: string,
  params?: GetInstantMixFromItemParams,) => [`/Items/${id}/InstantMix`, ...(params ? [params] : [])];


export type GetInstantMixFromItemQueryResult = NonNullable<Awaited<ReturnType<typeof getInstantMixFromItem>>>
export type GetInstantMixFromItemQueryError = ErrorType<void>

export const useGetInstantMixFromItem = <TData = Awaited<ReturnType<typeof getInstantMixFromItem>>, TError = ErrorType<void>>(
  id: string,
  params?: GetInstantMixFromItemParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getInstantMixFromItem>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInstantMixFromItemQueryKey(id, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstantMixFromItem>>> = ({ signal }) => getInstantMixFromItem(id, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getInstantMixFromItem>>, TError, TData>(queryKey, queryFn, { enabled: !!(id), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates an instant playlist based on a given genre.
 */
export const getInstantMixFromMusicGenreByName = (
  name: string,
  params?: GetInstantMixFromMusicGenreByNameParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/MusicGenres/${name}/InstantMix`, method: 'get',
      params, signal
    },
  );
}


export const getGetInstantMixFromMusicGenreByNameQueryKey = (name: string,
  params?: GetInstantMixFromMusicGenreByNameParams,) => [`/MusicGenres/${name}/InstantMix`, ...(params ? [params] : [])];


export type GetInstantMixFromMusicGenreByNameQueryResult = NonNullable<Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>>
export type GetInstantMixFromMusicGenreByNameQueryError = ErrorType<void>

export const useGetInstantMixFromMusicGenreByName = <TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>, TError = ErrorType<void>>(
  name: string,
  params?: GetInstantMixFromMusicGenreByNameParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInstantMixFromMusicGenreByNameQueryKey(name, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>> = ({ signal }) => getInstantMixFromMusicGenreByName(name, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getInstantMixFromMusicGenreByName>>, TError, TData>(queryKey, queryFn, { enabled: !!(name), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates an instant playlist based on a given genre.
 */
export const getInstantMixFromMusicGenreById = (
  params: GetInstantMixFromMusicGenreByIdParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/MusicGenres/InstantMix`, method: 'get',
      params, signal
    },
  );
}


export const getGetInstantMixFromMusicGenreByIdQueryKey = (params: GetInstantMixFromMusicGenreByIdParams,) => [`/MusicGenres/InstantMix`, ...(params ? [params] : [])];


export type GetInstantMixFromMusicGenreByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>>
export type GetInstantMixFromMusicGenreByIdQueryError = ErrorType<void>

export const useGetInstantMixFromMusicGenreById = <TData = Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>, TError = ErrorType<void>>(
  params: GetInstantMixFromMusicGenreByIdParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInstantMixFromMusicGenreByIdQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>> = ({ signal }) => getInstantMixFromMusicGenreById(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getInstantMixFromMusicGenreById>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates an instant playlist based on a given playlist.
 */
export const getInstantMixFromPlaylist = (
  id: string,
  params?: GetInstantMixFromPlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Playlists/${id}/InstantMix`, method: 'get',
      params, signal
    },
  );
}


export const getGetInstantMixFromPlaylistQueryKey = (id: string,
  params?: GetInstantMixFromPlaylistParams,) => [`/Playlists/${id}/InstantMix`, ...(params ? [params] : [])];


export type GetInstantMixFromPlaylistQueryResult = NonNullable<Awaited<ReturnType<typeof getInstantMixFromPlaylist>>>
export type GetInstantMixFromPlaylistQueryError = ErrorType<void>

export const useGetInstantMixFromPlaylist = <TData = Awaited<ReturnType<typeof getInstantMixFromPlaylist>>, TError = ErrorType<void>>(
  id: string,
  params?: GetInstantMixFromPlaylistParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getInstantMixFromPlaylist>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInstantMixFromPlaylistQueryKey(id, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstantMixFromPlaylist>>> = ({ signal }) => getInstantMixFromPlaylist(id, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getInstantMixFromPlaylist>>, TError, TData>(queryKey, queryFn, { enabled: !!(id), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates an instant playlist based on a given song.
 */
export const getInstantMixFromSong = (
  id: string,
  params?: GetInstantMixFromSongParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Songs/${id}/InstantMix`, method: 'get',
      params, signal
    },
  );
}


export const getGetInstantMixFromSongQueryKey = (id: string,
  params?: GetInstantMixFromSongParams,) => [`/Songs/${id}/InstantMix`, ...(params ? [params] : [])];


export type GetInstantMixFromSongQueryResult = NonNullable<Awaited<ReturnType<typeof getInstantMixFromSong>>>
export type GetInstantMixFromSongQueryError = ErrorType<void>

export const useGetInstantMixFromSong = <TData = Awaited<ReturnType<typeof getInstantMixFromSong>>, TError = ErrorType<void>>(
  id: string,
  params?: GetInstantMixFromSongParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getInstantMixFromSong>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInstantMixFromSongQueryKey(id, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstantMixFromSong>>> = ({ signal }) => getInstantMixFromSong(id, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getInstantMixFromSong>>, TError, TData>(queryKey, queryFn, { enabled: !!(id), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get the item's external id info.
 */
export const getExternalIdInfos = (
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<ExternalIdInfo[]>(
    {
      url: `/Items/${itemId}/ExternalIdInfos`, method: 'get', signal
    },
  );
}


export const getGetExternalIdInfosQueryKey = (itemId: string,) => [`/Items/${itemId}/ExternalIdInfos`];


export type GetExternalIdInfosQueryResult = NonNullable<Awaited<ReturnType<typeof getExternalIdInfos>>>
export type GetExternalIdInfosQueryError = ErrorType<void | ProblemDetails>

export const useGetExternalIdInfos = <TData = Awaited<ReturnType<typeof getExternalIdInfos>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getExternalIdInfos>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExternalIdInfosQueryKey(itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExternalIdInfos>>> = ({ signal }) => getExternalIdInfos(itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getExternalIdInfos>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Applies search criteria to an item and refreshes metadata.
 */
export const applySearchCriteria = (
  itemId: string,
  remoteSearchResult: RemoteSearchResult,
  params?: ApplySearchCriteriaParams,
) => {
  return apiInstance<void>(
    {
      url: `/Items/RemoteSearch/Apply/${itemId}`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: remoteSearchResult,
      params
    },
  );
}



export type ApplySearchCriteriaMutationResult = NonNullable<Awaited<ReturnType<typeof applySearchCriteria>>>
export type ApplySearchCriteriaMutationBody = RemoteSearchResult
export type ApplySearchCriteriaMutationError = ErrorType<unknown>

export const useApplySearchCriteria = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof applySearchCriteria>>, TError, { itemId: string; data: RemoteSearchResult; params?: ApplySearchCriteriaParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof applySearchCriteria>>, { itemId: string; data: RemoteSearchResult; params?: ApplySearchCriteriaParams }> = (props) => {
    const { itemId, data, params } = props ?? {};

    return applySearchCriteria(itemId, data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof applySearchCriteria>>, TError, { itemId: string; data: RemoteSearchResult; params?: ApplySearchCriteriaParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get book remote search.
 */
export const getBookRemoteSearchResults = (
  bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery,
) => {
  return apiInstance<RemoteSearchResult[]>(
    {
      url: `/Items/RemoteSearch/Book`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: bookInfoRemoteSearchQuery
    },
  );
}



export type GetBookRemoteSearchResultsMutationResult = NonNullable<Awaited<ReturnType<typeof getBookRemoteSearchResults>>>
export type GetBookRemoteSearchResultsMutationBody = BookInfoRemoteSearchQuery
export type GetBookRemoteSearchResultsMutationError = ErrorType<void>

export const useGetBookRemoteSearchResults = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getBookRemoteSearchResults>>, TError, { data: BookInfoRemoteSearchQuery }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getBookRemoteSearchResults>>, { data: BookInfoRemoteSearchQuery }> = (props) => {
    const { data } = props ?? {};

    return getBookRemoteSearchResults(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getBookRemoteSearchResults>>, TError, { data: BookInfoRemoteSearchQuery }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get box set remote search.
 */
export const getBoxSetRemoteSearchResults = (
  boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery,
) => {
  return apiInstance<RemoteSearchResult[]>(
    {
      url: `/Items/RemoteSearch/BoxSet`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: boxSetInfoRemoteSearchQuery
    },
  );
}



export type GetBoxSetRemoteSearchResultsMutationResult = NonNullable<Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>>
export type GetBoxSetRemoteSearchResultsMutationBody = BoxSetInfoRemoteSearchQuery
export type GetBoxSetRemoteSearchResultsMutationError = ErrorType<void>

export const useGetBoxSetRemoteSearchResults = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>, TError, { data: BoxSetInfoRemoteSearchQuery }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>, { data: BoxSetInfoRemoteSearchQuery }> = (props) => {
    const { data } = props ?? {};

    return getBoxSetRemoteSearchResults(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getBoxSetRemoteSearchResults>>, TError, { data: BoxSetInfoRemoteSearchQuery }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get movie remote search.
 */
export const getMovieRemoteSearchResults = (
  movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery,
) => {
  return apiInstance<RemoteSearchResult[]>(
    {
      url: `/Items/RemoteSearch/Movie`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: movieInfoRemoteSearchQuery
    },
  );
}



export type GetMovieRemoteSearchResultsMutationResult = NonNullable<Awaited<ReturnType<typeof getMovieRemoteSearchResults>>>
export type GetMovieRemoteSearchResultsMutationBody = MovieInfoRemoteSearchQuery
export type GetMovieRemoteSearchResultsMutationError = ErrorType<void>

export const useGetMovieRemoteSearchResults = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getMovieRemoteSearchResults>>, TError, { data: MovieInfoRemoteSearchQuery }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getMovieRemoteSearchResults>>, { data: MovieInfoRemoteSearchQuery }> = (props) => {
    const { data } = props ?? {};

    return getMovieRemoteSearchResults(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getMovieRemoteSearchResults>>, TError, { data: MovieInfoRemoteSearchQuery }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get music album remote search.
 */
export const getMusicAlbumRemoteSearchResults = (
  albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery,
) => {
  return apiInstance<RemoteSearchResult[]>(
    {
      url: `/Items/RemoteSearch/MusicAlbum`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: albumInfoRemoteSearchQuery
    },
  );
}



export type GetMusicAlbumRemoteSearchResultsMutationResult = NonNullable<Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>>
export type GetMusicAlbumRemoteSearchResultsMutationBody = AlbumInfoRemoteSearchQuery
export type GetMusicAlbumRemoteSearchResultsMutationError = ErrorType<void>

export const useGetMusicAlbumRemoteSearchResults = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>, TError, { data: AlbumInfoRemoteSearchQuery }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>, { data: AlbumInfoRemoteSearchQuery }> = (props) => {
    const { data } = props ?? {};

    return getMusicAlbumRemoteSearchResults(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getMusicAlbumRemoteSearchResults>>, TError, { data: AlbumInfoRemoteSearchQuery }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get music artist remote search.
 */
export const getMusicArtistRemoteSearchResults = (
  artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery,
) => {
  return apiInstance<RemoteSearchResult[]>(
    {
      url: `/Items/RemoteSearch/MusicArtist`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: artistInfoRemoteSearchQuery
    },
  );
}



export type GetMusicArtistRemoteSearchResultsMutationResult = NonNullable<Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>>
export type GetMusicArtistRemoteSearchResultsMutationBody = ArtistInfoRemoteSearchQuery
export type GetMusicArtistRemoteSearchResultsMutationError = ErrorType<void>

export const useGetMusicArtistRemoteSearchResults = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>, TError, { data: ArtistInfoRemoteSearchQuery }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>, { data: ArtistInfoRemoteSearchQuery }> = (props) => {
    const { data } = props ?? {};

    return getMusicArtistRemoteSearchResults(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getMusicArtistRemoteSearchResults>>, TError, { data: ArtistInfoRemoteSearchQuery }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get music video remote search.
 */
export const getMusicVideoRemoteSearchResults = (
  musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery,
) => {
  return apiInstance<RemoteSearchResult[]>(
    {
      url: `/Items/RemoteSearch/MusicVideo`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: musicVideoInfoRemoteSearchQuery
    },
  );
}



export type GetMusicVideoRemoteSearchResultsMutationResult = NonNullable<Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>>
export type GetMusicVideoRemoteSearchResultsMutationBody = MusicVideoInfoRemoteSearchQuery
export type GetMusicVideoRemoteSearchResultsMutationError = ErrorType<void>

export const useGetMusicVideoRemoteSearchResults = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>, TError, { data: MusicVideoInfoRemoteSearchQuery }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>, { data: MusicVideoInfoRemoteSearchQuery }> = (props) => {
    const { data } = props ?? {};

    return getMusicVideoRemoteSearchResults(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getMusicVideoRemoteSearchResults>>, TError, { data: MusicVideoInfoRemoteSearchQuery }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get person remote search.
 */
export const getPersonRemoteSearchResults = (
  personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery,
) => {
  return apiInstance<RemoteSearchResult[]>(
    {
      url: `/Items/RemoteSearch/Person`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: personLookupInfoRemoteSearchQuery
    },
  );
}



export type GetPersonRemoteSearchResultsMutationResult = NonNullable<Awaited<ReturnType<typeof getPersonRemoteSearchResults>>>
export type GetPersonRemoteSearchResultsMutationBody = PersonLookupInfoRemoteSearchQuery
export type GetPersonRemoteSearchResultsMutationError = ErrorType<void>

export const useGetPersonRemoteSearchResults = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getPersonRemoteSearchResults>>, TError, { data: PersonLookupInfoRemoteSearchQuery }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getPersonRemoteSearchResults>>, { data: PersonLookupInfoRemoteSearchQuery }> = (props) => {
    const { data } = props ?? {};

    return getPersonRemoteSearchResults(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getPersonRemoteSearchResults>>, TError, { data: PersonLookupInfoRemoteSearchQuery }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get series remote search.
 */
export const getSeriesRemoteSearchResults = (
  seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery,
) => {
  return apiInstance<RemoteSearchResult[]>(
    {
      url: `/Items/RemoteSearch/Series`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: seriesInfoRemoteSearchQuery
    },
  );
}



export type GetSeriesRemoteSearchResultsMutationResult = NonNullable<Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>>
export type GetSeriesRemoteSearchResultsMutationBody = SeriesInfoRemoteSearchQuery
export type GetSeriesRemoteSearchResultsMutationError = ErrorType<void>

export const useGetSeriesRemoteSearchResults = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>, TError, { data: SeriesInfoRemoteSearchQuery }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>, { data: SeriesInfoRemoteSearchQuery }> = (props) => {
    const { data } = props ?? {};

    return getSeriesRemoteSearchResults(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getSeriesRemoteSearchResults>>, TError, { data: SeriesInfoRemoteSearchQuery }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get trailer remote search.
 */
export const getTrailerRemoteSearchResults = (
  trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery,
) => {
  return apiInstance<RemoteSearchResult[]>(
    {
      url: `/Items/RemoteSearch/Trailer`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: trailerInfoRemoteSearchQuery
    },
  );
}



export type GetTrailerRemoteSearchResultsMutationResult = NonNullable<Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>>
export type GetTrailerRemoteSearchResultsMutationBody = TrailerInfoRemoteSearchQuery
export type GetTrailerRemoteSearchResultsMutationError = ErrorType<void>

export const useGetTrailerRemoteSearchResults = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>, TError, { data: TrailerInfoRemoteSearchQuery }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>, { data: TrailerInfoRemoteSearchQuery }> = (props) => {
    const { data } = props ?? {};

    return getTrailerRemoteSearchResults(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getTrailerRemoteSearchResults>>, TError, { data: TrailerInfoRemoteSearchQuery }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Refreshes metadata for an item.
 */
export const refreshItem = (
  itemId: string,
  params?: RefreshItemParams,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}/Refresh`, method: 'post',
      params
    },
  );
}



export type RefreshItemMutationResult = NonNullable<Awaited<ReturnType<typeof refreshItem>>>

export type RefreshItemMutationError = ErrorType<ProblemDetails>

export const useRefreshItem = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof refreshItem>>, TError, { itemId: string; params?: RefreshItemParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshItem>>, { itemId: string; params?: RefreshItemParams }> = (props) => {
    const { itemId, params } = props ?? {};

    return refreshItem(itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof refreshItem>>, TError, { itemId: string; params?: RefreshItemParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets items based on a query.
 */
export const getItems = (
  params?: GetItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Items`, method: 'get',
      params, signal
    },
  );
}


export const getGetItemsQueryKey = (params?: GetItemsParams,) => [`/Items`, ...(params ? [params] : [])];


export type GetItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getItems>>>
export type GetItemsQueryError = ErrorType<void>

export const useGetItems = <TData = Awaited<ReturnType<typeof getItems>>, TError = ErrorType<void>>(
  params?: GetItemsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItems>>> = ({ signal }) => getItems(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getItems>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Deletes items from the library and filesystem.
 */
export const deleteItems = (
  params?: DeleteItemsParams,
) => {
  return apiInstance<void>(
    {
      url: `/Items`, method: 'delete',
      params
    },
  );
}



export type DeleteItemsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteItems>>>

export type DeleteItemsMutationError = ErrorType<ProblemDetails>

export const useDeleteItems = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteItems>>, TError, { params?: DeleteItemsParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteItems>>, { params?: DeleteItemsParams }> = (props) => {
    const { params } = props ?? {};

    return deleteItems(params,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteItems>>, TError, { params?: DeleteItemsParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets items based on a query.
 */
export const getItemsByUserId = (
  userId: string,
  params?: GetItemsByUserIdParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Users/${userId}/Items`, method: 'get',
      params, signal
    },
  );
}


export const getGetItemsByUserIdQueryKey = (userId: string,
  params?: GetItemsByUserIdParams,) => [`/Users/${userId}/Items`, ...(params ? [params] : [])];


export type GetItemsByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsByUserId>>>
export type GetItemsByUserIdQueryError = ErrorType<void>

export const useGetItemsByUserId = <TData = Awaited<ReturnType<typeof getItemsByUserId>>, TError = ErrorType<void>>(
  userId: string,
  params?: GetItemsByUserIdParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getItemsByUserId>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemsByUserIdQueryKey(userId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsByUserId>>> = ({ signal }) => getItemsByUserId(userId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getItemsByUserId>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets items based on a query.
 */
export const getResumeItems = (
  userId: string,
  params?: GetResumeItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Users/${userId}/Items/Resume`, method: 'get',
      params, signal
    },
  );
}


export const getGetResumeItemsQueryKey = (userId: string,
  params?: GetResumeItemsParams,) => [`/Users/${userId}/Items/Resume`, ...(params ? [params] : [])];


export type GetResumeItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getResumeItems>>>
export type GetResumeItemsQueryError = ErrorType<void>

export const useGetResumeItems = <TData = Awaited<ReturnType<typeof getResumeItems>>, TError = ErrorType<void>>(
  userId: string,
  params?: GetResumeItemsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getResumeItems>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetResumeItemsQueryKey(userId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getResumeItems>>> = ({ signal }) => getResumeItems(userId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getResumeItems>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Updates an item.
 */
export const updateItem = (
  itemId: string,
  baseItemDto: BaseItemDto,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: baseItemDto
    },
  );
}



export type UpdateItemMutationResult = NonNullable<Awaited<ReturnType<typeof updateItem>>>
export type UpdateItemMutationBody = BaseItemDto
export type UpdateItemMutationError = ErrorType<ProblemDetails>

export const useUpdateItem = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateItem>>, TError, { itemId: string; data: BaseItemDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateItem>>, { itemId: string; data: BaseItemDto }> = (props) => {
    const { itemId, data } = props ?? {};

    return updateItem(itemId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateItem>>, TError, { itemId: string; data: BaseItemDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Deletes an item from the library and filesystem.
 */
export const deleteItem = (
  itemId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}`, method: 'delete'
    },
  );
}



export type DeleteItemMutationResult = NonNullable<Awaited<ReturnType<typeof deleteItem>>>

export type DeleteItemMutationError = ErrorType<ProblemDetails>

export const useDeleteItem = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteItem>>, TError, { itemId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteItem>>, { itemId: string }> = (props) => {
    const { itemId } = props ?? {};

    return deleteItem(itemId,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteItem>>, TError, { itemId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates an item's content type.
 */
export const updateItemContentType = (
  itemId: string,
  params?: UpdateItemContentTypeParams,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}/ContentType`, method: 'post',
      params
    },
  );
}



export type UpdateItemContentTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateItemContentType>>>

export type UpdateItemContentTypeMutationError = ErrorType<ProblemDetails>

export const useUpdateItemContentType = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateItemContentType>>, TError, { itemId: string; params?: UpdateItemContentTypeParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateItemContentType>>, { itemId: string; params?: UpdateItemContentTypeParams }> = (props) => {
    const { itemId, params } = props ?? {};

    return updateItemContentType(itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof updateItemContentType>>, TError, { itemId: string; params?: UpdateItemContentTypeParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets metadata editor info for an item.
 */
export const getMetadataEditorInfo = (
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<MetadataEditorInfo>(
    {
      url: `/Items/${itemId}/MetadataEditor`, method: 'get', signal
    },
  );
}


export const getGetMetadataEditorInfoQueryKey = (itemId: string,) => [`/Items/${itemId}/MetadataEditor`];


export type GetMetadataEditorInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getMetadataEditorInfo>>>
export type GetMetadataEditorInfoQueryError = ErrorType<void | ProblemDetails>

export const useGetMetadataEditorInfo = <TData = Awaited<ReturnType<typeof getMetadataEditorInfo>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMetadataEditorInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMetadataEditorInfoQueryKey(itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadataEditorInfo>>> = ({ signal }) => getMetadataEditorInfo(itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMetadataEditorInfo>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets similar items.
 */
export const getSimilarAlbums = (
  itemId: string,
  params?: GetSimilarAlbumsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Albums/${itemId}/Similar`, method: 'get',
      params, signal
    },
  );
}


export const getGetSimilarAlbumsQueryKey = (itemId: string,
  params?: GetSimilarAlbumsParams,) => [`/Albums/${itemId}/Similar`, ...(params ? [params] : [])];


export type GetSimilarAlbumsQueryResult = NonNullable<Awaited<ReturnType<typeof getSimilarAlbums>>>
export type GetSimilarAlbumsQueryError = ErrorType<void>

export const useGetSimilarAlbums = <TData = Awaited<ReturnType<typeof getSimilarAlbums>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetSimilarAlbumsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSimilarAlbums>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSimilarAlbumsQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSimilarAlbums>>> = ({ signal }) => getSimilarAlbums(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSimilarAlbums>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets similar items.
 */
export const getSimilarArtists = (
  itemId: string,
  params?: GetSimilarArtistsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Artists/${itemId}/Similar`, method: 'get',
      params, signal
    },
  );
}


export const getGetSimilarArtistsQueryKey = (itemId: string,
  params?: GetSimilarArtistsParams,) => [`/Artists/${itemId}/Similar`, ...(params ? [params] : [])];


export type GetSimilarArtistsQueryResult = NonNullable<Awaited<ReturnType<typeof getSimilarArtists>>>
export type GetSimilarArtistsQueryError = ErrorType<void>

export const useGetSimilarArtists = <TData = Awaited<ReturnType<typeof getSimilarArtists>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetSimilarArtistsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSimilarArtists>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSimilarArtistsQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSimilarArtists>>> = ({ signal }) => getSimilarArtists(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSimilarArtists>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets all parents of an item.
 */
export const getAncestors = (
  itemId: string,
  params?: GetAncestorsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto[]>(
    {
      url: `/Items/${itemId}/Ancestors`, method: 'get',
      params, signal
    },
  );
}


export const getGetAncestorsQueryKey = (itemId: string,
  params?: GetAncestorsParams,) => [`/Items/${itemId}/Ancestors`, ...(params ? [params] : [])];


export type GetAncestorsQueryResult = NonNullable<Awaited<ReturnType<typeof getAncestors>>>
export type GetAncestorsQueryError = ErrorType<void | ProblemDetails>

export const useGetAncestors = <TData = Awaited<ReturnType<typeof getAncestors>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string,
  params?: GetAncestorsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAncestors>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAncestorsQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAncestors>>> = ({ signal }) => getAncestors(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getAncestors>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @deprecated
 * @summary Gets critic review for an item.
 */
export const getCriticReviews = (
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Items/${itemId}/CriticReviews`, method: 'get', signal
    },
  );
}


export const getGetCriticReviewsQueryKey = (itemId: string,) => [`/Items/${itemId}/CriticReviews`];


export type GetCriticReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getCriticReviews>>>
export type GetCriticReviewsQueryError = ErrorType<void>

export const useGetCriticReviews = <TData = Awaited<ReturnType<typeof getCriticReviews>>, TError = ErrorType<void>>(
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getCriticReviews>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCriticReviewsQueryKey(itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCriticReviews>>> = ({ signal }) => getCriticReviews(itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getCriticReviews>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Downloads item media.
 */
export const getDownload = (
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Items/${itemId}/Download`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetDownloadQueryKey = (itemId: string,) => [`/Items/${itemId}/Download`];


export type GetDownloadQueryResult = NonNullable<Awaited<ReturnType<typeof getDownload>>>
export type GetDownloadQueryError = ErrorType<void | ProblemDetails>

export const useGetDownload = <TData = Awaited<ReturnType<typeof getDownload>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDownload>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDownloadQueryKey(itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDownload>>> = ({ signal }) => getDownload(itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDownload>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get the original file of an item.
 */
export const getFile = (
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Items/${itemId}/File`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetFileQueryKey = (itemId: string,) => [`/Items/${itemId}/File`];


export type GetFileQueryResult = NonNullable<Awaited<ReturnType<typeof getFile>>>
export type GetFileQueryError = ErrorType<void | ProblemDetails>

export const useGetFile = <TData = Awaited<ReturnType<typeof getFile>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFileQueryKey(itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFile>>> = ({ signal }) => getFile(itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getFile>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets similar items.
 */
export const getSimilarItems = (
  itemId: string,
  params?: GetSimilarItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Items/${itemId}/Similar`, method: 'get',
      params, signal
    },
  );
}


export const getGetSimilarItemsQueryKey = (itemId: string,
  params?: GetSimilarItemsParams,) => [`/Items/${itemId}/Similar`, ...(params ? [params] : [])];


export type GetSimilarItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getSimilarItems>>>
export type GetSimilarItemsQueryError = ErrorType<void>

export const useGetSimilarItems = <TData = Awaited<ReturnType<typeof getSimilarItems>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetSimilarItemsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSimilarItems>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSimilarItemsQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSimilarItems>>> = ({ signal }) => getSimilarItems(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSimilarItems>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get theme songs and videos for an item.
 */
export const getThemeMedia = (
  itemId: string,
  params?: GetThemeMediaParams,
  signal?: AbortSignal
) => {
  return apiInstance<AllThemeMediaResult>(
    {
      url: `/Items/${itemId}/ThemeMedia`, method: 'get',
      params, signal
    },
  );
}


export const getGetThemeMediaQueryKey = (itemId: string,
  params?: GetThemeMediaParams,) => [`/Items/${itemId}/ThemeMedia`, ...(params ? [params] : [])];


export type GetThemeMediaQueryResult = NonNullable<Awaited<ReturnType<typeof getThemeMedia>>>
export type GetThemeMediaQueryError = ErrorType<void>

export const useGetThemeMedia = <TData = Awaited<ReturnType<typeof getThemeMedia>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetThemeMediaParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getThemeMedia>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetThemeMediaQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getThemeMedia>>> = ({ signal }) => getThemeMedia(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getThemeMedia>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get theme songs for an item.
 */
export const getThemeSongs = (
  itemId: string,
  params?: GetThemeSongsParams,
  signal?: AbortSignal
) => {
  return apiInstance<ThemeMediaResult>(
    {
      url: `/Items/${itemId}/ThemeSongs`, method: 'get',
      params, signal
    },
  );
}


export const getGetThemeSongsQueryKey = (itemId: string,
  params?: GetThemeSongsParams,) => [`/Items/${itemId}/ThemeSongs`, ...(params ? [params] : [])];


export type GetThemeSongsQueryResult = NonNullable<Awaited<ReturnType<typeof getThemeSongs>>>
export type GetThemeSongsQueryError = ErrorType<void | ProblemDetails>

export const useGetThemeSongs = <TData = Awaited<ReturnType<typeof getThemeSongs>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string,
  params?: GetThemeSongsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getThemeSongs>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetThemeSongsQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getThemeSongs>>> = ({ signal }) => getThemeSongs(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getThemeSongs>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get theme videos for an item.
 */
export const getThemeVideos = (
  itemId: string,
  params?: GetThemeVideosParams,
  signal?: AbortSignal
) => {
  return apiInstance<ThemeMediaResult>(
    {
      url: `/Items/${itemId}/ThemeVideos`, method: 'get',
      params, signal
    },
  );
}


export const getGetThemeVideosQueryKey = (itemId: string,
  params?: GetThemeVideosParams,) => [`/Items/${itemId}/ThemeVideos`, ...(params ? [params] : [])];


export type GetThemeVideosQueryResult = NonNullable<Awaited<ReturnType<typeof getThemeVideos>>>
export type GetThemeVideosQueryError = ErrorType<void | ProblemDetails>

export const useGetThemeVideos = <TData = Awaited<ReturnType<typeof getThemeVideos>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string,
  params?: GetThemeVideosParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getThemeVideos>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetThemeVideosQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getThemeVideos>>> = ({ signal }) => getThemeVideos(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getThemeVideos>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get item counts.
 */
export const getItemCounts = (
  params?: GetItemCountsParams,
  signal?: AbortSignal
) => {
  return apiInstance<ItemCounts>(
    {
      url: `/Items/Counts`, method: 'get',
      params, signal
    },
  );
}


export const getGetItemCountsQueryKey = (params?: GetItemCountsParams,) => [`/Items/Counts`, ...(params ? [params] : [])];


export type GetItemCountsQueryResult = NonNullable<Awaited<ReturnType<typeof getItemCounts>>>
export type GetItemCountsQueryError = ErrorType<void>

export const useGetItemCounts = <TData = Awaited<ReturnType<typeof getItemCounts>>, TError = ErrorType<void>>(
  params?: GetItemCountsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getItemCounts>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemCountsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemCounts>>> = ({ signal }) => getItemCounts(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getItemCounts>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the library options info.
 */
export const getLibraryOptionsInfo = (
  params?: GetLibraryOptionsInfoParams,
  signal?: AbortSignal
) => {
  return apiInstance<LibraryOptionsResultDto>(
    {
      url: `/Libraries/AvailableOptions`, method: 'get',
      params, signal
    },
  );
}


export const getGetLibraryOptionsInfoQueryKey = (params?: GetLibraryOptionsInfoParams,) => [`/Libraries/AvailableOptions`, ...(params ? [params] : [])];


export type GetLibraryOptionsInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getLibraryOptionsInfo>>>
export type GetLibraryOptionsInfoQueryError = ErrorType<void>

export const useGetLibraryOptionsInfo = <TData = Awaited<ReturnType<typeof getLibraryOptionsInfo>>, TError = ErrorType<void>>(
  params?: GetLibraryOptionsInfoParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLibraryOptionsInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLibraryOptionsInfoQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLibraryOptionsInfo>>> = ({ signal }) => getLibraryOptionsInfo(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLibraryOptionsInfo>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Reports that new movies have been added by an external source.
 */
export const postUpdatedMedia = (
  mediaUpdateInfoDto: MediaUpdateInfoDto,
) => {
  return apiInstance<void>(
    {
      url: `/Library/Media/Updated`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: mediaUpdateInfoDto
    },
  );
}



export type PostUpdatedMediaMutationResult = NonNullable<Awaited<ReturnType<typeof postUpdatedMedia>>>
export type PostUpdatedMediaMutationBody = MediaUpdateInfoDto
export type PostUpdatedMediaMutationError = ErrorType<unknown>

export const usePostUpdatedMedia = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUpdatedMedia>>, TError, { data: MediaUpdateInfoDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUpdatedMedia>>, { data: MediaUpdateInfoDto }> = (props) => {
    const { data } = props ?? {};

    return postUpdatedMedia(data,)
  }



  return useMutation<Awaited<ReturnType<typeof postUpdatedMedia>>, TError, { data: MediaUpdateInfoDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets all user media folders.
 */
export const getMediaFolders = (
  params?: GetMediaFoldersParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Library/MediaFolders`, method: 'get',
      params, signal
    },
  );
}


export const getGetMediaFoldersQueryKey = (params?: GetMediaFoldersParams,) => [`/Library/MediaFolders`, ...(params ? [params] : [])];


export type GetMediaFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getMediaFolders>>>
export type GetMediaFoldersQueryError = ErrorType<void>

export const useGetMediaFolders = <TData = Awaited<ReturnType<typeof getMediaFolders>>, TError = ErrorType<void>>(
  params?: GetMediaFoldersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMediaFolders>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaFoldersQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMediaFolders>>> = ({ signal }) => getMediaFolders(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMediaFolders>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Reports that new movies have been added by an external source.
 */
export const postAddedMovies = (
  params?: PostAddedMoviesParams,
) => {
  return apiInstance<void>(
    {
      url: `/Library/Movies/Added`, method: 'post',
      params
    },
  );
}



export type PostAddedMoviesMutationResult = NonNullable<Awaited<ReturnType<typeof postAddedMovies>>>

export type PostAddedMoviesMutationError = ErrorType<unknown>

export const usePostAddedMovies = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postAddedMovies>>, TError, { params?: PostAddedMoviesParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAddedMovies>>, { params?: PostAddedMoviesParams }> = (props) => {
    const { params } = props ?? {};

    return postAddedMovies(params,)
  }



  return useMutation<Awaited<ReturnType<typeof postAddedMovies>>, TError, { params?: PostAddedMoviesParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports that new movies have been added by an external source.
 */
export const postUpdatedMovies = (
  params?: PostUpdatedMoviesParams,
) => {
  return apiInstance<void>(
    {
      url: `/Library/Movies/Updated`, method: 'post',
      params
    },
  );
}



export type PostUpdatedMoviesMutationResult = NonNullable<Awaited<ReturnType<typeof postUpdatedMovies>>>

export type PostUpdatedMoviesMutationError = ErrorType<unknown>

export const usePostUpdatedMovies = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUpdatedMovies>>, TError, { params?: PostUpdatedMoviesParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUpdatedMovies>>, { params?: PostUpdatedMoviesParams }> = (props) => {
    const { params } = props ?? {};

    return postUpdatedMovies(params,)
  }



  return useMutation<Awaited<ReturnType<typeof postUpdatedMovies>>, TError, { params?: PostUpdatedMoviesParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a list of physical paths from virtual folders.
 */
export const getPhysicalPaths = (

  signal?: AbortSignal
) => {
  return apiInstance<string[]>(
    {
      url: `/Library/PhysicalPaths`, method: 'get', signal
    },
  );
}


export const getGetPhysicalPathsQueryKey = () => [`/Library/PhysicalPaths`];


export type GetPhysicalPathsQueryResult = NonNullable<Awaited<ReturnType<typeof getPhysicalPaths>>>
export type GetPhysicalPathsQueryError = ErrorType<void>

export const useGetPhysicalPaths = <TData = Awaited<ReturnType<typeof getPhysicalPaths>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPhysicalPaths>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhysicalPathsQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhysicalPaths>>> = ({ signal }) => getPhysicalPaths(signal);




  const query = useQuery<Awaited<ReturnType<typeof getPhysicalPaths>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Starts a library scan.
 */
export const refreshLibrary = (

) => {
  return apiInstance<void>(
    {
      url: `/Library/Refresh`, method: 'post'
    },
  );
}



export type RefreshLibraryMutationResult = NonNullable<Awaited<ReturnType<typeof refreshLibrary>>>

export type RefreshLibraryMutationError = ErrorType<unknown>

export const useRefreshLibrary = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof refreshLibrary>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshLibrary>>, TVariables> = () => {


    return refreshLibrary()
  }



  return useMutation<Awaited<ReturnType<typeof refreshLibrary>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports that new episodes of a series have been added by an external source.
 */
export const postAddedSeries = (
  params?: PostAddedSeriesParams,
) => {
  return apiInstance<void>(
    {
      url: `/Library/Series/Added`, method: 'post',
      params
    },
  );
}



export type PostAddedSeriesMutationResult = NonNullable<Awaited<ReturnType<typeof postAddedSeries>>>

export type PostAddedSeriesMutationError = ErrorType<unknown>

export const usePostAddedSeries = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postAddedSeries>>, TError, { params?: PostAddedSeriesParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAddedSeries>>, { params?: PostAddedSeriesParams }> = (props) => {
    const { params } = props ?? {};

    return postAddedSeries(params,)
  }



  return useMutation<Awaited<ReturnType<typeof postAddedSeries>>, TError, { params?: PostAddedSeriesParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports that new episodes of a series have been added by an external source.
 */
export const postUpdatedSeries = (
  params?: PostUpdatedSeriesParams,
) => {
  return apiInstance<void>(
    {
      url: `/Library/Series/Updated`, method: 'post',
      params
    },
  );
}



export type PostUpdatedSeriesMutationResult = NonNullable<Awaited<ReturnType<typeof postUpdatedSeries>>>

export type PostUpdatedSeriesMutationError = ErrorType<unknown>

export const usePostUpdatedSeries = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUpdatedSeries>>, TError, { params?: PostUpdatedSeriesParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUpdatedSeries>>, { params?: PostUpdatedSeriesParams }> = (props) => {
    const { params } = props ?? {};

    return postUpdatedSeries(params,)
  }



  return useMutation<Awaited<ReturnType<typeof postUpdatedSeries>>, TError, { params?: PostUpdatedSeriesParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets similar items.
 */
export const getSimilarMovies = (
  itemId: string,
  params?: GetSimilarMoviesParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Movies/${itemId}/Similar`, method: 'get',
      params, signal
    },
  );
}


export const getGetSimilarMoviesQueryKey = (itemId: string,
  params?: GetSimilarMoviesParams,) => [`/Movies/${itemId}/Similar`, ...(params ? [params] : [])];


export type GetSimilarMoviesQueryResult = NonNullable<Awaited<ReturnType<typeof getSimilarMovies>>>
export type GetSimilarMoviesQueryError = ErrorType<void>

export const useGetSimilarMovies = <TData = Awaited<ReturnType<typeof getSimilarMovies>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetSimilarMoviesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSimilarMovies>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSimilarMoviesQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSimilarMovies>>> = ({ signal }) => getSimilarMovies(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSimilarMovies>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets similar items.
 */
export const getSimilarShows = (
  itemId: string,
  params?: GetSimilarShowsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Shows/${itemId}/Similar`, method: 'get',
      params, signal
    },
  );
}


export const getGetSimilarShowsQueryKey = (itemId: string,
  params?: GetSimilarShowsParams,) => [`/Shows/${itemId}/Similar`, ...(params ? [params] : [])];


export type GetSimilarShowsQueryResult = NonNullable<Awaited<ReturnType<typeof getSimilarShows>>>
export type GetSimilarShowsQueryError = ErrorType<void>

export const useGetSimilarShows = <TData = Awaited<ReturnType<typeof getSimilarShows>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetSimilarShowsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSimilarShows>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSimilarShowsQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSimilarShows>>> = ({ signal }) => getSimilarShows(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSimilarShows>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets similar items.
 */
export const getSimilarTrailers = (
  itemId: string,
  params?: GetSimilarTrailersParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Trailers/${itemId}/Similar`, method: 'get',
      params, signal
    },
  );
}


export const getGetSimilarTrailersQueryKey = (itemId: string,
  params?: GetSimilarTrailersParams,) => [`/Trailers/${itemId}/Similar`, ...(params ? [params] : [])];


export type GetSimilarTrailersQueryResult = NonNullable<Awaited<ReturnType<typeof getSimilarTrailers>>>
export type GetSimilarTrailersQueryError = ErrorType<void>

export const useGetSimilarTrailers = <TData = Awaited<ReturnType<typeof getSimilarTrailers>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetSimilarTrailersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSimilarTrailers>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSimilarTrailersQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSimilarTrailers>>> = ({ signal }) => getSimilarTrailers(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSimilarTrailers>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets all virtual folders.
 */
export const getVirtualFolders = (

  signal?: AbortSignal
) => {
  return apiInstance<VirtualFolderInfo[]>(
    {
      url: `/Library/VirtualFolders`, method: 'get', signal
    },
  );
}


export const getGetVirtualFoldersQueryKey = () => [`/Library/VirtualFolders`];


export type GetVirtualFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getVirtualFolders>>>
export type GetVirtualFoldersQueryError = ErrorType<void>

export const useGetVirtualFolders = <TData = Awaited<ReturnType<typeof getVirtualFolders>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getVirtualFolders>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVirtualFoldersQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVirtualFolders>>> = ({ signal }) => getVirtualFolders(signal);




  const query = useQuery<Awaited<ReturnType<typeof getVirtualFolders>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Adds a virtual folder.
 */
export const addVirtualFolder = (
  addVirtualFolderDto: AddVirtualFolderDto,
  params?: AddVirtualFolderParams,
) => {
  return apiInstance<void>(
    {
      url: `/Library/VirtualFolders`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: addVirtualFolderDto,
      params
    },
  );
}



export type AddVirtualFolderMutationResult = NonNullable<Awaited<ReturnType<typeof addVirtualFolder>>>
export type AddVirtualFolderMutationBody = AddVirtualFolderDto
export type AddVirtualFolderMutationError = ErrorType<unknown>

export const useAddVirtualFolder = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof addVirtualFolder>>, TError, { data: AddVirtualFolderDto; params?: AddVirtualFolderParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addVirtualFolder>>, { data: AddVirtualFolderDto; params?: AddVirtualFolderParams }> = (props) => {
    const { data, params } = props ?? {};

    return addVirtualFolder(data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof addVirtualFolder>>, TError, { data: AddVirtualFolderDto; params?: AddVirtualFolderParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Removes a virtual folder.
 */
export const removeVirtualFolder = (
  params?: RemoveVirtualFolderParams,
) => {
  return apiInstance<void>(
    {
      url: `/Library/VirtualFolders`, method: 'delete',
      params
    },
  );
}



export type RemoveVirtualFolderMutationResult = NonNullable<Awaited<ReturnType<typeof removeVirtualFolder>>>

export type RemoveVirtualFolderMutationError = ErrorType<unknown>

export const useRemoveVirtualFolder = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeVirtualFolder>>, TError, { params?: RemoveVirtualFolderParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeVirtualFolder>>, { params?: RemoveVirtualFolderParams }> = (props) => {
    const { params } = props ?? {};

    return removeVirtualFolder(params,)
  }



  return useMutation<Awaited<ReturnType<typeof removeVirtualFolder>>, TError, { params?: RemoveVirtualFolderParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Update library options.
 */
export const updateLibraryOptions = (
  updateLibraryOptionsDto: UpdateLibraryOptionsDto,
) => {
  return apiInstance<void>(
    {
      url: `/Library/VirtualFolders/LibraryOptions`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: updateLibraryOptionsDto
    },
  );
}



export type UpdateLibraryOptionsMutationResult = NonNullable<Awaited<ReturnType<typeof updateLibraryOptions>>>
export type UpdateLibraryOptionsMutationBody = UpdateLibraryOptionsDto
export type UpdateLibraryOptionsMutationError = ErrorType<unknown>

export const useUpdateLibraryOptions = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateLibraryOptions>>, TError, { data: UpdateLibraryOptionsDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateLibraryOptions>>, { data: UpdateLibraryOptionsDto }> = (props) => {
    const { data } = props ?? {};

    return updateLibraryOptions(data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateLibraryOptions>>, TError, { data: UpdateLibraryOptionsDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Renames a virtual folder.
 */
export const renameVirtualFolder = (
  params?: RenameVirtualFolderParams,
) => {
  return apiInstance<void>(
    {
      url: `/Library/VirtualFolders/Name`, method: 'post',
      params
    },
  );
}



export type RenameVirtualFolderMutationResult = NonNullable<Awaited<ReturnType<typeof renameVirtualFolder>>>

export type RenameVirtualFolderMutationError = ErrorType<ProblemDetails>

export const useRenameVirtualFolder = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof renameVirtualFolder>>, TError, { params?: RenameVirtualFolderParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof renameVirtualFolder>>, { params?: RenameVirtualFolderParams }> = (props) => {
    const { params } = props ?? {};

    return renameVirtualFolder(params,)
  }



  return useMutation<Awaited<ReturnType<typeof renameVirtualFolder>>, TError, { params?: RenameVirtualFolderParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Add a media path to a library.
 */
export const addMediaPath = (
  mediaPathDto: MediaPathDto,
  params?: AddMediaPathParams,
) => {
  return apiInstance<void>(
    {
      url: `/Library/VirtualFolders/Paths`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: mediaPathDto,
      params
    },
  );
}



export type AddMediaPathMutationResult = NonNullable<Awaited<ReturnType<typeof addMediaPath>>>
export type AddMediaPathMutationBody = MediaPathDto
export type AddMediaPathMutationError = ErrorType<unknown>

export const useAddMediaPath = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof addMediaPath>>, TError, { data: MediaPathDto; params?: AddMediaPathParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addMediaPath>>, { data: MediaPathDto; params?: AddMediaPathParams }> = (props) => {
    const { data, params } = props ?? {};

    return addMediaPath(data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof addMediaPath>>, TError, { data: MediaPathDto; params?: AddMediaPathParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Remove a media path.
 */
export const removeMediaPath = (
  params?: RemoveMediaPathParams,
) => {
  return apiInstance<void>(
    {
      url: `/Library/VirtualFolders/Paths`, method: 'delete',
      params
    },
  );
}



export type RemoveMediaPathMutationResult = NonNullable<Awaited<ReturnType<typeof removeMediaPath>>>

export type RemoveMediaPathMutationError = ErrorType<unknown>

export const useRemoveMediaPath = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeMediaPath>>, TError, { params?: RemoveMediaPathParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeMediaPath>>, { params?: RemoveMediaPathParams }> = (props) => {
    const { params } = props ?? {};

    return removeMediaPath(params,)
  }



  return useMutation<Awaited<ReturnType<typeof removeMediaPath>>, TError, { params?: RemoveMediaPathParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a media path.
 */
export const updateMediaPath = (
  updateMediaPathRequestDto: UpdateMediaPathRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/Library/VirtualFolders/Paths/Update`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: updateMediaPathRequestDto
    },
  );
}



export type UpdateMediaPathMutationResult = NonNullable<Awaited<ReturnType<typeof updateMediaPath>>>
export type UpdateMediaPathMutationBody = UpdateMediaPathRequestDto
export type UpdateMediaPathMutationError = ErrorType<unknown>

export const useUpdateMediaPath = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateMediaPath>>, TError, { data: UpdateMediaPathRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMediaPath>>, { data: UpdateMediaPathRequestDto }> = (props) => {
    const { data } = props ?? {};

    return updateMediaPath(data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateMediaPath>>, TError, { data: UpdateMediaPathRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get channel mapping options.
 */
export const getChannelMappingOptions = (
  params?: GetChannelMappingOptionsParams,
  signal?: AbortSignal
) => {
  return apiInstance<ChannelMappingOptionsDto>(
    {
      url: `/LiveTv/ChannelMappingOptions`, method: 'get',
      params, signal
    },
  );
}


export const getGetChannelMappingOptionsQueryKey = (params?: GetChannelMappingOptionsParams,) => [`/LiveTv/ChannelMappingOptions`, ...(params ? [params] : [])];


export type GetChannelMappingOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelMappingOptions>>>
export type GetChannelMappingOptionsQueryError = ErrorType<void>

export const useGetChannelMappingOptions = <TData = Awaited<ReturnType<typeof getChannelMappingOptions>>, TError = ErrorType<void>>(
  params?: GetChannelMappingOptionsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getChannelMappingOptions>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChannelMappingOptionsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelMappingOptions>>> = ({ signal }) => getChannelMappingOptions(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getChannelMappingOptions>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Set channel mappings.
 */
export const setChannelMapping = (
  setChannelMappingDto: SetChannelMappingDto,
) => {
  return apiInstance<TunerChannelMapping>(
    {
      url: `/LiveTv/ChannelMappings`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: setChannelMappingDto
    },
  );
}



export type SetChannelMappingMutationResult = NonNullable<Awaited<ReturnType<typeof setChannelMapping>>>
export type SetChannelMappingMutationBody = SetChannelMappingDto
export type SetChannelMappingMutationError = ErrorType<void>

export const useSetChannelMapping = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof setChannelMapping>>, TError, { data: SetChannelMappingDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setChannelMapping>>, { data: SetChannelMappingDto }> = (props) => {
    const { data } = props ?? {};

    return setChannelMapping(data,)
  }



  return useMutation<Awaited<ReturnType<typeof setChannelMapping>>, TError, { data: SetChannelMappingDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets available live tv channels.
 */
export const getLiveTvChannels = (
  params?: GetLiveTvChannelsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/LiveTv/Channels`, method: 'get',
      params, signal
    },
  );
}


export const getGetLiveTvChannelsQueryKey = (params?: GetLiveTvChannelsParams,) => [`/LiveTv/Channels`, ...(params ? [params] : [])];


export type GetLiveTvChannelsQueryResult = NonNullable<Awaited<ReturnType<typeof getLiveTvChannels>>>
export type GetLiveTvChannelsQueryError = ErrorType<void>

export const useGetLiveTvChannels = <TData = Awaited<ReturnType<typeof getLiveTvChannels>>, TError = ErrorType<void>>(
  params?: GetLiveTvChannelsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLiveTvChannels>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLiveTvChannelsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLiveTvChannels>>> = ({ signal }) => getLiveTvChannels(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLiveTvChannels>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a live tv channel.
 */
export const getChannel = (
  channelId: string,
  params?: GetChannelParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/LiveTv/Channels/${channelId}`, method: 'get',
      params, signal
    },
  );
}


export const getGetChannelQueryKey = (channelId: string,
  params?: GetChannelParams,) => [`/LiveTv/Channels/${channelId}`, ...(params ? [params] : [])];


export type GetChannelQueryResult = NonNullable<Awaited<ReturnType<typeof getChannel>>>
export type GetChannelQueryError = ErrorType<void>

export const useGetChannel = <TData = Awaited<ReturnType<typeof getChannel>>, TError = ErrorType<void>>(
  channelId: string,
  params?: GetChannelParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getChannel>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChannelQueryKey(channelId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannel>>> = ({ signal }) => getChannel(channelId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getChannel>>, TError, TData>(queryKey, queryFn, { enabled: !!(channelId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get guid info.
 */
export const getGuideInfo = (

  signal?: AbortSignal
) => {
  return apiInstance<GuideInfo>(
    {
      url: `/LiveTv/GuideInfo`, method: 'get', signal
    },
  );
}


export const getGetGuideInfoQueryKey = () => [`/LiveTv/GuideInfo`];


export type GetGuideInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getGuideInfo>>>
export type GetGuideInfoQueryError = ErrorType<void>

export const useGetGuideInfo = <TData = Awaited<ReturnType<typeof getGuideInfo>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getGuideInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGuideInfoQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGuideInfo>>> = ({ signal }) => getGuideInfo(signal);




  const query = useQuery<Awaited<ReturnType<typeof getGuideInfo>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets available live tv services.
 */
export const getLiveTvInfo = (

  signal?: AbortSignal
) => {
  return apiInstance<LiveTvInfo>(
    {
      url: `/LiveTv/Info`, method: 'get', signal
    },
  );
}


export const getGetLiveTvInfoQueryKey = () => [`/LiveTv/Info`];


export type GetLiveTvInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getLiveTvInfo>>>
export type GetLiveTvInfoQueryError = ErrorType<void>

export const useGetLiveTvInfo = <TData = Awaited<ReturnType<typeof getLiveTvInfo>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLiveTvInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLiveTvInfoQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLiveTvInfo>>> = ({ signal }) => getLiveTvInfo(signal);




  const query = useQuery<Awaited<ReturnType<typeof getLiveTvInfo>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Adds a listings provider.
 */
export const addListingProvider = (
  listingsProviderInfo: ListingsProviderInfo,
  params?: AddListingProviderParams,
) => {
  return apiInstance<ListingsProviderInfo>(
    {
      url: `/LiveTv/ListingProviders`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: listingsProviderInfo,
      params
    },
  );
}



export type AddListingProviderMutationResult = NonNullable<Awaited<ReturnType<typeof addListingProvider>>>
export type AddListingProviderMutationBody = ListingsProviderInfo
export type AddListingProviderMutationError = ErrorType<void>

export const useAddListingProvider = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof addListingProvider>>, TError, { data: ListingsProviderInfo; params?: AddListingProviderParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addListingProvider>>, { data: ListingsProviderInfo; params?: AddListingProviderParams }> = (props) => {
    const { data, params } = props ?? {};

    return addListingProvider(data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof addListingProvider>>, TError, { data: ListingsProviderInfo; params?: AddListingProviderParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Delete listing provider.
 */
export const deleteListingProvider = (
  params?: DeleteListingProviderParams,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/ListingProviders`, method: 'delete',
      params
    },
  );
}



export type DeleteListingProviderMutationResult = NonNullable<Awaited<ReturnType<typeof deleteListingProvider>>>

export type DeleteListingProviderMutationError = ErrorType<unknown>

export const useDeleteListingProvider = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteListingProvider>>, TError, { params?: DeleteListingProviderParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteListingProvider>>, { params?: DeleteListingProviderParams }> = (props) => {
    const { params } = props ?? {};

    return deleteListingProvider(params,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteListingProvider>>, TError, { params?: DeleteListingProviderParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets default listings provider info.
 */
export const getDefaultListingProvider = (

  signal?: AbortSignal
) => {
  return apiInstance<ListingsProviderInfo>(
    {
      url: `/LiveTv/ListingProviders/Default`, method: 'get', signal
    },
  );
}


export const getGetDefaultListingProviderQueryKey = () => [`/LiveTv/ListingProviders/Default`];


export type GetDefaultListingProviderQueryResult = NonNullable<Awaited<ReturnType<typeof getDefaultListingProvider>>>
export type GetDefaultListingProviderQueryError = ErrorType<void>

export const useGetDefaultListingProvider = <TData = Awaited<ReturnType<typeof getDefaultListingProvider>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDefaultListingProvider>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultListingProviderQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultListingProvider>>> = ({ signal }) => getDefaultListingProvider(signal);




  const query = useQuery<Awaited<ReturnType<typeof getDefaultListingProvider>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets available lineups.
 */
export const getLineups = (
  params?: GetLineupsParams,
  signal?: AbortSignal
) => {
  return apiInstance<NameIdPair[]>(
    {
      url: `/LiveTv/ListingProviders/Lineups`, method: 'get',
      params, signal
    },
  );
}


export const getGetLineupsQueryKey = (params?: GetLineupsParams,) => [`/LiveTv/ListingProviders/Lineups`, ...(params ? [params] : [])];


export type GetLineupsQueryResult = NonNullable<Awaited<ReturnType<typeof getLineups>>>
export type GetLineupsQueryError = ErrorType<void>

export const useGetLineups = <TData = Awaited<ReturnType<typeof getLineups>>, TError = ErrorType<void>>(
  params?: GetLineupsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLineups>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLineupsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLineups>>> = ({ signal }) => getLineups(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLineups>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets available countries.
 */
export const getSchedulesDirectCountries = (

  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/LiveTv/ListingProviders/SchedulesDirect/Countries`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetSchedulesDirectCountriesQueryKey = () => [`/LiveTv/ListingProviders/SchedulesDirect/Countries`];


export type GetSchedulesDirectCountriesQueryResult = NonNullable<Awaited<ReturnType<typeof getSchedulesDirectCountries>>>
export type GetSchedulesDirectCountriesQueryError = ErrorType<void>

export const useGetSchedulesDirectCountries = <TData = Awaited<ReturnType<typeof getSchedulesDirectCountries>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSchedulesDirectCountries>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSchedulesDirectCountriesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchedulesDirectCountries>>> = ({ signal }) => getSchedulesDirectCountries(signal);




  const query = useQuery<Awaited<ReturnType<typeof getSchedulesDirectCountries>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a live tv recording stream.
 */
export const getLiveRecordingFile = (
  recordingId: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/LiveTv/LiveRecordings/${recordingId}/stream`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetLiveRecordingFileQueryKey = (recordingId: string,) => [`/LiveTv/LiveRecordings/${recordingId}/stream`];


export type GetLiveRecordingFileQueryResult = NonNullable<Awaited<ReturnType<typeof getLiveRecordingFile>>>
export type GetLiveRecordingFileQueryError = ErrorType<ProblemDetails>

export const useGetLiveRecordingFile = <TData = Awaited<ReturnType<typeof getLiveRecordingFile>>, TError = ErrorType<ProblemDetails>>(
  recordingId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLiveRecordingFile>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLiveRecordingFileQueryKey(recordingId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLiveRecordingFile>>> = ({ signal }) => getLiveRecordingFile(recordingId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLiveRecordingFile>>, TError, TData>(queryKey, queryFn, { enabled: !!(recordingId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a live tv channel stream.
 */
export const getLiveStreamFile = (
  streamId: string,
  container: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/LiveTv/LiveStreamFiles/${streamId}/stream.${container}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetLiveStreamFileQueryKey = (streamId: string,
  container: string,) => [`/LiveTv/LiveStreamFiles/${streamId}/stream.${container}`];


export type GetLiveStreamFileQueryResult = NonNullable<Awaited<ReturnType<typeof getLiveStreamFile>>>
export type GetLiveStreamFileQueryError = ErrorType<ProblemDetails>

export const useGetLiveStreamFile = <TData = Awaited<ReturnType<typeof getLiveStreamFile>>, TError = ErrorType<ProblemDetails>>(
  streamId: string,
  container: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLiveStreamFile>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLiveStreamFileQueryKey(streamId, container);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLiveStreamFile>>> = ({ signal }) => getLiveStreamFile(streamId, container, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLiveStreamFile>>, TError, TData>(queryKey, queryFn, { enabled: !!(streamId && container), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets available live tv epgs.
 */
export const getLiveTvPrograms = (
  params?: GetLiveTvProgramsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/LiveTv/Programs`, method: 'get',
      params, signal
    },
  );
}


export const getGetLiveTvProgramsQueryKey = (params?: GetLiveTvProgramsParams,) => [`/LiveTv/Programs`, ...(params ? [params] : [])];


export type GetLiveTvProgramsQueryResult = NonNullable<Awaited<ReturnType<typeof getLiveTvPrograms>>>
export type GetLiveTvProgramsQueryError = ErrorType<void>

export const useGetLiveTvPrograms = <TData = Awaited<ReturnType<typeof getLiveTvPrograms>>, TError = ErrorType<void>>(
  params?: GetLiveTvProgramsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLiveTvPrograms>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLiveTvProgramsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLiveTvPrograms>>> = ({ signal }) => getLiveTvPrograms(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLiveTvPrograms>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets available live tv epgs.
 */
export const getPrograms = (
  getProgramsDto: GetProgramsDto,
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/LiveTv/Programs`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: getProgramsDto
    },
  );
}



export type GetProgramsMutationResult = NonNullable<Awaited<ReturnType<typeof getPrograms>>>
export type GetProgramsMutationBody = GetProgramsDto
export type GetProgramsMutationError = ErrorType<void>

export const useGetPrograms = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getPrograms>>, TError, { data: GetProgramsDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getPrograms>>, { data: GetProgramsDto }> = (props) => {
    const { data } = props ?? {};

    return getPrograms(data,)
  }



  return useMutation<Awaited<ReturnType<typeof getPrograms>>, TError, { data: GetProgramsDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a live tv program.
 */
export const getProgram = (
  programId: string,
  params?: GetProgramParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/LiveTv/Programs/${programId}`, method: 'get',
      params, signal
    },
  );
}


export const getGetProgramQueryKey = (programId: string,
  params?: GetProgramParams,) => [`/LiveTv/Programs/${programId}`, ...(params ? [params] : [])];


export type GetProgramQueryResult = NonNullable<Awaited<ReturnType<typeof getProgram>>>
export type GetProgramQueryError = ErrorType<void>

export const useGetProgram = <TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(
  programId: string,
  params?: GetProgramParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProgramQueryKey(programId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgram>>> = ({ signal }) => getProgram(programId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getProgram>>, TError, TData>(queryKey, queryFn, { enabled: !!(programId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets recommended live tv epgs.
 */
export const getRecommendedPrograms = (
  params?: GetRecommendedProgramsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/LiveTv/Programs/Recommended`, method: 'get',
      params, signal
    },
  );
}


export const getGetRecommendedProgramsQueryKey = (params?: GetRecommendedProgramsParams,) => [`/LiveTv/Programs/Recommended`, ...(params ? [params] : [])];


export type GetRecommendedProgramsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendedPrograms>>>
export type GetRecommendedProgramsQueryError = ErrorType<void>

export const useGetRecommendedPrograms = <TData = Awaited<ReturnType<typeof getRecommendedPrograms>>, TError = ErrorType<void>>(
  params?: GetRecommendedProgramsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRecommendedPrograms>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendedProgramsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendedPrograms>>> = ({ signal }) => getRecommendedPrograms(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRecommendedPrograms>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets live tv recordings.
 */
export const getRecordings = (
  params?: GetRecordingsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/LiveTv/Recordings`, method: 'get',
      params, signal
    },
  );
}


export const getGetRecordingsQueryKey = (params?: GetRecordingsParams,) => [`/LiveTv/Recordings`, ...(params ? [params] : [])];


export type GetRecordingsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecordings>>>
export type GetRecordingsQueryError = ErrorType<void>

export const useGetRecordings = <TData = Awaited<ReturnType<typeof getRecordings>>, TError = ErrorType<void>>(
  params?: GetRecordingsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRecordings>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecordingsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecordings>>> = ({ signal }) => getRecordings(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRecordings>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a live tv recording.
 */
export const getRecording = (
  recordingId: string,
  params?: GetRecordingParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/LiveTv/Recordings/${recordingId}`, method: 'get',
      params, signal
    },
  );
}


export const getGetRecordingQueryKey = (recordingId: string,
  params?: GetRecordingParams,) => [`/LiveTv/Recordings/${recordingId}`, ...(params ? [params] : [])];


export type GetRecordingQueryResult = NonNullable<Awaited<ReturnType<typeof getRecording>>>
export type GetRecordingQueryError = ErrorType<void>

export const useGetRecording = <TData = Awaited<ReturnType<typeof getRecording>>, TError = ErrorType<void>>(
  recordingId: string,
  params?: GetRecordingParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecordingQueryKey(recordingId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecording>>> = ({ signal }) => getRecording(recordingId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRecording>>, TError, TData>(queryKey, queryFn, { enabled: !!(recordingId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Deletes a live tv recording.
 */
export const deleteRecording = (
  recordingId: string,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/Recordings/${recordingId}`, method: 'delete'
    },
  );
}



export type DeleteRecordingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRecording>>>

export type DeleteRecordingMutationError = ErrorType<ProblemDetails>

export const useDeleteRecording = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteRecording>>, TError, { recordingId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRecording>>, { recordingId: string }> = (props) => {
    const { recordingId } = props ?? {};

    return deleteRecording(recordingId,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteRecording>>, TError, { recordingId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets recording folders.
 */
export const getRecordingFolders = (
  params?: GetRecordingFoldersParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/LiveTv/Recordings/Folders`, method: 'get',
      params, signal
    },
  );
}


export const getGetRecordingFoldersQueryKey = (params?: GetRecordingFoldersParams,) => [`/LiveTv/Recordings/Folders`, ...(params ? [params] : [])];


export type GetRecordingFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getRecordingFolders>>>
export type GetRecordingFoldersQueryError = ErrorType<void>

export const useGetRecordingFolders = <TData = Awaited<ReturnType<typeof getRecordingFolders>>, TError = ErrorType<void>>(
  params?: GetRecordingFoldersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRecordingFolders>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecordingFoldersQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecordingFolders>>> = ({ signal }) => getRecordingFolders(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRecordingFolders>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @deprecated
 * @summary Gets live tv recording groups.
 */
export const getRecordingGroups = (
  params?: GetRecordingGroupsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/LiveTv/Recordings/Groups`, method: 'get',
      params, signal
    },
  );
}


export const getGetRecordingGroupsQueryKey = (params?: GetRecordingGroupsParams,) => [`/LiveTv/Recordings/Groups`, ...(params ? [params] : [])];


export type GetRecordingGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecordingGroups>>>
export type GetRecordingGroupsQueryError = ErrorType<void>

export const useGetRecordingGroups = <TData = Awaited<ReturnType<typeof getRecordingGroups>>, TError = ErrorType<void>>(
  params?: GetRecordingGroupsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRecordingGroups>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecordingGroupsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecordingGroups>>> = ({ signal }) => getRecordingGroups(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRecordingGroups>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @deprecated
 * @summary Get recording group.
 */
export const getRecordingGroup = (
  groupId: string,
  signal?: AbortSignal
) => {
  return apiInstance<unknown>(
    {
      url: `/LiveTv/Recordings/Groups/${groupId}`, method: 'get', signal
    },
  );
}


export const getGetRecordingGroupQueryKey = (groupId: string,) => [`/LiveTv/Recordings/Groups/${groupId}`];


export type GetRecordingGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getRecordingGroup>>>
export type GetRecordingGroupQueryError = ErrorType<void | ProblemDetails>

export const useGetRecordingGroup = <TData = Awaited<ReturnType<typeof getRecordingGroup>>, TError = ErrorType<void | ProblemDetails>>(
  groupId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRecordingGroup>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecordingGroupQueryKey(groupId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecordingGroup>>> = ({ signal }) => getRecordingGroup(groupId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRecordingGroup>>, TError, TData>(queryKey, queryFn, { enabled: !!(groupId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @deprecated
 * @summary Gets live tv recording series.
 */
export const getRecordingsSeries = (
  params?: GetRecordingsSeriesParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/LiveTv/Recordings/Series`, method: 'get',
      params, signal
    },
  );
}


export const getGetRecordingsSeriesQueryKey = (params?: GetRecordingsSeriesParams,) => [`/LiveTv/Recordings/Series`, ...(params ? [params] : [])];


export type GetRecordingsSeriesQueryResult = NonNullable<Awaited<ReturnType<typeof getRecordingsSeries>>>
export type GetRecordingsSeriesQueryError = ErrorType<void>

export const useGetRecordingsSeries = <TData = Awaited<ReturnType<typeof getRecordingsSeries>>, TError = ErrorType<void>>(
  params?: GetRecordingsSeriesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRecordingsSeries>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecordingsSeriesQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecordingsSeries>>> = ({ signal }) => getRecordingsSeries(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRecordingsSeries>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets live tv series timers.
 */
export const getSeriesTimers = (
  params?: GetSeriesTimersParams,
  signal?: AbortSignal
) => {
  return apiInstance<SeriesTimerInfoDtoQueryResult>(
    {
      url: `/LiveTv/SeriesTimers`, method: 'get',
      params, signal
    },
  );
}


export const getGetSeriesTimersQueryKey = (params?: GetSeriesTimersParams,) => [`/LiveTv/SeriesTimers`, ...(params ? [params] : [])];


export type GetSeriesTimersQueryResult = NonNullable<Awaited<ReturnType<typeof getSeriesTimers>>>
export type GetSeriesTimersQueryError = ErrorType<void>

export const useGetSeriesTimers = <TData = Awaited<ReturnType<typeof getSeriesTimers>>, TError = ErrorType<void>>(
  params?: GetSeriesTimersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSeriesTimers>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSeriesTimersQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeriesTimers>>> = ({ signal }) => getSeriesTimers(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSeriesTimers>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates a live tv series timer.
 */
export const createSeriesTimer = (
  seriesTimerInfoDto: SeriesTimerInfoDto,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/SeriesTimers`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: seriesTimerInfoDto
    },
  );
}



export type CreateSeriesTimerMutationResult = NonNullable<Awaited<ReturnType<typeof createSeriesTimer>>>
export type CreateSeriesTimerMutationBody = SeriesTimerInfoDto
export type CreateSeriesTimerMutationError = ErrorType<unknown>

export const useCreateSeriesTimer = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof createSeriesTimer>>, TError, { data: SeriesTimerInfoDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSeriesTimer>>, { data: SeriesTimerInfoDto }> = (props) => {
    const { data } = props ?? {};

    return createSeriesTimer(data,)
  }



  return useMutation<Awaited<ReturnType<typeof createSeriesTimer>>, TError, { data: SeriesTimerInfoDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a live tv series timer.
 */
export const getSeriesTimer = (
  timerId: string,
  signal?: AbortSignal
) => {
  return apiInstance<SeriesTimerInfoDto>(
    {
      url: `/LiveTv/SeriesTimers/${timerId}`, method: 'get', signal
    },
  );
}


export const getGetSeriesTimerQueryKey = (timerId: string,) => [`/LiveTv/SeriesTimers/${timerId}`];


export type GetSeriesTimerQueryResult = NonNullable<Awaited<ReturnType<typeof getSeriesTimer>>>
export type GetSeriesTimerQueryError = ErrorType<void | ProblemDetails>

export const useGetSeriesTimer = <TData = Awaited<ReturnType<typeof getSeriesTimer>>, TError = ErrorType<void | ProblemDetails>>(
  timerId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSeriesTimer>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSeriesTimerQueryKey(timerId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeriesTimer>>> = ({ signal }) => getSeriesTimer(timerId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSeriesTimer>>, TError, TData>(queryKey, queryFn, { enabled: !!(timerId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Cancels a live tv series timer.
 */
export const cancelSeriesTimer = (
  timerId: string,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/SeriesTimers/${timerId}`, method: 'delete'
    },
  );
}



export type CancelSeriesTimerMutationResult = NonNullable<Awaited<ReturnType<typeof cancelSeriesTimer>>>

export type CancelSeriesTimerMutationError = ErrorType<unknown>

export const useCancelSeriesTimer = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof cancelSeriesTimer>>, TError, { timerId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelSeriesTimer>>, { timerId: string }> = (props) => {
    const { timerId } = props ?? {};

    return cancelSeriesTimer(timerId,)
  }



  return useMutation<Awaited<ReturnType<typeof cancelSeriesTimer>>, TError, { timerId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a live tv series timer.
 */
export const updateSeriesTimer = (
  timerId: string,
  seriesTimerInfoDto: SeriesTimerInfoDto,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/SeriesTimers/${timerId}`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: seriesTimerInfoDto
    },
  );
}



export type UpdateSeriesTimerMutationResult = NonNullable<Awaited<ReturnType<typeof updateSeriesTimer>>>
export type UpdateSeriesTimerMutationBody = SeriesTimerInfoDto
export type UpdateSeriesTimerMutationError = ErrorType<unknown>

export const useUpdateSeriesTimer = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateSeriesTimer>>, TError, { timerId: string; data: SeriesTimerInfoDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSeriesTimer>>, { timerId: string; data: SeriesTimerInfoDto }> = (props) => {
    const { timerId, data } = props ?? {};

    return updateSeriesTimer(timerId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateSeriesTimer>>, TError, { timerId: string; data: SeriesTimerInfoDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the live tv timers.
 */
export const getTimers = (
  params?: GetTimersParams,
  signal?: AbortSignal
) => {
  return apiInstance<TimerInfoDtoQueryResult>(
    {
      url: `/LiveTv/Timers`, method: 'get',
      params, signal
    },
  );
}


export const getGetTimersQueryKey = (params?: GetTimersParams,) => [`/LiveTv/Timers`, ...(params ? [params] : [])];


export type GetTimersQueryResult = NonNullable<Awaited<ReturnType<typeof getTimers>>>
export type GetTimersQueryError = ErrorType<void>

export const useGetTimers = <TData = Awaited<ReturnType<typeof getTimers>>, TError = ErrorType<void>>(
  params?: GetTimersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getTimers>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimersQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimers>>> = ({ signal }) => getTimers(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getTimers>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates a live tv timer.
 */
export const createTimer = (
  timerInfoDto: TimerInfoDto,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/Timers`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: timerInfoDto
    },
  );
}



export type CreateTimerMutationResult = NonNullable<Awaited<ReturnType<typeof createTimer>>>
export type CreateTimerMutationBody = TimerInfoDto
export type CreateTimerMutationError = ErrorType<unknown>

export const useCreateTimer = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof createTimer>>, TError, { data: TimerInfoDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTimer>>, { data: TimerInfoDto }> = (props) => {
    const { data } = props ?? {};

    return createTimer(data,)
  }



  return useMutation<Awaited<ReturnType<typeof createTimer>>, TError, { data: TimerInfoDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a timer.
 */
export const getTimer = (
  timerId: string,
  signal?: AbortSignal
) => {
  return apiInstance<TimerInfoDto>(
    {
      url: `/LiveTv/Timers/${timerId}`, method: 'get', signal
    },
  );
}


export const getGetTimerQueryKey = (timerId: string,) => [`/LiveTv/Timers/${timerId}`];


export type GetTimerQueryResult = NonNullable<Awaited<ReturnType<typeof getTimer>>>
export type GetTimerQueryError = ErrorType<void>

export const useGetTimer = <TData = Awaited<ReturnType<typeof getTimer>>, TError = ErrorType<void>>(
  timerId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getTimer>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimerQueryKey(timerId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimer>>> = ({ signal }) => getTimer(timerId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getTimer>>, TError, TData>(queryKey, queryFn, { enabled: !!(timerId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Cancels a live tv timer.
 */
export const cancelTimer = (
  timerId: string,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/Timers/${timerId}`, method: 'delete'
    },
  );
}



export type CancelTimerMutationResult = NonNullable<Awaited<ReturnType<typeof cancelTimer>>>

export type CancelTimerMutationError = ErrorType<unknown>

export const useCancelTimer = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof cancelTimer>>, TError, { timerId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelTimer>>, { timerId: string }> = (props) => {
    const { timerId } = props ?? {};

    return cancelTimer(timerId,)
  }



  return useMutation<Awaited<ReturnType<typeof cancelTimer>>, TError, { timerId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a live tv timer.
 */
export const updateTimer = (
  timerId: string,
  timerInfoDto: TimerInfoDto,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/Timers/${timerId}`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: timerInfoDto
    },
  );
}



export type UpdateTimerMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimer>>>
export type UpdateTimerMutationBody = TimerInfoDto
export type UpdateTimerMutationError = ErrorType<unknown>

export const useUpdateTimer = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateTimer>>, TError, { timerId: string; data: TimerInfoDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimer>>, { timerId: string; data: TimerInfoDto }> = (props) => {
    const { timerId, data } = props ?? {};

    return updateTimer(timerId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateTimer>>, TError, { timerId: string; data: TimerInfoDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the default values for a new timer.
 */
export const getDefaultTimer = (
  params?: GetDefaultTimerParams,
  signal?: AbortSignal
) => {
  return apiInstance<SeriesTimerInfoDto>(
    {
      url: `/LiveTv/Timers/Defaults`, method: 'get',
      params, signal
    },
  );
}


export const getGetDefaultTimerQueryKey = (params?: GetDefaultTimerParams,) => [`/LiveTv/Timers/Defaults`, ...(params ? [params] : [])];


export type GetDefaultTimerQueryResult = NonNullable<Awaited<ReturnType<typeof getDefaultTimer>>>
export type GetDefaultTimerQueryError = ErrorType<void>

export const useGetDefaultTimer = <TData = Awaited<ReturnType<typeof getDefaultTimer>>, TError = ErrorType<void>>(
  params?: GetDefaultTimerParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getDefaultTimer>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultTimerQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultTimer>>> = ({ signal }) => getDefaultTimer(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getDefaultTimer>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Adds a tuner host.
 */
export const addTunerHost = (
  tunerHostInfo: TunerHostInfo,
) => {
  return apiInstance<TunerHostInfo>(
    {
      url: `/LiveTv/TunerHosts`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: tunerHostInfo
    },
  );
}



export type AddTunerHostMutationResult = NonNullable<Awaited<ReturnType<typeof addTunerHost>>>
export type AddTunerHostMutationBody = TunerHostInfo
export type AddTunerHostMutationError = ErrorType<void>

export const useAddTunerHost = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof addTunerHost>>, TError, { data: TunerHostInfo }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTunerHost>>, { data: TunerHostInfo }> = (props) => {
    const { data } = props ?? {};

    return addTunerHost(data,)
  }



  return useMutation<Awaited<ReturnType<typeof addTunerHost>>, TError, { data: TunerHostInfo }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Deletes a tuner host.
 */
export const deleteTunerHost = (
  params?: DeleteTunerHostParams,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/TunerHosts`, method: 'delete',
      params
    },
  );
}



export type DeleteTunerHostMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTunerHost>>>

export type DeleteTunerHostMutationError = ErrorType<unknown>

export const useDeleteTunerHost = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteTunerHost>>, TError, { params?: DeleteTunerHostParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTunerHost>>, { params?: DeleteTunerHostParams }> = (props) => {
    const { params } = props ?? {};

    return deleteTunerHost(params,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteTunerHost>>, TError, { params?: DeleteTunerHostParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get tuner host types.
 */
export const getTunerHostTypes = (

  signal?: AbortSignal
) => {
  return apiInstance<NameIdPair[]>(
    {
      url: `/LiveTv/TunerHosts/Types`, method: 'get', signal
    },
  );
}


export const getGetTunerHostTypesQueryKey = () => [`/LiveTv/TunerHosts/Types`];


export type GetTunerHostTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getTunerHostTypes>>>
export type GetTunerHostTypesQueryError = ErrorType<void>

export const useGetTunerHostTypes = <TData = Awaited<ReturnType<typeof getTunerHostTypes>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getTunerHostTypes>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTunerHostTypesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTunerHostTypes>>> = ({ signal }) => getTunerHostTypes(signal);




  const query = useQuery<Awaited<ReturnType<typeof getTunerHostTypes>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Resets a tv tuner.
 */
export const resetTuner = (
  tunerId: string,
) => {
  return apiInstance<void>(
    {
      url: `/LiveTv/Tuners/${tunerId}/Reset`, method: 'post'
    },
  );
}



export type ResetTunerMutationResult = NonNullable<Awaited<ReturnType<typeof resetTuner>>>

export type ResetTunerMutationError = ErrorType<unknown>

export const useResetTuner = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof resetTuner>>, TError, { tunerId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetTuner>>, { tunerId: string }> = (props) => {
    const { tunerId } = props ?? {};

    return resetTuner(tunerId,)
  }



  return useMutation<Awaited<ReturnType<typeof resetTuner>>, TError, { tunerId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Discover tuners.
 */
export const discoverTuners = (
  params?: DiscoverTunersParams,
  signal?: AbortSignal
) => {
  return apiInstance<TunerHostInfo[]>(
    {
      url: `/LiveTv/Tuners/Discover`, method: 'get',
      params, signal
    },
  );
}


export const getDiscoverTunersQueryKey = (params?: DiscoverTunersParams,) => [`/LiveTv/Tuners/Discover`, ...(params ? [params] : [])];


export type DiscoverTunersQueryResult = NonNullable<Awaited<ReturnType<typeof discoverTuners>>>
export type DiscoverTunersQueryError = ErrorType<void>

export const useDiscoverTuners = <TData = Awaited<ReturnType<typeof discoverTuners>>, TError = ErrorType<void>>(
  params?: DiscoverTunersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof discoverTuners>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDiscoverTunersQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof discoverTuners>>> = ({ signal }) => discoverTuners(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof discoverTuners>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Discover tuners.
 */
export const discvoverTuners = (
  params?: DiscvoverTunersParams,
  signal?: AbortSignal
) => {
  return apiInstance<TunerHostInfo[]>(
    {
      url: `/LiveTv/Tuners/Discvover`, method: 'get',
      params, signal
    },
  );
}


export const getDiscvoverTunersQueryKey = (params?: DiscvoverTunersParams,) => [`/LiveTv/Tuners/Discvover`, ...(params ? [params] : [])];


export type DiscvoverTunersQueryResult = NonNullable<Awaited<ReturnType<typeof discvoverTuners>>>
export type DiscvoverTunersQueryError = ErrorType<void>

export const useDiscvoverTuners = <TData = Awaited<ReturnType<typeof discvoverTuners>>, TError = ErrorType<void>>(
  params?: DiscvoverTunersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof discvoverTuners>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDiscvoverTunersQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof discvoverTuners>>> = ({ signal }) => discvoverTuners(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof discvoverTuners>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets known countries.
 */
export const getCountries = (

  signal?: AbortSignal
) => {
  return apiInstance<CountryInfo[]>(
    {
      url: `/Localization/Countries`, method: 'get', signal
    },
  );
}


export const getGetCountriesQueryKey = () => [`/Localization/Countries`];


export type GetCountriesQueryResult = NonNullable<Awaited<ReturnType<typeof getCountries>>>
export type GetCountriesQueryError = ErrorType<void>

export const useGetCountries = <TData = Awaited<ReturnType<typeof getCountries>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getCountries>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCountriesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCountries>>> = ({ signal }) => getCountries(signal);




  const query = useQuery<Awaited<ReturnType<typeof getCountries>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets known cultures.
 */
export const getCultures = (

  signal?: AbortSignal
) => {
  return apiInstance<CultureDto[]>(
    {
      url: `/Localization/Cultures`, method: 'get', signal
    },
  );
}


export const getGetCulturesQueryKey = () => [`/Localization/Cultures`];


export type GetCulturesQueryResult = NonNullable<Awaited<ReturnType<typeof getCultures>>>
export type GetCulturesQueryError = ErrorType<void>

export const useGetCultures = <TData = Awaited<ReturnType<typeof getCultures>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getCultures>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCulturesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCultures>>> = ({ signal }) => getCultures(signal);




  const query = useQuery<Awaited<ReturnType<typeof getCultures>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets localization options.
 */
export const getLocalizationOptions = (

  signal?: AbortSignal
) => {
  return apiInstance<LocalizationOption[]>(
    {
      url: `/Localization/Options`, method: 'get', signal
    },
  );
}


export const getGetLocalizationOptionsQueryKey = () => [`/Localization/Options`];


export type GetLocalizationOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof getLocalizationOptions>>>
export type GetLocalizationOptionsQueryError = ErrorType<void>

export const useGetLocalizationOptions = <TData = Awaited<ReturnType<typeof getLocalizationOptions>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLocalizationOptions>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLocalizationOptionsQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocalizationOptions>>> = ({ signal }) => getLocalizationOptions(signal);




  const query = useQuery<Awaited<ReturnType<typeof getLocalizationOptions>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets known parental ratings.
 */
export const getParentalRatings = (

  signal?: AbortSignal
) => {
  return apiInstance<ParentalRating[]>(
    {
      url: `/Localization/ParentalRatings`, method: 'get', signal
    },
  );
}


export const getGetParentalRatingsQueryKey = () => [`/Localization/ParentalRatings`];


export type GetParentalRatingsQueryResult = NonNullable<Awaited<ReturnType<typeof getParentalRatings>>>
export type GetParentalRatingsQueryError = ErrorType<void>

export const useGetParentalRatings = <TData = Awaited<ReturnType<typeof getParentalRatings>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getParentalRatings>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetParentalRatingsQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getParentalRatings>>> = ({ signal }) => getParentalRatings(signal);




  const query = useQuery<Awaited<ReturnType<typeof getParentalRatings>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets live playback media info for an item.
 */
export const getPlaybackInfo = (
  itemId: string,
  params: GetPlaybackInfoParams,
  signal?: AbortSignal
) => {
  return apiInstance<PlaybackInfoResponse>(
    {
      url: `/Items/${itemId}/PlaybackInfo`, method: 'get',
      params, signal
    },
  );
}


export const getGetPlaybackInfoQueryKey = (itemId: string,
  params: GetPlaybackInfoParams,) => [`/Items/${itemId}/PlaybackInfo`, ...(params ? [params] : [])];


export type GetPlaybackInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getPlaybackInfo>>>
export type GetPlaybackInfoQueryError = ErrorType<void>

export const useGetPlaybackInfo = <TData = Awaited<ReturnType<typeof getPlaybackInfo>>, TError = ErrorType<void>>(
  itemId: string,
  params: GetPlaybackInfoParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPlaybackInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPlaybackInfoQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlaybackInfo>>> = ({ signal }) => getPlaybackInfo(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getPlaybackInfo>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
Query parameters are obsolete.
 * @summary Gets live playback media info for an item.
 */
export const getPostedPlaybackInfo = (
  itemId: string,
  playbackInfoDto: PlaybackInfoDto,
  params?: GetPostedPlaybackInfoParams,
) => {
  return apiInstance<PlaybackInfoResponse>(
    {
      url: `/Items/${itemId}/PlaybackInfo`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: playbackInfoDto,
      params
    },
  );
}



export type GetPostedPlaybackInfoMutationResult = NonNullable<Awaited<ReturnType<typeof getPostedPlaybackInfo>>>
export type GetPostedPlaybackInfoMutationBody = PlaybackInfoDto
export type GetPostedPlaybackInfoMutationError = ErrorType<void>

export const useGetPostedPlaybackInfo = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getPostedPlaybackInfo>>, TError, { itemId: string; data: PlaybackInfoDto; params?: GetPostedPlaybackInfoParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getPostedPlaybackInfo>>, { itemId: string; data: PlaybackInfoDto; params?: GetPostedPlaybackInfoParams }> = (props) => {
    const { itemId, data, params } = props ?? {};

    return getPostedPlaybackInfo(itemId, data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof getPostedPlaybackInfo>>, TError, { itemId: string; data: PlaybackInfoDto; params?: GetPostedPlaybackInfoParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Closes a media source.
 */
export const closeLiveStream = (
  params: CloseLiveStreamParams,
) => {
  return apiInstance<void>(
    {
      url: `/LiveStreams/Close`, method: 'post',
      params
    },
  );
}



export type CloseLiveStreamMutationResult = NonNullable<Awaited<ReturnType<typeof closeLiveStream>>>

export type CloseLiveStreamMutationError = ErrorType<unknown>

export const useCloseLiveStream = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof closeLiveStream>>, TError, { params: CloseLiveStreamParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof closeLiveStream>>, { params: CloseLiveStreamParams }> = (props) => {
    const { params } = props ?? {};

    return closeLiveStream(params,)
  }



  return useMutation<Awaited<ReturnType<typeof closeLiveStream>>, TError, { params: CloseLiveStreamParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Opens a media source.
 */
export const openLiveStream = (
  openLiveStreamDto: OpenLiveStreamDto,
  params?: OpenLiveStreamParams,
) => {
  return apiInstance<LiveStreamResponse>(
    {
      url: `/LiveStreams/Open`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: openLiveStreamDto,
      params
    },
  );
}



export type OpenLiveStreamMutationResult = NonNullable<Awaited<ReturnType<typeof openLiveStream>>>
export type OpenLiveStreamMutationBody = OpenLiveStreamDto
export type OpenLiveStreamMutationError = ErrorType<void>

export const useOpenLiveStream = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof openLiveStream>>, TError, { data: OpenLiveStreamDto; params?: OpenLiveStreamParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof openLiveStream>>, { data: OpenLiveStreamDto; params?: OpenLiveStreamParams }> = (props) => {
    const { data, params } = props ?? {};

    return openLiveStream(data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof openLiveStream>>, TError, { data: OpenLiveStreamDto; params?: OpenLiveStreamParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Tests the network with a request with the size of the bitrate.
 */
export const getBitrateTestBytes = (
  params?: GetBitrateTestBytesParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Playback/BitrateTest`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetBitrateTestBytesQueryKey = (params?: GetBitrateTestBytesParams,) => [`/Playback/BitrateTest`, ...(params ? [params] : [])];


export type GetBitrateTestBytesQueryResult = NonNullable<Awaited<ReturnType<typeof getBitrateTestBytes>>>
export type GetBitrateTestBytesQueryError = ErrorType<void>

export const useGetBitrateTestBytes = <TData = Awaited<ReturnType<typeof getBitrateTestBytes>>, TError = ErrorType<void>>(
  params?: GetBitrateTestBytesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getBitrateTestBytes>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBitrateTestBytesQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBitrateTestBytes>>> = ({ signal }) => getBitrateTestBytes(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getBitrateTestBytes>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets movie recommendations.
 */
export const getMovieRecommendations = (
  params?: GetMovieRecommendationsParams,
  signal?: AbortSignal
) => {
  return apiInstance<RecommendationDto[]>(
    {
      url: `/Movies/Recommendations`, method: 'get',
      params, signal
    },
  );
}


export const getGetMovieRecommendationsQueryKey = (params?: GetMovieRecommendationsParams,) => [`/Movies/Recommendations`, ...(params ? [params] : [])];


export type GetMovieRecommendationsQueryResult = NonNullable<Awaited<ReturnType<typeof getMovieRecommendations>>>
export type GetMovieRecommendationsQueryError = ErrorType<void>

export const useGetMovieRecommendations = <TData = Awaited<ReturnType<typeof getMovieRecommendations>>, TError = ErrorType<void>>(
  params?: GetMovieRecommendationsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMovieRecommendations>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMovieRecommendationsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMovieRecommendations>>> = ({ signal }) => getMovieRecommendations(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMovieRecommendations>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @deprecated
 * @summary Gets all music genres from a given item, folder, or the entire library.
 */
export const getMusicGenres = (
  params?: GetMusicGenresParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/MusicGenres`, method: 'get',
      params, signal
    },
  );
}


export const getGetMusicGenresQueryKey = (params?: GetMusicGenresParams,) => [`/MusicGenres`, ...(params ? [params] : [])];


export type GetMusicGenresQueryResult = NonNullable<Awaited<ReturnType<typeof getMusicGenres>>>
export type GetMusicGenresQueryError = ErrorType<void>

export const useGetMusicGenres = <TData = Awaited<ReturnType<typeof getMusicGenres>>, TError = ErrorType<void>>(
  params?: GetMusicGenresParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMusicGenres>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMusicGenresQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMusicGenres>>> = ({ signal }) => getMusicGenres(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMusicGenres>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a music genre, by name.
 */
export const getMusicGenre = (
  genreName: string,
  params?: GetMusicGenreParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/MusicGenres/${genreName}`, method: 'get',
      params, signal
    },
  );
}


export const getGetMusicGenreQueryKey = (genreName: string,
  params?: GetMusicGenreParams,) => [`/MusicGenres/${genreName}`, ...(params ? [params] : [])];


export type GetMusicGenreQueryResult = NonNullable<Awaited<ReturnType<typeof getMusicGenre>>>
export type GetMusicGenreQueryError = ErrorType<void>

export const useGetMusicGenre = <TData = Awaited<ReturnType<typeof getMusicGenre>>, TError = ErrorType<void>>(
  genreName: string,
  params?: GetMusicGenreParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMusicGenre>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMusicGenreQueryKey(genreName, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMusicGenre>>> = ({ signal }) => getMusicGenre(genreName, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getMusicGenre>>, TError, TData>(queryKey, queryFn, { enabled: !!(genreName), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a user's notifications.
 */
export const getNotifications = (
  userId: string,
  signal?: AbortSignal
) => {
  return apiInstance<NotificationResultDto>(
    {
      url: `/Notifications/${userId}`, method: 'get', signal
    },
  );
}


export const getGetNotificationsQueryKey = (userId: string,) => [`/Notifications/${userId}`];


export type GetNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof getNotifications>>>
export type GetNotificationsQueryError = ErrorType<void>

export const useGetNotifications = <TData = Awaited<ReturnType<typeof getNotifications>>, TError = ErrorType<void>>(
  userId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationsQueryKey(userId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotifications>>> = ({ signal }) => getNotifications(userId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getNotifications>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Sets notifications as read.
 */
export const setRead = (
  userId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Notifications/${userId}/Read`, method: 'post'
    },
  );
}



export type SetReadMutationResult = NonNullable<Awaited<ReturnType<typeof setRead>>>

export type SetReadMutationError = ErrorType<unknown>

export const useSetRead = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof setRead>>, TError, { userId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setRead>>, { userId: string }> = (props) => {
    const { userId } = props ?? {};

    return setRead(userId,)
  }



  return useMutation<Awaited<ReturnType<typeof setRead>>, TError, { userId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a user's notification summary.
 */
export const getNotificationsSummary = (
  userId: string,
  signal?: AbortSignal
) => {
  return apiInstance<NotificationsSummaryDto>(
    {
      url: `/Notifications/${userId}/Summary`, method: 'get', signal
    },
  );
}


export const getGetNotificationsSummaryQueryKey = (userId: string,) => [`/Notifications/${userId}/Summary`];


export type GetNotificationsSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getNotificationsSummary>>>
export type GetNotificationsSummaryQueryError = ErrorType<void>

export const useGetNotificationsSummary = <TData = Awaited<ReturnType<typeof getNotificationsSummary>>, TError = ErrorType<void>>(
  userId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNotificationsSummary>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationsSummaryQueryKey(userId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotificationsSummary>>> = ({ signal }) => getNotificationsSummary(userId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getNotificationsSummary>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Sets notifications as unread.
 */
export const setUnread = (
  userId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Notifications/${userId}/Unread`, method: 'post'
    },
  );
}



export type SetUnreadMutationResult = NonNullable<Awaited<ReturnType<typeof setUnread>>>

export type SetUnreadMutationError = ErrorType<unknown>

export const useSetUnread = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof setUnread>>, TError, { userId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setUnread>>, { userId: string }> = (props) => {
    const { userId } = props ?? {};

    return setUnread(userId,)
  }



  return useMutation<Awaited<ReturnType<typeof setUnread>>, TError, { userId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Sends a notification to all admins.
 */
export const createAdminNotification = (
  adminNotificationDto: AdminNotificationDto,
) => {
  return apiInstance<void>(
    {
      url: `/Notifications/Admin`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: adminNotificationDto
    },
  );
}



export type CreateAdminNotificationMutationResult = NonNullable<Awaited<ReturnType<typeof createAdminNotification>>>
export type CreateAdminNotificationMutationBody = AdminNotificationDto
export type CreateAdminNotificationMutationError = ErrorType<unknown>

export const useCreateAdminNotification = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof createAdminNotification>>, TError, { data: AdminNotificationDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdminNotification>>, { data: AdminNotificationDto }> = (props) => {
    const { data } = props ?? {};

    return createAdminNotification(data,)
  }



  return useMutation<Awaited<ReturnType<typeof createAdminNotification>>, TError, { data: AdminNotificationDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets notification services.
 */
export const getNotificationServices = (

  signal?: AbortSignal
) => {
  return apiInstance<NameIdPair[]>(
    {
      url: `/Notifications/Services`, method: 'get', signal
    },
  );
}


export const getGetNotificationServicesQueryKey = () => [`/Notifications/Services`];


export type GetNotificationServicesQueryResult = NonNullable<Awaited<ReturnType<typeof getNotificationServices>>>
export type GetNotificationServicesQueryError = ErrorType<void>

export const useGetNotificationServices = <TData = Awaited<ReturnType<typeof getNotificationServices>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNotificationServices>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationServicesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotificationServices>>> = ({ signal }) => getNotificationServices(signal);




  const query = useQuery<Awaited<ReturnType<typeof getNotificationServices>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets notification types.
 */
export const getNotificationTypes = (

  signal?: AbortSignal
) => {
  return apiInstance<NotificationTypeInfo[]>(
    {
      url: `/Notifications/Types`, method: 'get', signal
    },
  );
}


export const getGetNotificationTypesQueryKey = () => [`/Notifications/Types`];


export type GetNotificationTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getNotificationTypes>>>
export type GetNotificationTypesQueryError = ErrorType<void>

export const useGetNotificationTypes = <TData = Awaited<ReturnType<typeof getNotificationTypes>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNotificationTypes>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationTypesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotificationTypes>>> = ({ signal }) => getNotificationTypes(signal);




  const query = useQuery<Awaited<ReturnType<typeof getNotificationTypes>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets available packages.
 */
export const getPackages = (

  signal?: AbortSignal
) => {
  return apiInstance<PackageInfo[]>(
    {
      url: `/Packages`, method: 'get', signal
    },
  );
}


export const getGetPackagesQueryKey = () => [`/Packages`];


export type GetPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof getPackages>>>
export type GetPackagesQueryError = ErrorType<void>

export const useGetPackages = <TData = Awaited<ReturnType<typeof getPackages>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPackages>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPackagesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPackages>>> = ({ signal }) => getPackages(signal);




  const query = useQuery<Awaited<ReturnType<typeof getPackages>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a package by name or assembly GUID.
 */
export const getPackageInfo = (
  name: string,
  params?: GetPackageInfoParams,
  signal?: AbortSignal
) => {
  return apiInstance<PackageInfo>(
    {
      url: `/Packages/${name}`, method: 'get',
      params, signal
    },
  );
}


export const getGetPackageInfoQueryKey = (name: string,
  params?: GetPackageInfoParams,) => [`/Packages/${name}`, ...(params ? [params] : [])];


export type GetPackageInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getPackageInfo>>>
export type GetPackageInfoQueryError = ErrorType<void>

export const useGetPackageInfo = <TData = Awaited<ReturnType<typeof getPackageInfo>>, TError = ErrorType<void>>(
  name: string,
  params?: GetPackageInfoParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPackageInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPackageInfoQueryKey(name, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPackageInfo>>> = ({ signal }) => getPackageInfo(name, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getPackageInfo>>, TError, TData>(queryKey, queryFn, { enabled: !!(name), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Installs a package.
 */
export const installPackage = (
  name: string,
  params?: InstallPackageParams,
) => {
  return apiInstance<void>(
    {
      url: `/Packages/Installed/${name}`, method: 'post',
      params
    },
  );
}



export type InstallPackageMutationResult = NonNullable<Awaited<ReturnType<typeof installPackage>>>

export type InstallPackageMutationError = ErrorType<ProblemDetails>

export const useInstallPackage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof installPackage>>, TError, { name: string; params?: InstallPackageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof installPackage>>, { name: string; params?: InstallPackageParams }> = (props) => {
    const { name, params } = props ?? {};

    return installPackage(name, params,)
  }



  return useMutation<Awaited<ReturnType<typeof installPackage>>, TError, { name: string; params?: InstallPackageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Cancels a package installation.
 */
export const cancelPackageInstallation = (
  packageId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Packages/Installing/${packageId}`, method: 'delete'
    },
  );
}



export type CancelPackageInstallationMutationResult = NonNullable<Awaited<ReturnType<typeof cancelPackageInstallation>>>

export type CancelPackageInstallationMutationError = ErrorType<unknown>

export const useCancelPackageInstallation = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof cancelPackageInstallation>>, TError, { packageId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelPackageInstallation>>, { packageId: string }> = (props) => {
    const { packageId } = props ?? {};

    return cancelPackageInstallation(packageId,)
  }



  return useMutation<Awaited<ReturnType<typeof cancelPackageInstallation>>, TError, { packageId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets all package repositories.
 */
export const getRepositories = (

  signal?: AbortSignal
) => {
  return apiInstance<RepositoryInfo[]>(
    {
      url: `/Repositories`, method: 'get', signal
    },
  );
}


export const getGetRepositoriesQueryKey = () => [`/Repositories`];


export type GetRepositoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getRepositories>>>
export type GetRepositoriesQueryError = ErrorType<void>

export const useGetRepositories = <TData = Awaited<ReturnType<typeof getRepositories>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRepositories>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRepositoriesQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRepositories>>> = ({ signal }) => getRepositories(signal);




  const query = useQuery<Awaited<ReturnType<typeof getRepositories>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Sets the enabled and existing package repositories.
 */
export const setRepositories = (
  repositoryInfo: RepositoryInfo[],
) => {
  return apiInstance<void>(
    {
      url: `/Repositories`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: repositoryInfo
    },
  );
}



export type SetRepositoriesMutationResult = NonNullable<Awaited<ReturnType<typeof setRepositories>>>
export type SetRepositoriesMutationBody = RepositoryInfo[]
export type SetRepositoriesMutationError = ErrorType<unknown>

export const useSetRepositories = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof setRepositories>>, TError, { data: RepositoryInfo[] }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setRepositories>>, { data: RepositoryInfo[] }> = (props) => {
    const { data } = props ?? {};

    return setRepositories(data,)
  }



  return useMutation<Awaited<ReturnType<typeof setRepositories>>, TError, { data: RepositoryInfo[] }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets all persons.
 */
export const getPersons = (
  params?: GetPersonsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Persons`, method: 'get',
      params, signal
    },
  );
}


export const getGetPersonsQueryKey = (params?: GetPersonsParams,) => [`/Persons`, ...(params ? [params] : [])];


export type GetPersonsQueryResult = NonNullable<Awaited<ReturnType<typeof getPersons>>>
export type GetPersonsQueryError = ErrorType<void>

export const useGetPersons = <TData = Awaited<ReturnType<typeof getPersons>>, TError = ErrorType<void>>(
  params?: GetPersonsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPersons>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPersonsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersons>>> = ({ signal }) => getPersons(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getPersons>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get person by name.
 */
export const getPerson = (
  name: string,
  params?: GetPersonParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/Persons/${name}`, method: 'get',
      params, signal
    },
  );
}


export const getGetPersonQueryKey = (name: string,
  params?: GetPersonParams,) => [`/Persons/${name}`, ...(params ? [params] : [])];


export type GetPersonQueryResult = NonNullable<Awaited<ReturnType<typeof getPerson>>>
export type GetPersonQueryError = ErrorType<void | ProblemDetails>

export const useGetPerson = <TData = Awaited<ReturnType<typeof getPerson>>, TError = ErrorType<void | ProblemDetails>>(
  name: string,
  params?: GetPersonParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPerson>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPersonQueryKey(name, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPerson>>> = ({ signal }) => getPerson(name, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getPerson>>, TError, TData>(queryKey, queryFn, { enabled: !!(name), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
Query parameters are obsolete.
 * @summary Creates a new playlist.
 */
export const createPlaylist = (
  createPlaylistDto: CreatePlaylistDto,
  params?: CreatePlaylistParams,
) => {
  return apiInstance<PlaylistCreationResult>(
    {
      url: `/Playlists`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: createPlaylistDto,
      params
    },
  );
}



export type CreatePlaylistMutationResult = NonNullable<Awaited<ReturnType<typeof createPlaylist>>>
export type CreatePlaylistMutationBody = CreatePlaylistDto
export type CreatePlaylistMutationError = ErrorType<void>

export const useCreatePlaylist = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof createPlaylist>>, TError, { data: CreatePlaylistDto; params?: CreatePlaylistParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPlaylist>>, { data: CreatePlaylistDto; params?: CreatePlaylistParams }> = (props) => {
    const { data, params } = props ?? {};

    return createPlaylist(data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof createPlaylist>>, TError, { data: CreatePlaylistDto; params?: CreatePlaylistParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Adds items to a playlist.
 */
export const addToPlaylist = (
  playlistId: string,
  params?: AddToPlaylistParams,
) => {
  return apiInstance<void>(
    {
      url: `/Playlists/${playlistId}/Items`, method: 'post',
      params
    },
  );
}



export type AddToPlaylistMutationResult = NonNullable<Awaited<ReturnType<typeof addToPlaylist>>>

export type AddToPlaylistMutationError = ErrorType<unknown>

export const useAddToPlaylist = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof addToPlaylist>>, TError, { playlistId: string; params?: AddToPlaylistParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToPlaylist>>, { playlistId: string; params?: AddToPlaylistParams }> = (props) => {
    const { playlistId, params } = props ?? {};

    return addToPlaylist(playlistId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof addToPlaylist>>, TError, { playlistId: string; params?: AddToPlaylistParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Removes items from a playlist.
 */
export const removeFromPlaylist = (
  playlistId: string,
  params?: RemoveFromPlaylistParams,
) => {
  return apiInstance<void>(
    {
      url: `/Playlists/${playlistId}/Items`, method: 'delete',
      params
    },
  );
}



export type RemoveFromPlaylistMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromPlaylist>>>

export type RemoveFromPlaylistMutationError = ErrorType<unknown>

export const useRemoveFromPlaylist = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeFromPlaylist>>, TError, { playlistId: string; params?: RemoveFromPlaylistParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromPlaylist>>, { playlistId: string; params?: RemoveFromPlaylistParams }> = (props) => {
    const { playlistId, params } = props ?? {};

    return removeFromPlaylist(playlistId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof removeFromPlaylist>>, TError, { playlistId: string; params?: RemoveFromPlaylistParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the original items of a playlist.
 */
export const getPlaylistItems = (
  playlistId: string,
  params: GetPlaylistItemsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Playlists/${playlistId}/Items`, method: 'get',
      params, signal
    },
  );
}


export const getGetPlaylistItemsQueryKey = (playlistId: string,
  params: GetPlaylistItemsParams,) => [`/Playlists/${playlistId}/Items`, ...(params ? [params] : [])];


export type GetPlaylistItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getPlaylistItems>>>
export type GetPlaylistItemsQueryError = ErrorType<void>

export const useGetPlaylistItems = <TData = Awaited<ReturnType<typeof getPlaylistItems>>, TError = ErrorType<void>>(
  playlistId: string,
  params: GetPlaylistItemsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPlaylistItems>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPlaylistItemsQueryKey(playlistId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlaylistItems>>> = ({ signal }) => getPlaylistItems(playlistId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getPlaylistItems>>, TError, TData>(queryKey, queryFn, { enabled: !!(playlistId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Moves a playlist item.
 */
export const moveItem = (
  playlistId: string,
  itemId: string,
  newIndex: number,
) => {
  return apiInstance<void>(
    {
      url: `/Playlists/${playlistId}/Items/${itemId}/Move/${newIndex}`, method: 'post'
    },
  );
}



export type MoveItemMutationResult = NonNullable<Awaited<ReturnType<typeof moveItem>>>

export type MoveItemMutationError = ErrorType<unknown>

export const useMoveItem = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof moveItem>>, TError, { playlistId: string; itemId: string; newIndex: number }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveItem>>, { playlistId: string; itemId: string; newIndex: number }> = (props) => {
    const { playlistId, itemId, newIndex } = props ?? {};

    return moveItem(playlistId, itemId, newIndex,)
  }



  return useMutation<Awaited<ReturnType<typeof moveItem>>, TError, { playlistId: string; itemId: string; newIndex: number }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports playback has started within a session.
 */
export const reportPlaybackStart = (
  playbackStartInfo: PlaybackStartInfo,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/Playing`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: playbackStartInfo
    },
  );
}



export type ReportPlaybackStartMutationResult = NonNullable<Awaited<ReturnType<typeof reportPlaybackStart>>>
export type ReportPlaybackStartMutationBody = PlaybackStartInfo
export type ReportPlaybackStartMutationError = ErrorType<unknown>

export const useReportPlaybackStart = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof reportPlaybackStart>>, TError, { data: PlaybackStartInfo }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof reportPlaybackStart>>, { data: PlaybackStartInfo }> = (props) => {
    const { data } = props ?? {};

    return reportPlaybackStart(data,)
  }



  return useMutation<Awaited<ReturnType<typeof reportPlaybackStart>>, TError, { data: PlaybackStartInfo }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Pings a playback session.
 */
export const pingPlaybackSession = (
  params: PingPlaybackSessionParams,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/Playing/Ping`, method: 'post',
      params
    },
  );
}



export type PingPlaybackSessionMutationResult = NonNullable<Awaited<ReturnType<typeof pingPlaybackSession>>>

export type PingPlaybackSessionMutationError = ErrorType<unknown>

export const usePingPlaybackSession = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof pingPlaybackSession>>, TError, { params: PingPlaybackSessionParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof pingPlaybackSession>>, { params: PingPlaybackSessionParams }> = (props) => {
    const { params } = props ?? {};

    return pingPlaybackSession(params,)
  }



  return useMutation<Awaited<ReturnType<typeof pingPlaybackSession>>, TError, { params: PingPlaybackSessionParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports playback progress within a session.
 */
export const reportPlaybackProgress = (
  playbackProgressInfo: PlaybackProgressInfo,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/Playing/Progress`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: playbackProgressInfo
    },
  );
}



export type ReportPlaybackProgressMutationResult = NonNullable<Awaited<ReturnType<typeof reportPlaybackProgress>>>
export type ReportPlaybackProgressMutationBody = PlaybackProgressInfo
export type ReportPlaybackProgressMutationError = ErrorType<unknown>

export const useReportPlaybackProgress = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof reportPlaybackProgress>>, TError, { data: PlaybackProgressInfo }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof reportPlaybackProgress>>, { data: PlaybackProgressInfo }> = (props) => {
    const { data } = props ?? {};

    return reportPlaybackProgress(data,)
  }



  return useMutation<Awaited<ReturnType<typeof reportPlaybackProgress>>, TError, { data: PlaybackProgressInfo }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports playback has stopped within a session.
 */
export const reportPlaybackStopped = (
  playbackStopInfo: PlaybackStopInfo,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/Playing/Stopped`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: playbackStopInfo
    },
  );
}



export type ReportPlaybackStoppedMutationResult = NonNullable<Awaited<ReturnType<typeof reportPlaybackStopped>>>
export type ReportPlaybackStoppedMutationBody = PlaybackStopInfo
export type ReportPlaybackStoppedMutationError = ErrorType<unknown>

export const useReportPlaybackStopped = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof reportPlaybackStopped>>, TError, { data: PlaybackStopInfo }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof reportPlaybackStopped>>, { data: PlaybackStopInfo }> = (props) => {
    const { data } = props ?? {};

    return reportPlaybackStopped(data,)
  }



  return useMutation<Awaited<ReturnType<typeof reportPlaybackStopped>>, TError, { data: PlaybackStopInfo }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Marks an item as played for user.
 */
export const markPlayedItem = (
  userId: string,
  itemId: string,
  params?: MarkPlayedItemParams,
) => {
  return apiInstance<UserItemDataDto>(
    {
      url: `/Users/${userId}/PlayedItems/${itemId}`, method: 'post',
      params
    },
  );
}



export type MarkPlayedItemMutationResult = NonNullable<Awaited<ReturnType<typeof markPlayedItem>>>

export type MarkPlayedItemMutationError = ErrorType<void>

export const useMarkPlayedItem = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof markPlayedItem>>, TError, { userId: string; itemId: string; params?: MarkPlayedItemParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof markPlayedItem>>, { userId: string; itemId: string; params?: MarkPlayedItemParams }> = (props) => {
    const { userId, itemId, params } = props ?? {};

    return markPlayedItem(userId, itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof markPlayedItem>>, TError, { userId: string; itemId: string; params?: MarkPlayedItemParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Marks an item as unplayed for user.
 */
export const markUnplayedItem = (
  userId: string,
  itemId: string,
) => {
  return apiInstance<UserItemDataDto>(
    {
      url: `/Users/${userId}/PlayedItems/${itemId}`, method: 'delete'
    },
  );
}



export type MarkUnplayedItemMutationResult = NonNullable<Awaited<ReturnType<typeof markUnplayedItem>>>

export type MarkUnplayedItemMutationError = ErrorType<void>

export const useMarkUnplayedItem = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof markUnplayedItem>>, TError, { userId: string; itemId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof markUnplayedItem>>, { userId: string; itemId: string }> = (props) => {
    const { userId, itemId } = props ?? {};

    return markUnplayedItem(userId, itemId,)
  }



  return useMutation<Awaited<ReturnType<typeof markUnplayedItem>>, TError, { userId: string; itemId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports that a user has begun playing an item.
 */
export const onPlaybackStart = (
  userId: string,
  itemId: string,
  params?: OnPlaybackStartParams,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/PlayingItems/${itemId}`, method: 'post',
      params
    },
  );
}



export type OnPlaybackStartMutationResult = NonNullable<Awaited<ReturnType<typeof onPlaybackStart>>>

export type OnPlaybackStartMutationError = ErrorType<unknown>

export const useOnPlaybackStart = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof onPlaybackStart>>, TError, { userId: string; itemId: string; params?: OnPlaybackStartParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof onPlaybackStart>>, { userId: string; itemId: string; params?: OnPlaybackStartParams }> = (props) => {
    const { userId, itemId, params } = props ?? {};

    return onPlaybackStart(userId, itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof onPlaybackStart>>, TError, { userId: string; itemId: string; params?: OnPlaybackStartParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports that a user has stopped playing an item.
 */
export const onPlaybackStopped = (
  userId: string,
  itemId: string,
  params?: OnPlaybackStoppedParams,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/PlayingItems/${itemId}`, method: 'delete',
      params
    },
  );
}



export type OnPlaybackStoppedMutationResult = NonNullable<Awaited<ReturnType<typeof onPlaybackStopped>>>

export type OnPlaybackStoppedMutationError = ErrorType<unknown>

export const useOnPlaybackStopped = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof onPlaybackStopped>>, TError, { userId: string; itemId: string; params?: OnPlaybackStoppedParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof onPlaybackStopped>>, { userId: string; itemId: string; params?: OnPlaybackStoppedParams }> = (props) => {
    const { userId, itemId, params } = props ?? {};

    return onPlaybackStopped(userId, itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof onPlaybackStopped>>, TError, { userId: string; itemId: string; params?: OnPlaybackStoppedParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports a user's playback progress.
 */
export const onPlaybackProgress = (
  userId: string,
  itemId: string,
  params?: OnPlaybackProgressParams,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/PlayingItems/${itemId}/Progress`, method: 'post',
      params
    },
  );
}



export type OnPlaybackProgressMutationResult = NonNullable<Awaited<ReturnType<typeof onPlaybackProgress>>>

export type OnPlaybackProgressMutationError = ErrorType<unknown>

export const useOnPlaybackProgress = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof onPlaybackProgress>>, TError, { userId: string; itemId: string; params?: OnPlaybackProgressParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof onPlaybackProgress>>, { userId: string; itemId: string; params?: OnPlaybackProgressParams }> = (props) => {
    const { userId, itemId, params } = props ?? {};

    return onPlaybackProgress(userId, itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof onPlaybackProgress>>, TError, { userId: string; itemId: string; params?: OnPlaybackProgressParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a list of currently installed plugins.
 */
export const getPlugins = (

  signal?: AbortSignal
) => {
  return apiInstance<PluginInfo[]>(
    {
      url: `/Plugins`, method: 'get', signal
    },
  );
}


export const getGetPluginsQueryKey = () => [`/Plugins`];


export type GetPluginsQueryResult = NonNullable<Awaited<ReturnType<typeof getPlugins>>>
export type GetPluginsQueryError = ErrorType<void>

export const useGetPlugins = <TData = Awaited<ReturnType<typeof getPlugins>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPlugins>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPluginsQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlugins>>> = ({ signal }) => getPlugins(signal);




  const query = useQuery<Awaited<ReturnType<typeof getPlugins>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @deprecated
 * @summary Uninstalls a plugin.
 */
export const uninstallPlugin = (
  pluginId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Plugins/${pluginId}`, method: 'delete'
    },
  );
}



export type UninstallPluginMutationResult = NonNullable<Awaited<ReturnType<typeof uninstallPlugin>>>

export type UninstallPluginMutationError = ErrorType<ProblemDetails>

export const useUninstallPlugin = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof uninstallPlugin>>, TError, { pluginId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof uninstallPlugin>>, { pluginId: string }> = (props) => {
    const { pluginId } = props ?? {};

    return uninstallPlugin(pluginId,)
  }



  return useMutation<Awaited<ReturnType<typeof uninstallPlugin>>, TError, { pluginId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Uninstalls a plugin by version.
 */
export const uninstallPluginByVersion = (
  pluginId: string,
  version: string,
) => {
  return apiInstance<void>(
    {
      url: `/Plugins/${pluginId}/${version}`, method: 'delete'
    },
  );
}



export type UninstallPluginByVersionMutationResult = NonNullable<Awaited<ReturnType<typeof uninstallPluginByVersion>>>

export type UninstallPluginByVersionMutationError = ErrorType<ProblemDetails>

export const useUninstallPluginByVersion = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof uninstallPluginByVersion>>, TError, { pluginId: string; version: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof uninstallPluginByVersion>>, { pluginId: string; version: string }> = (props) => {
    const { pluginId, version } = props ?? {};

    return uninstallPluginByVersion(pluginId, version,)
  }



  return useMutation<Awaited<ReturnType<typeof uninstallPluginByVersion>>, TError, { pluginId: string; version: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Disable a plugin.
 */
export const disablePlugin = (
  pluginId: string,
  version: string,
) => {
  return apiInstance<void>(
    {
      url: `/Plugins/${pluginId}/${version}/Disable`, method: 'post'
    },
  );
}



export type DisablePluginMutationResult = NonNullable<Awaited<ReturnType<typeof disablePlugin>>>

export type DisablePluginMutationError = ErrorType<ProblemDetails>

export const useDisablePlugin = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof disablePlugin>>, TError, { pluginId: string; version: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof disablePlugin>>, { pluginId: string; version: string }> = (props) => {
    const { pluginId, version } = props ?? {};

    return disablePlugin(pluginId, version,)
  }



  return useMutation<Awaited<ReturnType<typeof disablePlugin>>, TError, { pluginId: string; version: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Enables a disabled plugin.
 */
export const enablePlugin = (
  pluginId: string,
  version: string,
) => {
  return apiInstance<void>(
    {
      url: `/Plugins/${pluginId}/${version}/Enable`, method: 'post'
    },
  );
}



export type EnablePluginMutationResult = NonNullable<Awaited<ReturnType<typeof enablePlugin>>>

export type EnablePluginMutationError = ErrorType<ProblemDetails>

export const useEnablePlugin = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof enablePlugin>>, TError, { pluginId: string; version: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof enablePlugin>>, { pluginId: string; version: string }> = (props) => {
    const { pluginId, version } = props ?? {};

    return enablePlugin(pluginId, version,)
  }



  return useMutation<Awaited<ReturnType<typeof enablePlugin>>, TError, { pluginId: string; version: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a plugin's image.
 */
export const getPluginImage = (
  pluginId: string,
  version: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Plugins/${pluginId}/${version}/Image`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetPluginImageQueryKey = (pluginId: string,
  version: string,) => [`/Plugins/${pluginId}/${version}/Image`];


export type GetPluginImageQueryResult = NonNullable<Awaited<ReturnType<typeof getPluginImage>>>
export type GetPluginImageQueryError = ErrorType<void | ProblemDetails>

export const useGetPluginImage = <TData = Awaited<ReturnType<typeof getPluginImage>>, TError = ErrorType<void | ProblemDetails>>(
  pluginId: string,
  version: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPluginImage>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPluginImageQueryKey(pluginId, version);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPluginImage>>> = ({ signal }) => getPluginImage(pluginId, version, signal);




  const query = useQuery<Awaited<ReturnType<typeof getPluginImage>>, TError, TData>(queryKey, queryFn, { enabled: !!(pluginId && version), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets plugin configuration.
 */
export const getPluginConfiguration = (
  pluginId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BasePluginConfiguration>(
    {
      url: `/Plugins/${pluginId}/Configuration`, method: 'get', signal
    },
  );
}


export const getGetPluginConfigurationQueryKey = (pluginId: string,) => [`/Plugins/${pluginId}/Configuration`];


export type GetPluginConfigurationQueryResult = NonNullable<Awaited<ReturnType<typeof getPluginConfiguration>>>
export type GetPluginConfigurationQueryError = ErrorType<void | ProblemDetails>

export const useGetPluginConfiguration = <TData = Awaited<ReturnType<typeof getPluginConfiguration>>, TError = ErrorType<void | ProblemDetails>>(
  pluginId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPluginConfiguration>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPluginConfigurationQueryKey(pluginId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPluginConfiguration>>> = ({ signal }) => getPluginConfiguration(pluginId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getPluginConfiguration>>, TError, TData>(queryKey, queryFn, { enabled: !!(pluginId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * Accepts plugin configuration as JSON body.
 * @summary Updates plugin configuration.
 */
export const updatePluginConfiguration = (
  pluginId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Plugins/${pluginId}/Configuration`, method: 'post'
    },
  );
}



export type UpdatePluginConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof updatePluginConfiguration>>>

export type UpdatePluginConfigurationMutationError = ErrorType<ProblemDetails>

export const useUpdatePluginConfiguration = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updatePluginConfiguration>>, TError, { pluginId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePluginConfiguration>>, { pluginId: string }> = (props) => {
    const { pluginId } = props ?? {};

    return updatePluginConfiguration(pluginId,)
  }



  return useMutation<Awaited<ReturnType<typeof updatePluginConfiguration>>, TError, { pluginId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a plugin's manifest.
 */
export const getPluginManifest = (
  pluginId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Plugins/${pluginId}/Manifest`, method: 'post'
    },
  );
}



export type GetPluginManifestMutationResult = NonNullable<Awaited<ReturnType<typeof getPluginManifest>>>

export type GetPluginManifestMutationError = ErrorType<ProblemDetails>

export const useGetPluginManifest = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof getPluginManifest>>, TError, { pluginId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getPluginManifest>>, { pluginId: string }> = (props) => {
    const { pluginId } = props ?? {};

    return getPluginManifest(pluginId,)
  }



  return useMutation<Awaited<ReturnType<typeof getPluginManifest>>, TError, { pluginId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Authorizes a pending quick connect request.
 */
export const authorize = (
  params: AuthorizeParams,
) => {
  return apiInstance<boolean>(
    {
      url: `/QuickConnect/Authorize`, method: 'post',
      params
    },
  );
}



export type AuthorizeMutationResult = NonNullable<Awaited<ReturnType<typeof authorize>>>

export type AuthorizeMutationError = ErrorType<void | ProblemDetails>

export const useAuthorize = <TError = ErrorType<void | ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof authorize>>, TError, { params: AuthorizeParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authorize>>, { params: AuthorizeParams }> = (props) => {
    const { params } = props ?? {};

    return authorize(params,)
  }



  return useMutation<Awaited<ReturnType<typeof authorize>>, TError, { params: AuthorizeParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Attempts to retrieve authentication information.
 */
export const connect = (
  params: ConnectParams,
  signal?: AbortSignal
) => {
  return apiInstance<QuickConnectResult>(
    {
      url: `/QuickConnect/Connect`, method: 'get',
      params, signal
    },
  );
}


export const getConnectQueryKey = (params: ConnectParams,) => [`/QuickConnect/Connect`, ...(params ? [params] : [])];


export type ConnectQueryResult = NonNullable<Awaited<ReturnType<typeof connect>>>
export type ConnectQueryError = ErrorType<ProblemDetails>

export const useConnect = <TData = Awaited<ReturnType<typeof connect>>, TError = ErrorType<ProblemDetails>>(
  params: ConnectParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof connect>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getConnectQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof connect>>> = ({ signal }) => connect(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof connect>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the current quick connect state.
 */
export const getEnabled = (

  signal?: AbortSignal
) => {
  return apiInstance<boolean>(
    {
      url: `/QuickConnect/Enabled`, method: 'get', signal
    },
  );
}


export const getGetEnabledQueryKey = () => [`/QuickConnect/Enabled`];


export type GetEnabledQueryResult = NonNullable<Awaited<ReturnType<typeof getEnabled>>>
export type GetEnabledQueryError = ErrorType<unknown>

export const useGetEnabled = <TData = Awaited<ReturnType<typeof getEnabled>>, TError = ErrorType<unknown>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getEnabled>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEnabledQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnabled>>> = ({ signal }) => getEnabled(signal);




  const query = useQuery<Awaited<ReturnType<typeof getEnabled>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Initiate a new quick connect request.
 */
export const initiate = (

  signal?: AbortSignal
) => {
  return apiInstance<QuickConnectResult>(
    {
      url: `/QuickConnect/Initiate`, method: 'get', signal
    },
  );
}


export const getInitiateQueryKey = () => [`/QuickConnect/Initiate`];


export type InitiateQueryResult = NonNullable<Awaited<ReturnType<typeof initiate>>>
export type InitiateQueryError = ErrorType<void>

export const useInitiate = <TData = Awaited<ReturnType<typeof initiate>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof initiate>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getInitiateQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof initiate>>> = ({ signal }) => initiate(signal);




  const query = useQuery<Awaited<ReturnType<typeof initiate>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets available remote images for an item.
 */
export const getRemoteImages = (
  itemId: string,
  params?: GetRemoteImagesParams,
  signal?: AbortSignal
) => {
  return apiInstance<RemoteImageResult>(
    {
      url: `/Items/${itemId}/RemoteImages`, method: 'get',
      params, signal
    },
  );
}


export const getGetRemoteImagesQueryKey = (itemId: string,
  params?: GetRemoteImagesParams,) => [`/Items/${itemId}/RemoteImages`, ...(params ? [params] : [])];


export type GetRemoteImagesQueryResult = NonNullable<Awaited<ReturnType<typeof getRemoteImages>>>
export type GetRemoteImagesQueryError = ErrorType<void | ProblemDetails>

export const useGetRemoteImages = <TData = Awaited<ReturnType<typeof getRemoteImages>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string,
  params?: GetRemoteImagesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRemoteImages>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRemoteImagesQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRemoteImages>>> = ({ signal }) => getRemoteImages(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRemoteImages>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Downloads a remote image for an item.
 */
export const downloadRemoteImage = (
  itemId: string,
  params: DownloadRemoteImageParams,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}/RemoteImages/Download`, method: 'post',
      params
    },
  );
}



export type DownloadRemoteImageMutationResult = NonNullable<Awaited<ReturnType<typeof downloadRemoteImage>>>

export type DownloadRemoteImageMutationError = ErrorType<ProblemDetails>

export const useDownloadRemoteImage = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof downloadRemoteImage>>, TError, { itemId: string; params: DownloadRemoteImageParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof downloadRemoteImage>>, { itemId: string; params: DownloadRemoteImageParams }> = (props) => {
    const { itemId, params } = props ?? {};

    return downloadRemoteImage(itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof downloadRemoteImage>>, TError, { itemId: string; params: DownloadRemoteImageParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets available remote image providers for an item.
 */
export const getRemoteImageProviders = (
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<ImageProviderInfo[]>(
    {
      url: `/Items/${itemId}/RemoteImages/Providers`, method: 'get', signal
    },
  );
}


export const getGetRemoteImageProvidersQueryKey = (itemId: string,) => [`/Items/${itemId}/RemoteImages/Providers`];


export type GetRemoteImageProvidersQueryResult = NonNullable<Awaited<ReturnType<typeof getRemoteImageProviders>>>
export type GetRemoteImageProvidersQueryError = ErrorType<void | ProblemDetails>

export const useGetRemoteImageProviders = <TData = Awaited<ReturnType<typeof getRemoteImageProviders>>, TError = ErrorType<void | ProblemDetails>>(
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRemoteImageProviders>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRemoteImageProvidersQueryKey(itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRemoteImageProviders>>> = ({ signal }) => getRemoteImageProviders(itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRemoteImageProviders>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get tasks.
 */
export const getTasks = (
  params?: GetTasksParams,
  signal?: AbortSignal
) => {
  return apiInstance<TaskInfo[]>(
    {
      url: `/ScheduledTasks`, method: 'get',
      params, signal
    },
  );
}


export const getGetTasksQueryKey = (params?: GetTasksParams,) => [`/ScheduledTasks`, ...(params ? [params] : [])];


export type GetTasksQueryResult = NonNullable<Awaited<ReturnType<typeof getTasks>>>
export type GetTasksQueryError = ErrorType<void>

export const useGetTasks = <TData = Awaited<ReturnType<typeof getTasks>>, TError = ErrorType<void>>(
  params?: GetTasksParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTasksQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTasks>>> = ({ signal }) => getTasks(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getTasks>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get task by id.
 */
export const getTask = (
  taskId: string,
  signal?: AbortSignal
) => {
  return apiInstance<TaskInfo>(
    {
      url: `/ScheduledTasks/${taskId}`, method: 'get', signal
    },
  );
}


export const getGetTaskQueryKey = (taskId: string,) => [`/ScheduledTasks/${taskId}`];


export type GetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof getTask>>>
export type GetTaskQueryError = ErrorType<void | ProblemDetails>

export const useGetTask = <TData = Awaited<ReturnType<typeof getTask>>, TError = ErrorType<void | ProblemDetails>>(
  taskId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTaskQueryKey(taskId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTask>>> = ({ signal }) => getTask(taskId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getTask>>, TError, TData>(queryKey, queryFn, { enabled: !!(taskId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Update specified task triggers.
 */
export const updateTask = (
  taskId: string,
  taskTriggerInfo: TaskTriggerInfo[],
) => {
  return apiInstance<void>(
    {
      url: `/ScheduledTasks/${taskId}/Triggers`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: taskTriggerInfo
    },
  );
}



export type UpdateTaskMutationResult = NonNullable<Awaited<ReturnType<typeof updateTask>>>
export type UpdateTaskMutationBody = TaskTriggerInfo[]
export type UpdateTaskMutationError = ErrorType<ProblemDetails>

export const useUpdateTask = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateTask>>, TError, { taskId: string; data: TaskTriggerInfo[] }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTask>>, { taskId: string; data: TaskTriggerInfo[] }> = (props) => {
    const { taskId, data } = props ?? {};

    return updateTask(taskId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateTask>>, TError, { taskId: string; data: TaskTriggerInfo[] }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Start specified task.
 */
export const startTask = (
  taskId: string,
) => {
  return apiInstance<void>(
    {
      url: `/ScheduledTasks/Running/${taskId}`, method: 'post'
    },
  );
}



export type StartTaskMutationResult = NonNullable<Awaited<ReturnType<typeof startTask>>>

export type StartTaskMutationError = ErrorType<ProblemDetails>

export const useStartTask = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof startTask>>, TError, { taskId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof startTask>>, { taskId: string }> = (props) => {
    const { taskId } = props ?? {};

    return startTask(taskId,)
  }



  return useMutation<Awaited<ReturnType<typeof startTask>>, TError, { taskId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Stop specified task.
 */
export const stopTask = (
  taskId: string,
) => {
  return apiInstance<void>(
    {
      url: `/ScheduledTasks/Running/${taskId}`, method: 'delete'
    },
  );
}



export type StopTaskMutationResult = NonNullable<Awaited<ReturnType<typeof stopTask>>>

export type StopTaskMutationError = ErrorType<ProblemDetails>

export const useStopTask = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof stopTask>>, TError, { taskId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof stopTask>>, { taskId: string }> = (props) => {
    const { taskId } = props ?? {};

    return stopTask(taskId,)
  }



  return useMutation<Awaited<ReturnType<typeof stopTask>>, TError, { taskId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the search hint result.
 */
export const get = (
  params: GetParams,
  signal?: AbortSignal
) => {
  return apiInstance<SearchHintResult>(
    {
      url: `/Search/Hints`, method: 'get',
      params, signal
    },
  );
}


export const getGetQueryKey = (params: GetParams,) => [`/Search/Hints`, ...(params ? [params] : [])];


export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>
export type GetQueryError = ErrorType<void>

export const useGet = <TData = Awaited<ReturnType<typeof get>>, TError = ErrorType<void>>(
  params: GetParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof get>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get all password reset providers.
 */
export const getPasswordResetProviders = (

  signal?: AbortSignal
) => {
  return apiInstance<NameIdPair[]>(
    {
      url: `/Auth/PasswordResetProviders`, method: 'get', signal
    },
  );
}


export const getGetPasswordResetProvidersQueryKey = () => [`/Auth/PasswordResetProviders`];


export type GetPasswordResetProvidersQueryResult = NonNullable<Awaited<ReturnType<typeof getPasswordResetProviders>>>
export type GetPasswordResetProvidersQueryError = ErrorType<void>

export const useGetPasswordResetProviders = <TData = Awaited<ReturnType<typeof getPasswordResetProviders>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPasswordResetProviders>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPasswordResetProvidersQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPasswordResetProviders>>> = ({ signal }) => getPasswordResetProviders(signal);




  const query = useQuery<Awaited<ReturnType<typeof getPasswordResetProviders>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get all auth providers.
 */
export const getAuthProviders = (

  signal?: AbortSignal
) => {
  return apiInstance<NameIdPair[]>(
    {
      url: `/Auth/Providers`, method: 'get', signal
    },
  );
}


export const getGetAuthProvidersQueryKey = () => [`/Auth/Providers`];


export type GetAuthProvidersQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthProviders>>>
export type GetAuthProvidersQueryError = ErrorType<void>

export const useGetAuthProviders = <TData = Awaited<ReturnType<typeof getAuthProviders>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAuthProviders>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthProvidersQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthProviders>>> = ({ signal }) => getAuthProviders(signal);




  const query = useQuery<Awaited<ReturnType<typeof getAuthProviders>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a list of sessions.
 */
export const getSessions = (
  params?: GetSessionsParams,
  signal?: AbortSignal
) => {
  return apiInstance<SessionInfo[]>(
    {
      url: `/Sessions`, method: 'get',
      params, signal
    },
  );
}


export const getGetSessionsQueryKey = (params?: GetSessionsParams,) => [`/Sessions`, ...(params ? [params] : [])];


export type GetSessionsQueryResult = NonNullable<Awaited<ReturnType<typeof getSessions>>>
export type GetSessionsQueryError = ErrorType<void>

export const useGetSessions = <TData = Awaited<ReturnType<typeof getSessions>>, TError = ErrorType<void>>(
  params?: GetSessionsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSessions>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSessionsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessions>>> = ({ signal }) => getSessions(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSessions>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Issues a full general command to a client.
 */
export const sendFullGeneralCommand = (
  sessionId: string,
  generalCommand: GeneralCommand,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/${sessionId}/Command`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: generalCommand
    },
  );
}



export type SendFullGeneralCommandMutationResult = NonNullable<Awaited<ReturnType<typeof sendFullGeneralCommand>>>
export type SendFullGeneralCommandMutationBody = GeneralCommand
export type SendFullGeneralCommandMutationError = ErrorType<unknown>

export const useSendFullGeneralCommand = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof sendFullGeneralCommand>>, TError, { sessionId: string; data: GeneralCommand }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendFullGeneralCommand>>, { sessionId: string; data: GeneralCommand }> = (props) => {
    const { sessionId, data } = props ?? {};

    return sendFullGeneralCommand(sessionId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof sendFullGeneralCommand>>, TError, { sessionId: string; data: GeneralCommand }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Issues a general command to a client.
 */
export const sendGeneralCommand = (
  sessionId: string,
  command: GeneralCommandType,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/${sessionId}/Command/${command}`, method: 'post'
    },
  );
}



export type SendGeneralCommandMutationResult = NonNullable<Awaited<ReturnType<typeof sendGeneralCommand>>>

export type SendGeneralCommandMutationError = ErrorType<unknown>

export const useSendGeneralCommand = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof sendGeneralCommand>>, TError, { sessionId: string; command: GeneralCommandType }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendGeneralCommand>>, { sessionId: string; command: GeneralCommandType }> = (props) => {
    const { sessionId, command } = props ?? {};

    return sendGeneralCommand(sessionId, command,)
  }



  return useMutation<Awaited<ReturnType<typeof sendGeneralCommand>>, TError, { sessionId: string; command: GeneralCommandType }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Issues a command to a client to display a message to the user.
 */
export const sendMessageCommand = (
  sessionId: string,
  messageCommand: MessageCommand,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/${sessionId}/Message`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: messageCommand
    },
  );
}



export type SendMessageCommandMutationResult = NonNullable<Awaited<ReturnType<typeof sendMessageCommand>>>
export type SendMessageCommandMutationBody = MessageCommand
export type SendMessageCommandMutationError = ErrorType<unknown>

export const useSendMessageCommand = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof sendMessageCommand>>, TError, { sessionId: string; data: MessageCommand }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendMessageCommand>>, { sessionId: string; data: MessageCommand }> = (props) => {
    const { sessionId, data } = props ?? {};

    return sendMessageCommand(sessionId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof sendMessageCommand>>, TError, { sessionId: string; data: MessageCommand }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Instructs a session to play an item.
 */
export const play = (
  sessionId: string,
  params: PlayParams,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/${sessionId}/Playing`, method: 'post',
      params
    },
  );
}



export type PlayMutationResult = NonNullable<Awaited<ReturnType<typeof play>>>

export type PlayMutationError = ErrorType<unknown>

export const usePlay = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof play>>, TError, { sessionId: string; params: PlayParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof play>>, { sessionId: string; params: PlayParams }> = (props) => {
    const { sessionId, params } = props ?? {};

    return play(sessionId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof play>>, TError, { sessionId: string; params: PlayParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Issues a playstate command to a client.
 */
export const sendPlaystateCommand = (
  sessionId: string,
  command: PlaystateCommand,
  params?: SendPlaystateCommandParams,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/${sessionId}/Playing/${command}`, method: 'post',
      params
    },
  );
}



export type SendPlaystateCommandMutationResult = NonNullable<Awaited<ReturnType<typeof sendPlaystateCommand>>>

export type SendPlaystateCommandMutationError = ErrorType<unknown>

export const useSendPlaystateCommand = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof sendPlaystateCommand>>, TError, { sessionId: string; command: PlaystateCommand; params?: SendPlaystateCommandParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendPlaystateCommand>>, { sessionId: string; command: PlaystateCommand; params?: SendPlaystateCommandParams }> = (props) => {
    const { sessionId, command, params } = props ?? {};

    return sendPlaystateCommand(sessionId, command, params,)
  }



  return useMutation<Awaited<ReturnType<typeof sendPlaystateCommand>>, TError, { sessionId: string; command: PlaystateCommand; params?: SendPlaystateCommandParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Issues a system command to a client.
 */
export const sendSystemCommand = (
  sessionId: string,
  command: GeneralCommandType,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/${sessionId}/System/${command}`, method: 'post'
    },
  );
}



export type SendSystemCommandMutationResult = NonNullable<Awaited<ReturnType<typeof sendSystemCommand>>>

export type SendSystemCommandMutationError = ErrorType<unknown>

export const useSendSystemCommand = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof sendSystemCommand>>, TError, { sessionId: string; command: GeneralCommandType }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendSystemCommand>>, { sessionId: string; command: GeneralCommandType }> = (props) => {
    const { sessionId, command } = props ?? {};

    return sendSystemCommand(sessionId, command,)
  }



  return useMutation<Awaited<ReturnType<typeof sendSystemCommand>>, TError, { sessionId: string; command: GeneralCommandType }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Adds an additional user to a session.
 */
export const addUserToSession = (
  sessionId: string,
  userId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/${sessionId}/User/${userId}`, method: 'post'
    },
  );
}



export type AddUserToSessionMutationResult = NonNullable<Awaited<ReturnType<typeof addUserToSession>>>

export type AddUserToSessionMutationError = ErrorType<unknown>

export const useAddUserToSession = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof addUserToSession>>, TError, { sessionId: string; userId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUserToSession>>, { sessionId: string; userId: string }> = (props) => {
    const { sessionId, userId } = props ?? {};

    return addUserToSession(sessionId, userId,)
  }



  return useMutation<Awaited<ReturnType<typeof addUserToSession>>, TError, { sessionId: string; userId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Removes an additional user from a session.
 */
export const removeUserFromSession = (
  sessionId: string,
  userId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/${sessionId}/User/${userId}`, method: 'delete'
    },
  );
}



export type RemoveUserFromSessionMutationResult = NonNullable<Awaited<ReturnType<typeof removeUserFromSession>>>

export type RemoveUserFromSessionMutationError = ErrorType<unknown>

export const useRemoveUserFromSession = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeUserFromSession>>, TError, { sessionId: string; userId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUserFromSession>>, { sessionId: string; userId: string }> = (props) => {
    const { sessionId, userId } = props ?? {};

    return removeUserFromSession(sessionId, userId,)
  }



  return useMutation<Awaited<ReturnType<typeof removeUserFromSession>>, TError, { sessionId: string; userId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Instructs a session to browse to an item or view.
 */
export const displayContent = (
  sessionId: string,
  params: DisplayContentParams,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/${sessionId}/Viewing`, method: 'post',
      params
    },
  );
}



export type DisplayContentMutationResult = NonNullable<Awaited<ReturnType<typeof displayContent>>>

export type DisplayContentMutationError = ErrorType<unknown>

export const useDisplayContent = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof displayContent>>, TError, { sessionId: string; params: DisplayContentParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof displayContent>>, { sessionId: string; params: DisplayContentParams }> = (props) => {
    const { sessionId, params } = props ?? {};

    return displayContent(sessionId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof displayContent>>, TError, { sessionId: string; params: DisplayContentParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates capabilities for a device.
 */
export const postCapabilities = (
  params?: PostCapabilitiesParams,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/Capabilities`, method: 'post',
      params
    },
  );
}



export type PostCapabilitiesMutationResult = NonNullable<Awaited<ReturnType<typeof postCapabilities>>>

export type PostCapabilitiesMutationError = ErrorType<unknown>

export const usePostCapabilities = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postCapabilities>>, TError, { params?: PostCapabilitiesParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCapabilities>>, { params?: PostCapabilitiesParams }> = (props) => {
    const { params } = props ?? {};

    return postCapabilities(params,)
  }



  return useMutation<Awaited<ReturnType<typeof postCapabilities>>, TError, { params?: PostCapabilitiesParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates capabilities for a device.
 */
export const postFullCapabilities = (
  clientCapabilitiesDto: ClientCapabilitiesDto,
  params?: PostFullCapabilitiesParams,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/Capabilities/Full`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: clientCapabilitiesDto,
      params
    },
  );
}



export type PostFullCapabilitiesMutationResult = NonNullable<Awaited<ReturnType<typeof postFullCapabilities>>>
export type PostFullCapabilitiesMutationBody = ClientCapabilitiesDto
export type PostFullCapabilitiesMutationError = ErrorType<unknown>

export const usePostFullCapabilities = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postFullCapabilities>>, TError, { data: ClientCapabilitiesDto; params?: PostFullCapabilitiesParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postFullCapabilities>>, { data: ClientCapabilitiesDto; params?: PostFullCapabilitiesParams }> = (props) => {
    const { data, params } = props ?? {};

    return postFullCapabilities(data, params,)
  }



  return useMutation<Awaited<ReturnType<typeof postFullCapabilities>>, TError, { data: ClientCapabilitiesDto; params?: PostFullCapabilitiesParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports that a session has ended.
 */
export const reportSessionEnded = (

) => {
  return apiInstance<void>(
    {
      url: `/Sessions/Logout`, method: 'post'
    },
  );
}



export type ReportSessionEndedMutationResult = NonNullable<Awaited<ReturnType<typeof reportSessionEnded>>>

export type ReportSessionEndedMutationError = ErrorType<unknown>

export const useReportSessionEnded = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof reportSessionEnded>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof reportSessionEnded>>, TVariables> = () => {


    return reportSessionEnded()
  }



  return useMutation<Awaited<ReturnType<typeof reportSessionEnded>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Reports that a session is viewing an item.
 */
export const reportViewing = (
  params: ReportViewingParams,
) => {
  return apiInstance<void>(
    {
      url: `/Sessions/Viewing`, method: 'post',
      params
    },
  );
}



export type ReportViewingMutationResult = NonNullable<Awaited<ReturnType<typeof reportViewing>>>

export type ReportViewingMutationError = ErrorType<unknown>

export const useReportViewing = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof reportViewing>>, TError, { params: ReportViewingParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof reportViewing>>, { params: ReportViewingParams }> = (props) => {
    const { params } = props ?? {};

    return reportViewing(params,)
  }



  return useMutation<Awaited<ReturnType<typeof reportViewing>>, TError, { params: ReportViewingParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Completes the startup wizard.
 */
export const completeWizard = (

) => {
  return apiInstance<void>(
    {
      url: `/Startup/Complete`, method: 'post'
    },
  );
}



export type CompleteWizardMutationResult = NonNullable<Awaited<ReturnType<typeof completeWizard>>>

export type CompleteWizardMutationError = ErrorType<unknown>

export const useCompleteWizard = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof completeWizard>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeWizard>>, TVariables> = () => {


    return completeWizard()
  }



  return useMutation<Awaited<ReturnType<typeof completeWizard>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the initial startup wizard configuration.
 */
export const getStartupConfiguration = (

  signal?: AbortSignal
) => {
  return apiInstance<StartupConfigurationDto>(
    {
      url: `/Startup/Configuration`, method: 'get', signal
    },
  );
}


export const getGetStartupConfigurationQueryKey = () => [`/Startup/Configuration`];


export type GetStartupConfigurationQueryResult = NonNullable<Awaited<ReturnType<typeof getStartupConfiguration>>>
export type GetStartupConfigurationQueryError = ErrorType<void>

export const useGetStartupConfiguration = <TData = Awaited<ReturnType<typeof getStartupConfiguration>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getStartupConfiguration>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStartupConfigurationQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStartupConfiguration>>> = ({ signal }) => getStartupConfiguration(signal);




  const query = useQuery<Awaited<ReturnType<typeof getStartupConfiguration>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Sets the initial startup wizard configuration.
 */
export const updateInitialConfiguration = (
  startupConfigurationDto: StartupConfigurationDto,
) => {
  return apiInstance<void>(
    {
      url: `/Startup/Configuration`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: startupConfigurationDto
    },
  );
}



export type UpdateInitialConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof updateInitialConfiguration>>>
export type UpdateInitialConfigurationMutationBody = StartupConfigurationDto
export type UpdateInitialConfigurationMutationError = ErrorType<unknown>

export const useUpdateInitialConfiguration = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateInitialConfiguration>>, TError, { data: StartupConfigurationDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateInitialConfiguration>>, { data: StartupConfigurationDto }> = (props) => {
    const { data } = props ?? {};

    return updateInitialConfiguration(data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateInitialConfiguration>>, TError, { data: StartupConfigurationDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the first user.
 */
export const getFirstUser2 = (

  signal?: AbortSignal
) => {
  return apiInstance<StartupUserDto>(
    {
      url: `/Startup/FirstUser`, method: 'get', signal
    },
  );
}


export const getGetFirstUser2QueryKey = () => [`/Startup/FirstUser`];


export type GetFirstUser2QueryResult = NonNullable<Awaited<ReturnType<typeof getFirstUser2>>>
export type GetFirstUser2QueryError = ErrorType<void>

export const useGetFirstUser2 = <TData = Awaited<ReturnType<typeof getFirstUser2>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getFirstUser2>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFirstUser2QueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFirstUser2>>> = ({ signal }) => getFirstUser2(signal);




  const query = useQuery<Awaited<ReturnType<typeof getFirstUser2>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Sets remote access and UPnP.
 */
export const setRemoteAccess = (
  startupRemoteAccessDto: StartupRemoteAccessDto,
) => {
  return apiInstance<void>(
    {
      url: `/Startup/RemoteAccess`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: startupRemoteAccessDto
    },
  );
}



export type SetRemoteAccessMutationResult = NonNullable<Awaited<ReturnType<typeof setRemoteAccess>>>
export type SetRemoteAccessMutationBody = StartupRemoteAccessDto
export type SetRemoteAccessMutationError = ErrorType<unknown>

export const useSetRemoteAccess = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof setRemoteAccess>>, TError, { data: StartupRemoteAccessDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setRemoteAccess>>, { data: StartupRemoteAccessDto }> = (props) => {
    const { data } = props ?? {};

    return setRemoteAccess(data,)
  }



  return useMutation<Awaited<ReturnType<typeof setRemoteAccess>>, TError, { data: StartupRemoteAccessDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the first user.
 */
export const getFirstUser = (

  signal?: AbortSignal
) => {
  return apiInstance<StartupUserDto>(
    {
      url: `/Startup/User`, method: 'get', signal
    },
  );
}


export const getGetFirstUserQueryKey = () => [`/Startup/User`];


export type GetFirstUserQueryResult = NonNullable<Awaited<ReturnType<typeof getFirstUser>>>
export type GetFirstUserQueryError = ErrorType<void>

export const useGetFirstUser = <TData = Awaited<ReturnType<typeof getFirstUser>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getFirstUser>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFirstUserQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFirstUser>>> = ({ signal }) => getFirstUser(signal);




  const query = useQuery<Awaited<ReturnType<typeof getFirstUser>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Sets the user name and password.
 */
export const updateStartupUser = (
  startupUserDto: StartupUserDto,
) => {
  return apiInstance<void>(
    {
      url: `/Startup/User`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: startupUserDto
    },
  );
}



export type UpdateStartupUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateStartupUser>>>
export type UpdateStartupUserMutationBody = StartupUserDto
export type UpdateStartupUserMutationError = ErrorType<unknown>

export const useUpdateStartupUser = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateStartupUser>>, TError, { data: StartupUserDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStartupUser>>, { data: StartupUserDto }> = (props) => {
    const { data } = props ?? {};

    return updateStartupUser(data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateStartupUser>>, TError, { data: StartupUserDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets all studios from a given item, folder, or the entire library.
 */
export const getStudios = (
  params?: GetStudiosParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Studios`, method: 'get',
      params, signal
    },
  );
}


export const getGetStudiosQueryKey = (params?: GetStudiosParams,) => [`/Studios`, ...(params ? [params] : [])];


export type GetStudiosQueryResult = NonNullable<Awaited<ReturnType<typeof getStudios>>>
export type GetStudiosQueryError = ErrorType<void>

export const useGetStudios = <TData = Awaited<ReturnType<typeof getStudios>>, TError = ErrorType<void>>(
  params?: GetStudiosParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getStudios>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudiosQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudios>>> = ({ signal }) => getStudios(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getStudios>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a studio by name.
 */
export const getStudio = (
  name: string,
  params?: GetStudioParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/Studios/${name}`, method: 'get',
      params, signal
    },
  );
}


export const getGetStudioQueryKey = (name: string,
  params?: GetStudioParams,) => [`/Studios/${name}`, ...(params ? [params] : [])];


export type GetStudioQueryResult = NonNullable<Awaited<ReturnType<typeof getStudio>>>
export type GetStudioQueryError = ErrorType<void>

export const useGetStudio = <TData = Awaited<ReturnType<typeof getStudio>>, TError = ErrorType<void>>(
  name: string,
  params?: GetStudioParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getStudio>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudioQueryKey(name, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudio>>> = ({ signal }) => getStudio(name, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getStudio>>, TError, TData>(queryKey, queryFn, { enabled: !!(name), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a list of available fallback font files.
 */
export const getFallbackFontList = (

  signal?: AbortSignal
) => {
  return apiInstance<FontFile[]>(
    {
      url: `/FallbackFont/Fonts`, method: 'get', signal
    },
  );
}


export const getGetFallbackFontListQueryKey = () => [`/FallbackFont/Fonts`];


export type GetFallbackFontListQueryResult = NonNullable<Awaited<ReturnType<typeof getFallbackFontList>>>
export type GetFallbackFontListQueryError = ErrorType<void>

export const useGetFallbackFontList = <TData = Awaited<ReturnType<typeof getFallbackFontList>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getFallbackFontList>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFallbackFontListQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFallbackFontList>>> = ({ signal }) => getFallbackFontList(signal);




  const query = useQuery<Awaited<ReturnType<typeof getFallbackFontList>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a fallback font file.
 */
export const getFallbackFont = (
  name: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/FallbackFont/Fonts/${name}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetFallbackFontQueryKey = (name: string,) => [`/FallbackFont/Fonts/${name}`];


export type GetFallbackFontQueryResult = NonNullable<Awaited<ReturnType<typeof getFallbackFont>>>
export type GetFallbackFontQueryError = ErrorType<void>

export const useGetFallbackFont = <TData = Awaited<ReturnType<typeof getFallbackFont>>, TError = ErrorType<void>>(
  name: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getFallbackFont>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFallbackFontQueryKey(name);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFallbackFont>>> = ({ signal }) => getFallbackFont(name, signal);




  const query = useQuery<Awaited<ReturnType<typeof getFallbackFont>>, TError, TData>(queryKey, queryFn, { enabled: !!(name), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Search remote subtitles.
 */
export const searchRemoteSubtitles = (
  itemId: string,
  language: string,
  params?: SearchRemoteSubtitlesParams,
  signal?: AbortSignal
) => {
  return apiInstance<RemoteSubtitleInfo[]>(
    {
      url: `/Items/${itemId}/RemoteSearch/Subtitles/${language}`, method: 'get',
      params, signal
    },
  );
}


export const getSearchRemoteSubtitlesQueryKey = (itemId: string,
  language: string,
  params?: SearchRemoteSubtitlesParams,) => [`/Items/${itemId}/RemoteSearch/Subtitles/${language}`, ...(params ? [params] : [])];


export type SearchRemoteSubtitlesQueryResult = NonNullable<Awaited<ReturnType<typeof searchRemoteSubtitles>>>
export type SearchRemoteSubtitlesQueryError = ErrorType<void>

export const useSearchRemoteSubtitles = <TData = Awaited<ReturnType<typeof searchRemoteSubtitles>>, TError = ErrorType<void>>(
  itemId: string,
  language: string,
  params?: SearchRemoteSubtitlesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof searchRemoteSubtitles>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchRemoteSubtitlesQueryKey(itemId, language, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchRemoteSubtitles>>> = ({ signal }) => searchRemoteSubtitles(itemId, language, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof searchRemoteSubtitles>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && language), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Downloads a remote subtitle.
 */
export const downloadRemoteSubtitles = (
  itemId: string,
  subtitleId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Items/${itemId}/RemoteSearch/Subtitles/${subtitleId}`, method: 'post'
    },
  );
}



export type DownloadRemoteSubtitlesMutationResult = NonNullable<Awaited<ReturnType<typeof downloadRemoteSubtitles>>>

export type DownloadRemoteSubtitlesMutationError = ErrorType<unknown>

export const useDownloadRemoteSubtitles = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof downloadRemoteSubtitles>>, TError, { itemId: string; subtitleId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof downloadRemoteSubtitles>>, { itemId: string; subtitleId: string }> = (props) => {
    const { itemId, subtitleId } = props ?? {};

    return downloadRemoteSubtitles(itemId, subtitleId,)
  }



  return useMutation<Awaited<ReturnType<typeof downloadRemoteSubtitles>>, TError, { itemId: string; subtitleId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the remote subtitles.
 */
export const getRemoteSubtitles = (
  id: string,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Providers/Subtitles/Subtitles/${id}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetRemoteSubtitlesQueryKey = (id: string,) => [`/Providers/Subtitles/Subtitles/${id}`];


export type GetRemoteSubtitlesQueryResult = NonNullable<Awaited<ReturnType<typeof getRemoteSubtitles>>>
export type GetRemoteSubtitlesQueryError = ErrorType<void>

export const useGetRemoteSubtitles = <TData = Awaited<ReturnType<typeof getRemoteSubtitles>>, TError = ErrorType<void>>(
  id: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRemoteSubtitles>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRemoteSubtitlesQueryKey(id);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRemoteSubtitles>>> = ({ signal }) => getRemoteSubtitles(id, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRemoteSubtitles>>, TError, TData>(queryKey, queryFn, { enabled: !!(id), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an HLS subtitle playlist.
 */
export const getSubtitlePlaylist = (
  itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/${mediaSourceId}/Subtitles/${index}/subtitles.m3u8`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetSubtitlePlaylistQueryKey = (itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams,) => [`/Videos/${itemId}/${mediaSourceId}/Subtitles/${index}/subtitles.m3u8`, ...(params ? [params] : [])];


export type GetSubtitlePlaylistQueryResult = NonNullable<Awaited<ReturnType<typeof getSubtitlePlaylist>>>
export type GetSubtitlePlaylistQueryError = ErrorType<void>

export const useGetSubtitlePlaylist = <TData = Awaited<ReturnType<typeof getSubtitlePlaylist>>, TError = ErrorType<void>>(
  itemId: string,
  mediaSourceId: string,
  index: number,
  params: GetSubtitlePlaylistParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSubtitlePlaylist>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSubtitlePlaylistQueryKey(itemId, mediaSourceId, index, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubtitlePlaylist>>> = ({ signal }) => getSubtitlePlaylist(itemId, mediaSourceId, index, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSubtitlePlaylist>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && mediaSourceId && index), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Upload an external subtitle file.
 */
export const uploadSubtitle = (
  itemId: string,
  uploadSubtitleDto: UploadSubtitleDto,
) => {
  return apiInstance<void>(
    {
      url: `/Videos/${itemId}/Subtitles`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: uploadSubtitleDto
    },
  );
}



export type UploadSubtitleMutationResult = NonNullable<Awaited<ReturnType<typeof uploadSubtitle>>>
export type UploadSubtitleMutationBody = UploadSubtitleDto
export type UploadSubtitleMutationError = ErrorType<unknown>

export const useUploadSubtitle = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof uploadSubtitle>>, TError, { itemId: string; data: UploadSubtitleDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadSubtitle>>, { itemId: string; data: UploadSubtitleDto }> = (props) => {
    const { itemId, data } = props ?? {};

    return uploadSubtitle(itemId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof uploadSubtitle>>, TError, { itemId: string; data: UploadSubtitleDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Deletes an external subtitle file.
 */
export const deleteSubtitle = (
  itemId: string,
  index: number,
) => {
  return apiInstance<void>(
    {
      url: `/Videos/${itemId}/Subtitles/${index}`, method: 'delete'
    },
  );
}



export type DeleteSubtitleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSubtitle>>>

export type DeleteSubtitleMutationError = ErrorType<ProblemDetails>

export const useDeleteSubtitle = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteSubtitle>>, TError, { itemId: string; index: number }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSubtitle>>, { itemId: string; index: number }> = (props) => {
    const { itemId, index } = props ?? {};

    return deleteSubtitle(itemId, index,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteSubtitle>>, TError, { itemId: string; index: number }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets subtitles in a specified format.
 */
export const getSubtitleWithTicks = (
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params?: GetSubtitleWithTicksParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${routeItemId}/${routeMediaSourceId}/Subtitles/${routeIndex}/${routeStartPositionTicks}/Stream.${routeFormat}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetSubtitleWithTicksQueryKey = (routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params?: GetSubtitleWithTicksParams,) => [`/Videos/${routeItemId}/${routeMediaSourceId}/Subtitles/${routeIndex}/${routeStartPositionTicks}/Stream.${routeFormat}`, ...(params ? [params] : [])];


export type GetSubtitleWithTicksQueryResult = NonNullable<Awaited<ReturnType<typeof getSubtitleWithTicks>>>
export type GetSubtitleWithTicksQueryError = ErrorType<unknown>

export const useGetSubtitleWithTicks = <TData = Awaited<ReturnType<typeof getSubtitleWithTicks>>, TError = ErrorType<unknown>>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeStartPositionTicks: number,
  routeFormat: string,
  params?: GetSubtitleWithTicksParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSubtitleWithTicks>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSubtitleWithTicksQueryKey(routeItemId, routeMediaSourceId, routeIndex, routeStartPositionTicks, routeFormat, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubtitleWithTicks>>> = ({ signal }) => getSubtitleWithTicks(routeItemId, routeMediaSourceId, routeIndex, routeStartPositionTicks, routeFormat, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSubtitleWithTicks>>, TError, TData>(queryKey, queryFn, { enabled: !!(routeItemId && routeMediaSourceId && routeIndex && routeStartPositionTicks && routeFormat), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets subtitles in a specified format.
 */
export const getSubtitle = (
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params?: GetSubtitleParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${routeItemId}/${routeMediaSourceId}/Subtitles/${routeIndex}/Stream.${routeFormat}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetSubtitleQueryKey = (routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params?: GetSubtitleParams,) => [`/Videos/${routeItemId}/${routeMediaSourceId}/Subtitles/${routeIndex}/Stream.${routeFormat}`, ...(params ? [params] : [])];


export type GetSubtitleQueryResult = NonNullable<Awaited<ReturnType<typeof getSubtitle>>>
export type GetSubtitleQueryError = ErrorType<unknown>

export const useGetSubtitle = <TData = Awaited<ReturnType<typeof getSubtitle>>, TError = ErrorType<unknown>>(
  routeItemId: string,
  routeMediaSourceId: string,
  routeIndex: number,
  routeFormat: string,
  params?: GetSubtitleParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSubtitle>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSubtitleQueryKey(routeItemId, routeMediaSourceId, routeIndex, routeFormat, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubtitle>>> = ({ signal }) => getSubtitle(routeItemId, routeMediaSourceId, routeIndex, routeFormat, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSubtitle>>, TError, TData>(queryKey, queryFn, { enabled: !!(routeItemId && routeMediaSourceId && routeIndex && routeFormat), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets suggestions.
 */
export const getSuggestions = (
  userId: string,
  params?: GetSuggestionsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Users/${userId}/Suggestions`, method: 'get',
      params, signal
    },
  );
}


export const getGetSuggestionsQueryKey = (userId: string,
  params?: GetSuggestionsParams,) => [`/Users/${userId}/Suggestions`, ...(params ? [params] : [])];


export type GetSuggestionsQueryResult = NonNullable<Awaited<ReturnType<typeof getSuggestions>>>
export type GetSuggestionsQueryError = ErrorType<void>

export const useGetSuggestions = <TData = Awaited<ReturnType<typeof getSuggestions>>, TError = ErrorType<void>>(
  userId: string,
  params?: GetSuggestionsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSuggestions>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSuggestionsQueryKey(userId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSuggestions>>> = ({ signal }) => getSuggestions(userId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSuggestions>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Notify SyncPlay group that member is buffering.
 */
export const syncPlayBuffering = (
  bufferRequestDto: BufferRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Buffering`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: bufferRequestDto
    },
  );
}



export type SyncPlayBufferingMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayBuffering>>>
export type SyncPlayBufferingMutationBody = BufferRequestDto
export type SyncPlayBufferingMutationError = ErrorType<unknown>

export const useSyncPlayBuffering = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayBuffering>>, TError, { data: BufferRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayBuffering>>, { data: BufferRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayBuffering(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayBuffering>>, TError, { data: BufferRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Join an existing SyncPlay group.
 */
export const syncPlayJoinGroup = (
  joinGroupRequestDto: JoinGroupRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Join`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: joinGroupRequestDto
    },
  );
}



export type SyncPlayJoinGroupMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayJoinGroup>>>
export type SyncPlayJoinGroupMutationBody = JoinGroupRequestDto
export type SyncPlayJoinGroupMutationError = ErrorType<unknown>

export const useSyncPlayJoinGroup = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayJoinGroup>>, TError, { data: JoinGroupRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayJoinGroup>>, { data: JoinGroupRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayJoinGroup(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayJoinGroup>>, TError, { data: JoinGroupRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Leave the joined SyncPlay group.
 */
export const syncPlayLeaveGroup = (

) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Leave`, method: 'post'
    },
  );
}



export type SyncPlayLeaveGroupMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayLeaveGroup>>>

export type SyncPlayLeaveGroupMutationError = ErrorType<unknown>

export const useSyncPlayLeaveGroup = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayLeaveGroup>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayLeaveGroup>>, TVariables> = () => {


    return syncPlayLeaveGroup()
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayLeaveGroup>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets all SyncPlay groups.
 */
export const syncPlayGetGroups = (

  signal?: AbortSignal
) => {
  return apiInstance<GroupInfoDto[]>(
    {
      url: `/SyncPlay/List`, method: 'get', signal
    },
  );
}


export const getSyncPlayGetGroupsQueryKey = () => [`/SyncPlay/List`];


export type SyncPlayGetGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof syncPlayGetGroups>>>
export type SyncPlayGetGroupsQueryError = ErrorType<void>

export const useSyncPlayGetGroups = <TData = Awaited<ReturnType<typeof syncPlayGetGroups>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof syncPlayGetGroups>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSyncPlayGetGroupsQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof syncPlayGetGroups>>> = ({ signal }) => syncPlayGetGroups(signal);




  const query = useQuery<Awaited<ReturnType<typeof syncPlayGetGroups>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Request to move an item in the playlist in SyncPlay group.
 */
export const syncPlayMovePlaylistItem = (
  movePlaylistItemRequestDto: MovePlaylistItemRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/MovePlaylistItem`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: movePlaylistItemRequestDto
    },
  );
}



export type SyncPlayMovePlaylistItemMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>>
export type SyncPlayMovePlaylistItemMutationBody = MovePlaylistItemRequestDto
export type SyncPlayMovePlaylistItemMutationError = ErrorType<unknown>

export const useSyncPlayMovePlaylistItem = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>, TError, { data: MovePlaylistItemRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>, { data: MovePlaylistItemRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayMovePlaylistItem(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayMovePlaylistItem>>, TError, { data: MovePlaylistItemRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Create a new SyncPlay group.
 */
export const syncPlayCreateGroup = (
  newGroupRequestDto: NewGroupRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/New`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: newGroupRequestDto
    },
  );
}



export type SyncPlayCreateGroupMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayCreateGroup>>>
export type SyncPlayCreateGroupMutationBody = NewGroupRequestDto
export type SyncPlayCreateGroupMutationError = ErrorType<unknown>

export const useSyncPlayCreateGroup = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayCreateGroup>>, TError, { data: NewGroupRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayCreateGroup>>, { data: NewGroupRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayCreateGroup(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayCreateGroup>>, TError, { data: NewGroupRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request next item in SyncPlay group.
 */
export const syncPlayNextItem = (
  nextItemRequestDto: NextItemRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/NextItem`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: nextItemRequestDto
    },
  );
}



export type SyncPlayNextItemMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayNextItem>>>
export type SyncPlayNextItemMutationBody = NextItemRequestDto
export type SyncPlayNextItemMutationError = ErrorType<unknown>

export const useSyncPlayNextItem = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayNextItem>>, TError, { data: NextItemRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayNextItem>>, { data: NextItemRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayNextItem(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayNextItem>>, TError, { data: NextItemRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request pause in SyncPlay group.
 */
export const syncPlayPause = (

) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Pause`, method: 'post'
    },
  );
}



export type SyncPlayPauseMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayPause>>>

export type SyncPlayPauseMutationError = ErrorType<unknown>

export const useSyncPlayPause = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayPause>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayPause>>, TVariables> = () => {


    return syncPlayPause()
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayPause>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Update session ping.
 */
export const syncPlayPing = (
  pingRequestDto: PingRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Ping`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: pingRequestDto
    },
  );
}



export type SyncPlayPingMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayPing>>>
export type SyncPlayPingMutationBody = PingRequestDto
export type SyncPlayPingMutationError = ErrorType<unknown>

export const useSyncPlayPing = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayPing>>, TError, { data: PingRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayPing>>, { data: PingRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayPing(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayPing>>, TError, { data: PingRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request previous item in SyncPlay group.
 */
export const syncPlayPreviousItem = (
  previousItemRequestDto: PreviousItemRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/PreviousItem`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: previousItemRequestDto
    },
  );
}



export type SyncPlayPreviousItemMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayPreviousItem>>>
export type SyncPlayPreviousItemMutationBody = PreviousItemRequestDto
export type SyncPlayPreviousItemMutationError = ErrorType<unknown>

export const useSyncPlayPreviousItem = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayPreviousItem>>, TError, { data: PreviousItemRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayPreviousItem>>, { data: PreviousItemRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayPreviousItem(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayPreviousItem>>, TError, { data: PreviousItemRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request to queue items to the playlist of a SyncPlay group.
 */
export const syncPlayQueue = (
  queueRequestDto: QueueRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Queue`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: queueRequestDto
    },
  );
}



export type SyncPlayQueueMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayQueue>>>
export type SyncPlayQueueMutationBody = QueueRequestDto
export type SyncPlayQueueMutationError = ErrorType<unknown>

export const useSyncPlayQueue = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayQueue>>, TError, { data: QueueRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayQueue>>, { data: QueueRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayQueue(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayQueue>>, TError, { data: QueueRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Notify SyncPlay group that member is ready for playback.
 */
export const syncPlayReady = (
  readyRequestDto: ReadyRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Ready`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: readyRequestDto
    },
  );
}



export type SyncPlayReadyMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayReady>>>
export type SyncPlayReadyMutationBody = ReadyRequestDto
export type SyncPlayReadyMutationError = ErrorType<unknown>

export const useSyncPlayReady = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayReady>>, TError, { data: ReadyRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayReady>>, { data: ReadyRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayReady(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayReady>>, TError, { data: ReadyRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request to remove items from the playlist in SyncPlay group.
 */
export const syncPlayRemoveFromPlaylist = (
  removeFromPlaylistRequestDto: RemoveFromPlaylistRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/RemoveFromPlaylist`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: removeFromPlaylistRequestDto
    },
  );
}



export type SyncPlayRemoveFromPlaylistMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>>
export type SyncPlayRemoveFromPlaylistMutationBody = RemoveFromPlaylistRequestDto
export type SyncPlayRemoveFromPlaylistMutationError = ErrorType<unknown>

export const useSyncPlayRemoveFromPlaylist = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>, TError, { data: RemoveFromPlaylistRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>, { data: RemoveFromPlaylistRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlayRemoveFromPlaylist(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayRemoveFromPlaylist>>, TError, { data: RemoveFromPlaylistRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request seek in SyncPlay group.
 */
export const syncPlaySeek = (
  seekRequestDto: SeekRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Seek`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: seekRequestDto
    },
  );
}



export type SyncPlaySeekMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlaySeek>>>
export type SyncPlaySeekMutationBody = SeekRequestDto
export type SyncPlaySeekMutationError = ErrorType<unknown>

export const useSyncPlaySeek = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlaySeek>>, TError, { data: SeekRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlaySeek>>, { data: SeekRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlaySeek(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlaySeek>>, TError, { data: SeekRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request SyncPlay group to ignore member during group-wait.
 */
export const syncPlaySetIgnoreWait = (
  ignoreWaitRequestDto: IgnoreWaitRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/SetIgnoreWait`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: ignoreWaitRequestDto
    },
  );
}



export type SyncPlaySetIgnoreWaitMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>>
export type SyncPlaySetIgnoreWaitMutationBody = IgnoreWaitRequestDto
export type SyncPlaySetIgnoreWaitMutationError = ErrorType<unknown>

export const useSyncPlaySetIgnoreWait = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>, TError, { data: IgnoreWaitRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>, { data: IgnoreWaitRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlaySetIgnoreWait(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlaySetIgnoreWait>>, TError, { data: IgnoreWaitRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request to set new playlist in SyncPlay group.
 */
export const syncPlaySetNewQueue = (
  playRequestDto: PlayRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/SetNewQueue`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: playRequestDto
    },
  );
}



export type SyncPlaySetNewQueueMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlaySetNewQueue>>>
export type SyncPlaySetNewQueueMutationBody = PlayRequestDto
export type SyncPlaySetNewQueueMutationError = ErrorType<unknown>

export const useSyncPlaySetNewQueue = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlaySetNewQueue>>, TError, { data: PlayRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlaySetNewQueue>>, { data: PlayRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlaySetNewQueue(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlaySetNewQueue>>, TError, { data: PlayRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request to change playlist item in SyncPlay group.
 */
export const syncPlaySetPlaylistItem = (
  setPlaylistItemRequestDto: SetPlaylistItemRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/SetPlaylistItem`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: setPlaylistItemRequestDto
    },
  );
}



export type SyncPlaySetPlaylistItemMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>>
export type SyncPlaySetPlaylistItemMutationBody = SetPlaylistItemRequestDto
export type SyncPlaySetPlaylistItemMutationError = ErrorType<unknown>

export const useSyncPlaySetPlaylistItem = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>, TError, { data: SetPlaylistItemRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>, { data: SetPlaylistItemRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlaySetPlaylistItem(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlaySetPlaylistItem>>, TError, { data: SetPlaylistItemRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request to set repeat mode in SyncPlay group.
 */
export const syncPlaySetRepeatMode = (
  setRepeatModeRequestDto: SetRepeatModeRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/SetRepeatMode`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: setRepeatModeRequestDto
    },
  );
}



export type SyncPlaySetRepeatModeMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlaySetRepeatMode>>>
export type SyncPlaySetRepeatModeMutationBody = SetRepeatModeRequestDto
export type SyncPlaySetRepeatModeMutationError = ErrorType<unknown>

export const useSyncPlaySetRepeatMode = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlaySetRepeatMode>>, TError, { data: SetRepeatModeRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlaySetRepeatMode>>, { data: SetRepeatModeRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlaySetRepeatMode(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlaySetRepeatMode>>, TError, { data: SetRepeatModeRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request to set shuffle mode in SyncPlay group.
 */
export const syncPlaySetShuffleMode = (
  setShuffleModeRequestDto: SetShuffleModeRequestDto,
) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/SetShuffleMode`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: setShuffleModeRequestDto
    },
  );
}



export type SyncPlaySetShuffleModeMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlaySetShuffleMode>>>
export type SyncPlaySetShuffleModeMutationBody = SetShuffleModeRequestDto
export type SyncPlaySetShuffleModeMutationError = ErrorType<unknown>

export const useSyncPlaySetShuffleMode = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlaySetShuffleMode>>, TError, { data: SetShuffleModeRequestDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlaySetShuffleMode>>, { data: SetShuffleModeRequestDto }> = (props) => {
    const { data } = props ?? {};

    return syncPlaySetShuffleMode(data,)
  }



  return useMutation<Awaited<ReturnType<typeof syncPlaySetShuffleMode>>, TError, { data: SetShuffleModeRequestDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request stop in SyncPlay group.
 */
export const syncPlayStop = (

) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Stop`, method: 'post'
    },
  );
}



export type SyncPlayStopMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayStop>>>

export type SyncPlayStopMutationError = ErrorType<unknown>

export const useSyncPlayStop = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayStop>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayStop>>, TVariables> = () => {


    return syncPlayStop()
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayStop>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Request unpause in SyncPlay group.
 */
export const syncPlayUnpause = (

) => {
  return apiInstance<void>(
    {
      url: `/SyncPlay/Unpause`, method: 'post'
    },
  );
}



export type SyncPlayUnpauseMutationResult = NonNullable<Awaited<ReturnType<typeof syncPlayUnpause>>>

export type SyncPlayUnpauseMutationError = ErrorType<unknown>

export const useSyncPlayUnpause = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof syncPlayUnpause>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncPlayUnpause>>, TVariables> = () => {


    return syncPlayUnpause()
  }



  return useMutation<Awaited<ReturnType<typeof syncPlayUnpause>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets information about the request endpoint.
 */
export const getEndpointInfo = (

  signal?: AbortSignal
) => {
  return apiInstance<EndPointInfo>(
    {
      url: `/System/Endpoint`, method: 'get', signal
    },
  );
}


export const getGetEndpointInfoQueryKey = () => [`/System/Endpoint`];


export type GetEndpointInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointInfo>>>
export type GetEndpointInfoQueryError = ErrorType<void>

export const useGetEndpointInfo = <TData = Awaited<ReturnType<typeof getEndpointInfo>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getEndpointInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEndpointInfoQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointInfo>>> = ({ signal }) => getEndpointInfo(signal);




  const query = useQuery<Awaited<ReturnType<typeof getEndpointInfo>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets information about the server.
 */
export const getSystemInfo = (

  signal?: AbortSignal
) => {
  return apiInstance<SystemInfo>(
    {
      url: `/System/Info`, method: 'get', signal
    },
  );
}


export const getGetSystemInfoQueryKey = () => [`/System/Info`];


export type GetSystemInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getSystemInfo>>>
export type GetSystemInfoQueryError = ErrorType<void>

export const useGetSystemInfo = <TData = Awaited<ReturnType<typeof getSystemInfo>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSystemInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSystemInfoQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemInfo>>> = ({ signal }) => getSystemInfo(signal);




  const query = useQuery<Awaited<ReturnType<typeof getSystemInfo>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets public information about the server.
 */
export const getPublicSystemInfo = (

  signal?: AbortSignal
) => {
  return apiInstance<PublicSystemInfo>(
    {
      url: `/System/Info/Public`, method: 'get', signal
    },
  );
}


export const getGetPublicSystemInfoQueryKey = () => [`/System/Info/Public`];


export type GetPublicSystemInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicSystemInfo>>>
export type GetPublicSystemInfoQueryError = ErrorType<unknown>

export const useGetPublicSystemInfo = <TData = Awaited<ReturnType<typeof getPublicSystemInfo>>, TError = ErrorType<unknown>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPublicSystemInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicSystemInfoQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicSystemInfo>>> = ({ signal }) => getPublicSystemInfo(signal);




  const query = useQuery<Awaited<ReturnType<typeof getPublicSystemInfo>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a list of available server log files.
 */
export const getServerLogs = (

  signal?: AbortSignal
) => {
  return apiInstance<LogFile[]>(
    {
      url: `/System/Logs`, method: 'get', signal
    },
  );
}


export const getGetServerLogsQueryKey = () => [`/System/Logs`];


export type GetServerLogsQueryResult = NonNullable<Awaited<ReturnType<typeof getServerLogs>>>
export type GetServerLogsQueryError = ErrorType<void>

export const useGetServerLogs = <TData = Awaited<ReturnType<typeof getServerLogs>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getServerLogs>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetServerLogsQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getServerLogs>>> = ({ signal }) => getServerLogs(signal);




  const query = useQuery<Awaited<ReturnType<typeof getServerLogs>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a log file.
 */
export const getLogFile = (
  params: GetLogFileParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/System/Logs/Log`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetLogFileQueryKey = (params: GetLogFileParams,) => [`/System/Logs/Log`, ...(params ? [params] : [])];


export type GetLogFileQueryResult = NonNullable<Awaited<ReturnType<typeof getLogFile>>>
export type GetLogFileQueryError = ErrorType<void>

export const useGetLogFile = <TData = Awaited<ReturnType<typeof getLogFile>>, TError = ErrorType<void>>(
  params: GetLogFileParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLogFile>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLogFileQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLogFile>>> = ({ signal }) => getLogFile(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLogFile>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Pings the system.
 */
export const getPingSystem = (

  signal?: AbortSignal
) => {
  return apiInstance<string>(
    {
      url: `/System/Ping`, method: 'get', signal
    },
  );
}


export const getGetPingSystemQueryKey = () => [`/System/Ping`];


export type GetPingSystemQueryResult = NonNullable<Awaited<ReturnType<typeof getPingSystem>>>
export type GetPingSystemQueryError = ErrorType<unknown>

export const useGetPingSystem = <TData = Awaited<ReturnType<typeof getPingSystem>>, TError = ErrorType<unknown>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPingSystem>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPingSystemQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPingSystem>>> = ({ signal }) => getPingSystem(signal);




  const query = useQuery<Awaited<ReturnType<typeof getPingSystem>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Pings the system.
 */
export const postPingSystem = (

) => {
  return apiInstance<string>(
    {
      url: `/System/Ping`, method: 'post'
    },
  );
}



export type PostPingSystemMutationResult = NonNullable<Awaited<ReturnType<typeof postPingSystem>>>

export type PostPingSystemMutationError = ErrorType<unknown>

export const usePostPingSystem = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof postPingSystem>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPingSystem>>, TVariables> = () => {


    return postPingSystem()
  }



  return useMutation<Awaited<ReturnType<typeof postPingSystem>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Restarts the application.
 */
export const restartApplication = (

) => {
  return apiInstance<void>(
    {
      url: `/System/Restart`, method: 'post'
    },
  );
}



export type RestartApplicationMutationResult = NonNullable<Awaited<ReturnType<typeof restartApplication>>>

export type RestartApplicationMutationError = ErrorType<unknown>

export const useRestartApplication = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof restartApplication>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof restartApplication>>, TVariables> = () => {


    return restartApplication()
  }



  return useMutation<Awaited<ReturnType<typeof restartApplication>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Shuts down the application.
 */
export const shutdownApplication = (

) => {
  return apiInstance<void>(
    {
      url: `/System/Shutdown`, method: 'post'
    },
  );
}



export type ShutdownApplicationMutationResult = NonNullable<Awaited<ReturnType<typeof shutdownApplication>>>

export type ShutdownApplicationMutationError = ErrorType<unknown>

export const useShutdownApplication = <TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof shutdownApplication>>, TError, TVariables, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof shutdownApplication>>, TVariables> = () => {


    return shutdownApplication()
  }



  return useMutation<Awaited<ReturnType<typeof shutdownApplication>>, TError, TVariables, TContext>(mutationFn, mutationOptions);
}

/**
 * @deprecated
 * @summary Gets wake on lan information.
 */
export const getWakeOnLanInfo = (

  signal?: AbortSignal
) => {
  return apiInstance<WakeOnLanInfo[]>(
    {
      url: `/System/WakeOnLanInfo`, method: 'get', signal
    },
  );
}


export const getGetWakeOnLanInfoQueryKey = () => [`/System/WakeOnLanInfo`];


export type GetWakeOnLanInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getWakeOnLanInfo>>>
export type GetWakeOnLanInfoQueryError = ErrorType<void>

export const useGetWakeOnLanInfo = <TData = Awaited<ReturnType<typeof getWakeOnLanInfo>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getWakeOnLanInfo>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWakeOnLanInfoQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWakeOnLanInfo>>> = ({ signal }) => getWakeOnLanInfo(signal);




  const query = useQuery<Awaited<ReturnType<typeof getWakeOnLanInfo>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the current UTC time.
 */
export const getUtcTime = (

  signal?: AbortSignal
) => {
  return apiInstance<UtcTimeResponse>(
    {
      url: `/GetUtcTime`, method: 'get', signal
    },
  );
}


export const getGetUtcTimeQueryKey = () => [`/GetUtcTime`];


export type GetUtcTimeQueryResult = NonNullable<Awaited<ReturnType<typeof getUtcTime>>>
export type GetUtcTimeQueryError = ErrorType<unknown>

export const useGetUtcTime = <TData = Awaited<ReturnType<typeof getUtcTime>>, TError = ErrorType<unknown>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUtcTime>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUtcTimeQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUtcTime>>> = ({ signal }) => getUtcTime(signal);




  const query = useQuery<Awaited<ReturnType<typeof getUtcTime>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the TMDb image configuration options.
 */
export const tmdbClientConfiguration = (

  signal?: AbortSignal
) => {
  return apiInstance<ConfigImageTypes>(
    {
      url: `/Tmdb/ClientConfiguration`, method: 'get', signal
    },
  );
}


export const getTmdbClientConfigurationQueryKey = () => [`/Tmdb/ClientConfiguration`];


export type TmdbClientConfigurationQueryResult = NonNullable<Awaited<ReturnType<typeof tmdbClientConfiguration>>>
export type TmdbClientConfigurationQueryError = ErrorType<void>

export const useTmdbClientConfiguration = <TData = Awaited<ReturnType<typeof tmdbClientConfiguration>>, TError = ErrorType<void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof tmdbClientConfiguration>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTmdbClientConfigurationQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof tmdbClientConfiguration>>> = ({ signal }) => tmdbClientConfiguration(signal);




  const query = useQuery<Awaited<ReturnType<typeof tmdbClientConfiguration>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Finds movies and trailers similar to a given trailer.
 */
export const getTrailers = (
  params?: GetTrailersParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Trailers`, method: 'get',
      params, signal
    },
  );
}


export const getGetTrailersQueryKey = (params?: GetTrailersParams,) => [`/Trailers`, ...(params ? [params] : [])];


export type GetTrailersQueryResult = NonNullable<Awaited<ReturnType<typeof getTrailers>>>
export type GetTrailersQueryError = ErrorType<void>

export const useGetTrailers = <TData = Awaited<ReturnType<typeof getTrailers>>, TError = ErrorType<void>>(
  params?: GetTrailersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getTrailers>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTrailersQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTrailers>>> = ({ signal }) => getTrailers(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getTrailers>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets episodes for a tv season.
 */
export const getEpisodes = (
  seriesId: string,
  params?: GetEpisodesParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Shows/${seriesId}/Episodes`, method: 'get',
      params, signal
    },
  );
}


export const getGetEpisodesQueryKey = (seriesId: string,
  params?: GetEpisodesParams,) => [`/Shows/${seriesId}/Episodes`, ...(params ? [params] : [])];


export type GetEpisodesQueryResult = NonNullable<Awaited<ReturnType<typeof getEpisodes>>>
export type GetEpisodesQueryError = ErrorType<void | ProblemDetails>

export const useGetEpisodes = <TData = Awaited<ReturnType<typeof getEpisodes>>, TError = ErrorType<void | ProblemDetails>>(
  seriesId: string,
  params?: GetEpisodesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getEpisodes>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEpisodesQueryKey(seriesId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEpisodes>>> = ({ signal }) => getEpisodes(seriesId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getEpisodes>>, TError, TData>(queryKey, queryFn, { enabled: !!(seriesId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets seasons for a tv series.
 */
export const getSeasons = (
  seriesId: string,
  params?: GetSeasonsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Shows/${seriesId}/Seasons`, method: 'get',
      params, signal
    },
  );
}


export const getGetSeasonsQueryKey = (seriesId: string,
  params?: GetSeasonsParams,) => [`/Shows/${seriesId}/Seasons`, ...(params ? [params] : [])];


export type GetSeasonsQueryResult = NonNullable<Awaited<ReturnType<typeof getSeasons>>>
export type GetSeasonsQueryError = ErrorType<void | ProblemDetails>

export const useGetSeasons = <TData = Awaited<ReturnType<typeof getSeasons>>, TError = ErrorType<void | ProblemDetails>>(
  seriesId: string,
  params?: GetSeasonsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSeasons>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSeasonsQueryKey(seriesId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeasons>>> = ({ signal }) => getSeasons(seriesId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSeasons>>, TError, TData>(queryKey, queryFn, { enabled: !!(seriesId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a list of next up episodes.
 */
export const getNextUp = (
  params?: GetNextUpParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Shows/NextUp`, method: 'get',
      params, signal
    },
  );
}


export const getGetNextUpQueryKey = (params?: GetNextUpParams,) => [`/Shows/NextUp`, ...(params ? [params] : [])];


export type GetNextUpQueryResult = NonNullable<Awaited<ReturnType<typeof getNextUp>>>
export type GetNextUpQueryError = ErrorType<void>

export const useGetNextUp = <TData = Awaited<ReturnType<typeof getNextUp>>, TError = ErrorType<void>>(
  params?: GetNextUpParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNextUp>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNextUpQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNextUp>>> = ({ signal }) => getNextUp(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getNextUp>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a list of upcoming episodes.
 */
export const getUpcomingEpisodes = (
  params?: GetUpcomingEpisodesParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Shows/Upcoming`, method: 'get',
      params, signal
    },
  );
}


export const getGetUpcomingEpisodesQueryKey = (params?: GetUpcomingEpisodesParams,) => [`/Shows/Upcoming`, ...(params ? [params] : [])];


export type GetUpcomingEpisodesQueryResult = NonNullable<Awaited<ReturnType<typeof getUpcomingEpisodes>>>
export type GetUpcomingEpisodesQueryError = ErrorType<void>

export const useGetUpcomingEpisodes = <TData = Awaited<ReturnType<typeof getUpcomingEpisodes>>, TError = ErrorType<void>>(
  params?: GetUpcomingEpisodesParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUpcomingEpisodes>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUpcomingEpisodesQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUpcomingEpisodes>>> = ({ signal }) => getUpcomingEpisodes(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getUpcomingEpisodes>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an audio stream.
 */
export const getUniversalAudioStream = (
  itemId: string,
  params?: GetUniversalAudioStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/universal`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetUniversalAudioStreamQueryKey = (itemId: string,
  params?: GetUniversalAudioStreamParams,) => [`/Audio/${itemId}/universal`, ...(params ? [params] : [])];


export type GetUniversalAudioStreamQueryResult = NonNullable<Awaited<ReturnType<typeof getUniversalAudioStream>>>
export type GetUniversalAudioStreamQueryError = ErrorType<void>

export const useGetUniversalAudioStream = <TData = Awaited<ReturnType<typeof getUniversalAudioStream>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetUniversalAudioStreamParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUniversalAudioStream>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUniversalAudioStreamQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUniversalAudioStream>>> = ({ signal }) => getUniversalAudioStream(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getUniversalAudioStream>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets an audio stream.
 */
export const headUniversalAudioStream = (
  itemId: string,
  params?: HeadUniversalAudioStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Audio/${itemId}/universal`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadUniversalAudioStreamMutationResult = NonNullable<Awaited<ReturnType<typeof headUniversalAudioStream>>>

export type HeadUniversalAudioStreamMutationError = ErrorType<void>

export const useHeadUniversalAudioStream = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headUniversalAudioStream>>, TError, { itemId: string; params?: HeadUniversalAudioStreamParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headUniversalAudioStream>>, { itemId: string; params?: HeadUniversalAudioStreamParams }> = (props) => {
    const { itemId, params } = props ?? {};

    return headUniversalAudioStream(itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headUniversalAudioStream>>, TError, { itemId: string; params?: HeadUniversalAudioStreamParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a list of users.
 */
export const getUsers = (
  params?: GetUsersParams,
  signal?: AbortSignal
) => {
  return apiInstance<UserDto[]>(
    {
      url: `/Users`, method: 'get',
      params, signal
    },
  );
}


export const getGetUsersQueryKey = (params?: GetUsersParams,) => [`/Users`, ...(params ? [params] : [])];


export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = ErrorType<void>

export const useGetUsers = <TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorType<void>>(
  params?: GetUsersParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getUsers>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a user by Id.
 */
export const getUserById = (
  userId: string,
  signal?: AbortSignal
) => {
  return apiInstance<UserDto>(
    {
      url: `/Users/${userId}`, method: 'get', signal
    },
  );
}


export const getGetUserByIdQueryKey = (userId: string,) => [`/Users/${userId}`];


export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = ErrorType<void | ProblemDetails>

export const useGetUserById = <TData = Awaited<ReturnType<typeof getUserById>>, TError = ErrorType<void | ProblemDetails>>(
  userId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserByIdQueryKey(userId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(userId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getUserById>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Deletes a user.
 */
export const deleteUser = (
  userId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}`, method: 'delete'
    },
  );
}



export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>

export type DeleteUserMutationError = ErrorType<ProblemDetails>

export const useDeleteUser = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { userId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, { userId: string }> = (props) => {
    const { userId } = props ?? {};

    return deleteUser(userId,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteUser>>, TError, { userId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a user.
 */
export const updateUser = (
  userId: string,
  userDto: UserDto,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: userDto
    },
  );
}



export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
export type UpdateUserMutationBody = UserDto
export type UpdateUserMutationError = ErrorType<ProblemDetails>

export const useUpdateUser = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError, { userId: string; data: UserDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, { userId: string; data: UserDto }> = (props) => {
    const { userId, data } = props ?? {};

    return updateUser(userId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateUser>>, TError, { userId: string; data: UserDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Authenticates a user.
 */
export const authenticateUser = (
  userId: string,
  params: AuthenticateUserParams,
) => {
  return apiInstance<AuthenticationResult>(
    {
      url: `/Users/${userId}/Authenticate`, method: 'post',
      params
    },
  );
}



export type AuthenticateUserMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateUser>>>

export type AuthenticateUserMutationError = ErrorType<ProblemDetails>

export const useAuthenticateUser = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof authenticateUser>>, TError, { userId: string; params: AuthenticateUserParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateUser>>, { userId: string; params: AuthenticateUserParams }> = (props) => {
    const { userId, params } = props ?? {};

    return authenticateUser(userId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof authenticateUser>>, TError, { userId: string; params: AuthenticateUserParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a user configuration.
 */
export const updateUserConfiguration = (
  userId: string,
  userConfiguration: UserConfiguration,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/Configuration`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: userConfiguration
    },
  );
}



export type UpdateUserConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserConfiguration>>>
export type UpdateUserConfigurationMutationBody = UserConfiguration
export type UpdateUserConfigurationMutationError = ErrorType<ProblemDetails>

export const useUpdateUserConfiguration = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateUserConfiguration>>, TError, { userId: string; data: UserConfiguration }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserConfiguration>>, { userId: string; data: UserConfiguration }> = (props) => {
    const { userId, data } = props ?? {};

    return updateUserConfiguration(userId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateUserConfiguration>>, TError, { userId: string; data: UserConfiguration }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a user's easy password.
 */
export const updateUserEasyPassword = (
  userId: string,
  updateUserEasyPassword: UpdateUserEasyPassword,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/EasyPassword`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: updateUserEasyPassword
    },
  );
}



export type UpdateUserEasyPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserEasyPassword>>>
export type UpdateUserEasyPasswordMutationBody = UpdateUserEasyPassword
export type UpdateUserEasyPasswordMutationError = ErrorType<ProblemDetails>

export const useUpdateUserEasyPassword = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateUserEasyPassword>>, TError, { userId: string; data: UpdateUserEasyPassword }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserEasyPassword>>, { userId: string; data: UpdateUserEasyPassword }> = (props) => {
    const { userId, data } = props ?? {};

    return updateUserEasyPassword(userId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateUserEasyPassword>>, TError, { userId: string; data: UpdateUserEasyPassword }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a user's password.
 */
export const updateUserPassword = (
  userId: string,
  updateUserPassword: UpdateUserPassword,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/Password`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: updateUserPassword
    },
  );
}



export type UpdateUserPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserPassword>>>
export type UpdateUserPasswordMutationBody = UpdateUserPassword
export type UpdateUserPasswordMutationError = ErrorType<ProblemDetails>

export const useUpdateUserPassword = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateUserPassword>>, TError, { userId: string; data: UpdateUserPassword }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserPassword>>, { userId: string; data: UpdateUserPassword }> = (props) => {
    const { userId, data } = props ?? {};

    return updateUserPassword(userId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateUserPassword>>, TError, { userId: string; data: UpdateUserPassword }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a user policy.
 */
export const updateUserPolicy = (
  userId: string,
  userPolicy: UserPolicy,
) => {
  return apiInstance<void>(
    {
      url: `/Users/${userId}/Policy`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: userPolicy
    },
  );
}



export type UpdateUserPolicyMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserPolicy>>>
export type UpdateUserPolicyMutationBody = UserPolicy
export type UpdateUserPolicyMutationError = ErrorType<ProblemDetails>

export const useUpdateUserPolicy = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateUserPolicy>>, TError, { userId: string; data: UserPolicy }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserPolicy>>, { userId: string; data: UserPolicy }> = (props) => {
    const { userId, data } = props ?? {};

    return updateUserPolicy(userId, data,)
  }



  return useMutation<Awaited<ReturnType<typeof updateUserPolicy>>, TError, { userId: string; data: UserPolicy }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Authenticates a user by name.
 */
export const authenticateUserByName = (
  authenticateUserByName: AuthenticateUserByName,
) => {
  return apiInstance<AuthenticationResult>(
    {
      url: `/Users/AuthenticateByName`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: authenticateUserByName
    },
  );
}



export type AuthenticateUserByNameMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateUserByName>>>
export type AuthenticateUserByNameMutationBody = AuthenticateUserByName
export type AuthenticateUserByNameMutationError = ErrorType<unknown>

export const useAuthenticateUserByName = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof authenticateUserByName>>, TError, { data: AuthenticateUserByName }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateUserByName>>, { data: AuthenticateUserByName }> = (props) => {
    const { data } = props ?? {};

    return authenticateUserByName(data,)
  }



  return useMutation<Awaited<ReturnType<typeof authenticateUserByName>>, TError, { data: AuthenticateUserByName }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Authenticates a user with quick connect.
 */
export const authenticateWithQuickConnect = (
  quickConnectDto: QuickConnectDto,
) => {
  return apiInstance<AuthenticationResult>(
    {
      url: `/Users/AuthenticateWithQuickConnect`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: quickConnectDto
    },
  );
}



export type AuthenticateWithQuickConnectMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateWithQuickConnect>>>
export type AuthenticateWithQuickConnectMutationBody = QuickConnectDto
export type AuthenticateWithQuickConnectMutationError = ErrorType<void>

export const useAuthenticateWithQuickConnect = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof authenticateWithQuickConnect>>, TError, { data: QuickConnectDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateWithQuickConnect>>, { data: QuickConnectDto }> = (props) => {
    const { data } = props ?? {};

    return authenticateWithQuickConnect(data,)
  }



  return useMutation<Awaited<ReturnType<typeof authenticateWithQuickConnect>>, TError, { data: QuickConnectDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Initiates the forgot password process for a local user.
 */
export const forgotPassword = (
  forgotPasswordDto: ForgotPasswordDto,
) => {
  return apiInstance<ForgotPasswordResult>(
    {
      url: `/Users/ForgotPassword`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: forgotPasswordDto
    },
  );
}



export type ForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof forgotPassword>>>
export type ForgotPasswordMutationBody = ForgotPasswordDto
export type ForgotPasswordMutationError = ErrorType<unknown>

export const useForgotPassword = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError, { data: ForgotPasswordDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof forgotPassword>>, { data: ForgotPasswordDto }> = (props) => {
    const { data } = props ?? {};

    return forgotPassword(data,)
  }



  return useMutation<Awaited<ReturnType<typeof forgotPassword>>, TError, { data: ForgotPasswordDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Redeems a forgot password pin.
 */
export const forgotPasswordPin = (
  forgotPasswordPinDto: ForgotPasswordPinDto,
) => {
  return apiInstance<PinRedeemResult>(
    {
      url: `/Users/ForgotPassword/Pin`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: forgotPasswordPinDto
    },
  );
}



export type ForgotPasswordPinMutationResult = NonNullable<Awaited<ReturnType<typeof forgotPasswordPin>>>
export type ForgotPasswordPinMutationBody = ForgotPasswordPinDto
export type ForgotPasswordPinMutationError = ErrorType<unknown>

export const useForgotPasswordPin = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof forgotPasswordPin>>, TError, { data: ForgotPasswordPinDto }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof forgotPasswordPin>>, { data: ForgotPasswordPinDto }> = (props) => {
    const { data } = props ?? {};

    return forgotPasswordPin(data,)
  }



  return useMutation<Awaited<ReturnType<typeof forgotPasswordPin>>, TError, { data: ForgotPasswordPinDto }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets the user based on auth token.
 */
export const getCurrentUser = (

  signal?: AbortSignal
) => {
  return apiInstance<UserDto>(
    {
      url: `/Users/Me`, method: 'get', signal
    },
  );
}


export const getGetCurrentUserQueryKey = () => [`/Users/Me`];


export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = ErrorType<ProblemDetails | void>

export const useGetCurrentUser = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = ErrorType<ProblemDetails | void>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCurrentUserQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(signal);




  const query = useQuery<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Creates a user.
 */
export const createUserByName = (
  createUserByName: CreateUserByName,
) => {
  return apiInstance<UserDto>(
    {
      url: `/Users/New`, method: 'post',
      headers: { 'Content-Type': 'application/json', },
      data: createUserByName
    },
  );
}



export type CreateUserByNameMutationResult = NonNullable<Awaited<ReturnType<typeof createUserByName>>>
export type CreateUserByNameMutationBody = CreateUserByName
export type CreateUserByNameMutationError = ErrorType<void>

export const useCreateUserByName = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof createUserByName>>, TError, { data: CreateUserByName }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserByName>>, { data: CreateUserByName }> = (props) => {
    const { data } = props ?? {};

    return createUserByName(data,)
  }



  return useMutation<Awaited<ReturnType<typeof createUserByName>>, TError, { data: CreateUserByName }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a list of publicly visible users for display on a login screen.
 */
export const getPublicUsers = (

  signal?: AbortSignal
) => {
  return apiInstance<UserDto[]>(
    {
      url: `/Users/Public`, method: 'get', signal
    },
  );
}


export const getGetPublicUsersQueryKey = () => [`/Users/Public`];


export type GetPublicUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicUsers>>>
export type GetPublicUsersQueryError = ErrorType<unknown>

export const useGetPublicUsers = <TData = Awaited<ReturnType<typeof getPublicUsers>>, TError = ErrorType<unknown>>(
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPublicUsers>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicUsersQueryKey();




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicUsers>>> = ({ signal }) => getPublicUsers(signal);




  const query = useQuery<Awaited<ReturnType<typeof getPublicUsers>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Marks an item as a favorite.
 */
export const markFavoriteItem = (
  userId: string,
  itemId: string,
) => {
  return apiInstance<UserItemDataDto>(
    {
      url: `/Users/${userId}/FavoriteItems/${itemId}`, method: 'post'
    },
  );
}



export type MarkFavoriteItemMutationResult = NonNullable<Awaited<ReturnType<typeof markFavoriteItem>>>

export type MarkFavoriteItemMutationError = ErrorType<void>

export const useMarkFavoriteItem = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof markFavoriteItem>>, TError, { userId: string; itemId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof markFavoriteItem>>, { userId: string; itemId: string }> = (props) => {
    const { userId, itemId } = props ?? {};

    return markFavoriteItem(userId, itemId,)
  }



  return useMutation<Awaited<ReturnType<typeof markFavoriteItem>>, TError, { userId: string; itemId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Unmarks item as a favorite.
 */
export const unmarkFavoriteItem = (
  userId: string,
  itemId: string,
) => {
  return apiInstance<UserItemDataDto>(
    {
      url: `/Users/${userId}/FavoriteItems/${itemId}`, method: 'delete'
    },
  );
}



export type UnmarkFavoriteItemMutationResult = NonNullable<Awaited<ReturnType<typeof unmarkFavoriteItem>>>

export type UnmarkFavoriteItemMutationError = ErrorType<void>

export const useUnmarkFavoriteItem = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof unmarkFavoriteItem>>, TError, { userId: string; itemId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof unmarkFavoriteItem>>, { userId: string; itemId: string }> = (props) => {
    const { userId, itemId } = props ?? {};

    return unmarkFavoriteItem(userId, itemId,)
  }



  return useMutation<Awaited<ReturnType<typeof unmarkFavoriteItem>>, TError, { userId: string; itemId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets an item from a user's library.
 */
export const getItem = (
  userId: string,
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/Users/${userId}/Items/${itemId}`, method: 'get', signal
    },
  );
}


export const getGetItemQueryKey = (userId: string,
  itemId: string,) => [`/Users/${userId}/Items/${itemId}`];


export type GetItemQueryResult = NonNullable<Awaited<ReturnType<typeof getItem>>>
export type GetItemQueryError = ErrorType<void>

export const useGetItem = <TData = Awaited<ReturnType<typeof getItem>>, TError = ErrorType<void>>(
  userId: string,
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getItem>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemQueryKey(userId, itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItem>>> = ({ signal }) => getItem(userId, itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getItem>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId && itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets intros to play before the main media item plays.
 */
export const getIntros = (
  userId: string,
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Users/${userId}/Items/${itemId}/Intros`, method: 'get', signal
    },
  );
}


export const getGetIntrosQueryKey = (userId: string,
  itemId: string,) => [`/Users/${userId}/Items/${itemId}/Intros`];


export type GetIntrosQueryResult = NonNullable<Awaited<ReturnType<typeof getIntros>>>
export type GetIntrosQueryError = ErrorType<void>

export const useGetIntros = <TData = Awaited<ReturnType<typeof getIntros>>, TError = ErrorType<void>>(
  userId: string,
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getIntros>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIntrosQueryKey(userId, itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIntros>>> = ({ signal }) => getIntros(userId, itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getIntros>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId && itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets local trailers for an item.
 */
export const getLocalTrailers = (
  userId: string,
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto[]>(
    {
      url: `/Users/${userId}/Items/${itemId}/LocalTrailers`, method: 'get', signal
    },
  );
}


export const getGetLocalTrailersQueryKey = (userId: string,
  itemId: string,) => [`/Users/${userId}/Items/${itemId}/LocalTrailers`];


export type GetLocalTrailersQueryResult = NonNullable<Awaited<ReturnType<typeof getLocalTrailers>>>
export type GetLocalTrailersQueryError = ErrorType<void>

export const useGetLocalTrailers = <TData = Awaited<ReturnType<typeof getLocalTrailers>>, TError = ErrorType<void>>(
  userId: string,
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLocalTrailers>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLocalTrailersQueryKey(userId, itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocalTrailers>>> = ({ signal }) => getLocalTrailers(userId, itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLocalTrailers>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId && itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Deletes a user's saved personal rating for an item.
 */
export const deleteUserItemRating = (
  userId: string,
  itemId: string,
) => {
  return apiInstance<UserItemDataDto>(
    {
      url: `/Users/${userId}/Items/${itemId}/Rating`, method: 'delete'
    },
  );
}



export type DeleteUserItemRatingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserItemRating>>>

export type DeleteUserItemRatingMutationError = ErrorType<void>

export const useDeleteUserItemRating = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUserItemRating>>, TError, { userId: string; itemId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserItemRating>>, { userId: string; itemId: string }> = (props) => {
    const { userId, itemId } = props ?? {};

    return deleteUserItemRating(userId, itemId,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteUserItemRating>>, TError, { userId: string; itemId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Updates a user's rating for an item.
 */
export const updateUserItemRating = (
  userId: string,
  itemId: string,
  params?: UpdateUserItemRatingParams,
) => {
  return apiInstance<UserItemDataDto>(
    {
      url: `/Users/${userId}/Items/${itemId}/Rating`, method: 'post',
      params
    },
  );
}



export type UpdateUserItemRatingMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserItemRating>>>

export type UpdateUserItemRatingMutationError = ErrorType<void>

export const useUpdateUserItemRating = <TError = ErrorType<void>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateUserItemRating>>, TError, { userId: string; itemId: string; params?: UpdateUserItemRatingParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserItemRating>>, { userId: string; itemId: string; params?: UpdateUserItemRatingParams }> = (props) => {
    const { userId, itemId, params } = props ?? {};

    return updateUserItemRating(userId, itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof updateUserItemRating>>, TError, { userId: string; itemId: string; params?: UpdateUserItemRatingParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets special features for an item.
 */
export const getSpecialFeatures = (
  userId: string,
  itemId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto[]>(
    {
      url: `/Users/${userId}/Items/${itemId}/SpecialFeatures`, method: 'get', signal
    },
  );
}


export const getGetSpecialFeaturesQueryKey = (userId: string,
  itemId: string,) => [`/Users/${userId}/Items/${itemId}/SpecialFeatures`];


export type GetSpecialFeaturesQueryResult = NonNullable<Awaited<ReturnType<typeof getSpecialFeatures>>>
export type GetSpecialFeaturesQueryError = ErrorType<void>

export const useGetSpecialFeatures = <TData = Awaited<ReturnType<typeof getSpecialFeatures>>, TError = ErrorType<void>>(
  userId: string,
  itemId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getSpecialFeatures>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSpecialFeaturesQueryKey(userId, itemId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpecialFeatures>>> = ({ signal }) => getSpecialFeatures(userId, itemId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getSpecialFeatures>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId && itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets latest media.
 */
export const getLatestMedia = (
  userId: string,
  params?: GetLatestMediaParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto[]>(
    {
      url: `/Users/${userId}/Items/Latest`, method: 'get',
      params, signal
    },
  );
}


export const getGetLatestMediaQueryKey = (userId: string,
  params?: GetLatestMediaParams,) => [`/Users/${userId}/Items/Latest`, ...(params ? [params] : [])];


export type GetLatestMediaQueryResult = NonNullable<Awaited<ReturnType<typeof getLatestMedia>>>
export type GetLatestMediaQueryError = ErrorType<void>

export const useGetLatestMedia = <TData = Awaited<ReturnType<typeof getLatestMedia>>, TError = ErrorType<void>>(
  userId: string,
  params?: GetLatestMediaParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getLatestMedia>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLatestMediaQueryKey(userId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLatestMedia>>> = ({ signal }) => getLatestMedia(userId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getLatestMedia>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets the root folder from a user's library.
 */
export const getRootFolder = (
  userId: string,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/Users/${userId}/Items/Root`, method: 'get', signal
    },
  );
}


export const getGetRootFolderQueryKey = (userId: string,) => [`/Users/${userId}/Items/Root`];


export type GetRootFolderQueryResult = NonNullable<Awaited<ReturnType<typeof getRootFolder>>>
export type GetRootFolderQueryError = ErrorType<void>

export const useGetRootFolder = <TData = Awaited<ReturnType<typeof getRootFolder>>, TError = ErrorType<void>>(
  userId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getRootFolder>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRootFolderQueryKey(userId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRootFolder>>> = ({ signal }) => getRootFolder(userId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getRootFolder>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get user view grouping options.
 */
export const getGroupingOptions = (
  userId: string,
  signal?: AbortSignal
) => {
  return apiInstance<SpecialViewOptionDto[]>(
    {
      url: `/Users/${userId}/GroupingOptions`, method: 'get', signal
    },
  );
}


export const getGetGroupingOptionsQueryKey = (userId: string,) => [`/Users/${userId}/GroupingOptions`];


export type GetGroupingOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupingOptions>>>
export type GetGroupingOptionsQueryError = ErrorType<void | ProblemDetails>

export const useGetGroupingOptions = <TData = Awaited<ReturnType<typeof getGroupingOptions>>, TError = ErrorType<void | ProblemDetails>>(
  userId: string, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getGroupingOptions>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGroupingOptionsQueryKey(userId);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupingOptions>>> = ({ signal }) => getGroupingOptions(userId, signal);




  const query = useQuery<Awaited<ReturnType<typeof getGroupingOptions>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get user views.
 */
export const getUserViews = (
  userId: string,
  params?: GetUserViewsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Users/${userId}/Views`, method: 'get',
      params, signal
    },
  );
}


export const getGetUserViewsQueryKey = (userId: string,
  params?: GetUserViewsParams,) => [`/Users/${userId}/Views`, ...(params ? [params] : [])];


export type GetUserViewsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserViews>>>
export type GetUserViewsQueryError = ErrorType<void>

export const useGetUserViews = <TData = Awaited<ReturnType<typeof getUserViews>>, TError = ErrorType<void>>(
  userId: string,
  params?: GetUserViewsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserViews>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserViewsQueryKey(userId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserViews>>> = ({ signal }) => getUserViews(userId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getUserViews>>, TError, TData>(queryKey, queryFn, { enabled: !!(userId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Get video attachment.
 */
export const getAttachment = (
  videoId: string,
  mediaSourceId: string,
  index: number,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${videoId}/${mediaSourceId}/Attachments/${index}`, method: 'get',
      responseType: 'blob', signal
    },
  );
}


export const getGetAttachmentQueryKey = (videoId: string,
  mediaSourceId: string,
  index: number,) => [`/Videos/${videoId}/${mediaSourceId}/Attachments/${index}`];


export type GetAttachmentQueryResult = NonNullable<Awaited<ReturnType<typeof getAttachment>>>
export type GetAttachmentQueryError = ErrorType<ProblemDetails>

export const useGetAttachment = <TData = Awaited<ReturnType<typeof getAttachment>>, TError = ErrorType<ProblemDetails>>(
  videoId: string,
  mediaSourceId: string,
  index: number, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAttachment>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAttachmentQueryKey(videoId, mediaSourceId, index);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAttachment>>> = ({ signal }) => getAttachment(videoId, mediaSourceId, index, signal);




  const query = useQuery<Awaited<ReturnType<typeof getAttachment>>, TError, TData>(queryKey, queryFn, { enabled: !!(videoId && mediaSourceId && index), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets additional parts for a video.
 */
export const getAdditionalPart = (
  itemId: string,
  params?: GetAdditionalPartParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Videos/${itemId}/AdditionalParts`, method: 'get',
      params, signal
    },
  );
}


export const getGetAdditionalPartQueryKey = (itemId: string,
  params?: GetAdditionalPartParams,) => [`/Videos/${itemId}/AdditionalParts`, ...(params ? [params] : [])];


export type GetAdditionalPartQueryResult = NonNullable<Awaited<ReturnType<typeof getAdditionalPart>>>
export type GetAdditionalPartQueryError = ErrorType<void>

export const useGetAdditionalPart = <TData = Awaited<ReturnType<typeof getAdditionalPart>>, TError = ErrorType<void>>(
  itemId: string,
  params?: GetAdditionalPartParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAdditionalPart>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAdditionalPartQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdditionalPart>>> = ({ signal }) => getAdditionalPart(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getAdditionalPart>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Removes alternate video sources.
 */
export const deleteAlternateSources = (
  itemId: string,
) => {
  return apiInstance<void>(
    {
      url: `/Videos/${itemId}/AlternateSources`, method: 'delete'
    },
  );
}



export type DeleteAlternateSourcesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAlternateSources>>>

export type DeleteAlternateSourcesMutationError = ErrorType<ProblemDetails>

export const useDeleteAlternateSources = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteAlternateSources>>, TError, { itemId: string }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAlternateSources>>, { itemId: string }> = (props) => {
    const { itemId } = props ?? {};

    return deleteAlternateSources(itemId,)
  }



  return useMutation<Awaited<ReturnType<typeof deleteAlternateSources>>, TError, { itemId: string }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a video stream.
 */
export const getVideoStream = (
  itemId: string,
  params?: GetVideoStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/stream`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetVideoStreamQueryKey = (itemId: string,
  params?: GetVideoStreamParams,) => [`/Videos/${itemId}/stream`, ...(params ? [params] : [])];


export type GetVideoStreamQueryResult = NonNullable<Awaited<ReturnType<typeof getVideoStream>>>
export type GetVideoStreamQueryError = ErrorType<unknown>

export const useGetVideoStream = <TData = Awaited<ReturnType<typeof getVideoStream>>, TError = ErrorType<unknown>>(
  itemId: string,
  params?: GetVideoStreamParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getVideoStream>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVideoStreamQueryKey(itemId, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVideoStream>>> = ({ signal }) => getVideoStream(itemId, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getVideoStream>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a video stream.
 */
export const headVideoStream = (
  itemId: string,
  params?: HeadVideoStreamParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/stream`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadVideoStreamMutationResult = NonNullable<Awaited<ReturnType<typeof headVideoStream>>>

export type HeadVideoStreamMutationError = ErrorType<unknown>

export const useHeadVideoStream = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headVideoStream>>, TError, { itemId: string; params?: HeadVideoStreamParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headVideoStream>>, { itemId: string; params?: HeadVideoStreamParams }> = (props) => {
    const { itemId, params } = props ?? {};

    return headVideoStream(itemId, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headVideoStream>>, TError, { itemId: string; params?: HeadVideoStreamParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Gets a video stream.
 */
export const getVideoStreamByContainer = (
  itemId: string,
  container: string,
  params?: GetVideoStreamByContainerParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/stream.${container}`, method: 'get',
      params,
      responseType: 'blob', signal
    },
  );
}


export const getGetVideoStreamByContainerQueryKey = (itemId: string,
  container: string,
  params?: GetVideoStreamByContainerParams,) => [`/Videos/${itemId}/stream.${container}`, ...(params ? [params] : [])];


export type GetVideoStreamByContainerQueryResult = NonNullable<Awaited<ReturnType<typeof getVideoStreamByContainer>>>
export type GetVideoStreamByContainerQueryError = ErrorType<unknown>

export const useGetVideoStreamByContainer = <TData = Awaited<ReturnType<typeof getVideoStreamByContainer>>, TError = ErrorType<unknown>>(
  itemId: string,
  container: string,
  params?: GetVideoStreamByContainerParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getVideoStreamByContainer>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVideoStreamByContainerQueryKey(itemId, container, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVideoStreamByContainer>>> = ({ signal }) => getVideoStreamByContainer(itemId, container, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getVideoStreamByContainer>>, TError, TData>(queryKey, queryFn, { enabled: !!(itemId && container), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a video stream.
 */
export const headVideoStreamByContainer = (
  itemId: string,
  container: string,
  params?: HeadVideoStreamByContainerParams,
  signal?: AbortSignal
) => {
  return apiInstance<Blob>(
    {
      url: `/Videos/${itemId}/stream.${container}`, method: 'head',
      params,
      responseType: 'blob', signal
    },
  );
}



export type HeadVideoStreamByContainerMutationResult = NonNullable<Awaited<ReturnType<typeof headVideoStreamByContainer>>>

export type HeadVideoStreamByContainerMutationError = ErrorType<unknown>

export const useHeadVideoStreamByContainer = <TError = ErrorType<unknown>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof headVideoStreamByContainer>>, TError, { itemId: string; container: string; params?: HeadVideoStreamByContainerParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof headVideoStreamByContainer>>, { itemId: string; container: string; params?: HeadVideoStreamByContainerParams }> = (props) => {
    const { itemId, container, params } = props ?? {};

    return headVideoStreamByContainer(itemId, container, params,)
  }



  return useMutation<Awaited<ReturnType<typeof headVideoStreamByContainer>>, TError, { itemId: string; container: string; params?: HeadVideoStreamByContainerParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Merges videos into a single record.
 */
export const mergeVersions = (
  params: MergeVersionsParams,
) => {
  return apiInstance<void>(
    {
      url: `/Videos/MergeVersions`, method: 'post',
      params
    },
  );
}



export type MergeVersionsMutationResult = NonNullable<Awaited<ReturnType<typeof mergeVersions>>>

export type MergeVersionsMutationError = ErrorType<ProblemDetails>

export const useMergeVersions = <TError = ErrorType<ProblemDetails>,

  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof mergeVersions>>, TError, { params: MergeVersionsParams }, TContext>, }
  ) => {
  const { mutation: mutationOptions } = options ?? {};




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof mergeVersions>>, { params: MergeVersionsParams }> = (props) => {
    const { params } = props ?? {};

    return mergeVersions(params,)
  }



  return useMutation<Awaited<ReturnType<typeof mergeVersions>>, TError, { params: MergeVersionsParams }, TContext>(mutationFn, mutationOptions);
}

/**
 * @summary Get years.
 */
export const getYears = (
  params?: GetYearsParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDtoQueryResult>(
    {
      url: `/Years`, method: 'get',
      params, signal
    },
  );
}


export const getGetYearsQueryKey = (params?: GetYearsParams,) => [`/Years`, ...(params ? [params] : [])];


export type GetYearsQueryResult = NonNullable<Awaited<ReturnType<typeof getYears>>>
export type GetYearsQueryError = ErrorType<void>

export const useGetYears = <TData = Awaited<ReturnType<typeof getYears>>, TError = ErrorType<void>>(
  params?: GetYearsParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getYears>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetYearsQueryKey(params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getYears>>> = ({ signal }) => getYears(params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getYears>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Gets a year.
 */
export const getYear = (
  year: number,
  params?: GetYearParams,
  signal?: AbortSignal
) => {
  return apiInstance<BaseItemDto>(
    {
      url: `/Years/${year}`, method: 'get',
      params, signal
    },
  );
}


export const getGetYearQueryKey = (year: number,
  params?: GetYearParams,) => [`/Years/${year}`, ...(params ? [params] : [])];


export type GetYearQueryResult = NonNullable<Awaited<ReturnType<typeof getYear>>>
export type GetYearQueryError = ErrorType<void | ProblemDetails>

export const useGetYear = <TData = Awaited<ReturnType<typeof getYear>>, TError = ErrorType<void | ProblemDetails>>(
  year: number,
  params?: GetYearParams, options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getYear>>, TError, TData>, }

): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetYearQueryKey(year, params);




  const queryFn: QueryFunction<Awaited<ReturnType<typeof getYear>>> = ({ signal }) => getYear(year, params, signal);




  const query = useQuery<Awaited<ReturnType<typeof getYear>>, TError, TData>(queryKey, queryFn, { enabled: !!(year), ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}

